/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 75 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __nlink_t nlink_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 149 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef long ptrdiff_t;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 134 "/usr/include/stdint.h"
typedef long intmax_t;
#line 135 "/usr/include/stdint.h"
typedef unsigned long uintmax_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE ;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 20 "../lib/argv-iter.h"
struct argv_iterator ;
#line 21
enum argv_iter_err ;
#line 30
enum argv_iter_err {
    AI_ERR_OK = 1,
    AI_ERR_EOF = 2,
    AI_ERR_MEM = 3,
    AI_ERR_READ = 4
} ;
#line 35 "../lib/exclude.h"
struct exclude ;
#line 45 "../lib/hash.h"
struct hash_tuning {
   float shrink_threshold ;
   float shrink_factor ;
   float growth_threshold ;
   float growth_factor ;
   _Bool is_n_buckets ;
};
#line 57 "../lib/hash.h"
typedef struct hash_tuning Hash_tuning;
#line 59
struct hash_table ;
#line 61 "../lib/hash.h"
typedef struct hash_table Hash_table;
#line 26 "../lib/xstrtol.h"
enum strtol_error {
    LONGINT_OK = 0,
    LONGINT_OVERFLOW = 1,
    LONGINT_INVALID_SUFFIX_CHAR = 2,
    LONGINT_INVALID_SUFFIX_CHAR_WITH_OVERFLOW = 3,
    LONGINT_INVALID = 4
} ;
#line 39 "../lib/xstrtol.h"
typedef enum strtol_error strtol_error;
#line 31 "../lib/i-ring.h"
struct I_ring {
   int ir_data[4] ;
   int ir_default_val ;
   unsigned int ir_front ;
   unsigned int ir_back ;
   _Bool ir_empty ;
};
#line 39 "../lib/i-ring.h"
typedef struct I_ring I_ring;
#line 68 "../lib/fts_.h"
struct _ftsent ;
#line 68
struct cycle_check_state ;
#line 68 "../lib/fts_.h"
union __anonunion_fts_cycle_698394876 {
   struct hash_table *ht ;
   struct cycle_check_state *state ;
};
#line 68 "../lib/fts_.h"
struct __anonstruct_FTS_210876612 {
   struct _ftsent *fts_cur ;
   struct _ftsent *fts_child ;
   struct _ftsent **fts_array ;
   dev_t fts_dev ;
   char *fts_path ;
   int fts_rfd ;
   int fts_cwd_fd ;
   size_t fts_pathlen ;
   size_t fts_nitems ;
   int (*fts_compar)(struct _ftsent  const  ** , struct _ftsent  const  ** ) ;
   int fts_options ;
   struct hash_table *fts_leaf_optimization_works_ht ;
   union __anonunion_fts_cycle_698394876 fts_cycle ;
   I_ring fts_fd_ring ;
};
#line 68 "../lib/fts_.h"
typedef struct __anonstruct_FTS_210876612 FTS;
#line 185 "../lib/fts_.h"
struct _ftsent {
   struct _ftsent *fts_cycle ;
   struct _ftsent *fts_parent ;
   struct _ftsent *fts_link ;
   long fts_number ;
   void *fts_pointer ;
   char *fts_accpath ;
   char *fts_path ;
   int fts_errno ;
   int fts_symfd ;
   size_t fts_pathlen ;
   FTS *fts_fts ;
   ptrdiff_t fts_level ;
   size_t fts_namelen ;
   nlink_t fts_n_dirs_remaining ;
   unsigned short fts_info ;
   unsigned short fts_flags ;
   unsigned short fts_instr ;
   struct stat fts_statp[1] ;
   char fts_name[1] ;
};
#line 185 "../lib/fts_.h"
typedef struct _ftsent FTSENT;
#line 70 "/home/wslee/project/coreutils-8.1/src/du.c"
struct entry {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 81 "/home/wslee/project/coreutils-8.1/src/du.c"
struct duinfo {
   uintmax_t size ;
   struct timespec tmax ;
};
#line 118 "/home/wslee/project/coreutils-8.1/src/du.c"
struct dulevel {
   struct duinfo ent ;
   struct duinfo subdir ;
};
#line 159
enum time_type {
    time_mtime = 0,
    time_ctime = 1,
    time_atime = 2
} ;
#line 241
enum time_style {
    full_iso_time_style = 0,
    long_iso_time_style = 1,
    iso_time_style = 2
} ;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 32 "/home/wslee/project/coreutils-8.1/lib/quotearg.h"
enum quoting_style {
    literal_quoting_style = 0,
    shell_quoting_style = 1,
    shell_always_quoting_style = 2,
    c_quoting_style = 3,
    c_maybe_quoting_style = 4,
    escape_quoting_style = 5,
    locale_quoting_style = 6,
    clocale_quoting_style = 7,
    custom_quoting_style = 8
} ;
#line 21 "/home/wslee/project/coreutils-8.1/lib/argv-iter.h"
enum argv_iter_err ;
#line 25 "/home/wslee/project/coreutils-8.1/lib/argv-iter.c"
struct argv_iterator {
   FILE *fp ;
   size_t item_idx ;
   char *tok ;
   size_t buf_len ;
   char **arg_list ;
   char **p ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 28 "/home/wslee/project/coreutils-8.1/lib/backupfile.h"
enum backup_type {
    no_backups = 0,
    simple_backups = 1,
    numbered_existing_backups = 2,
    numbered_backups = 3
} ;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream ;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 148 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
enum numbered_backup_result {
    BACKUP_IS_SAME_LENGTH = 0,
    BACKUP_IS_LONGER = 1,
    BACKUP_IS_NEW = 2
} ;
#line 32 "/home/wslee/project/coreutils-8.1/lib/base64.h"
struct base64_decode_context {
   unsigned int i ;
   char buf[4] ;
};
#line 27 "/usr/include/xlocale.h"
struct __locale_data ;
#line 27 "/usr/include/xlocale.h"
struct __locale_struct {
   struct __locale_data *__locales[13] ;
   unsigned short const   *__ctype_b ;
   int const   *__ctype_tolower ;
   int const   *__ctype_toupper ;
   char const   *__names[13] ;
};
#line 27 "/usr/include/xlocale.h"
typedef struct __locale_struct *__locale_t;
#line 42 "/usr/include/xlocale.h"
typedef __locale_t locale_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 22 "/home/wslee/project/coreutils-8.1/lib/canonicalize.h"
enum canonicalize_mode_t {
    CAN_EXISTING = 0,
    CAN_ALL_BUT_LAST = 1,
    CAN_MISSING = 2
} ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/canonicalize.h"
typedef enum canonicalize_mode_t canonicalize_mode_t;
#line 40 "/home/wslee/project/coreutils-8.1/lib/chdir-long.c"
struct cd_buf {
   int fd ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 7 "/home/wslee/project/coreutils-8.1/lib/dev-ino.h"
struct dev_ino {
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 28 "/home/wslee/project/coreutils-8.1/lib/cycle-check.h"
struct cycle_check_state {
   struct dev_ino dev_ino ;
   uintmax_t chdir_counter ;
   int magic ;
};
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef int wchar_t;
#line 82 "/usr/include/wchar.h"
union __anonunion___value_771759453 {
   unsigned int __wch ;
   char __wchb[4] ;
};
#line 82 "/usr/include/wchar.h"
struct __anonstruct___mbstate_t_204422684 {
   int __count ;
   union __anonunion___value_771759453 __value ;
};
#line 82 "/usr/include/wchar.h"
typedef struct __anonstruct___mbstate_t_204422684 __mbstate_t;
#line 357 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned int wint_t;
#line 106 "/usr/include/wchar.h"
typedef __mbstate_t mbstate_t;
#line 161 "/home/wslee/project/coreutils-8.1/lib/mbchar.h"
struct mbchar {
   char const   *ptr ;
   size_t bytes ;
   _Bool wc_valid ;
   wchar_t wc ;
   char buf[24] ;
};
#line 173 "/home/wslee/project/coreutils-8.1/lib/mbchar.h"
typedef struct mbchar mbchar_t;
#line 109 "/home/wslee/project/coreutils-8.1/lib/mbuiter.h"
struct mbuiter_multi {
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 202 "/home/wslee/project/coreutils-8.1/lib/mbuiter.h"
typedef struct mbuiter_multi mbui_iterator_t;
#line 74 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
struct patopts {
   char const   *pattern ;
   int options ;
};
#line 82 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
struct exclude_pattern {
   struct patopts *exclude ;
   size_t exclude_alloc ;
   size_t exclude_count ;
};
#line 89
enum exclude_type {
    exclude_hash = 0,
    exclude_pattern = 1
} ;
#line 95 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
union __anonunion_v_510793701 {
   Hash_table *table ;
   struct exclude_pattern pat ;
};
#line 95 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
struct exclude_segment {
   struct exclude_segment *next ;
   enum exclude_type type ;
   int options ;
   union __anonunion_v_510793701 v ;
};
#line 108 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
struct exclude {
   struct exclude_segment *head ;
   struct exclude_segment *tail ;
};
#line 9 "/home/wslee/project/coreutils-8.1/lib/hash-triple.h"
struct F_triple {
   char *name ;
   ino_t st_ino ;
   dev_t st_dev ;
};
#line 27 "/home/wslee/project/coreutils-8.1/lib/fsusage.h"
struct fs_usage {
   uintmax_t fsu_blocksize ;
   uintmax_t fsu_blocks ;
   uintmax_t fsu_bfree ;
   uintmax_t fsu_bavail ;
   _Bool fsu_bavail_top_bit_set ;
   uintmax_t fsu_files ;
   uintmax_t fsu_ffree ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_109580352 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_109580352 __fsid_t;
#line 162 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt_t;
#line 166 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt_t f_blocks ;
   __fsblkcnt_t f_bfree ;
   __fsblkcnt_t f_bavail ;
   __fsfilcnt_t f_files ;
   __fsfilcnt_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 24 "/home/wslee/project/coreutils-8.1/lib/fts-cycle.c"
struct Active_dir {
   dev_t dev ;
   ino_t ino ;
   FTSENT *fts_ent ;
};
#line 728 "/home/wslee/project/coreutils-8.1/lib/fts.c"
struct LCO_ent {
   dev_t st_dev ;
   _Bool opt_ok ;
};
#line 104 "getdate.y"
typedef long long_time_t;
#line 119 "getdate.y"
struct __anonstruct_textint_824309684 {
   _Bool negative ;
   long value ;
   size_t digits ;
};
#line 119 "getdate.y"
typedef struct __anonstruct_textint_824309684 textint;
#line 127 "getdate.y"
struct __anonstruct_table_528220008 {
   char const   *name ;
   int type ;
   int value ;
};
#line 127 "getdate.y"
typedef struct __anonstruct_table_528220008 table;
#line 140 "getdate.y"
struct __anonstruct_relative_time_110745635 {
   long year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   long_time_t seconds ;
   long ns ;
};
#line 140 "getdate.y"
typedef struct __anonstruct_relative_time_110745635 relative_time;
#line 159 "getdate.y"
struct __anonstruct_parser_control_427311395 {
   char const   *input ;
   long day_ordinal ;
   int day_number ;
   int local_isdst ;
   long time_zone ;
   int meridian ;
   textint year ;
   long month ;
   long day ;
   long hour ;
   long minutes ;
   struct timespec seconds ;
   relative_time rel ;
   _Bool timespec_seen ;
   _Bool rels_seen ;
   size_t dates_seen ;
   size_t days_seen ;
   size_t local_zones_seen ;
   size_t dsts_seen ;
   size_t times_seen ;
   size_t zones_seen ;
   table local_time_zone_table[3] ;
};
#line 159 "getdate.y"
typedef struct __anonstruct_parser_control_427311395 parser_control;
#line 204
union YYSTYPE ;
#line 421 "getdate.c"
union YYSTYPE {
   long intval ;
   textint textintval ;
   struct timespec timespec ;
   relative_time rel ;
};
#line 421 "getdate.c"
typedef union YYSTYPE YYSTYPE;
#line 456 "getdate.c"
typedef unsigned char yytype_uint8;
#line 463 "getdate.c"
typedef signed char yytype_int8;
#line 477 "getdate.c"
typedef short yytype_int16;
#line 608 "getdate.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 28 "/home/wslee/project/coreutils-8.1/lib/xtime.h"
typedef long long xtime_t;
#line 147 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __clockid_t;
#line 91 "/usr/include/time.h"
typedef __clockid_t clockid_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 47 "/home/wslee/project/coreutils-8.1/lib/hash.c"
struct hash_entry {
   void *data ;
   struct hash_entry *next ;
};
#line 53 "/home/wslee/project/coreutils-8.1/lib/hash.c"
struct hash_table {
   struct hash_entry *bucket ;
   struct hash_entry  const  *bucket_limit ;
   size_t n_buckets ;
   size_t n_buckets_used ;
   size_t n_entries ;
   Hash_tuning const   *tuning ;
   size_t (*hasher)(void const   * , size_t  ) ;
   _Bool (*comparator)(void const   * , void const   * ) ;
   void (*data_freer)(void * ) ;
   struct hash_entry *free_entry_list ;
};
#line 53 "/usr/include/locale.h"
struct lconv {
   char *decimal_point ;
   char *thousands_sep ;
   char *grouping ;
   char *int_curr_symbol ;
   char *currency_symbol ;
   char *mon_decimal_point ;
   char *mon_thousands_sep ;
   char *mon_grouping ;
   char *positive_sign ;
   char *negative_sign ;
   char int_frac_digits ;
   char frac_digits ;
   char p_cs_precedes ;
   char p_sep_by_space ;
   char n_cs_precedes ;
   char n_sep_by_space ;
   char p_sign_posn ;
   char n_sign_posn ;
   char int_p_cs_precedes ;
   char int_p_sep_by_space ;
   char int_n_cs_precedes ;
   char int_n_sep_by_space ;
   char int_p_sign_posn ;
   char int_n_sign_posn ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 36 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
union __anonunion_id_984444735 {
   uid_t u ;
   gid_t g ;
};
#line 36 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
struct userid {
   union __anonunion_id_984444735 id ;
   struct userid *next ;
   char name[] ;
};
#line 80 "/home/wslee/project/coreutils-8.1/lib/isnan.c"
union __anonunion_memory_double_618071262 {
   long double value ;
   unsigned int word[((sizeof(long double ) + sizeof(unsigned int )) - 1UL) / sizeof(unsigned int )] ;
};
#line 80 "/home/wslee/project/coreutils-8.1/lib/isnan.c"
typedef union __anonunion_memory_double_618071262 memory_double;
#line 26 "/home/wslee/project/coreutils-8.1/lib/linebuffer.h"
struct linebuffer {
   size_t size ;
   size_t length ;
   char *buffer ;
};
#line 36 "/usr/include/nl_types.h"
typedef int nl_item;
#line 48 "/home/wslee/project/coreutils-8.1/lib/malloca.c"
struct preliminary_header {
   void *next ;
   char room[sizeof(int )] ;
};
#line 52 "/home/wslee/project/coreutils-8.1/lib/malloca.c"
struct header {
   void *next ;
   char room[((((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL - sizeof(struct preliminary_header )) + sizeof(int )] ;
};
#line 19 "/home/wslee/project/coreutils-8.1/lib/mbsalign.h"
enum __anonenum_mbs_align_t_481190589 {
    MBS_ALIGN_LEFT = 0,
    MBS_ALIGN_RIGHT = 1,
    MBS_ALIGN_CENTER = 2
} ;
#line 19 "/home/wslee/project/coreutils-8.1/lib/mbsalign.h"
typedef enum __anonenum_mbs_align_t_481190589 mbs_align_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 62 "/home/wslee/project/coreutils-8.1/lib/md5.h"
struct md5_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 259 "/home/wslee/project/coreutils-8.1/lib/md5.c"
struct __anonstruct_833865290 {
   char c ;
   uint32_t x ;
};
#line 43 "/home/wslee/project/coreutils-8.1/lib/memchr2.c"
typedef unsigned long longword;
#line 2 "/home/wslee/project/coreutils-8.1/lib/mkancesdirs.h"
struct savewd ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 28 "/home/wslee/project/coreutils-8.1/lib/savewd.h"
enum __anonenum_state_467303978 {
    INITIAL_STATE = 0,
    FD_STATE = 1,
    FD_POST_CHDIR_STATE = 2,
    FORKING_STATE = 3,
    ERROR_STATE = 4,
    FINAL_STATE = 5
} ;
#line 28 "/home/wslee/project/coreutils-8.1/lib/savewd.h"
union __anonunion_val_408517849 {
   int fd ;
   int errnum ;
   pid_t child ;
};
#line 28 "/home/wslee/project/coreutils-8.1/lib/savewd.h"
struct savewd {
   enum __anonenum_state_467303978 state ;
   union __anonunion_val_408517849 val ;
};
#line 25 "/home/wslee/project/coreutils-8.1/lib/modechange.h"
struct mode_change ;
#line 98 "/home/wslee/project/coreutils-8.1/lib/modechange.c"
struct mode_change {
   char op ;
   char flag ;
   mode_t affected ;
   mode_t value ;
   mode_t mentioned ;
};
#line 26 "/home/wslee/project/coreutils-8.1/lib/mountlist.h"
struct mount_entry {
   char *me_devname ;
   char *me_mountdir ;
   char *me_type ;
   dev_t me_dev ;
   unsigned int me_dummy : 1 ;
   unsigned int me_remote : 1 ;
   unsigned int me_type_malloced : 1 ;
   struct mount_entry *me_next ;
};
#line 53 "/usr/include/mntent.h"
struct mntent {
   char *mnt_fsname ;
   char *mnt_dir ;
   char *mnt_type ;
   char *mnt_opts ;
   int mnt_freq ;
   int mnt_passno ;
};
#line 33 "/home/wslee/project/coreutils-8.1/lib/nproc.h"
enum nproc_query {
    NPROC_ALL = 0,
    NPROC_CURRENT = 1,
    NPROC_CURRENT_OVERRIDABLE = 2
} ;
#line 118 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef unsigned long __cpu_mask;
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct __anonstruct_cpu_set_t_826868708 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef struct __anonstruct_cpu_set_t_826868708 cpu_set_t;
#line 49 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
enum __anonenum_arg_type_817662448 {
    TYPE_NONE = 0,
    TYPE_SCHAR = 1,
    TYPE_UCHAR = 2,
    TYPE_SHORT = 3,
    TYPE_USHORT = 4,
    TYPE_INT = 5,
    TYPE_UINT = 6,
    TYPE_LONGINT = 7,
    TYPE_ULONGINT = 8,
    TYPE_LONGLONGINT = 9,
    TYPE_ULONGLONGINT = 10,
    TYPE_DOUBLE = 11,
    TYPE_LONGDOUBLE = 12,
    TYPE_CHAR = 13,
    TYPE_WIDE_CHAR = 14,
    TYPE_STRING = 15,
    TYPE_WIDE_STRING = 16,
    TYPE_POINTER = 17,
    TYPE_COUNT_SCHAR_POINTER = 18,
    TYPE_COUNT_SHORT_POINTER = 19,
    TYPE_COUNT_INT_POINTER = 20,
    TYPE_COUNT_LONGINT_POINTER = 21,
    TYPE_COUNT_LONGLONGINT_POINTER = 22
} ;
#line 49 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
typedef enum __anonenum_arg_type_817662448 arg_type;
#line 91 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
union __anonunion_a_145370145 {
   signed char a_schar ;
   unsigned char a_uchar ;
   short a_short ;
   unsigned short a_ushort ;
   int a_int ;
   unsigned int a_uint ;
   long a_longint ;
   unsigned long a_ulongint ;
   long long a_longlongint ;
   unsigned long long a_ulonglongint ;
   float a_float ;
   double a_double ;
   long double a_longdouble ;
   int a_char ;
   wint_t a_wide_char ;
   char const   *a_string ;
   wchar_t const   *a_wide_string ;
   void *a_pointer ;
   signed char *a_count_schar_pointer ;
   short *a_count_short_pointer ;
   int *a_count_int_pointer ;
   long *a_count_longint_pointer ;
   long long *a_count_longlongint_pointer ;
};
#line 91 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
struct __anonstruct_argument_576421957 {
   arg_type type ;
   union __anonunion_a_145370145 a ;
};
#line 91 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
typedef struct __anonstruct_argument_576421957 argument;
#line 138 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
struct __anonstruct_arguments_777806161 {
   size_t count ;
   argument *arg ;
};
#line 138 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
typedef struct __anonstruct_arguments_777806161 arguments;
#line 66 "/home/wslee/project/coreutils-8.1/lib/fpucw.h"
typedef unsigned short fpucw_t;
#line 43 "/home/wslee/project/coreutils-8.1/lib/printf-parse.h"
struct __anonstruct_char_directive_658480644 {
   char const   *dir_start ;
   char const   *dir_end ;
   int flags ;
   char const   *width_start ;
   char const   *width_end ;
   size_t width_arg_index ;
   char const   *precision_start ;
   char const   *precision_end ;
   size_t precision_arg_index ;
   char conversion ;
   size_t arg_index ;
};
#line 43 "/home/wslee/project/coreutils-8.1/lib/printf-parse.h"
typedef struct __anonstruct_char_directive_658480644 char_directive;
#line 60 "/home/wslee/project/coreutils-8.1/lib/printf-parse.h"
struct __anonstruct_char_directives_143329776 {
   size_t count ;
   char_directive *dir ;
   size_t max_width_length ;
   size_t max_precision_length ;
};
#line 60 "/home/wslee/project/coreutils-8.1/lib/printf-parse.h"
typedef struct __anonstruct_char_directives_143329776 char_directives;
#line 237 "/home/wslee/project/coreutils-8.1/lib/quotearg.h"
struct quoting_options ;
#line 46 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
struct quoting_options {
   enum quoting_style style ;
   int flags ;
   unsigned int quote_these_too[255UL / (sizeof(int ) * 8UL) + 1UL] ;
   char const   *left_quote ;
   char const   *right_quote ;
};
#line 678 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
struct slotvec {
   size_t size ;
   char *val ;
};
#line 33 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.h"
struct isaac_state {
   uint32_t mm[1 << 8] ;
   uint32_t iv[8] ;
   uint32_t a ;
   uint32_t b ;
   uint32_t c ;
};
#line 25 "/home/wslee/project/coreutils-8.1/lib/randread.h"
struct randread_source ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/randint.h"
typedef uintmax_t randint;
#line 33
struct randint_source ;
#line 54 "/home/wslee/project/coreutils-8.1/lib/randint.c"
struct randint_source {
   struct randread_source *source ;
   randint randnum ;
   randint randmax ;
};
#line 69 "/home/wslee/project/coreutils-8.1/lib/randread.c"
union __anonunion_data_453857088 {
   uint32_t w[1 << 8] ;
   unsigned char b[(unsigned long )(1 << 8) * sizeof(uint32_t )] ;
};
#line 69 "/home/wslee/project/coreutils-8.1/lib/randread.c"
struct isaac {
   size_t buffered ;
   struct isaac_state state ;
   union __anonunion_data_453857088 data ;
};
#line 69 "/home/wslee/project/coreutils-8.1/lib/randread.c"
union __anonunion_buf_207963531 {
   char c[2UL * ((unsigned long )(1 << 8) * sizeof(uint32_t ))] ;
   struct isaac isaac ;
};
#line 69 "/home/wslee/project/coreutils-8.1/lib/randread.c"
struct randread_source {
   FILE *source ;
   void (*handler)(void const   * ) ;
   void const   *handler_arg ;
   union __anonunion_buf_207963531 buf ;
};
#line 239 "/home/wslee/project/coreutils-8.1/lib/randread.c"
struct __anonstruct_833865290___0 {
   char c ;
   uint32_t x ;
};
#line 25 "/home/wslee/project/coreutils-8.1/lib/readtokens.h"
struct tokenbuffer {
   size_t size ;
   char *buffer ;
};
#line 30 "/home/wslee/project/coreutils-8.1/lib/readtokens.h"
typedef struct tokenbuffer token_buffer;
#line 895 "/usr/include/stdio.h"
struct obstack ;
#line 142 "/home/wslee/project/coreutils-8.1/lib/obstack.h"
struct _obstack_chunk {
   char *limit ;
   struct _obstack_chunk *prev ;
   char contents[4] ;
};
#line 149 "/home/wslee/project/coreutils-8.1/lib/obstack.h"
union __anonunion_temp_267926141 {
   long tempint ;
   void *tempptr ;
};
#line 149 "/home/wslee/project/coreutils-8.1/lib/obstack.h"
struct obstack {
   long chunk_size ;
   struct _obstack_chunk *chunk ;
   char *object_base ;
   char *next_free ;
   char *chunk_limit ;
   union __anonunion_temp_267926141 temp ;
   int alignment_mask ;
   struct _obstack_chunk *(*chunkfun)(void * , long  ) ;
   void (*freefun)(void * , struct _obstack_chunk * ) ;
   void *extra_arg ;
   unsigned int use_extra_arg : 1 ;
   unsigned int maybe_empty_object : 1 ;
   unsigned int alloc_failed : 1 ;
};
#line 28 "/home/wslee/project/coreutils-8.1/lib/readtokens0.h"
struct Tokens {
   size_t n_tok ;
   char **tok ;
   size_t *tok_len ;
   struct obstack o_data ;
   struct obstack o_tok ;
   struct obstack o_tok_len ;
};
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 42 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __exit_status {
   short e_termination ;
   short e_exit ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct __anonstruct_ut_tv_415302911 {
   __int32_t tv_sec ;
   __int32_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/bits/utmpx.h"
struct utmpx {
   short ut_type ;
   __pid_t ut_pid ;
   char ut_line[32] ;
   char ut_id[4] ;
   char ut_user[32] ;
   char ut_host[256] ;
   struct __exit_status ut_exit ;
   __int32_t ut_session ;
   struct __anonstruct_ut_tv_415302911 ut_tv ;
   __int32_t ut_addr_v6[4] ;
   char __glibc_reserved[20] ;
};
#line 144 "/home/wslee/project/coreutils-8.1/lib/readutmp.h"
typedef struct utmpx STRUCT_UTMP;
#line 56 "./regex.h"
typedef ssize_t regoff_t;
#line 61 "./regex.h"
typedef size_t __re_idx_t;
#line 64 "./regex.h"
typedef size_t __re_size_t;
#line 68 "./regex.h"
typedef size_t __re_long_size_t;
#line 94 "./regex.h"
typedef unsigned long reg_syntax_t;
#line 372
enum __anonenum_reg_errcode_t_721730718 {
    _REG_ENOSYS = -1,
    _REG_NOERROR = 0,
    _REG_NOMATCH = 1,
    _REG_BADPAT = 2,
    _REG_ECOLLATE = 3,
    _REG_ECTYPE = 4,
    _REG_EESCAPE = 5,
    _REG_ESUBREG = 6,
    _REG_EBRACK = 7,
    _REG_EPAREN = 8,
    _REG_EBRACE = 9,
    _REG_BADBR = 10,
    _REG_ERANGE = 11,
    _REG_ESPACE = 12,
    _REG_BADRPT = 13,
    _REG_EEND = 14,
    _REG_ESIZE = 15,
    _REG_ERPAREN = 16
} ;
#line 372 "./regex.h"
typedef enum __anonenum_reg_errcode_t_721730718 reg_errcode_t;
#line 450 "./regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   __re_long_size_t allocated ;
   __re_long_size_t used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 518 "./regex.h"
typedef struct re_pattern_buffer regex_t;
#line 522 "./regex.h"
struct re_registers {
   __re_size_t num_regs ;
   regoff_t *start ;
   regoff_t *end ;
};
#line 541 "./regex.h"
struct __anonstruct_regmatch_t_1035675074 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 541 "./regex.h"
typedef struct __anonstruct_regmatch_t_1035675074 regmatch_t;
#line 52 "/usr/include/wctype.h"
typedef unsigned long wctype_t;
#line 130 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef __re_idx_t Idx;
#line 153 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef __re_size_t re_hashval_t;
#line 157 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef unsigned long bitset_word_t;
#line 194 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef bitset_word_t bitset_t[4];
#line 195 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef bitset_word_t *re_bitset_ptr_t;
#line 196 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef bitset_word_t const   *re_const_bitset_ptr_t;
#line 209
enum __anonenum_re_context_type_961346151 {
    INSIDE_WORD = 5,
    WORD_FIRST = 6,
    WORD_LAST = 9,
    INSIDE_NOTWORD = 10,
    LINE_FIRST = 16,
    LINE_LAST = 32,
    BUF_FIRST = 64,
    BUF_LAST = 128,
    WORD_DELIM = 256,
    NOT_WORD_DELIM = 512
} ;
#line 209 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef enum __anonenum_re_context_type_961346151 re_context_type;
#line 223 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_re_node_set_397540522 {
   Idx alloc ;
   Idx nelem ;
   Idx *elems ;
};
#line 223 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_re_node_set_397540522 re_node_set;
#line 230
enum __anonenum_re_token_type_t_412351811 {
    NON_TYPE = 0,
    CHARACTER = 1,
    END_OF_RE = 2,
    SIMPLE_BRACKET = 3,
    OP_BACK_REF = 4,
    OP_PERIOD = 5,
    COMPLEX_BRACKET = 6,
    OP_UTF8_PERIOD = 7,
    OP_OPEN_SUBEXP = 8,
    OP_CLOSE_SUBEXP = 9,
    OP_ALT = 10,
    OP_DUP_ASTERISK = 11,
    ANCHOR = 12,
    CONCAT = 16,
    SUBEXP = 17,
    OP_DUP_PLUS = 18,
    OP_DUP_QUESTION = 19,
    OP_OPEN_BRACKET = 20,
    OP_CLOSE_BRACKET = 21,
    OP_CHARSET_RANGE = 22,
    OP_OPEN_DUP_NUM = 23,
    OP_CLOSE_DUP_NUM = 24,
    OP_NON_MATCH_LIST = 25,
    OP_OPEN_COLL_ELEM = 26,
    OP_CLOSE_COLL_ELEM = 27,
    OP_OPEN_EQUIV_CLASS = 28,
    OP_CLOSE_EQUIV_CLASS = 29,
    OP_OPEN_CHAR_CLASS = 30,
    OP_CLOSE_CHAR_CLASS = 31,
    OP_WORD = 32,
    OP_NOTWORD = 33,
    OP_SPACE = 34,
    OP_NOTSPACE = 35,
    BACK_SLASH = 36
} ;
#line 230 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef enum __anonenum_re_token_type_t_412351811 re_token_type_t;
#line 282 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_re_charset_t_533161772 {
   wchar_t *mbchars ;
   wchar_t *range_starts ;
   wchar_t *range_ends ;
   wctype_t *char_classes ;
   unsigned int non_match : 1 ;
   Idx nmbchars ;
   Idx ncoll_syms ;
   Idx nequiv_classes ;
   Idx nranges ;
   Idx nchar_classes ;
};
#line 282 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_re_charset_t_533161772 re_charset_t;
#line 329 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
union __anonunion_opr_701081363 {
   unsigned char c ;
   re_bitset_ptr_t sbcset ;
   re_charset_t *mbcset ;
   Idx idx ;
   re_context_type ctx_type ;
};
#line 329 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_re_token_t_425383872 {
   union __anonunion_opr_701081363 opr ;
   re_token_type_t type : 8 ;
   unsigned int constraint : 10 ;
   unsigned int duplicated : 1 ;
   unsigned int opt_subexp : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int mb_partial : 1 ;
   unsigned int word_char : 1 ;
};
#line 329 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_re_token_t_425383872 re_token_t;
#line 360 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct re_string_t {
   unsigned char const   *raw_mbs ;
   unsigned char *mbs ;
   wint_t *wcs ;
   Idx *offsets ;
   mbstate_t cur_state ;
   Idx raw_mbs_idx ;
   Idx valid_len ;
   Idx valid_raw_len ;
   Idx bufs_len ;
   Idx cur_idx ;
   Idx raw_len ;
   Idx len ;
   Idx raw_stop ;
   Idx stop ;
   unsigned int tip_context ;
   unsigned char *trans ;
   re_const_bitset_ptr_t word_char ;
   unsigned char icase ;
   unsigned char is_utf8 ;
   unsigned char map_notascii ;
   unsigned char mbs_allocated ;
   unsigned char offsets_needed ;
   unsigned char newline_anchor ;
   unsigned char word_ops_used ;
   int mb_cur_max ;
};
#line 415 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct re_string_t re_string_t;
#line 418
struct re_dfa_t ;
#line 419 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct re_dfa_t re_dfa_t;
#line 482 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct bin_tree_t {
   struct bin_tree_t *parent ;
   struct bin_tree_t *left ;
   struct bin_tree_t *right ;
   struct bin_tree_t *first ;
   struct bin_tree_t *next ;
   re_token_t token ;
   Idx node_idx ;
};
#line 496 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct bin_tree_t bin_tree_t;
#line 501 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct bin_tree_storage_t {
   struct bin_tree_storage_t *next ;
   bin_tree_t data[(1024UL - sizeof(void *)) / sizeof(bin_tree_t )] ;
};
#line 506 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct bin_tree_storage_t bin_tree_storage_t;
#line 536 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct re_dfastate_t {
   re_hashval_t hash ;
   re_node_set nodes ;
   re_node_set non_eps_nodes ;
   re_node_set inveclosure ;
   re_node_set *entrance_nodes ;
   struct re_dfastate_t **trtable ;
   struct re_dfastate_t **word_trtable ;
   unsigned int context : 4 ;
   unsigned int halt : 1 ;
   unsigned int accept_mb : 1 ;
   unsigned int has_backref : 1 ;
   unsigned int has_constraint : 1 ;
};
#line 554 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct re_dfastate_t re_dfastate_t;
#line 556 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct re_state_table_entry {
   Idx num ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 565 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_state_array_t_793059239 {
   Idx next_idx ;
   Idx alloc ;
   re_dfastate_t **array ;
};
#line 565 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_state_array_t_793059239 state_array_t;
#line 574 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_re_sub_match_last_t_590766955 {
   Idx node ;
   Idx str_idx ;
   state_array_t path ;
};
#line 574 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_re_sub_match_last_t_590766955 re_sub_match_last_t;
#line 585 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_re_sub_match_top_t_1066558227 {
   Idx str_idx ;
   Idx node ;
   state_array_t *path ;
   Idx alasts ;
   Idx nlasts ;
   re_sub_match_last_t **lasts ;
};
#line 585 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_re_sub_match_top_t_1066558227 re_sub_match_top_t;
#line 595 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct re_backref_cache_entry {
   Idx node ;
   Idx str_idx ;
   Idx subexp_from ;
   Idx subexp_to ;
   char more ;
   char unused ;
   unsigned short eps_reachable_subexps_map ;
};
#line 606 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_re_match_context_t_201234058 {
   re_string_t input ;
   re_dfa_t const   *dfa ;
   int eflags ;
   Idx match_last ;
   Idx last_node ;
   re_dfastate_t **state_log ;
   Idx state_log_top ;
   Idx nbkref_ents ;
   Idx abkref_ents ;
   struct re_backref_cache_entry *bkref_ents ;
   int max_mb_elem_len ;
   Idx nsub_tops ;
   Idx asub_tops ;
   re_sub_match_top_t **sub_tops ;
};
#line 606 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_re_match_context_t_201234058 re_match_context_t;
#line 633 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_re_sift_context_t_945197081 {
   re_dfastate_t **sifted_states ;
   re_dfastate_t **limited_states ;
   Idx last_node ;
   Idx last_str_idx ;
   re_node_set limits ;
};
#line 633 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_re_sift_context_t_945197081 re_sift_context_t;
#line 642 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct re_fail_stack_ent_t {
   Idx idx ;
   Idx node ;
   regmatch_t *regs ;
   re_node_set eps_via_nodes ;
};
#line 650 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct re_fail_stack_t {
   Idx num ;
   Idx alloc ;
   struct re_fail_stack_ent_t *stack ;
};
#line 657 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct re_dfa_t {
   re_token_t *nodes ;
   size_t nodes_alloc ;
   size_t nodes_len ;
   Idx *nexts ;
   Idx *org_indices ;
   re_node_set *edests ;
   re_node_set *eclosures ;
   re_node_set *inveclosures ;
   struct re_state_table_entry *state_table ;
   re_dfastate_t *init_state ;
   re_dfastate_t *init_state_word ;
   re_dfastate_t *init_state_nl ;
   re_dfastate_t *init_state_begbuf ;
   bin_tree_t *str_tree ;
   bin_tree_storage_t *str_tree_storage ;
   re_bitset_ptr_t sb_char ;
   int str_tree_storage_idx ;
   re_hashval_t state_hash_mask ;
   Idx init_node ;
   Idx nbackref ;
   bitset_word_t used_bkref_map ;
   bitset_word_t completed_bkref_map ;
   unsigned int has_plural_match : 1 ;
   unsigned int has_mb_node : 1 ;
   unsigned int is_utf8 : 1 ;
   unsigned int map_notascii : 1 ;
   unsigned int word_ops_used : 1 ;
   int mb_cur_max ;
   bitset_t word_char ;
   reg_syntax_t syntax ;
   Idx *subexp_map ;
};
#line 713
enum __anonenum_bracket_elem_type_1002392186 {
    SB_CHAR = 0,
    MB_CHAR = 1,
    EQUIV_CLASS = 2,
    COLL_SYM = 3,
    CHAR_CLASS = 4
} ;
#line 713 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef enum __anonenum_bracket_elem_type_1002392186 bracket_elem_type;
#line 722 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
union __anonunion_opr_675232149 {
   unsigned char ch ;
   unsigned char *name ;
   wchar_t wch ;
};
#line 722 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
struct __anonstruct_bracket_elem_t_509387307 {
   bracket_elem_type type ;
   union __anonunion_opr_675232149 opr ;
};
#line 722 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
typedef struct __anonstruct_bracket_elem_t_509387307 bracket_elem_t;
#line 3373 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
struct dests_alloc {
   re_node_set dests_node[256] ;
   bitset_t dests_ch[256] ;
};
#line 23 "/home/wslee/project/coreutils-8.1/lib/save-cwd.h"
struct saved_cwd {
   int desc ;
   char *name ;
};
#line 209 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
union __anonunion_875737058 {
   int __in ;
   int __i ;
};
#line 208 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
union __anonunion_875737059 {
   int __in ;
   int __i ;
};
#line 210 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
union __anonunion_875737060 {
   int __in ;
   int __i ;
};
#line 33 "/home/wslee/project/coreutils-8.1/lib/sha1.h"
struct sha1_ctx {
   uint32_t A ;
   uint32_t B ;
   uint32_t C ;
   uint32_t D ;
   uint32_t E ;
   uint32_t total[2] ;
   uint32_t buflen ;
   uint32_t buffer[32] ;
};
#line 247 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
struct __anonstruct_833865290___1 {
   char c ;
   uint32_t x ;
};
#line 29 "/home/wslee/project/coreutils-8.1/lib/sha256.h"
struct sha256_ctx {
   uint32_t state[8] ;
   uint32_t total[2] ;
   size_t buflen ;
   uint32_t buffer[32] ;
};
#line 378 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
struct __anonstruct_833865290___2 {
   char c ;
   uint32_t x ;
};
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 30 "/home/wslee/project/coreutils-8.1/lib/u64.h"
typedef uint64_t u64;
#line 30 "/home/wslee/project/coreutils-8.1/lib/sha512.h"
struct sha512_ctx {
   u64 state[8] ;
   u64 total[2] ;
   size_t buflen ;
   u64 buffer[32] ;
};
#line 386 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
struct __anonstruct_972123420 {
   char c ;
   u64 x ;
};
#line 41 "/home/wslee/project/coreutils-8.1/lib/sig2str.c"
struct numname {
   int num ;
   char const   name[8] ;
};
#line 29 "/usr/include/iconv.h"
typedef void *iconv_t;
#line 63 "/home/wslee/project/coreutils-8.1/lib/striconv.c"
union __anonunion_tmp_771759453 {
   unsigned int align ;
   char buf[4096] ;
};
#line 100 "/home/wslee/project/coreutils-8.1/lib/mbiter.h"
struct mbiter_multi {
   char const   *limit ;
   _Bool in_shift ;
   mbstate_t state ;
   _Bool next_done ;
   struct mbchar cur ;
};
#line 195 "/home/wslee/project/coreutils-8.1/lib/mbiter.h"
typedef struct mbiter_multi mbi_iterator_t;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 24 "/home/wslee/project/coreutils-8.1/lib/unitypes.h"
typedef uint32_t ucs4_t;
#line 62 "/home/wslee/project/coreutils-8.1/lib/utimecmp.c"
struct fs_res {
   dev_t dev ;
   int resolution ;
   _Bool exact ;
};
#line 1 "cil-FITHh4pK.o"
#pragma merger("0","du.o.i","")
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 243 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 519
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 140 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 143
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 231
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 1 "/home/wslee/project/coreutils-8.1/src/version.h"
char const   *Version ;
#line 25 "../lib/timespec.h"
__inline static int timespec_cmp(struct timespec a , struct timespec b ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 28
  if (a.tv_sec < b.tv_sec) {
#line 28
    tmp___2 = -1;
  } else {
#line 28
    if (a.tv_sec > b.tv_sec) {
#line 28
      tmp___1 = 1;
    } else {
#line 28
      if (a.tv_nsec < b.tv_nsec) {
#line 28
        tmp___0 = -1;
      } else {
#line 28
        if (a.tv_nsec > b.tv_nsec) {
#line 28
          tmp = 1;
        } else {
#line 28
          tmp = 0;
        }
#line 28
        tmp___0 = tmp;
      }
#line 28
      tmp___1 = tmp___0;
    }
#line 28
    tmp___2 = tmp___1;
  }
#line 28
  return (tmp___2);
}
}
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 53 "../lib/xalloc.h"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 55
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 57
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 58
void *xrealloc(void *p , size_t n ) ;
#line 131 "../lib/xalloc.h"
__inline static void *xnrealloc(void *p , size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 134
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 134
    tmp = -1;
  } else {
#line 134
    tmp = -2;
  }
#line 134
  if ((size_t )tmp / s < n) {
#line 135
    xalloc_die();
  }
#line 136
  tmp___0 = xrealloc(p, n * s);
#line 136
  return (tmp___0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 252
extern int fflush_unlocked(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 603
extern int putchar_unlocked(int __c ) ;
#line 726
extern int fputs_unlocked(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 837
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror_unlocked)(FILE *__stream ) ;
#line 69 "../lib/dirname.h"
char *last_component(char const   *name ) ;
#line 30 "../lib/closeout.h"
void close_stdout(void) ;
#line 69 "../lib/version-etc.h"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 98 "../lib/propername.h"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) ;
#line 32 "../lib/progname.h"
char const   *program_name ;
#line 35
void set_program_name(char const   *argv0 ) ;
#line 566 "/home/wslee/project/coreutils-8.1/src/system.h"
__inline static void emit_size_note(void) 
{ 
  char *tmp ;

  {
#line 569
  tmp = gettext("\nSIZE may be (or may be an integer optionally followed by) one of following:\nKB 1000, K 1024, MB 1000*1000, M 1024*1024, and so on for G, T, P, E, Z, Y.\n");
#line 569
  fputs_unlocked((char const   * __restrict  )tmp, (FILE * __restrict  )stdout);
#line 573
  return;
}
}
#line 575 "/home/wslee/project/coreutils-8.1/src/system.h"
__inline static void emit_blocksize_note(char const   *program ) 
{ 
  char *tmp ;

  {
#line 578
  tmp = gettext("\nDisplay values are in units of the first available SIZE from --block-size,\nand the %s_BLOCK_SIZE, BLOCK_SIZE and BLOCKSIZE environment variables.\nOtherwise, units default to 1024 bytes (or 512 if POSIXLY_CORRECT is set).\n");
#line 578
  printf((char const   * __restrict  )tmp, program);
#line 583
  return;
}
}
#line 585 "/home/wslee/project/coreutils-8.1/src/system.h"
__inline static void emit_ancillary_info(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char const   *lc_messages ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 588
  tmp = last_component(program_name);
#line 588
  tmp___0 = gettext("\nReport %s bugs to %s\n");
#line 588
  printf((char const   * __restrict  )tmp___0, tmp, "bug-coreutils@gnu.org");
#line 591
  tmp___1 = gettext("%s home page: <http://www.gnu.org/software/%s/>\n");
#line 591
  printf((char const   * __restrict  )tmp___1, "GNU coreutils", "coreutils");
#line 593
  tmp___2 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 593
  fputs_unlocked((char const   * __restrict  )tmp___2, (FILE * __restrict  )stdout);
#line 597
  tmp___3 = setlocale(5, (char const   *)((void *)0));
#line 597
  lc_messages = (char const   *)tmp___3;
#line 598
  if (lc_messages) {
#line 598
    tmp___6 = strncmp(lc_messages, "en_", (size_t )3);
#line 598
    if (tmp___6) {
#line 604
      tmp___4 = last_component(program_name);
#line 604
      tmp___5 = gettext("Report %s translation bugs to <http://translationproject.org/team/>\n");
#line 604
      printf((char const   * __restrict  )tmp___5, tmp___4);
    }
  }
#line 608
  tmp___7 = last_component(program_name);
#line 608
  tmp___8 = gettext("For complete documentation, run: info coreutils \'%s invocation\'\n");
#line 608
  printf((char const   * __restrict  )tmp___8, tmp___7);
#line 610
  return;
}
}
#line 44 "../lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___0 ) ;
#line 614 "/home/wslee/project/coreutils-8.1/src/system.h"
__inline static char *timetostr(time_t t , char *buf___0 ) 
{ 
  char *tmp ;

  {
#line 617
  tmp = imaxtostr(t, buf___0);
#line 617
  return (tmp);
}
}
#line 622 "/home/wslee/project/coreutils-8.1/src/system.h"
__inline static char *bad_cast(char const   *s ) 
{ 


  {
#line 625
  return ((char *)s);
}
}
#line 673
 __attribute__((__noreturn__)) void usage(int status ) ;
#line 52 "../lib/argmatch.h"
void (*argmatch_die)(void) ;
#line 79
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) ;
#line 38 "../lib/argv-iter.h"
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_argv)(char **argv ) ;
#line 40
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_stream)(FILE *fp ) ;
#line 42
char *( __attribute__((__nonnull__(2), __nonnull__(1))) argv_iter)(struct argv_iterator *ai ,
                                                                   enum argv_iter_err *err ) ;
#line 44
size_t ( __attribute__((__nonnull__(1))) argv_iter_n_args)(struct argv_iterator  const  *ai ) ;
#line 46
void ( __attribute__((__nonnull__(1))) argv_iter_free)(struct argv_iterator *ai ) ;
#line 42 "../lib/error.h"
extern void ( /* format attribute */  error)(int __status , int __errnum , char const   *__format 
                                             , ...) ;
#line 39 "../lib/exclude.h"
struct exclude *new_exclude(void) ;
#line 41
void add_exclude(struct exclude *ex , char const   *pattern , int options ) ;
#line 42
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) ;
#line 44
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) ;
#line 28 "../lib/fprintftime.h"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) ;
#line 81 "../lib/hash.h"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) ;
#line 85
void hash_free(Hash_table *table ) ;
#line 89
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) ;
#line 45 "../lib/xstrtol.h"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) ;
#line 74
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct option  const  *long_options___1 ,
                                                  char const   *arg ) ;
#line 80 "../lib/human.h"
char *human_readable(uintmax_t n , char *buf___0 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) ;
#line 82
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) ;
#line 21 "../lib/quote.h"
char const   *quote(char const   *name ) ;
#line 358 "../lib/quotearg.h"
char *quotearg_colon(char const   *arg ) ;
#line 103 "../lib/stat-time.h"
__inline static struct timespec get_stat_atime(struct stat  const  *st ) 
{ 


  {
#line 107
  return ((struct timespec )st->st_atim);
}
}
#line 117 "../lib/stat-time.h"
__inline static struct timespec get_stat_ctime(struct stat  const  *st ) 
{ 


  {
#line 121
  return ((struct timespec )st->st_ctim);
}
}
#line 131 "../lib/stat-time.h"
__inline static struct timespec get_stat_mtime(struct stat  const  *st ) 
{ 


  {
#line 135
  return ((struct timespec )st->st_mtim);
}
}
#line 27 "../lib/stdio-safer.h"
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) ;
#line 255 "../lib/fts_.h"
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 259
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 260
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 4 "../lib/xfts.h"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) ;
#line 8
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent ) ;
#line 77 "/home/wslee/project/coreutils-8.1/src/du.c"
static Hash_table *htab  ;
#line 92 "/home/wslee/project/coreutils-8.1/src/du.c"
__inline static void duinfo_init(struct duinfo *a ) 
{ 


  {
#line 95
  a->size = (uintmax_t )0;
#line 96
  a->tmax.tv_sec = -1L << (sizeof(time_t ) * 8UL - 1UL);
#line 97
  a->tmax.tv_nsec = (__syscall_slong_t )-1;
#line 98
  return;
}
}
#line 101 "/home/wslee/project/coreutils-8.1/src/du.c"
__inline static void duinfo_set(struct duinfo *a , uintmax_t size , struct timespec tmax ) 
{ 


  {
#line 104
  a->size = size;
#line 105
  a->tmax = tmax;
#line 106
  return;
}
}
#line 109 "/home/wslee/project/coreutils-8.1/src/du.c"
__inline static void duinfo_add(struct duinfo *a , struct duinfo  const  *b ) 
{ 
  int tmp ;

  {
#line 112
  a->size += (uintmax_t )b->size;
#line 113
  tmp = timespec_cmp(a->tmax, (struct timespec )b->tmax);
#line 113
  if (tmp < 0) {
#line 114
    a->tmax = (struct timespec )b->tmax;
  }
#line 115
  return;
}
}
#line 128 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool opt_all  =    (_Bool)0;
#line 132 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool apparent_size  =    (_Bool)0;
#line 135 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool opt_count_all  =    (_Bool)0;
#line 138 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool opt_nul_terminate_output  =    (_Bool)0;
#line 141 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool print_grand_total  =    (_Bool)0;
#line 144 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool opt_separate_dirs  =    (_Bool)0;
#line 149 "/home/wslee/project/coreutils-8.1/src/du.c"
static size_t max_depth  =    0xffffffffffffffffUL;
#line 152 "/home/wslee/project/coreutils-8.1/src/du.c"
static int human_output_opts  ;
#line 155 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool opt_time  =    (_Bool)0;
#line 166 "/home/wslee/project/coreutils-8.1/src/du.c"
static enum time_type time_type  =    (enum time_type )0;
#line 169 "/home/wslee/project/coreutils-8.1/src/du.c"
static char const   *time_style  =    (char const   *)((void *)0);
#line 172 "/home/wslee/project/coreutils-8.1/src/du.c"
static char const   *time_format  =    (char const   *)((void *)0);
#line 175 "/home/wslee/project/coreutils-8.1/src/du.c"
static uintmax_t output_block_size  ;
#line 178 "/home/wslee/project/coreutils-8.1/src/du.c"
static struct exclude *exclude  ;
#line 181 "/home/wslee/project/coreutils-8.1/src/du.c"
static struct duinfo tot_dui  ;
#line 200 "/home/wslee/project/coreutils-8.1/src/du.c"
static struct option  const  long_options[24]  = 
#line 200
  {      {"all", 0, (int *)((void *)0), 'a'}, 
        {"apparent-size", 0, (int *)((void *)0), 128}, 
        {"block-size", 1, (int *)((void *)0), 'B'}, 
        {"bytes", 0, (int *)((void *)0), 'b'}, 
        {"count-links", 0, (int *)((void *)0), 'l'}, 
        {"dereference", 0, (int *)((void *)0), 'L'}, 
        {"dereference-args", 0, (int *)((void *)0), 'D'}, 
        {"exclude", 1, (int *)((void *)0), 129}, 
        {"exclude-from", 1, (int *)((void *)0), 'X'}, 
        {"files0-from", 1, (int *)((void *)0), 130}, 
        {"human-readable", 0, (int *)((void *)0), 'h'}, 
        {"si", 0, (int *)((void *)0), 131}, 
        {"max-depth", 1, (int *)((void *)0), 132}, 
        {"null", 0, (int *)((void *)0), '0'}, 
        {"no-dereference", 0, (int *)((void *)0), 'P'}, 
        {"one-file-system", 0, (int *)((void *)0), 'x'}, 
        {"separate-dirs", 0, (int *)((void *)0), 'S'}, 
        {"summarize", 0, (int *)((void *)0), 's'}, 
        {"total", 0, (int *)((void *)0), 'c'}, 
        {"time", 2, (int *)((void *)0), 133}, 
        {"time-style", 1, (int *)((void *)0), 134}, 
        {"help", 0, (int *)((void *)0), -130}, 
        {"version", 0, (int *)((void *)0), -131}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 228 "/home/wslee/project/coreutils-8.1/src/du.c"
static char const   * const  time_args[6]  = {      (char const   * const  )"atime",      (char const   * const  )"access",      (char const   * const  )"use",      (char const   * const  )"ctime", 
        (char const   * const  )"status",      (char const   * const  )((void *)0)};
#line 232 "/home/wslee/project/coreutils-8.1/src/du.c"
static enum time_type  const  time_types[5]  = {      (enum time_type  const  )2,      (enum time_type  const  )2,      (enum time_type  const  )2,      (enum time_type  const  )1, 
        (enum time_type  const  )1};
#line 248 "/home/wslee/project/coreutils-8.1/src/du.c"
static char const   * const  time_style_args[4]  = {      (char const   * const  )"full-iso",      (char const   * const  )"long-iso",      (char const   * const  )"iso",      (char const   * const  )((void *)0)};
#line 252 "/home/wslee/project/coreutils-8.1/src/du.c"
static enum time_style  const  time_style_types[3]  = {      (enum time_style  const  )0,      (enum time_style  const  )1,      (enum time_style  const  )2};
#line 258
 __attribute__((__noreturn__)) void usage(int status ) ;
#line 258 "/home/wslee/project/coreutils-8.1/src/du.c"
void usage(int status ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;

  {
#line 261
  if (status != 0) {
#line 262
    tmp = gettext("Try `%s --help\' for more information.\n");
#line 262
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp, program_name);
  } else {
#line 266
    tmp___0 = gettext("Usage: %s [OPTION]... [FILE]...\n  or:  %s [OPTION]... --files0-from=F\n");
#line 266
    printf((char const   * __restrict  )tmp___0, program_name, program_name);
#line 270
    tmp___1 = gettext("Summarize disk usage of each FILE, recursively for directories.\n\n");
#line 270
    fputs_unlocked((char const   * __restrict  )tmp___1, (FILE * __restrict  )stdout);
#line 274
    tmp___2 = gettext("Mandatory arguments to long options are mandatory for short options too.\n");
#line 274
    fputs_unlocked((char const   * __restrict  )tmp___2, (FILE * __restrict  )stdout);
#line 277
    tmp___3 = gettext("  -a, --all             write counts for all files, not just directories\n      --apparent-size   print apparent sizes, rather than disk usage; although\n                          the apparent size is usually smaller, it may be\n                          larger due to holes in (`sparse\') files, internal\n                          fragmentation, indirect blocks, and the like\n");
#line 277
    fputs_unlocked((char const   * __restrict  )tmp___3, (FILE * __restrict  )stdout);
#line 284
    tmp___4 = gettext("  -B, --block-size=SIZE  use SIZE-byte blocks\n  -b, --bytes           equivalent to `--apparent-size --block-size=1\'\n  -c, --total           produce a grand total\n  -D, --dereference-args  dereference only symlinks that are listed on the\n                          command line\n");
#line 284
    fputs_unlocked((char const   * __restrict  )tmp___4, (FILE * __restrict  )stdout);
#line 291
    tmp___5 = gettext("      --files0-from=F   summarize disk usage of the NUL-terminated file\n                          names specified in file F;\n                          If F is - then read names from standard input\n  -H                    equivalent to --dereference-args (-D)\n  -h, --human-readable  print sizes in human readable format (e.g., 1K 234M 2G)\n      --si              like -h, but use powers of 1000 not 1024\n");
#line 291
    fputs_unlocked((char const   * __restrict  )tmp___5, (FILE * __restrict  )stdout);
#line 299
    tmp___6 = gettext("  -k                    like --block-size=1K\n  -l, --count-links     count sizes many times if hard linked\n  -m                    like --block-size=1M\n");
#line 299
    fputs_unlocked((char const   * __restrict  )tmp___6, (FILE * __restrict  )stdout);
#line 304
    tmp___7 = gettext("  -L, --dereference     dereference all symbolic links\n  -P, --no-dereference  don\'t follow any symbolic links (this is the default)\n  -0, --null            end each output line with 0 byte rather than newline\n  -S, --separate-dirs   do not include size of subdirectories\n  -s, --summarize       display only a total for each argument\n");
#line 304
    fputs_unlocked((char const   * __restrict  )tmp___7, (FILE * __restrict  )stdout);
#line 311
    tmp___8 = gettext("  -x, --one-file-system    skip directories on different file systems\n  -X, --exclude-from=FILE  exclude files that match any pattern in FILE\n      --exclude=PATTERN    exclude files that match PATTERN\n      --max-depth=N     print the total for a directory (or file, with --all)\n                          only if it is N or fewer levels below the command\n                          line argument;  --max-depth=0 is the same as\n                          --summarize\n");
#line 311
    fputs_unlocked((char const   * __restrict  )tmp___8, (FILE * __restrict  )stdout);
#line 320
    tmp___9 = gettext("      --time            show time of the last modification of any file in the\n                          directory, or any of its subdirectories\n      --time=WORD       show time as WORD instead of modification time:\n                          atime, access, use, ctime or status\n      --time-style=STYLE  show times using style STYLE:\n                          full-iso, long-iso, iso, +FORMAT\n                          FORMAT is interpreted like `date\'\n");
#line 320
    fputs_unlocked((char const   * __restrict  )tmp___9, (FILE * __restrict  )stdout);
#line 329
    tmp___10 = gettext("      --help     display this help and exit\n");
#line 329
    fputs_unlocked((char const   * __restrict  )tmp___10, (FILE * __restrict  )stdout);
#line 330
    tmp___11 = gettext("      --version  output version information and exit\n");
#line 330
    fputs_unlocked((char const   * __restrict  )tmp___11, (FILE * __restrict  )stdout);
#line 331
    emit_blocksize_note("DU");
#line 332
    emit_size_note();
#line 333
    emit_ancillary_info();
  }
#line 335
  exit(status);
}
}
#line 338 "/home/wslee/project/coreutils-8.1/src/du.c"
static size_t entry_hash(void const   *x , size_t table_size ) 
{ 
  struct entry  const  *p ;

  {
#line 341
  p = (struct entry  const  *)x;
#line 346
  return ((uintmax_t )p->st_ino % table_size);
}
}
#line 350 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool entry_compare(void const   *x , void const   *y ) 
{ 
  struct entry  const  *a ;
  struct entry  const  *b ;
  int tmp ;

  {
#line 353
  a = (struct entry  const  *)x;
#line 354
  b = (struct entry  const  *)y;
#line 355
  if (a->st_ino == b->st_ino) {
#line 355
    if (a->st_dev == b->st_dev) {
#line 355
      tmp = 1;
    } else {
#line 355
      tmp = 0;
    }
  } else {
#line 355
    tmp = 0;
  }
#line 355
  return ((_Bool )tmp);
}
}
#line 361 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool hash_ins(ino_t ino , dev_t dev ) 
{ 
  struct entry *ent ;
  struct entry *ent_from_table ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 367
  tmp = xmalloc(sizeof(*ent));
#line 367
  ent = (struct entry *)tmp;
#line 368
  ent->st_ino = ino;
#line 369
  ent->st_dev = dev;
#line 371
  tmp___0 = hash_insert(htab, (void const   *)ent);
#line 371
  ent_from_table = (struct entry *)tmp___0;
#line 372
  if ((unsigned long )ent_from_table == (unsigned long )((void *)0)) {
#line 375
    xalloc_die();
  }
#line 378
  if ((unsigned long )ent_from_table == (unsigned long )ent) {
#line 381
    return ((_Bool)1);
  }
#line 385
  free((void *)ent);
#line 387
  return ((_Bool)0);
}
}
#line 391 "/home/wslee/project/coreutils-8.1/src/du.c"
static void hash_init(void) 
{ 


  {
#line 394
  htab = hash_initialize((size_t )103, (Hash_tuning const   *)((void *)0), & entry_hash,
                         & entry_compare, (void (*)(void * ))(& free));
#line 396
  if ((unsigned long )htab == (unsigned long )((void *)0)) {
#line 397
    xalloc_die();
  }
#line 398
  return;
}
}
#line 404 "/home/wslee/project/coreutils-8.1/src/du.c"
static void show_date(char const   *format , struct timespec when ) 
{ 
  struct tm *tm ;
  struct tm *tmp ;
  char buf___0[((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL) + 1UL] ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 407
  tmp = localtime((time_t const   *)(& when.tv_sec));
#line 407
  tm = tmp;
#line 408
  if (! tm) {
#line 411
    tmp___0 = timetostr(when.tv_sec, buf___0);
#line 411
    tmp___1 = gettext("time %s is out of range");
#line 411
    error(0, 0, (char const   *)tmp___1, tmp___0);
#line 412
    fputs_unlocked((char const   * __restrict  )(buf___0), (FILE * __restrict  )stdout);
#line 413
    return;
  }
#line 416
  fprintftime(stdout, format, (struct tm  const  *)tm, 0, (int )when.tv_nsec);
#line 417
  return;
}
}
#line 421 "/home/wslee/project/coreutils-8.1/src/du.c"
static void print_only_size(uintmax_t n_bytes ) 
{ 
  char buf___0[(((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL) + 1UL] ;
  char *tmp ;

  {
#line 425
  tmp = human_readable(n_bytes, buf___0, human_output_opts, (uintmax_t )1, output_block_size);
#line 425
  fputs_unlocked((char const   * __restrict  )tmp, (FILE * __restrict  )stdout);
#line 427
  return;
}
}
#line 431 "/home/wslee/project/coreutils-8.1/src/du.c"
static void print_size(struct duinfo  const  *pdui , char const   *string ) 
{ 
  int tmp ;

  {
#line 434
  print_only_size((uintmax_t )pdui->size);
#line 435
  if (opt_time) {
#line 437
    putchar_unlocked('\t');
#line 438
    show_date(time_format, (struct timespec )pdui->tmax);
  }
#line 440
  if (opt_nul_terminate_output) {
#line 440
    tmp = '\000';
  } else {
#line 440
    tmp = '\n';
  }
#line 440
  printf((char const   * __restrict  )"\t%s%c", string, tmp);
#line 441
  fflush_unlocked(stdout);
#line 442
  return;
}
}
#line 456 "/home/wslee/project/coreutils-8.1/src/du.c"
static size_t prev_level  ;
#line 457 "/home/wslee/project/coreutils-8.1/src/du.c"
static size_t n_alloc  ;
#line 466 "/home/wslee/project/coreutils-8.1/src/du.c"
static struct dulevel *dulvl  ;
#line 449 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool process_file(FTS *fts , FTSENT *ent ) 
{ 
  _Bool ok ;
  struct duinfo dui ;
  struct duinfo dui_to_print ;
  size_t level ;
  _Bool print ;
  char const   *file ;
  struct stat  const  *sb ;
  _Bool skip ;
  char const   *tmp ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;
  char *tmp___6 ;
  _Bool tmp___7 ;
  struct timespec tmp___8 ;
  struct timespec tmp___9 ;
  struct timespec tmp___10 ;
  struct timespec tmp___11 ;
  struct timespec tmp___12 ;
  uintmax_t tmp___13 ;
  _Bool tmp___14 ;
  void *tmp___15 ;
  size_t i ;
  void *tmp___16 ;

  {
#line 467
  print = (_Bool)1;
#line 469
  file = (char const   *)ent->fts_path;
#line 470
  sb = (struct stat  const  *)(ent->fts_statp);
#line 474
  skip = excluded_file_name((struct exclude  const  *)exclude, file);
#line 475
  if (skip) {
#line 476
    fts_set(fts, ent, 4);
  }
#line 478
  switch ((int )ent->fts_info) {
  case 10: 
#line 481
  tmp = quote(file);
#line 481
  tmp___0 = gettext("cannot access %s");
#line 481
  error(0, ent->fts_errno, (char const   *)tmp___0, tmp);
#line 482
  return ((_Bool)0);
  case 7: 
#line 486
  tmp___1 = quote(file);
#line 486
  tmp___2 = gettext("%s");
#line 486
  error(0, ent->fts_errno, (char const   *)tmp___2, tmp___1);
#line 487
  return ((_Bool)0);
  case 4: 
#line 492
  tmp___3 = quote(file);
#line 492
  tmp___4 = gettext("cannot read directory %s");
#line 492
  error(0, ent->fts_errno, (char const   *)tmp___4, tmp___3);
#line 493
  ok = (_Bool)0;
#line 494
  break;
  case 2: 
#line 497
  tmp___7 = cycle_warning_required((FTS const   *)fts, (FTSENT const   *)ent);
#line 497
  if (tmp___7) {
#line 499
    while (1) {
#line 499
      tmp___5 = quote(file);
#line 499
      tmp___6 = gettext("WARNING: Circular directory structure.\nThis almost certainly means that you have a corrupted file system.\nNOTIFY YOUR SYSTEM MANAGER.\nThe following directory is part of the cycle:\n  %s\n");
#line 499
      error(0, 0, (char const   *)tmp___6, tmp___5);
#line 499
      break;
    }
#line 500
    return ((_Bool)0);
  }
#line 502
  ok = (_Bool)1;
#line 503
  break;
  default: 
#line 506
  ok = (_Bool)1;
#line 507
  break;
  }
#line 513
  if ((int )ent->fts_info == 1) {
#line 514
    return (ok);
  } else
#line 513
  if (skip) {
#line 514
    return (ok);
  }
#line 518
  if (skip) {
#line 527
    duinfo_init(& dui);
#line 528
    print = (_Bool)0;
  } else
#line 518
  if (! opt_count_all) {
#line 518
    if (! ((sb->st_mode & 61440U) == 16384U)) {
#line 518
      if (1UL < sb->st_nlink) {
#line 518
        tmp___14 = hash_ins((ino_t )sb->st_ino, (dev_t )sb->st_dev);
#line 518
        if (tmp___14) {
#line 518
          goto _L___1;
        } else {
#line 527
          duinfo_init(& dui);
#line 528
          print = (_Bool)0;
        }
      } else {
#line 518
        goto _L___1;
      }
    } else {
#line 518
      goto _L___1;
    }
  } else {
    _L___1: /* CIL Label */ 
#line 532
    if ((unsigned int )time_type == 0U) {
#line 532
      tmp___8 = get_stat_mtime(sb);
#line 532
      tmp___12 = tmp___8;
    } else {
#line 532
      if ((unsigned int )time_type == 2U) {
#line 532
        tmp___9 = get_stat_atime(sb);
#line 532
        tmp___11 = tmp___9;
      } else {
#line 532
        tmp___10 = get_stat_ctime(sb);
#line 532
        tmp___11 = tmp___10;
      }
#line 532
      tmp___12 = tmp___11;
    }
#line 532
    if (apparent_size) {
#line 532
      tmp___13 = (uintmax_t )sb->st_size;
    } else {
#line 532
      tmp___13 = (uintmax_t )sb->st_blocks * 512UL;
    }
#line 532
    duinfo_set(& dui, tmp___13, tmp___12);
  }
#line 541
  level = (size_t )ent->fts_level;
#line 542
  dui_to_print = dui;
#line 544
  if (n_alloc == 0UL) {
#line 546
    n_alloc = level + 10UL;
#line 547
    tmp___15 = xcalloc(n_alloc, sizeof(*dulvl));
#line 547
    dulvl = (struct dulevel *)tmp___15;
  } else
#line 551
  if (! (level == prev_level)) {
#line 555
    if (level > prev_level) {
#line 563
      if (n_alloc <= level) {
#line 565
        tmp___16 = xnrealloc((void *)dulvl, level, 2UL * sizeof(*dulvl));
#line 565
        dulvl = (struct dulevel *)tmp___16;
#line 566
        n_alloc = level * 2UL;
      }
#line 569
      i = prev_level + 1UL;
#line 569
      while (i <= level) {
#line 571
        duinfo_init(& (dulvl + i)->ent);
#line 572
        duinfo_init(& (dulvl + i)->subdir);
#line 569
        i ++;
      }
    } else {
#line 583
      if (! (level == prev_level - 1UL)) {
#line 583
        __assert_fail("level == prev_level - 1", "/home/wslee/project/coreutils-8.1/src/du.c",
                      583U, "process_file");
      }
#line 584
      duinfo_add(& dui_to_print, (struct duinfo  const  *)(& (dulvl + prev_level)->ent));
#line 585
      if (! opt_separate_dirs) {
#line 586
        duinfo_add(& dui_to_print, (struct duinfo  const  *)(& (dulvl + prev_level)->subdir));
      }
#line 587
      duinfo_add(& (dulvl + level)->subdir, (struct duinfo  const  *)(& (dulvl + prev_level)->ent));
#line 588
      duinfo_add(& (dulvl + level)->subdir, (struct duinfo  const  *)(& (dulvl + prev_level)->subdir));
    }
  }
#line 592
  prev_level = level;
#line 596
  if (opt_separate_dirs) {
#line 596
    if (! ((int )ent->fts_info == 6)) {
#line 596
      if (! ((int )ent->fts_info == 4)) {
#line 597
        duinfo_add(& (dulvl + level)->ent, (struct duinfo  const  *)(& dui));
      }
    }
  } else {
#line 597
    duinfo_add(& (dulvl + level)->ent, (struct duinfo  const  *)(& dui));
  }
#line 601
  duinfo_add(& tot_dui, (struct duinfo  const  *)(& dui));
#line 606
  if (! print) {
#line 607
    return (ok);
  }
#line 609
  if ((int )ent->fts_info == 6) {
#line 609
    goto _L___4;
  } else
#line 609
  if ((int )ent->fts_info == 4) {
    _L___4: /* CIL Label */ 
#line 609
    if (level <= max_depth) {
#line 611
      print_size((struct duinfo  const  *)(& dui_to_print), file);
    } else {
#line 609
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 609
  if (opt_all) {
#line 609
    if (level <= max_depth) {
#line 611
      print_size((struct duinfo  const  *)(& dui_to_print), file);
    } else {
#line 609
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 609
  if (level == 0UL) {
#line 611
    print_size((struct duinfo  const  *)(& dui_to_print), file);
  }
#line 613
  return (ok);
}
}
#line 621 "/home/wslee/project/coreutils-8.1/src/du.c"
static _Bool du_files(char **files , int bit_flags ) 
{ 
  _Bool ok ;
  FTS *fts ;
  FTS *tmp ;
  FTSENT *ent ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 624
  ok = (_Bool)1;
#line 626
  if (*files) {
#line 628
    tmp = xfts_open((char * const  *)files, bit_flags, (int (*)(FTSENT const   ** ,
                                                                FTSENT const   ** ))((void *)0));
#line 628
    fts = tmp;
#line 630
    while (1) {
#line 634
      ent = fts_read(fts);
#line 635
      if ((unsigned long )ent == (unsigned long )((void *)0)) {
#line 637
        tmp___2 = __errno_location();
#line 637
        if (*tmp___2 != 0) {
#line 640
          tmp___0 = gettext("fts_read failed");
#line 640
          tmp___1 = __errno_location();
#line 640
          error(0, *tmp___1, (char const   *)tmp___0);
#line 641
          ok = (_Bool)0;
        }
#line 643
        break;
      }
#line 647
      tmp___3 = process_file(fts, ent);
#line 647
      ok = (_Bool )((int )ok & (int )tmp___3);
    }
#line 650
    tmp___6 = fts_close(fts);
#line 650
    if (tmp___6 != 0) {
#line 652
      tmp___4 = gettext("fts_close failed");
#line 652
      tmp___5 = __errno_location();
#line 652
      error(0, *tmp___5, (char const   *)tmp___4);
#line 653
      ok = (_Bool)0;
    }
  }
#line 657
  return (ok);
}
}
#line 892
int main(int argc , char **argv ) ;
#line 892 "/home/wslee/project/coreutils-8.1/src/du.c"
static char const   posix_prefix[7]  = {      (char const   )'p',      (char const   )'o',      (char const   )'s',      (char const   )'i', 
        (char const   )'x',      (char const   )'-',      (char const   )'\000'};
#line 953 "/home/wslee/project/coreutils-8.1/src/du.c"
static char *temp_argv[2]  = {      (char *)((void *)0),      (char *)((void *)0)};
#line 660 "/home/wslee/project/coreutils-8.1/src/du.c"
int main(int argc , char **argv ) 
{ 
  char *cwd_only[2] ;
  _Bool max_depth_specified ;
  _Bool ok ;
  char *files_from ;
  int bit_flags ;
  int symlink_deref_bits ;
  _Bool opt_summarize_only ;
  char *tmp ;
  int oi ;
  int c ;
  int tmp___0 ;
  unsigned long tmp_ulong ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  strtol_error tmp___3 ;
  enum strtol_error e ;
  enum strtol_error tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  ptrdiff_t tmp___8 ;
  char const   *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  unsigned long d ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *p ;
  char *tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  ptrdiff_t tmp___17 ;
  struct argv_iterator *ai ;
  char const   *tmp___18 ;
  char *tmp___19 ;
  char *tmp___20 ;
  char const   *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;
  FILE *tmp___25 ;
  char **files ;
  char **tmp___26 ;
  _Bool skip_file ;
  enum argv_iter_err ai_err ;
  char *file_name___1 ;
  char *tmp___27 ;
  char const   *tmp___28 ;
  char *tmp___29 ;
  int *tmp___30 ;
  char const   *tmp___31 ;
  char *tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  char *tmp___35 ;
  unsigned long file_number ;
  size_t tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  _Bool tmp___39 ;
  char const   *tmp___40 ;
  char *tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;

  {
#line 664
  max_depth_specified = (_Bool)0;
#line 665
  ok = (_Bool)1;
#line 666
  files_from = (char *)((void *)0);
#line 669
  bit_flags = 1280;
#line 673
  symlink_deref_bits = 16;
#line 676
  opt_summarize_only = (_Bool)0;
#line 678
  cwd_only[0] = bad_cast(".");
#line 679
  cwd_only[1] = (char *)((void *)0);
#line 682
  set_program_name((char const   *)*(argv + 0));
#line 683
  setlocale(6, "");
#line 684
  bindtextdomain("coreutils", "/usr/local/share/locale");
#line 685
  textdomain("coreutils");
#line 687
  atexit(& close_stdout);
#line 689
  exclude = new_exclude();
#line 691
  tmp = getenv("DU_BLOCK_SIZE");
#line 691
  human_options((char const   *)tmp, & human_output_opts, & output_block_size);
#line 694
  while (1) {
#line 696
    oi = -1;
#line 697
    tmp___0 = getopt_long(argc, (char * const  *)argv, "0abchHklmsxB:DLPSX:", long_options,
                          & oi);
#line 697
    c = tmp___0;
#line 699
    if (c == -1) {
#line 700
      break;
    }
#line 702
    switch (c) {
    case 48: 
#line 711
    opt_nul_terminate_output = (_Bool)1;
#line 712
    break;
    case 97: 
#line 715
    opt_all = (_Bool)1;
#line 716
    break;
    case 128: 
#line 719
    apparent_size = (_Bool)1;
#line 720
    break;
    case 98: 
#line 723
    apparent_size = (_Bool)1;
#line 724
    human_output_opts = 0;
#line 725
    output_block_size = (uintmax_t )1;
#line 726
    break;
    case 99: 
#line 729
    print_grand_total = (_Bool)1;
#line 730
    break;
    case 104: 
#line 733
    human_output_opts = 176;
#line 734
    output_block_size = (uintmax_t )1;
#line 735
    break;
    case 131: 
#line 738
    human_output_opts = 144;
#line 739
    output_block_size = (uintmax_t )1;
#line 740
    break;
    case 107: 
#line 743
    human_output_opts = 0;
#line 744
    output_block_size = (uintmax_t )1024;
#line 745
    break;
    case 132: 
#line 750
    tmp___3 = xstrtoul((char const   *)optarg, (char **)((void *)0), 0, & tmp_ulong,
                       (char const   *)((void *)0));
#line 750
    if ((unsigned int )tmp___3 == 0U) {
#line 750
      if (tmp_ulong <= 0xffffffffffffffffUL) {
#line 753
        max_depth_specified = (_Bool)1;
#line 754
        max_depth = tmp_ulong;
      } else {
#line 758
        tmp___1 = quote((char const   *)optarg);
#line 758
        tmp___2 = gettext("invalid maximum depth %s");
#line 758
        error(0, 0, (char const   *)tmp___2, tmp___1);
#line 760
        ok = (_Bool)0;
      }
    } else {
#line 758
      tmp___1 = quote((char const   *)optarg);
#line 758
      tmp___2 = gettext("invalid maximum depth %s");
#line 758
      error(0, 0, (char const   *)tmp___2, tmp___1);
#line 760
      ok = (_Bool)0;
    }
#line 763
    break;
    case 109: 
#line 766
    human_output_opts = 0;
#line 767
    output_block_size = (uintmax_t )1048576;
#line 768
    break;
    case 108: 
#line 771
    opt_count_all = (_Bool)1;
#line 772
    break;
    case 115: 
#line 775
    opt_summarize_only = (_Bool)1;
#line 776
    break;
    case 120: 
#line 779
    bit_flags |= 64;
#line 780
    break;
    case 66: 
#line 784
    tmp___4 = human_options((char const   *)optarg, & human_output_opts, & output_block_size);
#line 784
    e = tmp___4;
#line 786
    if ((unsigned int )e != 0U) {
#line 787
      xstrtol_fatal(e, oi, (char )c, long_options, (char const   *)optarg);
    }
#line 789
    break;
    case 68: 
    case 72: 
#line 793
    symlink_deref_bits = 17;
#line 794
    break;
    case 76: 
#line 797
    symlink_deref_bits = 2;
#line 798
    break;
    case 80: 
#line 801
    symlink_deref_bits = 16;
#line 802
    break;
    case 83: 
#line 805
    opt_separate_dirs = (_Bool)1;
#line 806
    break;
    case 88: 
#line 809
    tmp___7 = add_exclude_file(& add_exclude, exclude, (char const   *)optarg, 1 << 28,
                               (char )'\n');
#line 809
    if (tmp___7) {
#line 812
      tmp___5 = quotearg_colon((char const   *)optarg);
#line 812
      tmp___6 = __errno_location();
#line 812
      error(0, *tmp___6, "%s", tmp___5);
#line 813
      ok = (_Bool)0;
    }
#line 815
    break;
    case 130: 
#line 818
    files_from = optarg;
#line 819
    break;
    case 129: 
#line 822
    add_exclude(exclude, (char const   *)optarg, 1 << 28);
#line 823
    break;
    case 133: 
#line 826
    opt_time = (_Bool)1;
#line 827
    if (optarg) {
#line 827
      tmp___8 = __xargmatch_internal("--time", (char const   *)optarg, time_args,
                                     (char const   *)(time_types), sizeof(time_types[0]),
                                     argmatch_die);
#line 827
      time_type = (enum time_type )time_types[tmp___8];
    } else {
#line 827
      time_type = (enum time_type )0;
    }
#line 831
    break;
    case 134: 
#line 834
    time_style = (char const   *)optarg;
#line 835
    break;
    case -130: 
#line 837
    usage(0);
#line 837
    break;
    case -131: 
#line 839
    tmp___9 = proper_name_utf8("Torbjorn Granlund", "Torbj\303\266rn Granlund");
#line 839
    version_etc(stdout, "du", "GNU coreutils", Version, tmp___9, "David MacKenzie",
                "Paul Eggert", "Jim Meyering", (char *)((void *)0));
#line 839
    exit(0);
#line 839
    break;
    default: 
#line 842
    ok = (_Bool)0;
    }
  }
#line 846
  if (! ok) {
#line 847
    usage(1);
  }
#line 849
  if (opt_all) {
#line 849
    if (opt_summarize_only) {
#line 851
      tmp___10 = gettext("cannot both summarize and show all entries");
#line 851
      error(0, 0, (char const   *)tmp___10);
#line 852
      usage(1);
    }
  }
#line 855
  if (opt_summarize_only) {
#line 855
    if (max_depth_specified) {
#line 855
      if (max_depth == 0UL) {
#line 857
        tmp___11 = gettext("warning: summarizing is the same as using --max-depth=0");
#line 857
        error(0, 0, (char const   *)tmp___11);
      }
    }
  }
#line 861
  if (opt_summarize_only) {
#line 861
    if (max_depth_specified) {
#line 861
      if (max_depth != 0UL) {
#line 863
        d = max_depth;
#line 864
        tmp___12 = gettext("warning: summarizing conflicts with --max-depth=%lu");
#line 864
        error(0, 0, (char const   *)tmp___12, d);
#line 865
        usage(1);
      }
    }
  }
#line 868
  if (opt_summarize_only) {
#line 869
    max_depth = (size_t )0;
  }
#line 872
  if (opt_time) {
#line 874
    if (! time_style) {
#line 876
      tmp___13 = getenv("TIME_STYLE");
#line 876
      time_style = (char const   *)tmp___13;
#line 879
      if (! time_style) {
#line 880
        time_style = "long-iso";
      } else {
#line 879
        tmp___16 = strcmp(time_style, "locale");
#line 879
        if (tmp___16 == 0) {
#line 880
          time_style = "long-iso";
        } else
#line 881
        if ((int const   )*time_style == 43) {
#line 885
          tmp___14 = strchr(time_style, '\n');
#line 885
          p = tmp___14;
#line 886
          if (p) {
#line 887
            *p = (char )'\000';
          }
        } else {
#line 893
          while (1) {
#line 893
            tmp___15 = strncmp(time_style, posix_prefix, sizeof(posix_prefix) - 1UL);
#line 893
            if (! (tmp___15 == 0)) {
#line 893
              break;
            }
#line 895
            time_style += sizeof(posix_prefix) - 1UL;
          }
        }
      }
    }
#line 899
    if ((int const   )*time_style == 43) {
#line 900
      time_format = time_style + 1;
    } else {
#line 903
      tmp___17 = __xargmatch_internal("time style", time_style, time_style_args, (char const   *)(time_style_types),
                                      sizeof(time_style_types[0]), argmatch_die);
#line 903
      switch ((unsigned int const   )time_style_types[tmp___17]) {
      case 0U: 
#line 907
      time_format = "%Y-%m-%d %H:%M:%S.%N %z";
#line 908
      break;
      case 1U: 
#line 911
      time_format = "%Y-%m-%d %H:%M";
#line 912
      break;
      case 2U: 
#line 915
      time_format = "%Y-%m-%d";
#line 916
      break;
      }
    }
  }
#line 922
  if (files_from) {
#line 926
    if (optind < argc) {
#line 928
      tmp___18 = quote((char const   *)*(argv + optind));
#line 928
      tmp___19 = gettext("extra operand %s");
#line 928
      error(0, 0, (char const   *)tmp___19, tmp___18);
#line 929
      tmp___20 = gettext("file operands cannot be combined with --files0-from");
#line 929
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"%s\n", tmp___20);
#line 931
      usage(1);
    }
#line 934
    tmp___24 = strcmp((char const   *)files_from, "-");
#line 934
    if (! (tmp___24 == 0)) {
#line 934
      tmp___25 = freopen_safer((char const   *)files_from, "r", stdin);
#line 934
      if (! tmp___25) {
#line 935
        tmp___21 = quote((char const   *)files_from);
#line 935
        tmp___22 = gettext("cannot open %s for reading");
#line 935
        tmp___23 = __errno_location();
#line 935
        error(1, *tmp___23, (char const   *)tmp___22, tmp___21);
      }
    }
#line 938
    ai = argv_iter_init_stream(stdin);
  } else {
#line 942
    if (optind < argc) {
#line 942
      tmp___26 = argv + optind;
    } else {
#line 942
      tmp___26 = cwd_only;
    }
#line 942
    files = tmp___26;
#line 943
    ai = argv_iter_init_argv(files);
  }
#line 946
  if (! ai) {
#line 947
    xalloc_die();
  }
#line 950
  hash_init();
#line 952
  bit_flags |= symlink_deref_bits;
#line 955
  while (1) {
#line 957
    skip_file = (_Bool)0;
#line 959
    tmp___27 = argv_iter(ai, & ai_err);
#line 959
    file_name___1 = tmp___27;
#line 960
    if ((unsigned int )ai_err == 2U) {
#line 961
      break;
    }
#line 962
    if (! file_name___1) {
#line 964
      switch ((unsigned int )ai_err) {
      case 4U: 
#line 967
      tmp___28 = quote((char const   *)files_from);
#line 967
      tmp___29 = gettext("%s: read error");
#line 967
      tmp___30 = __errno_location();
#line 967
      error(0, *tmp___30, (char const   *)tmp___29, tmp___28);
#line 968
      continue;
      case 3U: 
#line 971
      xalloc_die();
      default: 
#line 974
      __assert_fail("!\"unexpected error code from argv_iter\"", "/home/wslee/project/coreutils-8.1/src/du.c",
                    974U, "main");
      }
    }
#line 977
    if (files_from) {
#line 977
      tmp___33 = strcmp((char const   *)files_from, "-");
#line 977
      if (tmp___33 == 0) {
#line 977
        tmp___34 = strcmp((char const   *)file_name___1, "-");
#line 977
        if (tmp___34 == 0) {
#line 981
          tmp___31 = quote((char const   *)file_name___1);
#line 981
          tmp___32 = gettext("when reading file names from stdin, no file name of %s allowed");
#line 981
          error(0, 0, (char const   *)tmp___32, tmp___31);
#line 984
          skip_file = (_Bool)1;
        }
      }
    }
#line 991
    if (! *(file_name___1 + 0)) {
#line 997
      if ((unsigned long )files_from == (unsigned long )((void *)0)) {
#line 998
        tmp___35 = gettext("invalid zero-length file name");
#line 998
        error(0, 0, "%s", tmp___35);
      } else {
#line 1004
        tmp___36 = argv_iter_n_args((struct argv_iterator  const  *)ai);
#line 1004
        file_number = tmp___36;
#line 1005
        tmp___37 = gettext("invalid zero-length file name");
#line 1005
        tmp___38 = quotearg_colon((char const   *)files_from);
#line 1005
        error(0, 0, "%s:%lu: %s", tmp___38, file_number, tmp___37);
      }
#line 1008
      skip_file = (_Bool)1;
    }
#line 1011
    if (skip_file) {
#line 1012
      ok = (_Bool)0;
    } else {
#line 1015
      temp_argv[0] = file_name___1;
#line 1016
      tmp___39 = du_files(temp_argv, bit_flags);
#line 1016
      ok = (_Bool )((int )ok & (int )tmp___39);
    }
  }
#line 1020
  argv_iter_free(ai);
#line 1022
  if (files_from) {
#line 1022
    tmp___42 = ferror_unlocked(stdin);
#line 1022
    if (tmp___42) {
#line 1023
      tmp___40 = quote((char const   *)files_from);
#line 1023
      tmp___41 = gettext("error reading %s");
#line 1023
      error(1, 0, (char const   *)tmp___41, tmp___40);
    } else {
#line 1022
      tmp___43 = fclose(stdin);
#line 1022
      if (tmp___43 != 0) {
#line 1023
        tmp___40 = quote((char const   *)files_from);
#line 1023
        tmp___41 = gettext("error reading %s");
#line 1023
        error(1, 0, (char const   *)tmp___41, tmp___40);
      }
    }
  }
#line 1025
  if (print_grand_total) {
#line 1026
    tmp___44 = gettext("total");
#line 1026
    print_size((struct duinfo  const  *)(& tot_dui), (char const   *)tmp___44);
  }
#line 1028
  hash_free(htab);
#line 1030
  if (ok) {
#line 1030
    tmp___45 = 0;
  } else {
#line 1030
    tmp___45 = 1;
  }
#line 1030
  exit(tmp___45);
}
}
#line 1 "cil-znET3Yeh.o"
#pragma merger("0","../lib/areadlink-with-size.o.i","")
#line 24 "/home/wslee/project/coreutils-8.1/lib/areadlink.h"
char *areadlink_with_size(char const   *file , size_t size ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 812 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(1,2), __leaf__)) readlink)(char const   * __restrict  __path ,
                                                                                                     char * __restrict  __buf ,
                                                                                                     size_t __len ) ;
#line 51 "/home/wslee/project/coreutils-8.1/lib/areadlink-with-size.c"
char *areadlink_with_size(char const   *file , size_t size ) 
{ 
  size_t symlink_max ;
  size_t INITIAL_LIMIT_BOUND ;
  size_t initial_limit ;
  size_t tmp ;
  size_t buf_size ;
  size_t tmp___0 ;
  ssize_t r ;
  size_t link_length ;
  char *buffer ;
  void *tmp___1 ;
  int saved_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;

  {
#line 57
  symlink_max = (size_t )1024;
#line 58
  INITIAL_LIMIT_BOUND = (size_t )8192;
#line 59
  if (symlink_max < INITIAL_LIMIT_BOUND) {
#line 59
    tmp = symlink_max + 1UL;
  } else {
#line 59
    tmp = INITIAL_LIMIT_BOUND;
  }
#line 59
  initial_limit = tmp;
#line 64
  if (size < initial_limit) {
#line 64
    tmp___0 = size + 1UL;
  } else {
#line 64
    tmp___0 = initial_limit;
  }
#line 64
  buf_size = tmp___0;
#line 66
  while (1) {
#line 70
    tmp___1 = malloc(buf_size);
#line 70
    buffer = (char *)tmp___1;
#line 72
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 73
      return ((char *)((void *)0));
    }
#line 74
    r = readlink((char const   * __restrict  )file, (char * __restrict  )buffer, buf_size);
#line 75
    link_length = (size_t )r;
#line 79
    if (r < 0L) {
#line 79
      tmp___4 = __errno_location();
#line 79
      if (*tmp___4 != 34) {
#line 81
        tmp___2 = __errno_location();
#line 81
        saved_errno = *tmp___2;
#line 82
        free((void *)buffer);
#line 83
        tmp___3 = __errno_location();
#line 83
        *tmp___3 = saved_errno;
#line 84
        return ((char *)((void *)0));
      }
    }
#line 87
    if (link_length < buf_size) {
#line 89
      *(buffer + link_length) = (char)0;
#line 90
      return (buffer);
    }
#line 93
    free((void *)buffer);
#line 94
    if (buf_size <= 4611686018427387903UL) {
#line 95
      buf_size *= 2UL;
    } else
#line 96
    if (buf_size < 9223372036854775807UL) {
#line 97
      buf_size = 9223372036854775807UL;
    } else {
#line 100
      tmp___5 = __errno_location();
#line 100
      *tmp___5 = 12;
#line 101
      return ((char *)((void *)0));
    }
  }
}
}
#line 1 "cil-_nZZl0Nz.o"
#pragma merger("0","../lib/areadlink.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/areadlink.h"
char *areadlink(char const   *filename ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50 "/home/wslee/project/coreutils-8.1/lib/areadlink.c"
char *areadlink(char const   *filename ) 
{ 
  char initial_buf[1024] ;
  char *buffer ;
  size_t buf_size ;
  ssize_t link_length ;
  ssize_t tmp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  void *tmp___4 ;
  char *smaller_buffer ;
  void *tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;

  {
#line 58
  buffer = initial_buf;
#line 59
  buf_size = sizeof(initial_buf);
#line 61
  while (1) {
#line 64
    tmp = readlink((char const   * __restrict  )filename, (char * __restrict  )buffer,
                   buf_size);
#line 64
    link_length = tmp;
#line 68
    if (link_length < 0L) {
#line 68
      tmp___2 = __errno_location();
#line 68
      if (*tmp___2 != 34) {
#line 70
        if ((unsigned long )buffer != (unsigned long )(initial_buf)) {
#line 72
          tmp___0 = __errno_location();
#line 72
          saved_errno = *tmp___0;
#line 73
          free((void *)buffer);
#line 74
          tmp___1 = __errno_location();
#line 74
          *tmp___1 = saved_errno;
        }
#line 76
        return ((char *)((void *)0));
      }
    }
#line 79
    if ((size_t )link_length < buf_size) {
#line 81
      tmp___3 = link_length;
#line 81
      link_length ++;
#line 81
      *(buffer + tmp___3) = (char )'\000';
#line 84
      if ((unsigned long )buffer == (unsigned long )(initial_buf)) {
#line 86
        tmp___4 = malloc((size_t )link_length);
#line 86
        buffer = (char *)tmp___4;
#line 87
        if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 89
          return ((char *)((void *)0));
        }
#line 90
        memcpy((void * __restrict  )buffer, (void const   * __restrict  )(initial_buf),
               (size_t )link_length);
      } else
#line 95
      if ((size_t )link_length < buf_size) {
#line 97
        tmp___5 = realloc((void *)buffer, (size_t )link_length);
#line 97
        smaller_buffer = (char *)tmp___5;
#line 99
        if ((unsigned long )smaller_buffer != (unsigned long )((void *)0)) {
#line 100
          buffer = smaller_buffer;
        }
      }
#line 103
      return (buffer);
    }
#line 106
    if ((unsigned long )buffer != (unsigned long )(initial_buf)) {
#line 107
      free((void *)buffer);
    }
#line 108
    buf_size *= 2UL;
#line 109
    if (9223372036854775807UL < buf_size) {
#line 111
      tmp___6 = __errno_location();
#line 111
      *tmp___6 = 12;
#line 112
      return ((char *)((void *)0));
    }
#line 114
    tmp___7 = malloc(buf_size);
#line 114
    buffer = (char *)tmp___7;
#line 115
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 117
      return ((char *)((void *)0));
    }
  }
}
}
#line 1 "cil-9BktrM5m.o"
#pragma merger("0","../lib/areadlinkat.o.i","")
#line 27 "/home/wslee/project/coreutils-8.1/lib/areadlink.h"
char *areadlinkat(int fd , char const   *filename ) ;
#line 823 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__nonnull__(2,3), __leaf__)) readlinkat)(int __fd ,
                                                                                                       char const   * __restrict  __path ,
                                                                                                       char * __restrict  __buf ,
                                                                                                       size_t __len ) ;
#line 54 "/home/wslee/project/coreutils-8.1/lib/areadlinkat.c"
char *areadlinkat(int fd , char const   *filename ) 
{ 
  char initial_buf[1024] ;
  char *buffer ;
  size_t buf_size ;
  ssize_t link_length ;
  ssize_t tmp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  void *tmp___4 ;
  char *smaller_buffer ;
  void *tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;

  {
#line 62
  buffer = initial_buf;
#line 63
  buf_size = sizeof(initial_buf);
#line 65
  while (1) {
#line 68
    tmp = readlinkat(fd, (char const   * __restrict  )filename, (char * __restrict  )buffer,
                     buf_size);
#line 68
    link_length = tmp;
#line 72
    if (link_length < 0L) {
#line 72
      tmp___2 = __errno_location();
#line 72
      if (*tmp___2 != 34) {
#line 74
        if ((unsigned long )buffer != (unsigned long )(initial_buf)) {
#line 76
          tmp___0 = __errno_location();
#line 76
          saved_errno = *tmp___0;
#line 77
          free((void *)buffer);
#line 78
          tmp___1 = __errno_location();
#line 78
          *tmp___1 = saved_errno;
        }
#line 80
        return ((char *)((void *)0));
      }
    }
#line 83
    if ((size_t )link_length < buf_size) {
#line 85
      tmp___3 = link_length;
#line 85
      link_length ++;
#line 85
      *(buffer + tmp___3) = (char )'\000';
#line 88
      if ((unsigned long )buffer == (unsigned long )(initial_buf)) {
#line 90
        tmp___4 = malloc((size_t )link_length);
#line 90
        buffer = (char *)tmp___4;
#line 91
        if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 93
          return ((char *)((void *)0));
        }
#line 94
        memcpy((void * __restrict  )buffer, (void const   * __restrict  )(initial_buf),
               (size_t )link_length);
      } else
#line 99
      if ((size_t )link_length < buf_size) {
#line 101
        tmp___5 = realloc((void *)buffer, (size_t )link_length);
#line 101
        smaller_buffer = (char *)tmp___5;
#line 103
        if ((unsigned long )smaller_buffer != (unsigned long )((void *)0)) {
#line 104
          buffer = smaller_buffer;
        }
      }
#line 107
      return (buffer);
    }
#line 110
    if ((unsigned long )buffer != (unsigned long )(initial_buf)) {
#line 111
      free((void *)buffer);
    }
#line 112
    buf_size *= 2UL;
#line 113
    if (9223372036854775807UL < buf_size) {
#line 115
      tmp___6 = __errno_location();
#line 115
      *tmp___6 = 12;
#line 116
      return ((char *)((void *)0));
    }
#line 118
    tmp___7 = malloc(buf_size);
#line 118
    buffer = (char *)tmp___7;
#line 119
    if ((unsigned long )buffer == (unsigned long )((void *)0)) {
#line 121
      return ((char *)((void *)0));
    }
  }
}
}
#line 1 "cil-fr7_2w0Y.o"
#pragma merger("0","../lib/argmatch.o.i","")
#line 42 "/home/wslee/project/coreutils-8.1/lib/argmatch.h"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) ;
#line 56
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) ;
#line 68
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) ;
#line 94
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) ;
#line 602 "/usr/include/stdio.h"
extern int putc_unlocked(int __c , FILE *__stream ) ;
#line 65 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 394
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 335 "/home/wslee/project/coreutils-8.1/lib/quotearg.h"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) ;
#line 20 "/home/wslee/project/coreutils-8.1/lib/quote.h"
char const   *quote_n(int n , char const   *name ) ;
#line 60 "/home/wslee/project/coreutils-8.1/lib/argmatch.c"
static void __argmatch_die(void) 
{ 


  {
#line 63
  usage(1);
#line 64
  return;
}
}
#line 68 "/home/wslee/project/coreutils-8.1/lib/argmatch.c"
void (*argmatch_die)(void)  =    & __argmatch_die;
#line 82 "/home/wslee/project/coreutils-8.1/lib/argmatch.c"
ptrdiff_t argmatch(char const   *arg , char const   * const  *arglist , char const   *vallist ,
                   size_t valsize ) 
{ 
  size_t i ;
  size_t arglen ;
  ptrdiff_t matchind ;
  _Bool ambiguous ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 88
  matchind = (ptrdiff_t )-1;
#line 89
  ambiguous = (_Bool)0;
#line 91
  arglen = strlen(arg);
#line 94
  i = (size_t )0;
#line 94
  while (*(arglist + i)) {
#line 96
    tmp___1 = strncmp((char const   *)*(arglist + i), arg, arglen);
#line 96
    if (! tmp___1) {
#line 98
      tmp___0 = strlen((char const   *)*(arglist + i));
#line 98
      if (tmp___0 == arglen) {
#line 100
        return ((ptrdiff_t )i);
      } else
#line 101
      if (matchind == -1L) {
#line 103
        matchind = (ptrdiff_t )i;
      } else
#line 107
      if ((unsigned long )vallist == (unsigned long )((void *)0)) {
#line 113
        ambiguous = (_Bool)1;
      } else {
#line 107
        tmp = memcmp((void const   *)(vallist + valsize * (size_t )matchind), (void const   *)(vallist + valsize * i),
                     valsize);
#line 107
        if (tmp) {
#line 113
          ambiguous = (_Bool)1;
        }
      }
    }
#line 94
    i ++;
  }
#line 118
  if (ambiguous) {
#line 119
    return ((ptrdiff_t )-2);
  } else {
#line 121
    return (matchind);
  }
}
}
#line 129 "/home/wslee/project/coreutils-8.1/lib/argmatch.c"
void argmatch_invalid(char const   *context , char const   *value , ptrdiff_t problem ) 
{ 
  char const   *format ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;

  {
#line 132
  if (problem == -1L) {
#line 132
    tmp = gettext("invalid argument %s for %s");
#line 132
    tmp___1 = tmp;
  } else {
#line 132
    tmp___0 = gettext("ambiguous argument %s for %s");
#line 132
    tmp___1 = tmp___0;
  }
#line 132
  format = (char const   *)tmp___1;
#line 136
  tmp___2 = quote_n(1, context);
#line 136
  tmp___3 = quotearg_n_style(0, (enum quoting_style )6, value);
#line 136
  error(0, 0, format, tmp___3, tmp___2);
#line 138
  return;
}
}
#line 144 "/home/wslee/project/coreutils-8.1/lib/argmatch.c"
void argmatch_valid(char const   * const  *arglist , char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  char const   *last_val ;
  char *tmp ;
  int tmp___0 ;

  {
#line 149
  last_val = (char const   *)((void *)0);
#line 153
  tmp = gettext("Valid arguments are:");
#line 153
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )tmp);
#line 154
  i = (size_t )0;
#line 154
  while (*(arglist + i)) {
#line 155
    if (i == 0UL) {
#line 158
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n  - `%s\'",
              *(arglist + i));
#line 159
      last_val = vallist + valsize * i;
    } else {
#line 155
      tmp___0 = memcmp((void const   *)last_val, (void const   *)(vallist + valsize * i),
                       valsize);
#line 155
      if (tmp___0) {
#line 158
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"\n  - `%s\'",
                *(arglist + i));
#line 159
        last_val = vallist + valsize * i;
      } else {
#line 163
        fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )", `%s\'",
                *(arglist + i));
      }
    }
#line 154
    i ++;
  }
#line 165
  putc_unlocked('\n', stderr);
#line 166
  return;
}
}
#line 174 "/home/wslee/project/coreutils-8.1/lib/argmatch.c"
ptrdiff_t __xargmatch_internal(char const   *context , char const   *arg , char const   * const  *arglist ,
                               char const   *vallist , size_t valsize , void (*exit_fn)(void) ) 
{ 
  ptrdiff_t res ;
  ptrdiff_t tmp ;

  {
#line 180
  tmp = argmatch(arg, arglist, vallist, valsize);
#line 180
  res = tmp;
#line 181
  if (res >= 0L) {
#line 183
    return (res);
  }
#line 186
  argmatch_invalid(context, arg, res);
#line 187
  argmatch_valid(arglist, vallist, valsize);
#line 188
  (*exit_fn)();
#line 190
  return ((ptrdiff_t )-1);
}
}
#line 195 "/home/wslee/project/coreutils-8.1/lib/argmatch.c"
char const   *argmatch_to_argument(char const   *value , char const   * const  *arglist ,
                                   char const   *vallist , size_t valsize ) 
{ 
  size_t i ;
  int tmp ;

  {
#line 202
  i = (size_t )0;
#line 202
  while (*(arglist + i)) {
#line 203
    tmp = memcmp((void const   *)value, (void const   *)(vallist + valsize * i), valsize);
#line 203
    if (! tmp) {
#line 204
      return ((char const   *)*(arglist + i));
    }
#line 202
    i ++;
  }
#line 205
  return ((char const   *)((void *)0));
}
}
#line 1 "cil-F90z5JQK.o"
#pragma merger("0","../lib/argv-iter.o.i","")
#line 668 "/usr/include/stdio.h"
extern __ssize_t getdelim(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                          int __delimiter , FILE * __restrict  __stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 39 "/home/wslee/project/coreutils-8.1/lib/argv-iter.c"
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_argv)(char **argv ) 
{ 
  struct argv_iterator *ai ;
  void *tmp ;

  {
#line 42
  tmp = malloc(sizeof(*ai));
#line 42
  ai = (struct argv_iterator *)tmp;
#line 43
  if (! ai) {
#line 44
    return ((struct argv_iterator *)((void *)0));
  }
#line 45
  ai->fp = (FILE *)((void *)0);
#line 46
  ai->arg_list = argv;
#line 47
  ai->p = argv;
#line 48
  return (ai);
}
}
#line 53 "/home/wslee/project/coreutils-8.1/lib/argv-iter.c"
struct argv_iterator *( __attribute__((__nonnull__(1))) argv_iter_init_stream)(FILE *fp ) 
{ 
  struct argv_iterator *ai ;
  void *tmp ;

  {
#line 56
  tmp = malloc(sizeof(*ai));
#line 56
  ai = (struct argv_iterator *)tmp;
#line 57
  if (! ai) {
#line 58
    return ((struct argv_iterator *)((void *)0));
  }
#line 59
  ai->fp = fp;
#line 60
  ai->tok = (char *)((void *)0);
#line 61
  ai->buf_len = (size_t )0;
#line 63
  ai->item_idx = (size_t )0;
#line 64
  ai->arg_list = (char **)((void *)0);
#line 65
  return (ai);
}
}
#line 68 "/home/wslee/project/coreutils-8.1/lib/argv-iter.c"
char *( __attribute__((__nonnull__(2), __nonnull__(1))) argv_iter)(struct argv_iterator *ai ,
                                                                   enum argv_iter_err *err ) 
{ 
  ssize_t len ;
  __ssize_t tmp ;
  int tmp___1 ;
  char **tmp___2 ;

  {
#line 71
  if (ai->fp) {
#line 73
    tmp = getdelim((char ** __restrict  )(& ai->tok), (size_t * __restrict  )(& ai->buf_len),
                   '\000', (FILE * __restrict  )ai->fp);
#line 73
    len = tmp;
#line 74
    if (len < 0L) {
#line 76
      tmp___1 = feof(ai->fp);
#line 76
      if (tmp___1) {
#line 76
        *err = (enum argv_iter_err )2;
      } else {
#line 76
        *err = (enum argv_iter_err )4;
      }
#line 77
      return ((char *)((void *)0));
    }
#line 80
    *err = (enum argv_iter_err )1;
#line 81
    (ai->item_idx) ++;
#line 82
    return (ai->tok);
  } else
#line 86
  if ((unsigned long )*(ai->p) == (unsigned long )((void *)0)) {
#line 88
    *err = (enum argv_iter_err )2;
#line 89
    return ((char *)((void *)0));
  } else {
#line 93
    *err = (enum argv_iter_err )1;
#line 94
    tmp___2 = ai->p;
#line 94
    (ai->p) ++;
#line 94
    return (*tmp___2);
  }
}
}
#line 99 "/home/wslee/project/coreutils-8.1/lib/argv-iter.c"
size_t ( __attribute__((__nonnull__(1))) argv_iter_n_args)(struct argv_iterator  const  *ai ) 
{ 
  size_t tmp ;

  {
#line 102
  if (ai->fp) {
#line 102
    tmp = ai->item_idx;
  } else {
#line 102
    tmp = (size_t const   )(ai->p - ai->arg_list);
  }
#line 102
  return ((size_t )tmp);
}
}
#line 105 "/home/wslee/project/coreutils-8.1/lib/argv-iter.c"
void ( __attribute__((__nonnull__(1))) argv_iter_free)(struct argv_iterator *ai ) 
{ 


  {
#line 108
  if (ai->fp) {
#line 109
    free((void *)ai->tok);
  }
#line 110
  free((void *)ai);
#line 111
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 1 "cil-60cyjh9i.o"
#pragma merger("0","../lib/asnprintf.o.i","")
#line 72 "/home/wslee/project/coreutils-8.1/lib/vasnprintf.h"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) ;
#line 74
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) ;
#line 25 "/home/wslee/project/coreutils-8.1/lib/asnprintf.c"
char *( /* format attribute */  asnprintf)(char *resultbuf , size_t *lengthp , char const   *format 
                                           , ...) 
{ 
  va_list args ;
  char *result ;

  {
#line 31
  __builtin_va_start(args, format);
#line 32
  result = vasnprintf(resultbuf, lengthp, format, args);
#line 33
  __builtin_va_end(args);
#line 34
  return (result);
}
}
#line 1 "cil-ld2Xf_0w.o"
#pragma merger("0","../lib/asprintf.o.i","")
#line 546 "./stdio.h"
int ( /* format attribute */  rpl_asprintf)(char **resultp , char const   *format 
                                            , ...) ;
#line 548
int ( /* format attribute */  rpl_vasprintf)(char **resultp , char const   *format ,
                                             va_list args ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/asprintf.c"
int ( /* format attribute */  rpl_asprintf)(char **resultp , char const   *format 
                                            , ...) 
{ 
  va_list args ;
  int result ;

  {
#line 35
  __builtin_va_start(args, format);
#line 36
  result = rpl_vasprintf(resultp, format, args);
#line 37
  __builtin_va_end(args);
#line 38
  return (result);
}
}
#line 1 "cil-eaYtWwqK.o"
#pragma merger("0","../lib/backupfile.o.i","")
#line 47 "/home/wslee/project/coreutils-8.1/lib/backupfile.h"
char const   *simple_backup_suffix ;
#line 49
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) ;
#line 50
enum backup_type get_version(char const   *context , char const   *version ) ;
#line 51
enum backup_type xget_version(char const   *context , char const   *version ) ;
#line 67 "/home/wslee/project/coreutils-8.1/lib/dirname.h"
size_t base_len(char const   *name ) ;
#line 615 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) pathconf)(char const   *__path ,
                                                                                                int __name ) ;
#line 125 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 149 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 22 "/home/wslee/project/coreutils-8.1/lib/dirent-safer.h"
DIR *opendir_safer(char const   *name ) ;
#line 85 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
char const   *simple_backup_suffix  =    "~";
#line 93 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
static void check_extension(char *file , size_t filelen , char e ) 
{ 
  char *base ;
  char *tmp ;
  size_t baselen ;
  size_t tmp___0 ;
  size_t baselen_max ;
  long name_max ;
  char tmp___1[sizeof(".")] ;
  int *tmp___2 ;
  long size ;
  int *tmp___3 ;

  {
#line 96
  tmp = last_component((char const   *)file);
#line 96
  base = tmp;
#line 97
  tmp___0 = base_len((char const   *)base);
#line 97
  baselen = tmp___0;
#line 98
  baselen_max = (size_t )255;
#line 100
  if (14UL < baselen) {
#line 108
    memcpy((void * __restrict  )(tmp___1), (void const   * __restrict  )base, sizeof("."));
#line 109
    strcpy((char * __restrict  )base, (char const   * __restrict  )".");
#line 110
    tmp___2 = __errno_location();
#line 110
    *tmp___2 = 0;
#line 111
    name_max = pathconf((char const   *)file, 3);
#line 112
    if (0L <= name_max) {
#line 112
      goto _L;
    } else {
#line 112
      tmp___3 = __errno_location();
#line 112
      if (*tmp___3 == 0) {
        _L: /* CIL Label */ 
#line 114
        baselen_max = (size_t )name_max;
#line 114
        size = (long )baselen_max;
#line 115
        if (name_max != size) {
#line 116
          baselen_max = (size_t )-1;
        }
      }
    }
#line 118
    memcpy((void * __restrict  )base, (void const   * __restrict  )(tmp___1), sizeof("."));
  }
#line 136
  if (baselen_max < baselen) {
#line 138
    baselen = (size_t )((file + filelen) - base);
#line 139
    if (baselen_max <= baselen) {
#line 140
      baselen = baselen_max - 1UL;
    }
#line 141
    *(base + baselen) = e;
#line 142
    *(base + (baselen + 1UL)) = (char )'\000';
  }
#line 144
  return;
}
}
#line 173 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
static enum numbered_backup_result numbered_backup(char **buffer , size_t buffer_size ,
                                                   size_t filelen ) 
{ 
  enum numbered_backup_result result ;
  DIR *dirp ;
  struct dirent *dp ;
  char *buf___0 ;
  size_t versionlenmax ;
  char *base ;
  char *tmp ;
  size_t base_offset ;
  size_t baselen ;
  size_t tmp___0 ;
  char tmp___1[sizeof(".")] ;
  char const   *p ;
  char *q ;
  _Bool all_9s ;
  size_t versionlen ;
  size_t new_buflen ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;

  {
#line 176
  result = (enum numbered_backup_result )2;
#line 179
  buf___0 = *buffer;
#line 180
  versionlenmax = (size_t )1;
#line 181
  tmp = last_component((char const   *)buf___0);
#line 181
  base = tmp;
#line 182
  base_offset = (size_t )(base - buf___0);
#line 183
  tmp___0 = base_len((char const   *)base);
#line 183
  baselen = tmp___0;
#line 188
  memcpy((void * __restrict  )(tmp___1), (void const   * __restrict  )base, sizeof("."));
#line 189
  strcpy((char * __restrict  )base, (char const   * __restrict  )".");
#line 190
  dirp = opendir_safer((char const   *)buf___0);
#line 191
  memcpy((void * __restrict  )base, (void const   * __restrict  )(tmp___1), sizeof("."));
#line 192
  strcpy((char * __restrict  )(base + baselen), (char const   * __restrict  )".~1~");
#line 194
  if (! dirp) {
#line 195
    return (result);
  }
#line 197
  while (1) {
#line 197
    dp = readdir(dirp);
#line 197
    if (! ((unsigned long )dp != (unsigned long )((void *)0))) {
#line 197
      break;
    }
#line 205
    if (! (dp->d_ino != 0UL)) {
#line 206
      continue;
    } else {
#line 205
      tmp___2 = strlen((char const   *)(dp->d_name));
#line 205
      if (tmp___2 < baselen + 4UL) {
#line 206
        continue;
      }
    }
#line 208
    tmp___3 = memcmp((void const   *)(buf___0 + base_offset), (void const   *)(dp->d_name),
                     baselen + 2UL);
#line 208
    if (tmp___3 != 0) {
#line 209
      continue;
    }
#line 211
    p = (char const   *)((dp->d_name + baselen) + 2);
#line 217
    if (49 <= (int )*p) {
#line 217
      if (! ((int const   )*p <= 57)) {
#line 218
        continue;
      }
    } else {
#line 218
      continue;
    }
#line 219
    all_9s = (_Bool )((int const   )*p == 57);
#line 220
    versionlen = (size_t )1;
#line 220
    while ((unsigned int )*(p + versionlen) - 48U <= 9U) {
#line 221
      all_9s = (_Bool )((int )all_9s & ((int const   )*(p + versionlen) == 57));
#line 220
      versionlen ++;
    }
#line 223
    if ((int const   )*(p + versionlen) == 126) {
#line 223
      if (! *(p + (versionlen + 1UL))) {
#line 223
        if (! (versionlenmax < versionlen)) {
#line 223
          if (versionlenmax == versionlen) {
#line 223
            tmp___4 = memcmp((void const   *)((buf___0 + filelen) + 2), (void const   *)p,
                             versionlen);
#line 223
            if (! (tmp___4 <= 0)) {
#line 227
              continue;
            }
          } else {
#line 227
            continue;
          }
        }
      } else {
#line 227
        continue;
      }
    } else {
#line 227
      continue;
    }
#line 233
    versionlenmax = (size_t )all_9s + versionlen;
#line 234
    if (all_9s) {
#line 234
      result = (enum numbered_backup_result )1;
    } else {
#line 234
      result = (enum numbered_backup_result )0;
    }
#line 235
    new_buflen = ((filelen + 2UL) + versionlenmax) + 1UL;
#line 236
    if (buffer_size <= new_buflen) {
#line 238
      tmp___5 = xnrealloc((void *)buf___0, (size_t )2, new_buflen);
#line 238
      buf___0 = (char *)tmp___5;
#line 239
      buffer_size = new_buflen * 2UL;
    }
#line 241
    q = buf___0 + filelen;
#line 242
    tmp___6 = q;
#line 242
    q ++;
#line 242
    *tmp___6 = (char )'.';
#line 243
    tmp___7 = q;
#line 243
    q ++;
#line 243
    *tmp___7 = (char )'~';
#line 244
    *q = (char )'0';
#line 245
    q += (int )all_9s;
#line 246
    memcpy((void * __restrict  )q, (void const   * __restrict  )p, versionlen + 2UL);
#line 250
    q += versionlen;
#line 251
    while (1) {
#line 251
      q --;
#line 251
      if (! ((int )*q == 57)) {
#line 251
        break;
      }
#line 252
      *q = (char )'0';
    }
#line 253
    *q = (char )((int )*q + 1);
  }
#line 256
  closedir(dirp);
#line 257
  *buffer = buf___0;
#line 258
  return (result);
}
}
#line 265 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
char *find_backup_file_name(char const   *file , enum backup_type backup_type ) 
{ 
  size_t filelen ;
  size_t tmp ;
  char *s ;
  size_t ssize ;
  _Bool simple ;
  size_t simple_backup_suffix_size ;
  size_t tmp___0 ;
  size_t backup_suffix_size_guess ;
  void *tmp___1 ;
  enum numbered_backup_result tmp___2 ;

  {
#line 268
  tmp = strlen(file);
#line 268
  filelen = tmp;
#line 271
  simple = (_Bool)1;
#line 275
  tmp___0 = strlen(simple_backup_suffix);
#line 275
  simple_backup_suffix_size = tmp___0 + 1UL;
#line 276
  backup_suffix_size_guess = simple_backup_suffix_size;
#line 278
  if (backup_suffix_size_guess < 9UL) {
#line 279
    backup_suffix_size_guess = (size_t )9;
  }
#line 281
  ssize = (filelen + backup_suffix_size_guess) + 1UL;
#line 282
  tmp___1 = xmalloc(ssize);
#line 282
  s = (char *)tmp___1;
#line 283
  memcpy((void * __restrict  )s, (void const   * __restrict  )file, filelen + 1UL);
#line 285
  if ((unsigned int )backup_type != 1U) {
#line 286
    tmp___2 = numbered_backup(& s, ssize, filelen);
#line 286
    switch ((unsigned int )tmp___2) {
    case 0U: 
#line 289
    return (s);
    case 1U: 
#line 292
    simple = (_Bool)0;
#line 293
    break;
    case 2U: 
#line 296
    simple = (_Bool )((unsigned int )backup_type == 2U);
#line 297
    break;
    }
  }
#line 300
  if (simple) {
#line 301
    memcpy((void * __restrict  )(s + filelen), (void const   * __restrict  )simple_backup_suffix,
           simple_backup_suffix_size);
  }
#line 302
  check_extension(s, filelen, (char )'~');
#line 303
  return (s);
}
}
#line 306 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
static char const   * const  backup_args[9]  = 
#line 306
  {      (char const   * const  )"none",      (char const   * const  )"off",      (char const   * const  )"simple",      (char const   * const  )"never", 
        (char const   * const  )"existing",      (char const   * const  )"nil",      (char const   * const  )"numbered",      (char const   * const  )"t", 
        (char const   * const  )((void *)0)};
#line 317 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
static enum backup_type  const  backup_types[8]  = 
#line 317
  {      (enum backup_type  const  )0,      (enum backup_type  const  )0,      (enum backup_type  const  )1,      (enum backup_type  const  )1, 
        (enum backup_type  const  )2,      (enum backup_type  const  )2,      (enum backup_type  const  )3,      (enum backup_type  const  )3};
#line 334 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
enum backup_type get_version(char const   *context , char const   *version ) 
{ 
  ptrdiff_t tmp ;

  {
#line 337
  if ((unsigned long )version == (unsigned long )((char const   *)0)) {
#line 338
    return ((enum backup_type )2);
  } else
#line 337
  if ((int const   )*version == 0) {
#line 338
    return ((enum backup_type )2);
  } else {
#line 340
    tmp = __xargmatch_internal(context, version, backup_args, (char const   *)(backup_types),
                               sizeof(backup_types[0]), argmatch_die);
#line 340
    return ((enum backup_type )backup_types[tmp]);
  }
}
}
#line 350 "/home/wslee/project/coreutils-8.1/lib/backupfile.c"
enum backup_type xget_version(char const   *context , char const   *version ) 
{ 
  enum backup_type tmp ;
  char *tmp___0 ;
  enum backup_type tmp___1 ;

  {
#line 353
  if (version) {
#line 353
    if (*version) {
#line 354
      tmp = get_version(context, version);
#line 354
      return (tmp);
    } else {
#line 356
      tmp___0 = getenv("VERSION_CONTROL");
#line 356
      tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
#line 356
      return (tmp___1);
    }
  } else {
#line 356
    tmp___0 = getenv("VERSION_CONTROL");
#line 356
    tmp___1 = get_version("$VERSION_CONTROL", (char const   *)tmp___0);
#line 356
    return (tmp___1);
  }
}
}
#line 1 "cil-iZKEWt9e.o"
#pragma merger("0","../lib/base64.o.i","")
#line 38 "/home/wslee/project/coreutils-8.1/lib/base64.h"
_Bool isbase64(char ch ) ;
#line 40
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) ;
#line 43
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) ;
#line 45
void base64_decode_ctx_init(struct base64_decode_context *ctx ) ;
#line 47
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) ;
#line 51
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) ;
#line 92 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memchr)(void const   *__s ,
                                                                                               int __c ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 58 "/home/wslee/project/coreutils-8.1/lib/base64.c"
__inline static unsigned char to_uchar(char ch ) 
{ 


  {
#line 61
  return ((unsigned char )ch);
}
}
#line 72 "/home/wslee/project/coreutils-8.1/lib/base64.c"
static char const   b64str[64]  = 
#line 72
  {      (char const   )'A',      (char const   )'B',      (char const   )'C',      (char const   )'D', 
        (char const   )'E',      (char const   )'F',      (char const   )'G',      (char const   )'H', 
        (char const   )'I',      (char const   )'J',      (char const   )'K',      (char const   )'L', 
        (char const   )'M',      (char const   )'N',      (char const   )'O',      (char const   )'P', 
        (char const   )'Q',      (char const   )'R',      (char const   )'S',      (char const   )'T', 
        (char const   )'U',      (char const   )'V',      (char const   )'W',      (char const   )'X', 
        (char const   )'Y',      (char const   )'Z',      (char const   )'a',      (char const   )'b', 
        (char const   )'c',      (char const   )'d',      (char const   )'e',      (char const   )'f', 
        (char const   )'g',      (char const   )'h',      (char const   )'i',      (char const   )'j', 
        (char const   )'k',      (char const   )'l',      (char const   )'m',      (char const   )'n', 
        (char const   )'o',      (char const   )'p',      (char const   )'q',      (char const   )'r', 
        (char const   )'s',      (char const   )'t',      (char const   )'u',      (char const   )'v', 
        (char const   )'w',      (char const   )'x',      (char const   )'y',      (char const   )'z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'+',      (char const   )'/'};
#line 68 "/home/wslee/project/coreutils-8.1/lib/base64.c"
void base64_encode(char const   * __restrict  in , size_t inlen , char * __restrict  out ,
                   size_t outlen ) 
{ 
  char * __restrict  tmp ;
  unsigned char tmp___0 ;
  char * __restrict  tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  int tmp___4 ;
  char * __restrict  tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  int tmp___8 ;
  char * __restrict  tmp___9 ;
  unsigned char tmp___10 ;

  {
#line 75
  while (1) {
#line 75
    if (inlen) {
#line 75
      if (! outlen) {
#line 75
        break;
      }
    } else {
#line 75
      break;
    }
#line 77
    tmp = out;
#line 77
    out ++;
#line 77
    tmp___0 = to_uchar((char )*(in + 0));
#line 77
    *tmp = (char )b64str[((int )tmp___0 >> 2) & 63];
#line 78
    outlen --;
#line 78
    if (! outlen) {
#line 79
      break;
    }
#line 80
    tmp___1 = out;
#line 80
    out ++;
#line 80
    tmp___2 = to_uchar((char )*(in + 0));
#line 80
    inlen --;
#line 80
    if (inlen) {
#line 80
      tmp___3 = to_uchar((char )*(in + 1));
#line 80
      tmp___4 = (int )tmp___3 >> 4;
    } else {
#line 80
      tmp___4 = 0;
    }
#line 80
    *tmp___1 = (char )b64str[(((int )tmp___2 << 4) + tmp___4) & 63];
#line 83
    outlen --;
#line 83
    if (! outlen) {
#line 84
      break;
    }
#line 85
    tmp___5 = out;
#line 85
    out ++;
#line 85
    if (inlen) {
#line 85
      tmp___6 = to_uchar((char )*(in + 1));
#line 85
      inlen --;
#line 85
      if (inlen) {
#line 85
        tmp___7 = to_uchar((char )*(in + 2));
#line 85
        tmp___8 = (int )tmp___7 >> 6;
      } else {
#line 85
        tmp___8 = 0;
      }
#line 85
      *tmp___5 = (char )b64str[(((int )tmp___6 << 2) + tmp___8) & 63];
    } else {
#line 85
      *tmp___5 = (char )'=';
    }
#line 91
    outlen --;
#line 91
    if (! outlen) {
#line 92
      break;
    }
#line 93
    tmp___9 = out;
#line 93
    out ++;
#line 93
    if (inlen) {
#line 93
      tmp___10 = to_uchar((char )*(in + 2));
#line 93
      *tmp___9 = (char )b64str[(int )tmp___10 & 63];
    } else {
#line 93
      *tmp___9 = (char )'=';
    }
#line 94
    outlen --;
#line 94
    if (! outlen) {
#line 95
      break;
    }
#line 96
    if (inlen) {
#line 97
      inlen --;
    }
#line 98
    if (inlen) {
#line 99
      in += 3;
    }
  }
#line 102
  if (outlen) {
#line 103
    *out = (char )'\000';
  }
#line 104
  return;
}
}
#line 115 "/home/wslee/project/coreutils-8.1/lib/base64.c"
size_t base64_encode_alloc(char const   *in , size_t inlen , char **out ) 
{ 
  size_t outlen ;
  void *tmp ;

  {
#line 118
  outlen = 1UL + ((inlen + 2UL) / 3UL) * 4UL;
#line 132
  if (inlen > outlen) {
#line 134
    *out = (char *)((void *)0);
#line 135
    return ((size_t )0);
  }
#line 138
  tmp = malloc(outlen);
#line 138
  *out = (char *)tmp;
#line 139
  if (! *out) {
#line 140
    return (outlen);
  }
#line 142
  base64_encode((char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                outlen);
#line 144
  return (outlen - 1UL);
}
}
#line 223 "/home/wslee/project/coreutils-8.1/lib/base64.c"
static signed char const   b64[256]  = 
#line 223
  {      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )62, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )63, 
        (signed char const   )52,      (signed char const   )53,      (signed char const   )54,      (signed char const   )55, 
        (signed char const   )56,      (signed char const   )57,      (signed char const   )58,      (signed char const   )59, 
        (signed char const   )60,      (signed char const   )61,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )0,      (signed char const   )1,      (signed char const   )2, 
        (signed char const   )3,      (signed char const   )4,      (signed char const   )5,      (signed char const   )6, 
        (signed char const   )7,      (signed char const   )8,      (signed char const   )9,      (signed char const   )10, 
        (signed char const   )11,      (signed char const   )12,      (signed char const   )13,      (signed char const   )14, 
        (signed char const   )15,      (signed char const   )16,      (signed char const   )17,      (signed char const   )18, 
        (signed char const   )19,      (signed char const   )20,      (signed char const   )21,      (signed char const   )22, 
        (signed char const   )23,      (signed char const   )24,      (signed char const   )25,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )26,      (signed char const   )27,      (signed char const   )28, 
        (signed char const   )29,      (signed char const   )30,      (signed char const   )31,      (signed char const   )32, 
        (signed char const   )33,      (signed char const   )34,      (signed char const   )35,      (signed char const   )36, 
        (signed char const   )37,      (signed char const   )38,      (signed char const   )39,      (signed char const   )40, 
        (signed char const   )41,      (signed char const   )42,      (signed char const   )43,      (signed char const   )44, 
        (signed char const   )45,      (signed char const   )46,      (signed char const   )47,      (signed char const   )48, 
        (signed char const   )49,      (signed char const   )50,      (signed char const   )51,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1, 
        (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1,      (signed char const   )-1};
#line 299 "/home/wslee/project/coreutils-8.1/lib/base64.c"
_Bool isbase64(char ch ) 
{ 
  unsigned char tmp ;

  {
#line 302
  tmp = to_uchar(ch);
#line 302
  return ((_Bool )(0 <= (int )b64[tmp]));
}
}
#line 306 "/home/wslee/project/coreutils-8.1/lib/base64.c"
void base64_decode_ctx_init(struct base64_decode_context *ctx ) 
{ 


  {
#line 309
  ctx->i = 0U;
#line 310
  return;
}
}
#line 319 "/home/wslee/project/coreutils-8.1/lib/base64.c"
__inline static char *get_4(struct base64_decode_context *ctx , char const   * __restrict  *in ,
                            char const   * __restrict  in_end , size_t *n_non_newline ) 
{ 
  char const   *t ;
  void *tmp ;
  char const   *p ;
  char c ;
  char const   *tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 324
  if (ctx->i == 4U) {
#line 325
    ctx->i = 0U;
  }
#line 327
  if (ctx->i == 0U) {
#line 329
    t = (char const   *)*in;
#line 330
    if (4L <= in_end - *in) {
#line 330
      tmp = memchr((void const   *)t, '\n', (size_t )4);
#line 330
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 333
        *in += 4;
#line 334
        *n_non_newline = (size_t )4;
#line 335
        return ((char *)t);
      }
    }
  }
#line 341
  p = (char const   *)*in;
#line 342
  while ((unsigned long )p < (unsigned long )in_end) {
#line 344
    tmp___0 = p;
#line 344
    p ++;
#line 344
    c = (char )*tmp___0;
#line 345
    if ((int )c != 10) {
#line 347
      tmp___1 = ctx->i;
#line 347
      (ctx->i) ++;
#line 347
      ctx->buf[tmp___1] = c;
#line 348
      if (ctx->i == 4U) {
#line 349
        break;
      }
    }
  }
#line 353
  *in = (char const   * __restrict  )p;
#line 354
  *n_non_newline = (size_t )ctx->i;
#line 355
  return (ctx->buf);
}
}
#line 373 "/home/wslee/project/coreutils-8.1/lib/base64.c"
__inline static _Bool decode_4(char const   * __restrict  in , size_t inlen , char * __restrict  *outp ,
                               size_t *outleft ) 
{ 
  char *out ;
  _Bool tmp ;
  _Bool tmp___0 ;
  char *tmp___1 ;
  unsigned char tmp___2 ;
  unsigned char tmp___3 ;
  _Bool tmp___4 ;
  char *tmp___5 ;
  unsigned char tmp___6 ;
  unsigned char tmp___7 ;
  _Bool tmp___8 ;
  char *tmp___9 ;
  unsigned char tmp___10 ;
  unsigned char tmp___11 ;

  {
#line 377
  out = (char *)*outp;
#line 378
  if (inlen < 2UL) {
#line 379
    return ((_Bool)0);
  }
#line 381
  tmp = isbase64((char )*(in + 0));
#line 381
  if (tmp) {
#line 381
    tmp___0 = isbase64((char )*(in + 1));
#line 381
    if (! tmp___0) {
#line 382
      return ((_Bool)0);
    }
  } else {
#line 382
    return ((_Bool)0);
  }
#line 384
  if (*outleft) {
#line 386
    tmp___1 = out;
#line 386
    out ++;
#line 386
    tmp___2 = to_uchar((char )*(in + 0));
#line 386
    tmp___3 = to_uchar((char )*(in + 1));
#line 386
    *tmp___1 = (char )(((int const   )b64[tmp___2] << 2) | ((int const   )b64[tmp___3] >> 4));
#line 388
    (*outleft) --;
  }
#line 391
  if (inlen == 2UL) {
#line 392
    while (1) {
#line 392
      *outp = (char * __restrict  )out;
#line 392
      return ((_Bool)0);
#line 392
      break;
    }
  }
#line 394
  if ((int const   )*(in + 2) == 61) {
#line 396
    if (inlen != 4UL) {
#line 397
      while (1) {
#line 397
        *outp = (char * __restrict  )out;
#line 397
        return ((_Bool)0);
#line 397
        break;
      }
    }
#line 399
    if ((int const   )*(in + 3) != 61) {
#line 400
      while (1) {
#line 400
        *outp = (char * __restrict  )out;
#line 400
        return ((_Bool)0);
#line 400
        break;
      }
    }
  } else {
#line 404
    tmp___4 = isbase64((char )*(in + 2));
#line 404
    if (! tmp___4) {
#line 405
      while (1) {
#line 405
        *outp = (char * __restrict  )out;
#line 405
        return ((_Bool)0);
#line 405
        break;
      }
    }
#line 407
    if (*outleft) {
#line 409
      tmp___5 = out;
#line 409
      out ++;
#line 409
      tmp___6 = to_uchar((char )*(in + 1));
#line 409
      tmp___7 = to_uchar((char )*(in + 2));
#line 409
      *tmp___5 = (char )((((int const   )b64[tmp___6] << 4) & 240) | ((int const   )b64[tmp___7] >> 2));
#line 411
      (*outleft) --;
    }
#line 414
    if (inlen == 3UL) {
#line 415
      while (1) {
#line 415
        *outp = (char * __restrict  )out;
#line 415
        return ((_Bool)0);
#line 415
        break;
      }
    }
#line 417
    if ((int const   )*(in + 3) == 61) {
#line 419
      if (inlen != 4UL) {
#line 420
        while (1) {
#line 420
          *outp = (char * __restrict  )out;
#line 420
          return ((_Bool)0);
#line 420
          break;
        }
      }
    } else {
#line 424
      tmp___8 = isbase64((char )*(in + 3));
#line 424
      if (! tmp___8) {
#line 425
        while (1) {
#line 425
          *outp = (char * __restrict  )out;
#line 425
          return ((_Bool)0);
#line 425
          break;
        }
      }
#line 427
      if (*outleft) {
#line 429
        tmp___9 = out;
#line 429
        out ++;
#line 429
        tmp___10 = to_uchar((char )*(in + 2));
#line 429
        tmp___11 = to_uchar((char )*(in + 3));
#line 429
        *tmp___9 = (char )((((int const   )b64[tmp___10] << 6) & 192) | (int const   )b64[tmp___11]);
#line 431
        (*outleft) --;
      }
    }
  }
#line 436
  *outp = (char * __restrict  )out;
#line 437
  return ((_Bool)1);
}
}
#line 458 "/home/wslee/project/coreutils-8.1/lib/base64.c"
_Bool base64_decode_ctx(struct base64_decode_context *ctx , char const   * __restrict  in ,
                        size_t inlen , char * __restrict  out , size_t *outlen ) 
{ 
  size_t outleft ;
  _Bool ignore_newlines ;
  _Bool flush_ctx ;
  unsigned int ctx_i ;
  size_t outleft_save ;
  _Bool tmp ;
  char const   *in_end ;
  char const   *non_nl ;
  char *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 463
  outleft = *outlen;
#line 464
  ignore_newlines = (_Bool )((unsigned long )ctx != (unsigned long )((void *)0));
#line 465
  flush_ctx = (_Bool)0;
#line 466
  ctx_i = 0U;
#line 468
  if (ignore_newlines) {
#line 470
    ctx_i = ctx->i;
#line 471
    flush_ctx = (_Bool )(inlen == 0UL);
  }
#line 475
  while (1) {
#line 477
    outleft_save = outleft;
#line 478
    if (ctx_i == 0U) {
#line 478
      if (! flush_ctx) {
#line 480
        while (1) {
#line 484
          outleft_save = outleft;
#line 485
          tmp = decode_4(in, inlen, & out, & outleft);
#line 485
          if (! tmp) {
#line 486
            break;
          }
#line 488
          in += 4;
#line 489
          inlen -= 4UL;
        }
      }
    }
#line 493
    if (inlen == 0UL) {
#line 493
      if (! flush_ctx) {
#line 494
        break;
      }
    }
#line 498
    if (inlen) {
#line 498
      if ((int const   )*in == 10) {
#line 498
        if (ignore_newlines) {
#line 500
          in ++;
#line 501
          inlen --;
#line 502
          continue;
        }
      }
    }
#line 506
    out -= outleft_save - outleft;
#line 507
    outleft = outleft_save;
#line 510
    in_end = (char const   *)(in + inlen);
#line 513
    if (ignore_newlines) {
#line 514
      tmp___0 = get_4(ctx, & in, (char const   * __restrict  )in_end, & inlen);
#line 514
      non_nl = (char const   *)tmp___0;
    } else {
#line 516
      non_nl = (char const   *)in;
    }
#line 521
    if (inlen == 0UL) {
#line 523
      inlen = (size_t )0;
#line 524
      break;
    } else
#line 521
    if (inlen < 4UL) {
#line 521
      if (! flush_ctx) {
#line 521
        if (ignore_newlines) {
#line 523
          inlen = (size_t )0;
#line 524
          break;
        }
      }
    }
#line 526
    tmp___1 = decode_4((char const   * __restrict  )non_nl, inlen, & out, & outleft);
#line 526
    if (! tmp___1) {
#line 527
      break;
    }
#line 529
    inlen = (size_t )(in_end - (char const   *)in);
  }
#line 533
  *outlen -= outleft;
#line 535
  return ((_Bool )(inlen == 0UL));
}
}
#line 549 "/home/wslee/project/coreutils-8.1/lib/base64.c"
_Bool base64_decode_alloc_ctx(struct base64_decode_context *ctx , char const   *in ,
                              size_t inlen , char **out , size_t *outlen ) 
{ 
  size_t needlen ;
  void *tmp ;
  _Bool tmp___0 ;

  {
#line 559
  needlen = 3UL * (inlen / 4UL) + 2UL;
#line 561
  tmp = malloc(needlen);
#line 561
  *out = (char *)tmp;
#line 562
  if (! *out) {
#line 563
    return ((_Bool)1);
  }
#line 565
  tmp___0 = base64_decode_ctx(ctx, (char const   * __restrict  )in, inlen, (char * __restrict  )*out,
                              & needlen);
#line 565
  if (! tmp___0) {
#line 567
    free((void *)*out);
#line 568
    *out = (char *)((void *)0);
#line 569
    return ((_Bool)0);
  }
#line 572
  if (outlen) {
#line 573
    *outlen = needlen;
  }
#line 575
  return ((_Bool)1);
}
}
#line 1 "cil-wXkqzZz2.o"
#pragma merger("0","../lib/basename-lgpl.o.i","")
#line 29 "/home/wslee/project/coreutils-8.1/lib/basename-lgpl.c"
char *last_component(char const   *name ) 
{ 
  char const   *base ;
  char const   *p ;
  _Bool saw_slash ;

  {
#line 32
  base = name + 0;
#line 34
  saw_slash = (_Bool)0;
#line 36
  while ((int const   )*base == 47) {
#line 37
    base ++;
  }
#line 39
  p = base;
#line 39
  while (*p) {
#line 41
    if ((int const   )*p == 47) {
#line 42
      saw_slash = (_Bool)1;
    } else
#line 43
    if (saw_slash) {
#line 45
      base = p;
#line 46
      saw_slash = (_Bool)0;
    }
#line 39
    p ++;
  }
#line 50
  return ((char *)base);
}
}
#line 57 "/home/wslee/project/coreutils-8.1/lib/basename-lgpl.c"
size_t base_len(char const   *name ) 
{ 
  size_t len ;
  size_t prefix_len ;

  {
#line 61
  prefix_len = (size_t )0;
#line 63
  len = strlen(name);
#line 63
  while (1) {
#line 63
    if (1UL < len) {
#line 63
      if (! ((int const   )*(name + (len - 1UL)) == 47)) {
#line 63
        break;
      }
    } else {
#line 63
      break;
    }
#line 64
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 63
    len --;
  }
#line 74
  return (len);
}
}
#line 1 "cil-8B3persG.o"
#pragma merger("0","../lib/basename.o.i","")
#line 62 "/home/wslee/project/coreutils-8.1/lib/dirname.h"
char *base_name(char const   *name ) ;
#line 23 "/home/wslee/project/coreutils-8.1/lib/xstrndup.h"
char *xstrndup(char const   *string , size_t n ) ;
#line 27 "/home/wslee/project/coreutils-8.1/lib/basename.c"
char *base_name(char const   *name ) 
{ 
  char const   *base ;
  char *tmp ;
  size_t length ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___3 ;

  {
#line 30
  tmp = last_component(name);
#line 30
  base = (char const   *)tmp;
#line 35
  if (! *base) {
#line 36
    tmp___0 = base_len(name);
#line 36
    tmp___1 = xstrndup(name, tmp___0);
#line 36
    return (tmp___1);
  }
#line 39
  length = base_len(base);
#line 40
  if ((int const   )*(base + length) == 47) {
#line 41
    length ++;
  }
#line 57
  tmp___3 = xstrndup(base, length);
#line 57
  return (tmp___3);
}
}
#line 1 "cil-FgmjeU77.o"
#pragma merger("0","../lib/buffer-lcm.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/buffer-lcm.h"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) ;
#line 26 "/home/wslee/project/coreutils-8.1/lib/buffer-lcm.c"
size_t buffer_lcm(size_t a , size_t b , size_t lcm_max ) 
{ 
  size_t size ;
  size_t lcm ;
  size_t m ;
  size_t n ;
  size_t q ;
  size_t r ;
  size_t tmp ;

  {
#line 32
  if (! a) {
#line 33
    if (b) {
#line 33
      size = b;
    } else {
#line 33
      size = (size_t )8192;
    }
  } else {
#line 36
    if (b) {
#line 44
      m = a;
#line 44
      n = b;
#line 44
      while (1) {
#line 44
        r = m % n;
#line 44
        if (! (r != 0UL)) {
#line 44
          break;
        }
#line 45
        goto __Cont;
        __Cont: /* CIL Label */ 
#line 44
        m = n;
#line 44
        n = r;
      }
#line 48
      q = a / n;
#line 49
      lcm = q * b;
#line 50
      if (lcm <= lcm_max) {
#line 50
        if (lcm / b == q) {
#line 51
          return (lcm);
        }
      }
    }
#line 54
    size = a;
  }
#line 57
  if (size <= lcm_max) {
#line 57
    tmp = size;
  } else {
#line 57
    tmp = lcm_max;
  }
#line 57
  return (tmp);
}
}
#line 1 "cil-WtdlakPv.o"
#pragma merger("0","../lib/c-ctype.o.i","")
#line 121 "/home/wslee/project/coreutils-8.1/lib/c-ctype.h"
_Bool c_isascii(int c ) ;
#line 123
_Bool c_isalnum(int c ) ;
#line 124
_Bool c_isalpha(int c ) ;
#line 125
_Bool c_isblank(int c ) ;
#line 126
_Bool c_iscntrl(int c ) ;
#line 127
_Bool c_isdigit(int c ) ;
#line 128
_Bool c_islower(int c ) ;
#line 129
_Bool c_isgraph(int c ) ;
#line 130
_Bool c_isprint(int c ) ;
#line 131
_Bool c_ispunct(int c ) ;
#line 132
_Bool c_isspace(int c ) ;
#line 133
_Bool c_isupper(int c ) ;
#line 134
_Bool c_isxdigit(int c ) ;
#line 136
int c_tolower(int c ) ;
#line 137
int c_toupper(int c ) ;
#line 27 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isascii(int c ) 
{ 
  int tmp ;

  {
#line 30
  if (c >= 0) {
#line 30
    if (c <= 127) {
#line 30
      tmp = 1;
    } else {
#line 30
      tmp = 0;
    }
  } else {
#line 30
    tmp = 0;
  }
#line 30
  return ((_Bool )tmp);
}
}
#line 33 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isalnum(int c ) 
{ 
  int tmp ;

  {
#line 39
  if (c >= 48) {
#line 39
    if (c <= 57) {
#line 39
      tmp = 1;
    } else {
#line 39
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 39
  if ((c & -33) >= 65) {
#line 39
    if ((c & -33) <= 90) {
#line 39
      tmp = 1;
    } else {
#line 39
      tmp = 0;
    }
  } else {
#line 39
    tmp = 0;
  }
#line 39
  return ((_Bool )tmp);
}
}
#line 68 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isalpha(int c ) 
{ 
  int tmp ;

  {
#line 73
  if ((c & -33) >= 65) {
#line 73
    if ((c & -33) <= 90) {
#line 73
      tmp = 1;
    } else {
#line 73
      tmp = 0;
    }
  } else {
#line 73
    tmp = 0;
  }
#line 73
  return ((_Bool )tmp);
}
}
#line 97 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isblank(int c ) 
{ 
  int tmp ;

  {
#line 100
  if (c == 32) {
#line 100
    tmp = 1;
  } else
#line 100
  if (c == 9) {
#line 100
    tmp = 1;
  } else {
#line 100
    tmp = 0;
  }
#line 100
  return ((_Bool )tmp);
}
}
#line 103 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_iscntrl(int c ) 
{ 
  int tmp ;

  {
#line 107
  if ((c & -32) == 0) {
#line 107
    tmp = 1;
  } else
#line 107
  if (c == 127) {
#line 107
    tmp = 1;
  } else {
#line 107
    tmp = 0;
  }
#line 107
  return ((_Bool )tmp);
}
}
#line 137 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isdigit(int c ) 
{ 
  int tmp ;

  {
#line 141
  if (c >= 48) {
#line 141
    if (c <= 57) {
#line 141
      tmp = 1;
    } else {
#line 141
      tmp = 0;
    }
  } else {
#line 141
    tmp = 0;
  }
#line 141
  return ((_Bool )tmp);
}
}
#line 154 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_islower(int c ) 
{ 
  int tmp ;

  {
#line 158
  if (c >= 97) {
#line 158
    if (c <= 122) {
#line 158
      tmp = 1;
    } else {
#line 158
      tmp = 0;
    }
  } else {
#line 158
    tmp = 0;
  }
#line 158
  return ((_Bool )tmp);
}
}
#line 174 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isgraph(int c ) 
{ 
  int tmp ;

  {
#line 178
  if (c >= 33) {
#line 178
    if (c <= 126) {
#line 178
      tmp = 1;
    } else {
#line 178
      tmp = 0;
    }
  } else {
#line 178
    tmp = 0;
  }
#line 178
  return ((_Bool )tmp);
}
}
#line 208 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isprint(int c ) 
{ 
  int tmp ;

  {
#line 212
  if (c >= 32) {
#line 212
    if (c <= 126) {
#line 212
      tmp = 1;
    } else {
#line 212
      tmp = 0;
    }
  } else {
#line 212
    tmp = 0;
  }
#line 212
  return ((_Bool )tmp);
}
}
#line 242 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_ispunct(int c ) 
{ 
  int tmp ;

  {
#line 246
  if (c >= 33) {
#line 246
    if (c <= 126) {
#line 246
      if (c >= 48) {
#line 246
        if (c <= 57) {
#line 246
          tmp = 0;
        } else {
#line 246
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 246
      if ((c & -33) >= 65) {
#line 246
        if ((c & -33) <= 90) {
#line 246
          tmp = 0;
        } else {
#line 246
          tmp = 1;
        }
      } else {
#line 246
        tmp = 1;
      }
    } else {
#line 246
      tmp = 0;
    }
  } else {
#line 246
    tmp = 0;
  }
#line 246
  return ((_Bool )tmp);
}
}
#line 266 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isspace(int c ) 
{ 
  int tmp ;

  {
#line 269
  if (c == 32) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 9) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 10) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 11) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 12) {
#line 269
    tmp = 1;
  } else
#line 269
  if (c == 13) {
#line 269
    tmp = 1;
  } else {
#line 269
    tmp = 0;
  }
#line 269
  return ((_Bool )tmp);
}
}
#line 273 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isupper(int c ) 
{ 
  int tmp ;

  {
#line 277
  if (c >= 65) {
#line 277
    if (c <= 90) {
#line 277
      tmp = 1;
    } else {
#line 277
      tmp = 0;
    }
  } else {
#line 277
    tmp = 0;
  }
#line 277
  return ((_Bool )tmp);
}
}
#line 293 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
_Bool c_isxdigit(int c ) 
{ 
  int tmp ;

  {
#line 299
  if (c >= 48) {
#line 299
    if (c <= 57) {
#line 299
      tmp = 1;
    } else {
#line 299
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 299
  if ((c & -33) >= 65) {
#line 299
    if ((c & -33) <= 70) {
#line 299
      tmp = 1;
    } else {
#line 299
      tmp = 0;
    }
  } else {
#line 299
    tmp = 0;
  }
#line 299
  return ((_Bool )tmp);
}
}
#line 320 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
int c_tolower(int c ) 
{ 
  int tmp ;

  {
#line 324
  if (c >= 65) {
#line 324
    if (c <= 90) {
#line 324
      tmp = (c - 65) + 97;
    } else {
#line 324
      tmp = c;
    }
  } else {
#line 324
    tmp = c;
  }
#line 324
  return (tmp);
}
}
#line 359 "/home/wslee/project/coreutils-8.1/lib/c-ctype.c"
int c_toupper(int c ) 
{ 
  int tmp ;

  {
#line 363
  if (c >= 97) {
#line 363
    if (c <= 122) {
#line 363
      tmp = (c - 97) + 65;
    } else {
#line 363
      tmp = c;
    }
  } else {
#line 363
    tmp = c;
  }
#line 363
  return (tmp);
}
}
#line 1 "cil-FOf5f5Pl.o"
#pragma merger("0","../lib/c-strcasecmp.o.i","")
#line 42 "/home/wslee/project/coreutils-8.1/lib/c-strcase.h"
int c_strcasecmp(char const   *s1 , char const   *s2 ) ;
#line 27 "/home/wslee/project/coreutils-8.1/lib/c-strcasecmp.c"
int c_strcasecmp(char const   *s1 , char const   *s2 ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 30
  p1 = (unsigned char const   *)s1;
#line 31
  p2 = (unsigned char const   *)s2;
#line 34
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 35
    return (0);
  }
#line 37
  while (1) {
#line 39
    tmp = c_tolower((int )*p1);
#line 39
    c1 = (unsigned char )tmp;
#line 40
    tmp___0 = c_tolower((int )*p2);
#line 40
    c2 = (unsigned char )tmp___0;
#line 42
    if ((int )c1 == 0) {
#line 43
      break;
    }
#line 45
    p1 ++;
#line 46
    p2 ++;
#line 37
    if (! ((int )c1 == (int )c2)) {
#line 37
      break;
    }
  }
#line 51
  return ((int )c1 - (int )c2);
}
}
#line 1 "cil-rrVNAJ9L.o"
#pragma merger("0","../lib/c-strncasecmp.o.i","")
#line 47 "/home/wslee/project/coreutils-8.1/lib/c-strcase.h"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) ;
#line 27 "/home/wslee/project/coreutils-8.1/lib/c-strncasecmp.c"
int c_strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  register unsigned char const   *p1 ;
  register unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 30
  p1 = (unsigned char const   *)s1;
#line 31
  p2 = (unsigned char const   *)s2;
#line 34
  if ((unsigned long )p1 == (unsigned long )p2) {
#line 35
    return (0);
  } else
#line 34
  if (n == 0UL) {
#line 35
    return (0);
  }
#line 37
  while (1) {
#line 39
    tmp = c_tolower((int )*p1);
#line 39
    c1 = (unsigned char )tmp;
#line 40
    tmp___0 = c_tolower((int )*p2);
#line 40
    c2 = (unsigned char )tmp___0;
#line 42
    n --;
#line 42
    if (n == 0UL) {
#line 43
      break;
    } else
#line 42
    if ((int )c1 == 0) {
#line 43
      break;
    }
#line 45
    p1 ++;
#line 46
    p2 ++;
#line 37
    if (! ((int )c1 == (int )c2)) {
#line 37
      break;
    }
  }
#line 51
  return ((int )c1 - (int )c2);
}
}
#line 1 "cil-zWcUIari.o"
#pragma merger("0","../lib/c-strtod.o.i","")
#line 36 "/home/wslee/project/coreutils-8.1/lib/c-strtod.h"
double c_strtod(char const   *nptr , char **endptr ) ;
#line 151 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) __locale_t ( __attribute__((__leaf__)) newlocale)(int __category_mask ,
                                                                                       char const   *__locale ,
                                                                                       __locale_t __base ) ;
#line 260 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1,3), __leaf__)) strtod_l)(char const   * __restrict  __nptr ,
                                                                                                    char ** __restrict  __endptr ,
                                                                                                    __locale_t __loc ) ;
#line 51 "/home/wslee/project/coreutils-8.1/lib/c-strtod.c"
static locale_t volatile   c_locale_cache  ;
#line 55 "/home/wslee/project/coreutils-8.1/lib/c-strtod.c"
__inline static locale_t c_locale(void) 
{ 
  __locale_t tmp ;

  {
#line 58
  if (! c_locale_cache) {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache = (locale_t volatile   )tmp;
  }
#line 60
  return ((locale_t )c_locale_cache);
}
}
#line 65 "/home/wslee/project/coreutils-8.1/lib/c-strtod.c"
double c_strtod(char const   *nptr , char **endptr ) 
{ 
  double r ;
  locale_t locale ;
  locale_t tmp ;

  {
#line 72
  tmp = c_locale();
#line 72
  locale = tmp;
#line 73
  if (! locale) {
#line 75
    if (endptr) {
#line 76
      *endptr = (char *)nptr;
    }
#line 77
    return ((double )0);
  }
#line 80
  r = strtod_l((char const   * __restrict  )nptr, (char ** __restrict  )endptr, locale);
#line 111
  return (r);
}
}
#line 1 "cil-OqegwFSx.o"
#pragma merger("0","../lib/c-strtold.o.i","")
#line 37 "/home/wslee/project/coreutils-8.1/lib/c-strtod.h"
long double c_strtold(char const   *nptr , char **endptr ) ;
#line 268 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long double ( __attribute__((__nonnull__(1,3),
__leaf__)) strtold_l)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                      __locale_t __loc ) ;
#line 51 "/home/wslee/project/coreutils-8.1/lib/c-strtod.c"
static locale_t volatile   c_locale_cache___0  ;
#line 55 "/home/wslee/project/coreutils-8.1/lib/c-strtod.c"
__inline static locale_t c_locale___0(void) 
{ 
  __locale_t tmp ;

  {
#line 58
  if (! c_locale_cache___0) {
#line 59
    tmp = newlocale(((((((((((1 | (1 << 1)) | (1 << 2)) | (1 << 3)) | (1 << 4)) | (1 << 5)) | (1 << 7)) | (1 << 8)) | (1 << 9)) | (1 << 10)) | (1 << 11)) | (1 << 12),
                    "C", (locale_t )0);
#line 59
    c_locale_cache___0 = (locale_t volatile   )tmp;
  }
#line 60
  return ((locale_t )c_locale_cache___0);
}
}
#line 65 "/home/wslee/project/coreutils-8.1/lib/c-strtod.c"
long double c_strtold(char const   *nptr , char **endptr ) 
{ 
  long double r ;
  locale_t locale ;
  locale_t tmp ;

  {
#line 72
  tmp = c_locale___0();
#line 72
  locale = tmp;
#line 73
  if (! locale) {
#line 75
    if (endptr) {
#line 76
      *endptr = (char *)nptr;
    }
#line 77
    return ((long double )0);
  }
#line 80
  r = strtold_l((char const   * __restrict  )nptr, (char ** __restrict  )endptr, locale);
#line 111
  return (r);
}
}
#line 1 "cil-Bam4wb3V.o"
#pragma merger("0","../lib/canon-host.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/canon-host.h"
char *canon_host(char const   *host ) ;
#line 24
char *canon_host_r(char const   *host , int *cherror ) ;
#line 26
char const   *ch_strerror(void) ;
#line 171 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 28 "/home/wslee/project/coreutils-8.1/lib/canon-host.c"
static int last_cherror  ;
#line 32 "/home/wslee/project/coreutils-8.1/lib/canon-host.c"
char *canon_host(char const   *host ) 
{ 
  char *tmp ;

  {
#line 35
  tmp = canon_host_r(host, & last_cherror);
#line 35
  return (tmp);
}
}
#line 63 "/home/wslee/project/coreutils-8.1/lib/canon-host.c"
static struct addrinfo hints  ;
#line 59 "/home/wslee/project/coreutils-8.1/lib/canon-host.c"
char *canon_host_r(char const   *host , int *cherror ) 
{ 
  char *retval ;
  struct addrinfo *res ;
  int status ;
  char const   *tmp ;

  {
#line 62
  retval = (char *)((void *)0);
#line 64
  res = (struct addrinfo *)((void *)0);
#line 67
  hints.ai_flags = 2;
#line 68
  status = getaddrinfo((char const   * __restrict  )host, (char const   * __restrict  )((void *)0),
                       (struct addrinfo  const  * __restrict  )(& hints), (struct addrinfo ** __restrict  )(& res));
#line 69
  if (! status) {
#line 74
    if (res->ai_canonname) {
#line 74
      tmp = (char const   *)res->ai_canonname;
    } else {
#line 74
      tmp = host;
    }
#line 74
    retval = strdup(tmp);
#line 75
    if (! retval) {
#line 75
      if (cherror) {
#line 76
        *cherror = -10;
      }
    }
#line 77
    freeaddrinfo(res);
  } else
#line 79
  if (cherror) {
#line 80
    *cherror = status;
  }
#line 82
  return (retval);
}
}
#line 86 "/home/wslee/project/coreutils-8.1/lib/canon-host.c"
char const   *ch_strerror(void) 
{ 
  char const   *tmp ;

  {
#line 89
  tmp = gai_strerror(last_cherror);
#line 89
  return (tmp);
}
}
#line 1 "cil-V659v_S7.o"
#pragma merger("0","../lib/canonicalize.o.i","")
#line 39 "/home/wslee/project/coreutils-8.1/lib/canonicalize.h"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 284
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strspn)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 7 "/home/wslee/project/coreutils-8.1/lib/file-set.h"
void ( __attribute__((__nonnull__(2,3))) record_file)(Hash_table *ht___0 , char const   *file ,
                                                      struct stat  const  *stats ) ;
#line 11
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) ;
#line 16 "/home/wslee/project/coreutils-8.1/lib/hash-triple.h"
size_t triple_hash(void const   *x , size_t table_size ) ;
#line 19
_Bool triple_compare_ino_str(void const   *x , void const   *y ) ;
#line 20
void triple_free(void *x ) ;
#line 17 "/home/wslee/project/coreutils-8.1/lib/xgetcwd.h"
char *xgetcwd(void) ;
#line 54 "/home/wslee/project/coreutils-8.1/lib/canonicalize.c"
static _Bool seen_triple(Hash_table **ht___0 , char const   *filename , struct stat  const  *st ) 
{ 
  size_t initial_capacity ;
  _Bool tmp ;

  {
#line 57
  if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
#line 59
    initial_capacity = (size_t )7;
#line 60
    *ht___0 = hash_initialize(initial_capacity, (Hash_tuning const   *)((void *)0),
                              & triple_hash, & triple_compare_ino_str, & triple_free);
#line 65
    if ((unsigned long )*ht___0 == (unsigned long )((void *)0)) {
#line 66
      xalloc_die();
    }
  }
#line 69
  tmp = seen_file((Hash_table const   *)*ht___0, filename, st);
#line 69
  if (tmp) {
#line 70
    return ((_Bool)1);
  }
#line 72
  record_file(*ht___0, filename, st);
#line 73
  return ((_Bool)0);
}
}
#line 82 "/home/wslee/project/coreutils-8.1/lib/canonicalize.c"
char *canonicalize_filename_mode(char const   *name , canonicalize_mode_t can_mode ) 
{ 
  char *rname ;
  char *dest ;
  char *extra_buf ;
  char const   *start ;
  char const   *end ;
  char const   *rname_limit ;
  size_t extra_len ;
  Hash_table *ht___0 ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  char *p ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct stat st ;
  char *tmp___4 ;
  ptrdiff_t dest_offset ;
  size_t new_size ;
  void *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  char *buf___0 ;
  size_t n ;
  size_t len ;
  _Bool tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int *tmp___17 ;

  {
#line 85
  extra_buf = (char *)((void *)0);
#line 89
  extra_len = (size_t )0;
#line 90
  ht___0 = (Hash_table *)((void *)0);
#line 93
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 95
    tmp = __errno_location();
#line 95
    *tmp = 22;
#line 96
    return ((char *)((void *)0));
  }
#line 99
  if ((int const   )*(name + 0) == 0) {
#line 101
    tmp___0 = __errno_location();
#line 101
    *tmp___0 = 2;
#line 102
    return ((char *)((void *)0));
  }
#line 105
  if ((int const   )*(name + 0) != 47) {
#line 107
    rname = xgetcwd();
#line 108
    if (! rname) {
#line 109
      return ((char *)((void *)0));
    }
#line 110
    dest = strchr((char const   *)rname, '\000');
#line 111
    if (dest - rname < 4096L) {
#line 113
      tmp___1 = xrealloc((void *)rname, (size_t )4096);
#line 113
      p = (char *)tmp___1;
#line 114
      dest = p + (dest - rname);
#line 115
      rname = p;
#line 116
      rname_limit = (char const   *)(rname + 4096);
    } else {
#line 120
      rname_limit = (char const   *)dest;
    }
  } else {
#line 125
    tmp___2 = xmalloc((size_t )4096);
#line 125
    rname = (char *)tmp___2;
#line 126
    rname_limit = (char const   *)(rname + 4096);
#line 127
    *(rname + 0) = (char )'/';
#line 128
    dest = rname + 1;
  }
#line 133
  start = name;
#line 133
  while (*start) {
#line 136
    while ((int const   )*start == 47) {
#line 137
      start ++;
    }
#line 140
    end = start;
#line 140
    while (1) {
#line 140
      if (*end) {
#line 140
        if (! ((int const   )*end != 47)) {
#line 140
          break;
        }
      } else {
#line 140
        break;
      }
#line 140
      end ++;
    }
#line 143
    if (end - start == 0L) {
#line 144
      break;
    } else
#line 145
    if (end - start == 1L) {
#line 145
      if (! ((int const   )*(start + 0) == 46)) {
#line 145
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 147
    if (end - start == 2L) {
#line 147
      if ((int const   )*(start + 0) == 46) {
#line 147
        if ((int const   )*(start + 1) == 46) {
#line 150
          if ((unsigned long )dest > (unsigned long )(rname + 1)) {
#line 151
            while (1) {
#line 151
              dest --;
#line 151
              if (! ((int )*(dest + -1) != 47)) {
#line 151
                break;
              }
            }
          }
        } else {
#line 147
          goto _L___0;
        }
      } else {
#line 147
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 160
      if ((int )*(dest + -1) != 47) {
#line 161
        tmp___4 = dest;
#line 161
        dest ++;
#line 161
        *tmp___4 = (char )'/';
      }
#line 163
      if ((unsigned long )(dest + (end - start)) >= (unsigned long )rname_limit) {
#line 165
        dest_offset = dest - rname;
#line 166
        new_size = (size_t )(rname_limit - (char const   *)rname);
#line 168
        if ((end - start) + 1L > 4096L) {
#line 169
          new_size += (size_t )((end - start) + 1L);
        } else {
#line 171
          new_size += 4096UL;
        }
#line 172
        tmp___5 = xrealloc((void *)rname, new_size);
#line 172
        rname = (char *)tmp___5;
#line 173
        rname_limit = (char const   *)(rname + new_size);
#line 175
        dest = rname + dest_offset;
      }
#line 178
      tmp___6 = memcpy((void * __restrict  )dest, (void const   * __restrict  )start,
                       (size_t )(end - start));
#line 178
      dest = (char *)tmp___6;
#line 179
      dest += end - start;
#line 180
      *dest = (char )'\000';
#line 182
      tmp___9 = lstat((char const   * __restrict  )rname, (struct stat * __restrict  )(& st));
#line 182
      if (tmp___9 != 0) {
#line 184
        tmp___7 = __errno_location();
#line 184
        saved_errno = *tmp___7;
#line 185
        if ((unsigned int )can_mode == 0U) {
#line 186
          goto error;
        }
#line 187
        if ((unsigned int )can_mode == 1U) {
#line 189
          tmp___8 = strspn(end, "/");
#line 189
          if (*(end + tmp___8)) {
#line 190
            goto error;
          } else
#line 189
          if (saved_errno != 2) {
#line 190
            goto error;
          }
#line 191
          goto __Cont;
        }
#line 193
        st.st_mode = (__mode_t )0;
      }
#line 196
      if ((st.st_mode & 61440U) == 40960U) {
#line 205
        tmp___10 = seen_triple(& ht___0, name, (struct stat  const  *)(& st));
#line 205
        if (tmp___10) {
#line 207
          if ((unsigned int )can_mode == 2U) {
#line 208
            goto __Cont;
          }
#line 209
          saved_errno = 40;
#line 210
          goto error;
        }
#line 213
        buf___0 = areadlink_with_size((char const   *)rname, (size_t )st.st_size);
#line 214
        if (! buf___0) {
#line 216
          if ((unsigned int )can_mode == 2U) {
#line 216
            tmp___11 = __errno_location();
#line 216
            if (*tmp___11 != 12) {
#line 217
              goto __Cont;
            }
          }
#line 218
          tmp___12 = __errno_location();
#line 218
          saved_errno = *tmp___12;
#line 219
          goto error;
        }
#line 222
        n = strlen((char const   *)buf___0);
#line 223
        len = strlen(end);
#line 225
        if (! extra_len) {
#line 227
          if ((n + len) + 1UL > 4096UL) {
#line 227
            extra_len = (n + len) + 1UL;
          } else {
#line 227
            extra_len = (size_t )4096;
          }
#line 229
          tmp___13 = xmalloc(extra_len);
#line 229
          extra_buf = (char *)tmp___13;
        } else
#line 231
        if ((n + len) + 1UL > extra_len) {
#line 233
          extra_len = (n + len) + 1UL;
#line 234
          tmp___14 = xrealloc((void *)extra_buf, extra_len);
#line 234
          extra_buf = (char *)tmp___14;
        }
#line 238
        memmove((void *)(extra_buf + n), (void const   *)end, len + 1UL);
#line 239
        tmp___15 = memcpy((void * __restrict  )extra_buf, (void const   * __restrict  )buf___0,
                          n);
#line 239
        end = (char const   *)tmp___15;
#line 239
        name = end;
#line 241
        if ((int )*(buf___0 + 0) == 47) {
#line 243
          dest = rname + 1;
        } else
#line 251
        if ((unsigned long )dest > (unsigned long )(rname + 1)) {
#line 252
          while (1) {
#line 252
            dest --;
#line 252
            if (! ((int )*(dest + -1) != 47)) {
#line 252
              break;
            }
          }
        }
#line 258
        free((void *)buf___0);
      } else
#line 262
      if (! ((st.st_mode & 61440U) == 16384U)) {
#line 262
        if (*end) {
#line 262
          if ((unsigned int )can_mode != 2U) {
#line 264
            saved_errno = 20;
#line 265
            goto error;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 133
    start = end;
  }
#line 270
  if ((unsigned long )dest > (unsigned long )(rname + 1)) {
#line 270
    if ((int )*(dest + -1) == 47) {
#line 271
      dest --;
    }
  }
#line 274
  *dest = (char )'\000';
#line 276
  free((void *)extra_buf);
#line 277
  if (ht___0) {
#line 278
    hash_free(ht___0);
  }
#line 279
  return (rname);
  error: 
#line 282
  free((void *)extra_buf);
#line 283
  free((void *)rname);
#line 284
  if (ht___0) {
#line 285
    hash_free(ht___0);
  }
#line 286
  tmp___17 = __errno_location();
#line 286
  *tmp___17 = saved_errno;
#line 287
  return ((char *)((void *)0));
}
}
#line 1 "cil-oqGcs5rF.o"
#pragma merger("0","../lib/chdir-long.o.i","")
#line 356 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 500
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 504
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchdir)(int __fd ) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/chdir-long.h"
int chdir_long(char *dir ) ;
#line 180 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...) ;
#line 117 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memrchr)(void const   *__s ,
                                                                                                int __c ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 45 "/home/wslee/project/coreutils-8.1/lib/chdir-long.c"
__inline static void cdb_init(struct cd_buf *cdb ) 
{ 


  {
#line 48
  cdb->fd = -100;
#line 49
  return;
}
}
#line 51 "/home/wslee/project/coreutils-8.1/lib/chdir-long.c"
__inline static int cdb_fchdir(struct cd_buf  const  *cdb ) 
{ 
  int tmp ;

  {
#line 54
  tmp = fchdir((int )cdb->fd);
#line 54
  return (tmp);
}
}
#line 57 "/home/wslee/project/coreutils-8.1/lib/chdir-long.c"
__inline static void cdb_free(struct cd_buf  const  *cdb ) 
{ 
  _Bool close_fail ;
  int tmp ;

  {
#line 60
  if (0 <= (int )cdb->fd) {
#line 62
    tmp = close((int )cdb->fd);
#line 62
    close_fail = (_Bool )tmp;
#line 63
    if (! (! close_fail)) {
#line 63
      __assert_fail("! close_fail", "/home/wslee/project/coreutils-8.1/lib/chdir-long.c",
                    63U, "cdb_free");
    }
  }
#line 65
  return;
}
}
#line 71 "/home/wslee/project/coreutils-8.1/lib/chdir-long.c"
static int cdb_advance_fd(struct cd_buf *cdb , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;

  {
#line 74
  tmp = openat(cdb->fd, dir, 67840);
#line 74
  new_fd = tmp;
#line 76
  if (new_fd < 0) {
#line 77
    return (-1);
  }
#line 79
  cdb_free((struct cd_buf  const  *)cdb);
#line 80
  cdb->fd = new_fd;
#line 82
  return (0);
}
}
#line 86 "/home/wslee/project/coreutils-8.1/lib/chdir-long.c"
__inline static char *find_non_slash(char const   *s ) 
{ 
  size_t n_slash ;
  size_t tmp ;

  {
#line 89
  tmp = strspn(s, "/");
#line 89
  n_slash = tmp;
#line 90
  return ((char *)s + n_slash);
}
}
#line 108 "/home/wslee/project/coreutils-8.1/lib/chdir-long.c"
int chdir_long(char *dir ) 
{ 
  int e ;
  int tmp ;
  int *tmp___0 ;
  size_t len ;
  size_t tmp___1 ;
  char *dir_end ;
  struct cd_buf cdb ;
  size_t n_leading_slash ;
  int err ;
  char *slash ;
  void *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int err___0 ;
  char *slash___0 ;
  void *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
#line 111
  tmp = chdir((char const   *)dir);
#line 111
  e = tmp;
#line 112
  if (e == 0) {
#line 113
    return (e);
  } else {
#line 112
    tmp___0 = __errno_location();
#line 112
    if (*tmp___0 != 36) {
#line 113
      return (e);
    }
  }
#line 116
  tmp___1 = strlen((char const   *)dir);
#line 116
  len = tmp___1;
#line 117
  dir_end = dir + len;
#line 121
  cdb_init(& cdb);
#line 125
  if (! (0UL < len)) {
#line 125
    __assert_fail("0 < len", "/home/wslee/project/coreutils-8.1/lib/chdir-long.c",
                  125U, "chdir_long");
  }
#line 126
  if (! (4096UL <= len)) {
#line 126
    __assert_fail("PATH_MAX <= len", "/home/wslee/project/coreutils-8.1/lib/chdir-long.c",
                  126U, "chdir_long");
  }
#line 129
  n_leading_slash = strspn((char const   *)dir, "/");
#line 136
  if (n_leading_slash == 2UL) {
#line 141
    tmp___2 = memchr((void const   *)(dir + 3), '/', (size_t )(dir_end - (dir + 3)));
#line 141
    slash = (char *)tmp___2;
#line 142
    if ((unsigned long )slash == (unsigned long )((void *)0)) {
#line 144
      tmp___3 = __errno_location();
#line 144
      *tmp___3 = 36;
#line 145
      return (-1);
    }
#line 147
    *slash = (char )'\000';
#line 148
    err = cdb_advance_fd(& cdb, (char const   *)dir);
#line 149
    *slash = (char )'/';
#line 150
    if (err != 0) {
#line 151
      goto Fail;
    }
#line 152
    dir = find_non_slash((char const   *)(slash + 1));
  } else
#line 154
  if (n_leading_slash) {
#line 156
    tmp___4 = cdb_advance_fd(& cdb, "/");
#line 156
    if (tmp___4 != 0) {
#line 157
      goto Fail;
    }
#line 158
    dir += n_leading_slash;
  }
#line 161
  if (! ((int )*dir != 47)) {
#line 161
    __assert_fail("*dir != \'/\'", "/home/wslee/project/coreutils-8.1/lib/chdir-long.c",
                  161U, "chdir_long");
  }
#line 162
  if (! ((unsigned long )dir <= (unsigned long )dir_end)) {
#line 162
    __assert_fail("dir <= dir_end", "/home/wslee/project/coreutils-8.1/lib/chdir-long.c",
                  162U, "chdir_long");
  }
#line 164
  while (4096L <= dir_end - dir) {
#line 170
    tmp___5 = memrchr((void const   *)dir, '/', (size_t )4096);
#line 170
    slash___0 = (char *)tmp___5;
#line 171
    if ((unsigned long )slash___0 == (unsigned long )((void *)0)) {
#line 173
      tmp___6 = __errno_location();
#line 173
      *tmp___6 = 36;
#line 174
      return (-1);
    }
#line 177
    *slash___0 = (char )'\000';
#line 178
    if (! (slash___0 - dir < 4096L)) {
#line 178
      __assert_fail("slash - dir < PATH_MAX", "/home/wslee/project/coreutils-8.1/lib/chdir-long.c",
                    178U, "chdir_long");
    }
#line 179
    err___0 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 180
    *slash___0 = (char )'/';
#line 181
    if (err___0 != 0) {
#line 182
      goto Fail;
    }
#line 184
    dir = find_non_slash((char const   *)(slash___0 + 1));
  }
#line 187
  if ((unsigned long )dir < (unsigned long )dir_end) {
#line 189
    tmp___7 = cdb_advance_fd(& cdb, (char const   *)dir);
#line 189
    if (tmp___7 != 0) {
#line 190
      goto Fail;
    }
  }
#line 193
  tmp___8 = cdb_fchdir((struct cd_buf  const  *)(& cdb));
#line 193
  if (tmp___8 != 0) {
#line 194
    goto Fail;
  }
#line 196
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 197
  return (0);
  Fail: 
#line 201
  tmp___9 = __errno_location();
#line 201
  saved_errno = *tmp___9;
#line 202
  cdb_free((struct cd_buf  const  *)(& cdb));
#line 203
  tmp___10 = __errno_location();
#line 203
  *tmp___10 = saved_errno;
#line 204
  return (-1);
}
}
#line 1 "cil-6IjMVUgY.o"
#pragma merger("0","../lib/cloexec.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/cloexec.h"
int set_cloexec_flag(int desc , _Bool value ) ;
#line 146 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/cloexec.c"
int set_cloexec_flag(int desc , _Bool value ) 
{ 
  int flags ;
  int tmp ;
  int newflags ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 36
  tmp = fcntl(desc, 1, 0);
#line 36
  flags = tmp;
#line 38
  if (0 <= flags) {
#line 40
    if (value) {
#line 40
      tmp___0 = flags | 1;
    } else {
#line 40
      tmp___0 = flags & -2;
    }
#line 40
    newflags = tmp___0;
#line 42
    if (flags == newflags) {
#line 44
      return (0);
    } else {
#line 42
      tmp___1 = fcntl(desc, 2, newflags);
#line 42
      if (tmp___1 != -1) {
#line 44
        return (0);
      }
    }
  }
#line 47
  return (-1);
}
}
#line 1 "cil-rhoDSd5i.o"
#pragma merger("0","../lib/close-hook.o.i","")
#line 1 "cil-Px3ShBIp.o"
#pragma merger("0","../lib/close-stream.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/close-stream.h"
int close_stream(FILE *stream ) ;
#line 75 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __fpending)(FILE *__fp ) ;
#line 56 "/home/wslee/project/coreutils-8.1/lib/close-stream.c"
int close_stream(FILE *stream ) 
{ 
  _Bool some_pending ;
  size_t tmp ;
  _Bool prev_fail ;
  int tmp___0 ;
  _Bool fclose_fail ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 59
  tmp = __fpending(stream);
#line 59
  some_pending = (_Bool )(tmp != 0UL);
#line 60
  tmp___0 = ferror_unlocked(stream);
#line 60
  prev_fail = (_Bool )(tmp___0 != 0);
#line 61
  tmp___1 = fclose(stream);
#line 61
  fclose_fail = (_Bool )(tmp___1 != 0);
#line 71
  if (prev_fail) {
#line 71
    goto _L___0;
  } else
#line 71
  if (fclose_fail) {
#line 71
    if (some_pending) {
#line 71
      goto _L___0;
    } else {
#line 71
      tmp___3 = __errno_location();
#line 71
      if (*tmp___3 != 9) {
        _L___0: /* CIL Label */ 
#line 73
        if (! fclose_fail) {
#line 74
          tmp___2 = __errno_location();
#line 74
          *tmp___2 = 0;
        }
#line 75
        return (-1);
      }
    }
  }
#line 78
  return (0);
}
}
#line 1 "cil-rgmPP2mc.o"
#pragma merger("0","../lib/closein.o.i","")
#line 25 "/home/wslee/project/coreutils-8.1/lib/closein.h"
void close_stdin_set_file_name(char const   *file ) ;
#line 26
void close_stdin(void) ;
#line 139 "./stdio.h"
int rpl_fflush(FILE *stream ) ;
#line 257
int rpl_fseeko(FILE *fp , off_t offset , int whence ) ;
#line 606 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 18 "/home/wslee/project/coreutils-8.1/lib/exitfail.h"
int volatile   exit_failure ;
#line 34 "/home/wslee/project/coreutils-8.1/lib/freadahead.h"
size_t freadahead(FILE *fp ) ;
#line 37 "/home/wslee/project/coreutils-8.1/lib/closein.c"
static char const   *file_name  ;
#line 42 "/home/wslee/project/coreutils-8.1/lib/closein.c"
void close_stdin_set_file_name(char const   *file ) 
{ 


  {
#line 45
  file_name = file;
#line 46
  return;
}
}
#line 78 "/home/wslee/project/coreutils-8.1/lib/closein.c"
void close_stdin(void) 
{ 
  _Bool fail ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *close_error ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 81
  fail = (_Bool)0;
#line 86
  tmp___1 = freadahead(stdin);
#line 86
  if (tmp___1 > 0UL) {
#line 90
    tmp = rpl_fseeko(stdin, (off_t )0, 1);
#line 90
    if (tmp == 0) {
#line 90
      tmp___0 = rpl_fflush(stdin);
#line 90
      if (tmp___0 != 0) {
#line 91
        fail = (_Bool)1;
      }
    }
  }
#line 93
  tmp___2 = close_stream(stdin);
#line 93
  if (tmp___2 != 0) {
#line 94
    fail = (_Bool)1;
  }
#line 95
  if (fail) {
#line 99
    tmp___3 = gettext("error closing file");
#line 99
    close_error = (char const   *)tmp___3;
#line 100
    if (file_name) {
#line 101
      tmp___4 = quotearg_colon(file_name);
#line 101
      tmp___5 = __errno_location();
#line 101
      error(0, *tmp___5, "%s: %s", tmp___4, close_error);
    } else {
#line 104
      tmp___6 = __errno_location();
#line 104
      error(0, *tmp___6, "%s", close_error);
    }
  }
#line 107
  close_stdout();
#line 109
  if (fail) {
#line 110
    _exit((int )exit_failure);
  }
#line 111
  return;
}
}
#line 1 "cil-LWXGvCEy.o"
#pragma merger("0","../lib/closeout.o.i","")
#line 28 "/home/wslee/project/coreutils-8.1/lib/closeout.h"
void close_stdout_set_file_name(char const   *file ) ;
#line 29
void close_stdout_set_ignore_EPIPE(_Bool ignore ) ;
#line 36 "/home/wslee/project/coreutils-8.1/lib/closeout.c"
static char const   *file_name___0  ;
#line 40 "/home/wslee/project/coreutils-8.1/lib/closeout.c"
void close_stdout_set_file_name(char const   *file ) 
{ 


  {
#line 43
  file_name___0 = file;
#line 44
  return;
}
}
#line 46 "/home/wslee/project/coreutils-8.1/lib/closeout.c"
static _Bool ignore_EPIPE  ;
#line 77 "/home/wslee/project/coreutils-8.1/lib/closeout.c"
void close_stdout_set_ignore_EPIPE(_Bool ignore ) 
{ 


  {
#line 80
  ignore_EPIPE = ignore;
#line 81
  return;
}
}
#line 106 "/home/wslee/project/coreutils-8.1/lib/closeout.c"
void close_stdout(void) 
{ 
  char const   *write_error ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 109
  tmp___3 = close_stream(stdout);
#line 109
  if (tmp___3 != 0) {
#line 109
    if (ignore_EPIPE) {
#line 109
      tmp___4 = __errno_location();
#line 109
      if (! (*tmp___4 == 32)) {
#line 109
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 112
      tmp = gettext("write error");
#line 112
      write_error = (char const   *)tmp;
#line 113
      if (file_name___0) {
#line 114
        tmp___0 = quotearg_colon(file_name___0);
#line 114
        tmp___1 = __errno_location();
#line 114
        error(0, *tmp___1, "%s: %s", tmp___0, write_error);
      } else {
#line 117
        tmp___2 = __errno_location();
#line 117
        error(0, *tmp___2, "%s", write_error);
      }
#line 119
      _exit((int )exit_failure);
    }
  }
#line 122
  tmp___5 = close_stream(stderr);
#line 122
  if (tmp___5 != 0) {
#line 123
    _exit((int )exit_failure);
  }
#line 124
  return;
}
}
#line 1 "cil-xaZ_wFiz.o"
#pragma merger("0","../lib/copy-acl.o.i","")
#line 24 "/home/wslee/project/coreutils-8.1/lib/acl.h"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) ;
#line 26
int qset_acl(char const   *name , int desc , mode_t mode ) ;
#line 41 "/home/wslee/project/coreutils-8.1/lib/copy-acl.c"
static int qcopy_acl(char const   *src_name , int source_desc , char const   *dst_name ,
                     int dest_desc , mode_t mode ) 
{ 
  int tmp ;

  {
#line 520
  tmp = qset_acl(dst_name, dest_desc, mode);
#line 520
  return (tmp);
}
}
#line 535 "/home/wslee/project/coreutils-8.1/lib/copy-acl.c"
int copy_acl(char const   *src_name , int source_desc , char const   *dst_name , int dest_desc ,
             mode_t mode ) 
{ 
  int ret ;
  int tmp ;
  char const   *tmp___0 ;
  int *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 539
  tmp = qcopy_acl(src_name, source_desc, dst_name, dest_desc, mode);
#line 539
  ret = tmp;
#line 540
  switch (ret) {
  case -2: 
#line 543
  tmp___0 = quote(src_name);
#line 543
  tmp___1 = __errno_location();
#line 543
  error(0, *tmp___1, "%s", tmp___0);
#line 544
  return (-1);
  case -1: 
#line 547
  tmp___2 = quote(dst_name);
#line 547
  tmp___3 = gettext("preserving permissions for %s");
#line 547
  tmp___4 = __errno_location();
#line 547
  error(0, *tmp___4, (char const   *)tmp___3, tmp___2);
#line 548
  return (-1);
  default: 
#line 551
  return (0);
  }
}
}
#line 1 "cil-JSlzC4L9.o"
#pragma merger("0","../lib/creat-safer.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/fcntl-safer.h"
int creat_safer(char const   *file , mode_t mode ) ;
#line 202 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) creat)(char const   *__file , mode_t __mode ) ;
#line 21 "/home/wslee/project/coreutils-8.1/lib/unistd-safer.h"
int fd_safer(int fd ) ;
#line 27 "/home/wslee/project/coreutils-8.1/lib/creat-safer.c"
int creat_safer(char const   *file , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 30
  tmp = creat(file, mode);
#line 30
  tmp___0 = fd_safer(tmp);
#line 30
  return (tmp___0);
}
}
#line 1 "cil-HvbCSLUZ.o"
#pragma merger("0","../lib/cycle-check.o.i","")
#line 35 "/home/wslee/project/coreutils-8.1/lib/cycle-check.h"
void cycle_check_init(struct cycle_check_state *state ) ;
#line 36
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) ;
#line 36 "/home/wslee/project/coreutils-8.1/lib/cycle-check.c"
__inline static _Bool is_zero_or_power_of_two(uintmax_t i ) 
{ 


  {
#line 39
  return ((_Bool )((i & (i - 1UL)) == 0UL));
}
}
#line 42 "/home/wslee/project/coreutils-8.1/lib/cycle-check.c"
void cycle_check_init(struct cycle_check_state *state ) 
{ 


  {
#line 45
  state->chdir_counter = (uintmax_t )0;
#line 46
  state->magic = 9827862;
#line 47
  return;
}
}
#line 57 "/home/wslee/project/coreutils-8.1/lib/cycle-check.c"
_Bool cycle_check(struct cycle_check_state *state , struct stat  const  *sb ) 
{ 
  _Bool tmp ;

  {
#line 60
  if (! (state->magic == 9827862)) {
#line 60
    __assert_fail("state->magic == CC_MAGIC", "/home/wslee/project/coreutils-8.1/lib/cycle-check.c",
                  60U, "cycle_check");
  }
#line 65
  if (state->chdir_counter) {
#line 65
    if (sb->st_ino == (__ino_t const   )state->dev_ino.st_ino) {
#line 65
      if (sb->st_dev == (__dev_t const   )state->dev_ino.st_dev) {
#line 66
        return ((_Bool)1);
      }
    }
  }
#line 70
  (state->chdir_counter) ++;
#line 70
  tmp = is_zero_or_power_of_two(state->chdir_counter);
#line 70
  if (tmp) {
#line 77
    if (state->chdir_counter == 0UL) {
#line 78
      return ((_Bool)1);
    }
#line 80
    state->dev_ino.st_dev = (dev_t )sb->st_dev;
#line 81
    state->dev_ino.st_ino = (ino_t )sb->st_ino;
  }
#line 84
  return ((_Bool)0);
}
}
#line 1 "cil-glmqHMYh.o"
#pragma merger("0","../lib/diacrit.o.i","")
#line 20 "/home/wslee/project/coreutils-8.1/lib/diacrit.h"
char const   diacrit_base[256] ;
#line 21
char const   diacrit_diac[256] ;
#line 35 "/home/wslee/project/coreutils-8.1/lib/diacrit.c"
char const   diacrit_base[256]  = 
#line 35 "/home/wslee/project/coreutils-8.1/lib/diacrit.c"
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'A',      (char const   )'B',      (char const   )'C', 
        (char const   )'D',      (char const   )'E',      (char const   )'F',      (char const   )'G', 
        (char const   )'H',      (char const   )'I',      (char const   )'J',      (char const   )'K', 
        (char const   )'L',      (char const   )'M',      (char const   )'N',      (char const   )'O', 
        (char const   )'P',      (char const   )'Q',      (char const   )'R',      (char const   )'S', 
        (char const   )'T',      (char const   )'U',      (char const   )'V',      (char const   )'W', 
        (char const   )'X',      (char const   )'Y',      (char const   )'Z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )'a',      (char const   )'b',      (char const   )'c', 
        (char const   )'d',      (char const   )'e',      (char const   )'f',      (char const   )'g', 
        (char const   )'h',      (char const   )'i',      (char const   )'j',      (char const   )'k', 
        (char const   )'l',      (char const   )'m',      (char const   )'n',      (char const   )'o', 
        (char const   )'p',      (char const   )'q',      (char const   )'r',      (char const   )'s', 
        (char const   )'t',      (char const   )'u',      (char const   )'v',      (char const   )'w', 
        (char const   )'x',      (char const   )'y',      (char const   )'z',      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'A', 
        (char const   )'A',      (char const   )'A',      (char const   )'A',      (char const   )'C', 
        (char const   )'E',      (char const   )'E',      (char const   )'E',      (char const   )'E', 
        (char const   )'I',      (char const   )'I',      (char const   )'I',      (char const   )'I', 
        (char const   )0,      (char const   )'N',      (char const   )'O',      (char const   )'O', 
        (char const   )'O',      (char const   )'O',      (char const   )'O',      (char const   )0, 
        (char const   )'O',      (char const   )'U',      (char const   )'U',      (char const   )'U', 
        (char const   )'U',      (char const   )'Y',      (char const   )0,      (char const   )0, 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'a', 
        (char const   )'a',      (char const   )'a',      (char const   )'a',      (char const   )'c', 
        (char const   )'e',      (char const   )'e',      (char const   )'e',      (char const   )'e', 
        (char const   )'i',      (char const   )'i',      (char const   )'i',      (char const   )'i', 
        (char const   )0,      (char const   )'n',      (char const   )'o',      (char const   )'o', 
        (char const   )'o',      (char const   )'o',      (char const   )'o',      (char const   )0, 
        (char const   )'o',      (char const   )'u',      (char const   )'u',      (char const   )'u', 
        (char const   )'u',      (char const   )'y',      (char const   )0,      (char const   )'y'};
#line 103 "/home/wslee/project/coreutils-8.1/lib/diacrit.c"
char const   diacrit_diac[256]  = 
#line 103
  {      (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )4,      (char const   )0, 
        (char const   )3,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )6,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )0,      (char const   )0,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )6, 
        (char const   )5,      (char const   )8,      (char const   )1,      (char const   )7, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )3,      (char const   )2,      (char const   )4,      (char const   )5, 
        (char const   )0,      (char const   )6,      (char const   )3,      (char const   )2, 
        (char const   )4,      (char const   )6,      (char const   )5,      (char const   )0, 
        (char const   )9,      (char const   )3,      (char const   )2,      (char const   )4, 
        (char const   )5,      (char const   )2,      (char const   )0,      (char const   )0};
#line 1 "cil-maAoj_ws.o"
#pragma merger("0","../lib/dirchownmod.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/dirchownmod.h"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) ;
#line 208 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 213
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 283
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 296
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 476 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 481
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 486
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lchown)(char const   *__file ,
                                                                                             __uid_t __owner ,
                                                                                             __gid_t __group ) ;
#line 60 "/home/wslee/project/coreutils-8.1/lib/dirchownmod.c"
int dirchownmod(int fd , char const   *dir , mode_t mkdir_mode , uid_t owner , gid_t group ,
                mode_t mode , mode_t mode_bits ) 
{ 
  struct stat st ;
  int result ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  mode_t dir_mode ;
  int *tmp___2 ;
  mode_t indeterminate ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  mode_t chmod_mode ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int e ;
  int *tmp___11 ;
  int *tmp___12 ;

  {
#line 66
  if (fd < 0) {
#line 66
    tmp = stat((char const   * __restrict  )dir, (struct stat * __restrict  )(& st));
#line 66
    tmp___1 = tmp;
  } else {
#line 66
    tmp___0 = fstat(fd, & st);
#line 66
    tmp___1 = tmp___0;
  }
#line 66
  result = tmp___1;
#line 68
  if (result == 0) {
#line 70
    dir_mode = st.st_mode;
#line 76
    if (! ((dir_mode & 61440U) == 16384U)) {
#line 78
      tmp___2 = __errno_location();
#line 78
      *tmp___2 = 20;
#line 79
      result = -1;
    } else {
#line 87
      indeterminate = (mode_t )0;
#line 94
      if (owner != 4294967295U) {
#line 94
        if (owner != st.st_uid) {
#line 94
          goto _L;
        } else {
#line 94
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 94
      if (group != 4294967295U) {
#line 94
        if (group != st.st_gid) {
          _L: /* CIL Label */ 
#line 97
          if (0 <= fd) {
#line 97
            tmp___3 = fchown(fd, owner, group);
#line 97
            result = tmp___3;
          } else {
#line 97
            if (mkdir_mode != 4294967295U) {
#line 97
              tmp___4 = lchown(dir, owner, group);
#line 97
              tmp___6 = tmp___4;
            } else {
#line 97
              tmp___5 = chown(dir, owner, group);
#line 97
              tmp___6 = tmp___5;
            }
#line 97
            result = tmp___6;
          }
#line 108
          if (result == 0) {
#line 108
            if (dir_mode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 109
              indeterminate = dir_mode & 3072U;
            }
          }
        }
      }
#line 115
      if (result == 0) {
#line 115
        if (((dir_mode ^ mode) | indeterminate) & mode_bits) {
#line 117
          chmod_mode = mode | ((dir_mode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3))) & ~ mode_bits);
#line 119
          if (0 <= fd) {
#line 119
            tmp___7 = fchmod(fd, chmod_mode);
#line 119
            result = tmp___7;
          } else {
#line 119
            if (mkdir_mode != 4294967295U) {
#line 119
              tmp___8 = chmod(dir, chmod_mode);
#line 119
              tmp___10 = tmp___8;
            } else {
#line 119
              tmp___9 = chmod(dir, chmod_mode);
#line 119
              tmp___10 = tmp___9;
            }
#line 119
            result = tmp___10;
          }
        }
      }
    }
  }
#line 128
  if (0 <= fd) {
#line 130
    if (result == 0) {
#line 131
      result = close(fd);
    } else {
#line 134
      tmp___11 = __errno_location();
#line 134
      e = *tmp___11;
#line 135
      close(fd);
#line 136
      tmp___12 = __errno_location();
#line 136
      *tmp___12 = e;
    }
  }
#line 140
  return (result);
}
}
#line 1 "cil-zk3hFkdu.o"
#pragma merger("0","../lib/dirname-lgpl.o.i","")
#line 66 "/home/wslee/project/coreutils-8.1/lib/dirname.h"
char *mdir_name(char const   *file ) ;
#line 68
size_t dir_len(char const   *file ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/dirname-lgpl.c"
size_t dir_len(char const   *file ) 
{ 
  size_t prefix_length ;
  size_t length ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 34
  prefix_length = (size_t )0;
#line 38
  if (prefix_length != 0UL) {
#line 38
    tmp___0 = 0;
  } else {
#line 38
    if ((int const   )*(file + 0) == 47) {
#line 38
      tmp = 1;
    } else {
#line 38
      tmp = 0;
    }
#line 38
    tmp___0 = tmp;
  }
#line 38
  prefix_length += (size_t )tmp___0;
#line 48
  tmp___1 = last_component(file);
#line 48
  length = (size_t )(tmp___1 - (char *)file);
#line 48
  while (prefix_length < length) {
#line 50
    if (! ((int const   )*(file + (length - 1UL)) == 47)) {
#line 51
      break;
    }
#line 48
    length --;
  }
#line 52
  return (length);
}
}
#line 70 "/home/wslee/project/coreutils-8.1/lib/dirname-lgpl.c"
char *mdir_name(char const   *file ) 
{ 
  size_t length ;
  size_t tmp ;
  _Bool append_dot ;
  int tmp___0 ;
  char *dir ;
  void *tmp___1 ;
  size_t tmp___2 ;

  {
#line 73
  tmp = dir_len(file);
#line 73
  length = tmp;
#line 74
  if (length == 0UL) {
#line 74
    tmp___0 = 1;
  } else {
#line 74
    tmp___0 = 0;
  }
#line 74
  append_dot = (_Bool )tmp___0;
#line 78
  tmp___1 = malloc((length + (size_t )append_dot) + 1UL);
#line 78
  dir = (char *)tmp___1;
#line 79
  if (! dir) {
#line 80
    return ((char *)((void *)0));
  }
#line 81
  memcpy((void * __restrict  )dir, (void const   * __restrict  )file, length);
#line 82
  if (append_dot) {
#line 83
    tmp___2 = length;
#line 83
    length ++;
#line 83
    *(dir + tmp___2) = (char )'.';
  }
#line 84
  *(dir + length) = (char )'\000';
#line 85
  return (dir);
}
}
#line 1 "cil-_PAcsSxQ.o"
#pragma merger("0","../lib/dirname.o.i","")
#line 63 "/home/wslee/project/coreutils-8.1/lib/dirname.h"
char *dir_name(char const   *file ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/dirname.c"
char *dir_name(char const   *file ) 
{ 
  char *result ;
  char *tmp ;

  {
#line 34
  tmp = mdir_name(file);
#line 34
  result = tmp;
#line 35
  if (! result) {
#line 36
    xalloc_die();
  }
#line 37
  return (result);
}
}
#line 1 "cil-Z57rSiyQ.o"
#pragma merger("0","../lib/dup-safer.o.i","")
#line 20 "/home/wslee/project/coreutils-8.1/lib/unistd-safer.h"
int dup_safer(int fd ) ;
#line 32 "/home/wslee/project/coreutils-8.1/lib/dup-safer.c"
int dup_safer(int fd ) 
{ 
  int tmp ;

  {
#line 36
  tmp = fcntl(fd, 0, 3);
#line 36
  return (tmp);
}
}
#line 1 "cil-HyNCY55q.o"
#pragma merger("0","../lib/euidaccess-stat.o.i","")
#line 5 "/home/wslee/project/coreutils-8.1/lib/euidaccess-stat.h"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) ;
#line 681 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 687
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getegid)(void) ;
#line 696
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) group_member)(__gid_t __gid ) ;
#line 42 "/home/wslee/project/coreutils-8.1/lib/euidaccess-stat.c"
_Bool euidaccess_stat(struct stat  const  *st , int mode ) 
{ 
  uid_t euid ;
  unsigned int granted ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  gid_t egid ;
  __gid_t tmp___11 ;
  int tmp___12 ;

  {
#line 50
  mode &= 7;
#line 56
  if (mode == 0) {
#line 57
    return ((_Bool)1);
  }
#line 59
  euid = geteuid();
#line 63
  if (euid == 0U) {
#line 63
    if ((mode & 1) == 0) {
#line 65
      return ((_Bool)1);
    } else
#line 63
    if (st->st_mode & (unsigned int const   )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 65
      return ((_Bool)1);
    }
  }
#line 68
  if (256 == 4 << 6) {
#line 68
    if (128 == 2 << 6) {
#line 68
      if (64 == 1 << 6) {
#line 68
        if (256 >> 3 == 4 << 3) {
#line 68
          if (128 >> 3 == 2 << 3) {
#line 68
            if (64 >> 3 == 1 << 3) {
#line 68
              if ((256 >> 3) >> 3 == 4) {
#line 68
                if ((128 >> 3) >> 3 == 2) {
#line 68
                  if ((64 >> 3) >> 3 == 1) {
#line 77
                    granted = (unsigned int )st->st_mode;
                  } else {
#line 68
                    goto _L___6;
                  }
                } else {
#line 68
                  goto _L___6;
                }
              } else {
#line 68
                goto _L___6;
              }
            } else {
#line 68
              goto _L___6;
            }
          } else {
#line 68
            goto _L___6;
          }
        } else {
#line 68
          goto _L___6;
        }
      } else {
#line 68
        goto _L___6;
      }
    } else {
#line 68
      goto _L___6;
    }
  } else {
    _L___6: /* CIL Label */ 
#line 79
    if (st->st_mode & 256U) {
#line 79
      tmp___2 = 4 << 6;
    } else {
#line 79
      tmp___2 = 0;
    }
#line 79
    if (st->st_mode & 128U) {
#line 79
      tmp___3 = 2 << 6;
    } else {
#line 79
      tmp___3 = 0;
    }
#line 79
    if (st->st_mode & 64U) {
#line 79
      tmp___4 = 1 << 6;
    } else {
#line 79
      tmp___4 = 0;
    }
#line 79
    if (st->st_mode & (unsigned int const   )(256 >> 3)) {
#line 79
      tmp___5 = 4 << 3;
    } else {
#line 79
      tmp___5 = 0;
    }
#line 79
    if (st->st_mode & (unsigned int const   )(128 >> 3)) {
#line 79
      tmp___6 = 2 << 3;
    } else {
#line 79
      tmp___6 = 0;
    }
#line 79
    if (st->st_mode & (unsigned int const   )(64 >> 3)) {
#line 79
      tmp___7 = 1 << 3;
    } else {
#line 79
      tmp___7 = 0;
    }
#line 79
    if (st->st_mode & (unsigned int const   )((256 >> 3) >> 3)) {
#line 79
      tmp___8 = 4;
    } else {
#line 79
      tmp___8 = 0;
    }
#line 79
    if (st->st_mode & (unsigned int const   )((128 >> 3) >> 3)) {
#line 79
      tmp___9 = 2;
    } else {
#line 79
      tmp___9 = 0;
    }
#line 79
    if (st->st_mode & (unsigned int const   )((64 >> 3) >> 3)) {
#line 79
      tmp___10 = 1;
    } else {
#line 79
      tmp___10 = 0;
    }
#line 79
    granted = (unsigned int )((((((((tmp___2 + tmp___3) + tmp___4) + tmp___5) + tmp___6) + tmp___7) + tmp___8) + tmp___9) + tmp___10);
  }
#line 89
  if (euid == (uid_t )st->st_uid) {
#line 90
    granted >>= 6;
  } else {
#line 93
    tmp___11 = getegid();
#line 93
    egid = tmp___11;
#line 94
    if (egid == (gid_t )st->st_gid) {
#line 95
      granted >>= 3;
    } else {
#line 94
      tmp___12 = group_member((__gid_t )st->st_gid);
#line 94
      if (tmp___12) {
#line 95
        granted >>= 3;
      }
    }
  }
#line 98
  if (((unsigned int )mode & ~ granted) == 0U) {
#line 99
    return ((_Bool)1);
  }
#line 101
  return ((_Bool)0);
}
}
#line 1 "cil-VSZVxNMB.o"
#pragma merger("0","../lib/exclude.o.i","")
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 550
extern int getc_unlocked(FILE *__stream ) ;
#line 139 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) __ctype_get_mb_cur_max)(void) ;
#line 515
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 62 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 258
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 280
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 505 "./string.h"
int mbscasecmp(char const   *s1 , char const   *s2 ) ;
#line 194 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towlower)(wint_t __wc ) ;
#line 37 "/home/wslee/project/coreutils-8.1/lib/exclude.h"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) ;
#line 40
void free_exclude(struct exclude *ex ) ;
#line 45
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) ;
#line 70 "/home/wslee/project/coreutils-8.1/lib/hash.h"
void *hash_lookup(Hash_table const   *table , void const   *entry ) ;
#line 79
size_t hash_string(char const   *string , size_t n_buckets ) ;
#line 364 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) mbsinit)(mbstate_t const   *__ps )  __attribute__((__pure__)) ;
#line 368
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbrtowc)(wchar_t * __restrict  __pwc ,
                                                                                 char const   * __restrict  __s ,
                                                                                 size_t __n ,
                                                                                 mbstate_t * __restrict  __p ) ;
#line 305 "/home/wslee/project/coreutils-8.1/lib/mbchar.h"
unsigned int const   is_basic_table[8] ;
#line 307 "/home/wslee/project/coreutils-8.1/lib/mbchar.h"
__inline static _Bool is_basic(char c ) 
{ 


  {
#line 310
  return ((_Bool )((is_basic_table[(int )((unsigned char )c) >> 5] >> ((int )((unsigned char )c) & 31)) & 1U));
}
}
#line 31 "/home/wslee/project/coreutils-8.1/lib/strnlen1.h"
size_t strnlen1(char const   *string , size_t maxlen ) ;
#line 123 "/home/wslee/project/coreutils-8.1/lib/mbuiter.h"
__inline static void mbuiter_multi_next(struct mbuiter_multi *iter ) 
{ 
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;

  {
#line 126
  if (iter->next_done) {
#line 127
    return;
  }
#line 128
  if (iter->in_shift) {
#line 129
    goto with_shift;
  }
#line 131
  tmp___3 = is_basic((char )*(iter->cur.ptr));
#line 131
  if (tmp___3) {
#line 136
    iter->cur.bytes = (size_t )1;
#line 137
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 138
    iter->cur.wc_valid = (_Bool)1;
  } else {
#line 142
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
#line 142
    if (! tmp) {
#line 142
      __assert_fail("mbsinit (&iter->state)", "/home/wslee/project/coreutils-8.1/lib/mbuiter.h",
                    142U, "mbuiter_multi_next");
    }
#line 143
    iter->in_shift = (_Bool)1;
    with_shift: 
#line 145
    tmp___0 = __ctype_get_mb_cur_max();
#line 145
    tmp___1 = strnlen1(iter->cur.ptr, tmp___0);
#line 145
    iter->cur.bytes = mbrtowc((wchar_t * __restrict  )(& iter->cur.wc), (char const   * __restrict  )iter->cur.ptr,
                              tmp___1, (mbstate_t * __restrict  )(& iter->state));
#line 148
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 151
      iter->cur.bytes = (size_t )1;
#line 152
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 156
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 159
      iter->cur.bytes = strlen(iter->cur.ptr);
#line 160
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 166
      if (iter->cur.bytes == 0UL) {
#line 169
        iter->cur.bytes = (size_t )1;
#line 170
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
#line 170
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/wslee/project/coreutils-8.1/lib/mbuiter.h",
                        170U, "mbuiter_multi_next");
        }
#line 171
        if (! (iter->cur.wc == 0)) {
#line 171
          __assert_fail("iter->cur.wc == 0", "/home/wslee/project/coreutils-8.1/lib/mbuiter.h",
                        171U, "mbuiter_multi_next");
        }
      }
#line 173
      iter->cur.wc_valid = (_Bool)1;
#line 177
      tmp___2 = mbsinit((mbstate_t const   *)(& iter->state));
#line 177
      if (tmp___2) {
#line 178
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 181
  iter->next_done = (_Bool)1;
#line 182
  return;
}
}
#line 56 "/usr/include/fnmatch.h"
extern int fnmatch(char const   *__pattern , char const   *__name , int __flags ) ;
#line 56 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 59
void *x2realloc(void *p , size_t *pn ) ;
#line 61
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 194 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *x2nrealloc(void *p , size_t *pn , size_t s ) 
{ 
  size_t n ;
  void *tmp ;

  {
#line 197
  n = *pn;
#line 199
  if (! p) {
#line 201
    if (! n) {
#line 209
      n = 64UL / s;
#line 210
      n += (size_t )(! n);
    }
  } else {
#line 219
    if (0xaaaaaaaaaaaaaaaaUL / s <= n) {
#line 220
      xalloc_die();
    }
#line 221
    n += (n + 1UL) / 2UL;
  }
#line 224
  *pn = n;
#line 225
  tmp = xrealloc(p, n * s);
#line 225
  return (tmp);
}
}
#line 114 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
_Bool fnmatch_pattern_has_wildcards(char const   *str , int options ) 
{ 
  char const   *cset ;
  size_t n ;
  size_t tmp ;

  {
#line 117
  cset = "\\?*[]";
#line 118
  if (options & (1 << 1)) {
#line 119
    cset ++;
  }
#line 120
  while (*str) {
#line 122
    tmp = strcspn(str, cset);
#line 122
    n = tmp;
#line 123
    if ((int const   )*(str + n) == 0) {
#line 124
      break;
    } else
#line 125
    if ((int const   )*(str + n) == 92) {
#line 127
      str += n + 1UL;
#line 128
      if (*str) {
#line 129
        str ++;
      }
    } else {
#line 132
      return ((_Bool)1);
    }
  }
#line 134
  return ((_Bool)0);
}
}
#line 139 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
struct exclude *new_exclude(void) 
{ 
  struct exclude *tmp ;
  void *tmp___0 ;

  {
#line 142
  tmp___0 = xzalloc(sizeof(*tmp));
#line 142
  return ((struct exclude *)tmp___0);
}
}
#line 146 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static size_t string_hasher(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  size_t tmp ;

  {
#line 149
  p = (char const   *)data;
#line 150
  tmp = hash_string(p, n_buckets);
#line 150
  return (tmp);
}
}
#line 154 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static size_t string_hasher_ci(void const   *data , size_t n_buckets ) 
{ 
  char const   *p ;
  mbui_iterator_t iter ;
  size_t value ;
  mbchar_t m ;
  wchar_t wc ;
  wint_t tmp ;
  int tmp___0 ;

  {
#line 157
  p = (char const   *)data;
#line 159
  value = (size_t )0;
#line 161
  iter.cur.ptr = p;
#line 161
  iter.in_shift = (_Bool)0;
#line 161
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 161
  iter.next_done = (_Bool)0;
#line 161
  while (1) {
#line 161
    mbuiter_multi_next(& iter);
#line 161
    if (iter.cur.wc_valid) {
#line 161
      if (iter.cur.wc == 0) {
#line 161
        tmp___0 = 0;
      } else {
#line 161
        tmp___0 = 1;
      }
    } else {
#line 161
      tmp___0 = 1;
    }
#line 161
    if (! tmp___0) {
#line 161
      break;
    }
#line 163
    m = iter.cur;
#line 166
    if (m.wc_valid) {
#line 167
      tmp = towlower((wint_t )m.wc);
#line 167
      wc = (wchar_t )tmp;
    } else {
#line 169
      wc = (wchar_t )*(m.ptr);
    }
#line 171
    value = (value * 31UL + (size_t )wc) % n_buckets;
#line 161
    iter.cur.ptr += iter.cur.bytes;
#line 161
    iter.next_done = (_Bool)0;
  }
#line 174
  return (value);
}
}
#line 178 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static _Bool string_compare(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
#line 181
  p1 = (char const   *)data1;
#line 182
  p2 = (char const   *)data2;
#line 183
  tmp = strcmp(p1, p2);
#line 183
  return ((_Bool )(tmp == 0));
}
}
#line 187 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static _Bool string_compare_ci(void const   *data1 , void const   *data2 ) 
{ 
  char const   *p1 ;
  char const   *p2 ;
  int tmp ;

  {
#line 190
  p1 = (char const   *)data1;
#line 191
  p2 = (char const   *)data2;
#line 192
  tmp = mbscasecmp(p1, p2);
#line 192
  return ((_Bool )(tmp == 0));
}
}
#line 195 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static void string_free(void *data ) 
{ 


  {
#line 198
  free(data);
#line 199
  return;
}
}
#line 203 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static struct exclude_segment *new_exclude_segment(struct exclude *ex , enum exclude_type type ,
                                                   int options ) 
{ 
  struct exclude_segment *sp ;
  void *tmp ;
  _Bool (*tmp___0)(void const   *data1 , void const   *data2 ) ;
  size_t (*tmp___1)(void const   *data , size_t n_buckets ) ;

  {
#line 206
  tmp = xzalloc(sizeof(struct exclude_segment ));
#line 206
  sp = (struct exclude_segment *)tmp;
#line 207
  sp->type = type;
#line 208
  sp->options = options;
#line 209
  switch ((unsigned int )type) {
  case 1U: 
#line 212
  break;
  case 0U: 
#line 215
  if (options & (1 << 4)) {
#line 215
    tmp___0 = & string_compare_ci;
  } else {
#line 215
    tmp___0 = & string_compare;
  }
#line 215
  if (options & (1 << 4)) {
#line 215
    tmp___1 = & string_hasher_ci;
  } else {
#line 215
    tmp___1 = & string_hasher;
  }
#line 215
  sp->v.table = hash_initialize((size_t )0, (Hash_tuning const   *)((void *)0), tmp___1,
                                tmp___0, & string_free);
#line 223
  break;
  }
#line 225
  if (ex->tail) {
#line 226
    (ex->tail)->next = sp;
  } else {
#line 228
    ex->head = sp;
  }
#line 229
  ex->tail = sp;
#line 230
  return (sp);
}
}
#line 234 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static void free_exclude_segment(struct exclude_segment *seg ) 
{ 


  {
#line 237
  switch ((unsigned int )seg->type) {
  case 1U: 
#line 240
  free((void *)seg->v.pat.exclude);
#line 241
  break;
  case 0U: 
#line 244
  hash_free(seg->v.table);
#line 245
  break;
  }
#line 247
  free((void *)seg);
#line 248
  return;
}
}
#line 251 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
void free_exclude(struct exclude *ex ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_segment *next ;

  {
#line 255
  seg = ex->head;
#line 255
  while (seg) {
#line 257
    next = seg->next;
#line 258
    free_exclude_segment(seg);
#line 259
    seg = next;
  }
#line 261
  free((void *)ex);
#line 262
  return;
}
}
#line 267 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static int fnmatch_no_wildcards(char const   *pattern , char const   *f , int options ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  size_t patlen ;
  size_t tmp___2 ;
  int r ;
  int tmp___3 ;
  char *fcopy ;
  char *tmp___4 ;
  char *p ;
  int r___0 ;
  char *tmp___5 ;

  {
#line 270
  if (! (options & (1 << 3))) {
#line 271
    if (options & (1 << 4)) {
#line 271
      tmp = mbscasecmp(pattern, f);
#line 271
      tmp___1 = tmp;
    } else {
#line 271
      tmp___0 = strcmp(pattern, f);
#line 271
      tmp___1 = tmp___0;
    }
#line 271
    return (tmp___1);
  } else
#line 274
  if (! (options & (1 << 4))) {
#line 276
    tmp___2 = strlen(pattern);
#line 276
    patlen = tmp___2;
#line 277
    tmp___3 = strncmp(pattern, f, patlen);
#line 277
    r = tmp___3;
#line 278
    if (! r) {
#line 280
      r = (int )*(f + patlen);
#line 281
      if (r == 47) {
#line 282
        r = 0;
      }
    }
#line 284
    return (r);
  } else {
#line 295
    tmp___4 = xstrdup(f);
#line 295
    fcopy = tmp___4;
#line 298
    p = fcopy;
#line 298
    while (1) {
#line 300
      p = strchr((char const   *)p, '/');
#line 301
      if (p) {
#line 302
        *p = (char )'\000';
      }
#line 303
      r___0 = mbscasecmp(pattern, (char const   *)fcopy);
#line 304
      if (! p) {
#line 305
        break;
      } else
#line 304
      if (r___0 <= 0) {
#line 305
        break;
      }
#line 298
      tmp___5 = p;
#line 298
      p ++;
#line 298
      *tmp___5 = (char )'/';
    }
#line 307
    free((void *)fcopy);
#line 308
    return (r___0);
  }
}
}
#line 312 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
_Bool exclude_fnmatch(char const   *pattern , char const   *f , int options ) 
{ 
  int (*matcher)(char const   * , char const   * , int  ) ;
  int (*tmp)(char const   *__pattern , char const   *__name , int __flags ) ;
  _Bool matched ;
  int tmp___0 ;
  char const   *p ;
  int tmp___1 ;

  {
#line 315
  if (options & (1 << 28)) {
#line 315
    tmp = & fnmatch;
  } else {
#line 315
    tmp = & fnmatch_no_wildcards;
  }
#line 315
  matcher = tmp;
#line 319
  tmp___0 = (*matcher)(pattern, f, options);
#line 319
  matched = (_Bool )(tmp___0 == 0);
#line 322
  if (! (options & (1 << 30))) {
#line 323
    p = f;
#line 323
    while (1) {
#line 323
      if (*p) {
#line 323
        if (! (! matched)) {
#line 323
          break;
        }
      } else {
#line 323
        break;
      }
#line 324
      if ((int const   )*p == 47) {
#line 324
        if ((int const   )*(p + 1) != 47) {
#line 325
          tmp___1 = (*matcher)(pattern, p + 1, options);
#line 325
          matched = (_Bool )(tmp___1 == 0);
        }
      }
#line 323
      p ++;
    }
  }
#line 327
  return (matched);
}
}
#line 332 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static _Bool excluded_file_pattern_p(struct exclude_segment  const  *seg , char const   *f ) 
{ 
  size_t exclude_count ;
  struct patopts  const  *exclude___0 ;
  size_t i ;
  _Bool excluded ;
  char const   *pattern ;
  int options ;
  _Bool tmp ;

  {
#line 335
  exclude_count = (size_t )seg->v.pat.exclude_count;
#line 336
  exclude___0 = (struct patopts  const  *)seg->v.pat.exclude;
#line 338
  excluded = (_Bool )(! (! ((exclude___0 + 0)->options & (int const   )(1 << 29))));
#line 341
  i = (size_t )0;
#line 341
  while (i < exclude_count) {
#line 343
    pattern = (char const   *)(exclude___0 + i)->pattern;
#line 344
    options = (int )(exclude___0 + i)->options;
#line 345
    tmp = exclude_fnmatch(pattern, f, options);
#line 345
    if ((int )excluded != (int )tmp) {
#line 346
      return ((_Bool )(! excluded));
    }
#line 341
    i ++;
  }
#line 348
  return (excluded);
}
}
#line 354 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
static _Bool excluded_file_name_p(struct exclude_segment  const  *seg , char const   *f ,
                                  char *buffer ) 
{ 
  int options ;
  _Bool excluded ;
  Hash_table *table ;
  void *tmp ;
  char *p ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 358
  options = (int )seg->options;
#line 359
  excluded = (_Bool )(! (! (options & (1 << 29))));
#line 360
  table = (Hash_table *)seg->v.table;
#line 362
  while (1) {
#line 365
    strcpy((char * __restrict  )buffer, (char const   * __restrict  )f);
#line 367
    while (1) {
#line 369
      tmp = hash_lookup((Hash_table const   *)table, (void const   *)buffer);
#line 369
      if (tmp) {
#line 370
        return ((_Bool )(! excluded));
      }
#line 371
      if (options & (1 << 3)) {
#line 373
        tmp___0 = strrchr((char const   *)buffer, '/');
#line 373
        p = tmp___0;
#line 374
        if (p) {
#line 376
          *p = (char)0;
#line 377
          continue;
        }
      }
#line 380
      break;
    }
#line 383
    if (! (options & (1 << 30))) {
#line 385
      tmp___1 = strchr(f, '/');
#line 385
      f = (char const   *)tmp___1;
#line 386
      if (f) {
#line 387
        f ++;
      }
    } else {
#line 390
      break;
    }
#line 362
    if (! f) {
#line 362
      break;
    }
  }
#line 393
  return (excluded);
}
}
#line 398 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
_Bool excluded_file_name(struct exclude  const  *ex , char const   *f ) 
{ 
  struct exclude_segment *seg ;
  _Bool excluded ;
  char *filename ;
  _Bool rc ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 403
  filename = (char *)((void *)0);
#line 406
  if (! ex->head) {
#line 407
    return ((_Bool)0);
  }
#line 410
  excluded = (_Bool )(! (! ((ex->head)->options & (1 << 29))));
#line 413
  seg = (struct exclude_segment *)ex->head;
#line 413
  while (seg) {
#line 417
    switch ((unsigned int )seg->type) {
    case 1U: 
#line 420
    rc = excluded_file_pattern_p((struct exclude_segment  const  *)seg, f);
#line 421
    break;
    case 0U: 
#line 424
    if (! filename) {
#line 425
      tmp = strlen(f);
#line 425
      tmp___0 = xmalloc(tmp + 1UL);
#line 425
      filename = (char *)tmp___0;
    }
#line 426
    rc = excluded_file_name_p((struct exclude_segment  const  *)seg, f, filename);
#line 427
    break;
    default: 
#line 430
    abort();
    }
#line 432
    if ((int )rc != (int )excluded) {
#line 434
      excluded = rc;
#line 435
      break;
    }
#line 413
    seg = seg->next;
  }
#line 438
  free((void *)filename);
#line 439
  return (excluded);
}
}
#line 444 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
void add_exclude(struct exclude *ex , char const   *pattern , int options ) 
{ 
  struct exclude_segment *seg ;
  struct exclude_pattern *pat ;
  struct patopts *patopts ;
  void *tmp ;
  size_t tmp___0 ;
  char *str ;
  char *p ;
  void *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 449
  if (options & (1 << 28)) {
#line 449
    tmp___2 = fnmatch_pattern_has_wildcards(pattern, options);
#line 449
    if (tmp___2) {
#line 455
      if (ex->tail) {
#line 455
        if ((unsigned int )(ex->tail)->type == 1U) {
#line 455
          if (((ex->tail)->options & (1 << 29)) == (options & (1 << 29))) {
#line 458
            seg = ex->tail;
          } else {
#line 460
            seg = new_exclude_segment(ex, (enum exclude_type )1, options);
          }
        } else {
#line 460
          seg = new_exclude_segment(ex, (enum exclude_type )1, options);
        }
      } else {
#line 460
        seg = new_exclude_segment(ex, (enum exclude_type )1, options);
      }
#line 462
      pat = & seg->v.pat;
#line 463
      if (pat->exclude_count == pat->exclude_alloc) {
#line 464
        tmp = x2nrealloc((void *)pat->exclude, & pat->exclude_alloc, sizeof(*(pat->exclude)));
#line 464
        pat->exclude = (struct patopts *)tmp;
      }
#line 466
      tmp___0 = pat->exclude_count;
#line 466
      (pat->exclude_count) ++;
#line 466
      patopts = pat->exclude + tmp___0;
#line 467
      patopts->pattern = pattern;
#line 468
      patopts->options = options;
    } else {
#line 449
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 475
    if (ex->tail) {
#line 475
      if ((unsigned int )(ex->tail)->type == 0U) {
#line 475
        if (((ex->tail)->options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4))) == (options & ((((1 << 29) | (1 << 30)) | (1 << 3)) | (1 << 4)))) {
#line 478
          seg = ex->tail;
        } else {
#line 480
          seg = new_exclude_segment(ex, (enum exclude_type )0, options);
        }
      } else {
#line 480
        seg = new_exclude_segment(ex, (enum exclude_type )0, options);
      }
    } else {
#line 480
      seg = new_exclude_segment(ex, (enum exclude_type )0, options);
    }
#line 482
    str = xstrdup(pattern);
#line 483
    tmp___1 = hash_insert(seg->v.table, (void const   *)str);
#line 483
    p = (char *)tmp___1;
#line 484
    if ((unsigned long )p != (unsigned long )str) {
#line 485
      free((void *)str);
    }
  }
#line 487
  return;
}
}
#line 494 "/home/wslee/project/coreutils-8.1/lib/exclude.c"
int add_exclude_file(void (*add_func)(struct exclude * , char const   * , int  ) ,
                     struct exclude *ex , char const   *file_name___1 , int options ,
                     char line_end ) 
{ 
  _Bool use_stdin ;
  int tmp ;
  FILE *in ;
  char *buf___0 ;
  char *p ;
  char const   *pattern ;
  char const   *lim ;
  size_t buf_alloc ;
  size_t buf_count ;
  int c ;
  int e ;
  void *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  char *pattern_end ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;

  {
#line 499
  if ((int const   )*(file_name___1 + 0) == 45) {
#line 499
    if (! *(file_name___1 + 1)) {
#line 499
      tmp = 1;
    } else {
#line 499
      tmp = 0;
    }
  } else {
#line 499
    tmp = 0;
  }
#line 499
  use_stdin = (_Bool )tmp;
#line 501
  buf___0 = (char *)((void *)0);
#line 505
  buf_alloc = (size_t )0;
#line 506
  buf_count = (size_t )0;
#line 508
  e = 0;
#line 510
  if (use_stdin) {
#line 511
    in = stdin;
  } else {
#line 512
    in = fopen((char const   * __restrict  )file_name___1, (char const   * __restrict  )"r");
#line 512
    if (! in) {
#line 513
      return (-1);
    }
  }
#line 515
  while (1) {
#line 515
    c = getc_unlocked(in);
#line 515
    if (! (c != -1)) {
#line 515
      break;
    }
#line 517
    if (buf_count == buf_alloc) {
#line 518
      tmp___0 = x2realloc((void *)buf___0, & buf_alloc);
#line 518
      buf___0 = (char *)tmp___0;
    }
#line 519
    tmp___1 = buf_count;
#line 519
    buf_count ++;
#line 519
    *(buf___0 + tmp___1) = (char )c;
  }
#line 522
  tmp___3 = ferror_unlocked(in);
#line 522
  if (tmp___3) {
#line 523
    tmp___2 = __errno_location();
#line 523
    e = *tmp___2;
  }
#line 525
  if (! use_stdin) {
#line 525
    tmp___5 = fclose(in);
#line 525
    if (tmp___5 != 0) {
#line 526
      tmp___4 = __errno_location();
#line 526
      e = *tmp___4;
    }
  }
#line 528
  tmp___6 = xrealloc((void *)buf___0, buf_count + 1UL);
#line 528
  buf___0 = (char *)tmp___6;
#line 529
  *(buf___0 + buf_count) = line_end;
#line 530
  if (buf_count == 0UL) {
#line 530
    tmp___7 = 0;
  } else
#line 530
  if ((int )*(buf___0 + (buf_count - 1UL)) == (int )line_end) {
#line 530
    tmp___7 = 0;
  } else {
#line 530
    tmp___7 = 1;
  }
#line 530
  lim = (char const   *)((buf___0 + buf_count) + tmp___7);
#line 531
  pattern = (char const   *)buf___0;
#line 533
  p = buf___0;
#line 533
  while ((unsigned long )p < (unsigned long )lim) {
#line 534
    if ((int )*p == (int )line_end) {
#line 536
      pattern_end = p;
#line 538
      tmp___9 = __ctype_b_loc();
#line 538
      if ((int const   )*(*tmp___9 + (int )((unsigned char )line_end)) & 8192) {
#line 540
        while (1) {
#line 541
          if ((unsigned long )pattern_end == (unsigned long )pattern) {
#line 542
            goto next_pattern;
          } else {
#line 543
            tmp___8 = __ctype_b_loc();
#line 543
            if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*(pattern_end + -1))) & 8192)) {
#line 544
              break;
            }
          }
#line 540
          pattern_end --;
        }
      }
#line 547
      *pattern_end = (char )'\000';
#line 548
      (*add_func)(ex, pattern, options);
      next_pattern: 
#line 551
      pattern = (char const   *)(p + 1);
    }
#line 533
    p ++;
  }
#line 554
  tmp___10 = __errno_location();
#line 554
  *tmp___10 = e;
#line 555
  if (e) {
#line 555
    tmp___11 = -1;
  } else {
#line 555
    tmp___11 = 0;
  }
#line 555
  return (tmp___11);
}
}
#line 1 "cil-MmepFN9N.o"
#pragma merger("0","../lib/exitfail.o.i","")
#line 24 "/home/wslee/project/coreutils-8.1/lib/exitfail.c"
int volatile   exit_failure  =    (int volatile   )1;
#line 1 "cil-ZQJSjy9H.o"
#pragma merger("0","../lib/fd-reopen.o.i","")
#line 22 "/home/wslee/project/coreutils-8.1/lib/fd-reopen.h"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) ;
#line 537 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 156 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/fd-reopen.c"
int fd_reopen(int desired_fd , char const   *file , int flags , mode_t mode ) 
{ 
  int fd ;
  int tmp ;
  int fd2 ;
  int tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;

  {
#line 34
  tmp = open(file, flags, mode);
#line 34
  fd = tmp;
#line 36
  if (fd == desired_fd) {
#line 37
    return (fd);
  } else
#line 36
  if (fd < 0) {
#line 37
    return (fd);
  } else {
#line 40
    tmp___0 = dup2(fd, desired_fd);
#line 40
    fd2 = tmp___0;
#line 41
    tmp___1 = __errno_location();
#line 41
    saved_errno = *tmp___1;
#line 42
    close(fd);
#line 43
    tmp___2 = __errno_location();
#line 43
    *tmp___2 = saved_errno;
#line 44
    return (fd2);
  }
}
}
#line 1 "cil-eyT8Jftk.o"
#pragma merger("0","../lib/fd-safer.o.i","")
#line 37 "/home/wslee/project/coreutils-8.1/lib/fd-safer.c"
int fd_safer(int fd ) 
{ 
  int f ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 40
  if (0 <= fd) {
#line 40
    if (fd <= 2) {
#line 42
      tmp = dup_safer(fd);
#line 42
      f = tmp;
#line 43
      tmp___0 = __errno_location();
#line 43
      e = *tmp___0;
#line 44
      close(fd);
#line 45
      tmp___1 = __errno_location();
#line 45
      *tmp___1 = e;
#line 46
      fd = f;
    }
  }
#line 49
  return (fd);
}
}
#line 1 "cil-vw78Noa1.o"
#pragma merger("0","../lib/fdopendir.o.i","")
#line 141 "/usr/include/dirent.h"
extern DIR *fdopendir(int __fd ) ;
#line 97 "./dirent.h"
DIR *rpl_fdopendir(int fd ) ;
#line 120 "/home/wslee/project/coreutils-8.1/lib/fdopendir.c"
DIR *rpl_fdopendir(int fd ) 
{ 
  struct stat st ;
  int tmp ;
  int *tmp___0 ;
  DIR *tmp___1 ;

  {
#line 124
  tmp = fstat(fd, & st);
#line 124
  if (tmp) {
#line 125
    return ((DIR *)((void *)0));
  }
#line 126
  if (! ((st.st_mode & 61440U) == 16384U)) {
#line 128
    tmp___0 = __errno_location();
#line 128
    *tmp___0 = 20;
#line 129
    return ((DIR *)((void *)0));
  }
#line 131
  tmp___1 = fdopendir(fd);
#line 131
  return (tmp___1);
}
}
#line 1 "cil-RrVwUmhN.o"
#pragma merger("0","../lib/fflush.o.i","")
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 51 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __freading)(FILE *__fp ) ;
#line 37 "/home/wslee/project/coreutils-8.1/lib/fflush.c"
__inline static void clear_ungetc_buffer_preserving_position(FILE *fp ) 
{ 


  {
#line 40
  if (fp->_flags & 256) {
#line 42
    rpl_fseeko(fp, (off_t )0, 1);
  }
#line 43
  return;
}
}
#line 101 "/home/wslee/project/coreutils-8.1/lib/fflush.c"
int rpl_fflush(FILE *stream ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 123
  if ((unsigned long )stream == (unsigned long )((void *)0)) {
#line 124
    tmp = fflush(stream);
#line 124
    return (tmp);
  } else {
#line 123
    tmp___0 = __freading(stream);
#line 123
    if (! (tmp___0 != 0)) {
#line 124
      tmp = fflush(stream);
#line 124
      return (tmp);
    }
  }
#line 128
  clear_ungetc_buffer_preserving_position(stream);
#line 130
  tmp___1 = fflush(stream);
#line 130
  return (tmp___1);
}
}
#line 1 "cil-m1cu6xkD.o"
#pragma merger("0","../lib/file-has-acl.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/acl.h"
int file_has_acl(char const   *name , struct stat  const  *sb ) ;
#line 304 "/home/wslee/project/coreutils-8.1/lib/file-has-acl.c"
int file_has_acl(char const   *name , struct stat  const  *sb ) 
{ 


  {
#line 605
  return (0);
}
}
#line 1 "cil-uzAQxmKT.o"
#pragma merger("0","../lib/file-set.o.i","")
#line 28 "/home/wslee/project/coreutils-8.1/lib/file-set.c"
void ( __attribute__((__nonnull__(2,3))) record_file)(Hash_table *ht___0 , char const   *file ,
                                                      struct stat  const  *stats ) 
{ 
  struct F_triple *ent ;
  void *tmp ;
  struct F_triple *ent_from_table ;
  void *tmp___0 ;

  {
#line 33
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
#line 34
    return;
  }
#line 36
  tmp = xmalloc(sizeof(*ent));
#line 36
  ent = (struct F_triple *)tmp;
#line 37
  ent->name = xstrdup(file);
#line 38
  ent->st_ino = (ino_t )stats->st_ino;
#line 39
  ent->st_dev = (dev_t )stats->st_dev;
#line 42
  tmp___0 = hash_insert(ht___0, (void const   *)ent);
#line 42
  ent_from_table = (struct F_triple *)tmp___0;
#line 43
  if ((unsigned long )ent_from_table == (unsigned long )((void *)0)) {
#line 46
    xalloc_die();
  }
#line 49
  if ((unsigned long )ent_from_table != (unsigned long )ent) {
#line 53
    triple_free((void *)ent);
  }
#line 56
  return;
}
}
#line 60 "/home/wslee/project/coreutils-8.1/lib/file-set.c"
_Bool seen_file(Hash_table const   *ht___0 , char const   *file , struct stat  const  *stats ) 
{ 
  struct F_triple new_ent ;
  void *tmp ;
  int tmp___0 ;

  {
#line 66
  if ((unsigned long )ht___0 == (unsigned long )((void *)0)) {
#line 67
    return ((_Bool)0);
  }
#line 69
  new_ent.name = (char *)file;
#line 70
  new_ent.st_ino = (ino_t )stats->st_ino;
#line 71
  new_ent.st_dev = (dev_t )stats->st_dev;
#line 73
  tmp = hash_lookup(ht___0, (void const   *)(& new_ent));
#line 73
  if (tmp) {
#line 73
    tmp___0 = 1;
  } else {
#line 73
    tmp___0 = 0;
  }
#line 73
  return ((_Bool )tmp___0);
}
}
#line 1 "cil-9YlX7fMQ.o"
#pragma merger("0","../lib/file-type.o.i","")
#line 27 "/home/wslee/project/coreutils-8.1/lib/file-type.h"
char const   *file_type(struct stat  const  *st ) ;
#line 28 "/home/wslee/project/coreutils-8.1/lib/file-type.c"
char const   *file_type(struct stat  const  *st ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___12 ;

  {
#line 37
  if ((st->st_mode & 61440U) == 32768U) {
#line 38
    if (st->st_size == 0L) {
#line 38
      tmp = gettext("regular empty file");
#line 38
      tmp___1 = tmp;
    } else {
#line 38
      tmp___0 = gettext("regular file");
#line 38
      tmp___1 = tmp___0;
    }
#line 38
    return ((char const   *)tmp___1);
  }
#line 40
  if ((st->st_mode & 61440U) == 16384U) {
#line 41
    tmp___2 = gettext("directory");
#line 41
    return ((char const   *)tmp___2);
  }
#line 43
  if ((st->st_mode & 61440U) == 24576U) {
#line 44
    tmp___3 = gettext("block special file");
#line 44
    return ((char const   *)tmp___3);
  }
#line 46
  if ((st->st_mode & 61440U) == 8192U) {
#line 47
    tmp___4 = gettext("character special file");
#line 47
    return ((char const   *)tmp___4);
  }
#line 49
  if ((st->st_mode & 61440U) == 4096U) {
#line 50
    tmp___5 = gettext("fifo");
#line 50
    return ((char const   *)tmp___5);
  }
#line 52
  if ((st->st_mode & 61440U) == 40960U) {
#line 53
    tmp___6 = gettext("symbolic link");
#line 53
    return ((char const   *)tmp___6);
  }
#line 55
  if ((st->st_mode & 61440U) == 49152U) {
#line 56
    tmp___7 = gettext("socket");
#line 56
    return ((char const   *)tmp___7);
  }
#line 58
  if (st->st_mode - st->st_mode) {
#line 59
    tmp___8 = gettext("message queue");
#line 59
    return ((char const   *)tmp___8);
  }
#line 61
  if (st->st_mode - st->st_mode) {
#line 62
    tmp___9 = gettext("semaphore");
#line 62
    return ((char const   *)tmp___9);
  }
#line 64
  if (st->st_mode - st->st_mode) {
#line 65
    tmp___10 = gettext("shared memory object");
#line 65
    return ((char const   *)tmp___10);
  }
#line 70
  tmp___12 = gettext("weird file");
#line 70
  return ((char const   *)tmp___12);
}
}
#line 1 "cil-ahOFrRgY.o"
#pragma merger("0","../lib/filemode.o.i","")
#line 27 "/home/wslee/project/coreutils-8.1/lib/filemode.h"
void strmode(mode_t mode , char *str ) ;
#line 30
void filemodestring(struct stat  const  *statp , char *str ) ;
#line 53 "/home/wslee/project/coreutils-8.1/lib/filemode.c"
static char ftypelet(mode_t bits ) 
{ 


  {
#line 57
  if ((bits & 61440U) == 32768U) {
#line 58
    return ((char )'-');
  }
#line 59
  if ((bits & 61440U) == 16384U) {
#line 60
    return ((char )'d');
  }
#line 63
  if ((bits & 61440U) == 24576U) {
#line 64
    return ((char )'b');
  }
#line 65
  if ((bits & 61440U) == 8192U) {
#line 66
    return ((char )'c');
  }
#line 67
  if ((bits & 61440U) == 40960U) {
#line 68
    return ((char )'l');
  }
#line 69
  if ((bits & 61440U) == 4096U) {
#line 70
    return ((char )'p');
  }
#line 73
  if ((bits & 61440U) == 49152U) {
#line 74
    return ((char )'s');
  }
#line 90
  return ((char )'?');
}
}
#line 95 "/home/wslee/project/coreutils-8.1/lib/filemode.c"
void strmode(mode_t mode , char *str ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 98
  *(str + 0) = ftypelet(mode);
#line 99
  if (mode & 256U) {
#line 99
    *(str + 1) = (char )'r';
  } else {
#line 99
    *(str + 1) = (char )'-';
  }
#line 100
  if (mode & 128U) {
#line 100
    *(str + 2) = (char )'w';
  } else {
#line 100
    *(str + 2) = (char )'-';
  }
#line 101
  if (mode & 2048U) {
#line 101
    if (mode & 64U) {
#line 101
      tmp = 's';
    } else {
#line 101
      tmp = 'S';
    }
#line 101
    *(str + 3) = (char )tmp;
  } else {
#line 101
    if (mode & 64U) {
#line 101
      tmp___0 = 'x';
    } else {
#line 101
      tmp___0 = '-';
    }
#line 101
    *(str + 3) = (char )tmp___0;
  }
#line 104
  if (mode & (unsigned int )(256 >> 3)) {
#line 104
    *(str + 4) = (char )'r';
  } else {
#line 104
    *(str + 4) = (char )'-';
  }
#line 105
  if (mode & (unsigned int )(128 >> 3)) {
#line 105
    *(str + 5) = (char )'w';
  } else {
#line 105
    *(str + 5) = (char )'-';
  }
#line 106
  if (mode & 1024U) {
#line 106
    if (mode & (unsigned int )(64 >> 3)) {
#line 106
      tmp___1 = 's';
    } else {
#line 106
      tmp___1 = 'S';
    }
#line 106
    *(str + 6) = (char )tmp___1;
  } else {
#line 106
    if (mode & (unsigned int )(64 >> 3)) {
#line 106
      tmp___2 = 'x';
    } else {
#line 106
      tmp___2 = '-';
    }
#line 106
    *(str + 6) = (char )tmp___2;
  }
#line 109
  if (mode & (unsigned int )((256 >> 3) >> 3)) {
#line 109
    *(str + 7) = (char )'r';
  } else {
#line 109
    *(str + 7) = (char )'-';
  }
#line 110
  if (mode & (unsigned int )((128 >> 3) >> 3)) {
#line 110
    *(str + 8) = (char )'w';
  } else {
#line 110
    *(str + 8) = (char )'-';
  }
#line 111
  if (mode & 512U) {
#line 111
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 111
      tmp___3 = 't';
    } else {
#line 111
      tmp___3 = 'T';
    }
#line 111
    *(str + 9) = (char )tmp___3;
  } else {
#line 111
    if (mode & (unsigned int )((64 >> 3) >> 3)) {
#line 111
      tmp___4 = 'x';
    } else {
#line 111
      tmp___4 = '-';
    }
#line 111
    *(str + 9) = (char )tmp___4;
  }
#line 114
  *(str + 10) = (char )' ';
#line 115
  *(str + 11) = (char )'\000';
#line 116
  return;
}
}
#line 165 "/home/wslee/project/coreutils-8.1/lib/filemode.c"
void filemodestring(struct stat  const  *statp , char *str ) 
{ 


  {
#line 168
  strmode((mode_t )statp->st_mode, str);
#line 170
  if (statp->st_mode - statp->st_mode) {
#line 171
    *(str + 0) = (char )'F';
  } else
#line 174
  if (statp->st_mode - statp->st_mode) {
#line 175
    *(str + 0) = (char )'Q';
  } else
#line 176
  if (statp->st_mode - statp->st_mode) {
#line 177
    *(str + 0) = (char )'S';
  }
#line 180
  return;
}
}
#line 1 "cil-Ev4ynWqi.o"
#pragma merger("0","../lib/filenamecat-lgpl.o.i","")
#line 26 "/home/wslee/project/coreutils-8.1/lib/filenamecat.h"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 386 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) mempcpy)(void * __restrict  __dest ,
                                                                                                  void const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 37 "/home/wslee/project/coreutils-8.1/lib/filenamecat-lgpl.c"
static char const   *longest_relative_suffix(char const   *f ) 
{ 


  {
#line 40
  f += 0;
#line 40
  while ((int const   )*f == 47) {
#line 41
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 40
    f ++;
  }
#line 42
  return (f);
}
}
#line 60 "/home/wslee/project/coreutils-8.1/lib/filenamecat-lgpl.c"
char *mfile_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char const   *dirbase ;
  char *tmp ;
  size_t dirbaselen ;
  size_t tmp___0 ;
  size_t dirlen ;
  size_t needs_separator ;
  int tmp___1 ;
  char const   *base ;
  char const   *tmp___2 ;
  size_t baselen ;
  size_t tmp___3 ;
  char *p_concat ;
  void *tmp___4 ;
  char *p ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;

  {
#line 63
  tmp = last_component(dir);
#line 63
  dirbase = (char const   *)tmp;
#line 64
  tmp___0 = base_len(dirbase);
#line 64
  dirbaselen = tmp___0;
#line 65
  dirlen = (size_t )(dirbase - dir) + dirbaselen;
#line 66
  if (dirbaselen) {
#line 66
    if (! ((int const   )*(dirbase + (dirbaselen - 1UL)) == 47)) {
#line 66
      tmp___1 = 1;
    } else {
#line 66
      tmp___1 = 0;
    }
  } else {
#line 66
    tmp___1 = 0;
  }
#line 66
  needs_separator = (size_t )tmp___1;
#line 68
  tmp___2 = longest_relative_suffix(abase);
#line 68
  base = tmp___2;
#line 69
  tmp___3 = strlen(base);
#line 69
  baselen = tmp___3;
#line 71
  tmp___4 = malloc(((dirlen + needs_separator) + baselen) + 1UL);
#line 71
  p_concat = (char *)tmp___4;
#line 74
  if ((unsigned long )p_concat == (unsigned long )((void *)0)) {
#line 75
    return ((char *)((void *)0));
  }
#line 77
  tmp___5 = mempcpy((void * __restrict  )p_concat, (void const   * __restrict  )dir,
                    dirlen);
#line 77
  p = (char *)tmp___5;
#line 78
  *p = (char )'/';
#line 79
  p += needs_separator;
#line 81
  if (base_in_result) {
#line 82
    if ((int const   )*(abase + 0) == 47) {
#line 82
      tmp___6 = 1;
    } else {
#line 82
      tmp___6 = 0;
    }
#line 82
    *base_in_result = p - tmp___6;
  }
#line 84
  tmp___7 = mempcpy((void * __restrict  )p, (void const   * __restrict  )base, baselen);
#line 84
  p = (char *)tmp___7;
#line 85
  *p = (char )'\000';
#line 87
  return (p_concat);
}
}
#line 1 "cil-2J6MMGpC.o"
#pragma merger("0","../lib/filenamecat.o.i","")
#line 22 "/home/wslee/project/coreutils-8.1/lib/filenamecat.h"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) ;
#line 34 "/home/wslee/project/coreutils-8.1/lib/filenamecat.c"
char *file_name_concat(char const   *dir , char const   *abase , char **base_in_result ) 
{ 
  char *p ;
  char *tmp ;

  {
#line 37
  tmp = mfile_name_concat(dir, abase, base_in_result);
#line 37
  p = tmp;
#line 38
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 39
    xalloc_die();
  }
#line 40
  return (p);
}
}
#line 1 "cil-Px4fJy54.o"
#pragma merger("0","../lib/filevercmp.o.i","")
#line 40 "/home/wslee/project/coreutils-8.1/lib/filevercmp.h"
int filevercmp(char const   *s1 , char const   *s2 ) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/filevercmp.c"
static char const   *match_suffix(char const   **str ) 
{ 
  char const   *match ;
  _Bool read_alpha ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 36
  match = (char const   *)((void *)0);
#line 37
  read_alpha = (_Bool)0;
#line 38
  while (*(*str)) {
#line 40
    if (read_alpha) {
#line 42
      read_alpha = (_Bool)0;
#line 43
      tmp = c_isalpha((int )*(*str));
#line 43
      if (! tmp) {
#line 43
        if (126 != (int )*(*str)) {
#line 44
          match = (char const   *)((void *)0);
        }
      }
    } else
#line 46
    if (46 == (int )*(*str)) {
#line 48
      read_alpha = (_Bool)1;
#line 49
      if (! match) {
#line 50
        match = *str;
      }
    } else {
#line 52
      tmp___0 = c_isalnum((int )*(*str));
#line 52
      if (! tmp___0) {
#line 52
        if (126 != (int )*(*str)) {
#line 53
          match = (char const   *)((void *)0);
        }
      }
    }
#line 54
    (*str) ++;
  }
#line 56
  return (match);
}
}
#line 60 "/home/wslee/project/coreutils-8.1/lib/filevercmp.c"
__inline static int order(unsigned char c ) 
{ 
  _Bool tmp ;
  _Bool tmp___0 ;

  {
#line 63
  tmp___0 = c_isdigit((int )c);
#line 63
  if (tmp___0) {
#line 64
    return (0);
  } else {
#line 65
    tmp = c_isalpha((int )c);
#line 65
    if (tmp) {
#line 66
      return ((int )c);
    } else
#line 67
    if ((int )c == 126) {
#line 68
      return (-1);
    } else {
#line 70
      return (((int )c + 255) + 1);
    }
  }
}
}
#line 83 "/home/wslee/project/coreutils-8.1/lib/filevercmp.c"
static int verrevcmp(char const   *s1 , size_t s1_len , char const   *s2 , size_t s2_len ) 
{ 
  size_t s1_pos ;
  size_t s2_pos ;
  int first_diff ;
  int s1_c ;
  int tmp ;
  int tmp___0 ;
  int s2_c ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  _Bool tmp___8 ;

  {
#line 86
  s1_pos = (size_t )0;
#line 87
  s2_pos = (size_t )0;
#line 88
  while (1) {
#line 88
    if (! (s1_pos < s1_len)) {
#line 88
      if (! (s2_pos < s2_len)) {
#line 88
        break;
      }
    }
#line 90
    first_diff = 0;
#line 91
    while (1) {
#line 91
      if (s1_pos < s1_len) {
#line 91
        tmp___3 = c_isdigit((int )*(s1 + s1_pos));
#line 91
        if (tmp___3) {
#line 91
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 91
      if (s2_pos < s2_len) {
#line 91
        tmp___4 = c_isdigit((int )*(s2 + s2_pos));
#line 91
        if (tmp___4) {
#line 91
          break;
        }
      } else {
#line 91
        break;
      }
#line 94
      if (s1_pos == s1_len) {
#line 94
        tmp___0 = 0;
      } else {
#line 94
        tmp = order((unsigned char )*(s1 + s1_pos));
#line 94
        tmp___0 = tmp;
      }
#line 94
      s1_c = tmp___0;
#line 95
      if (s2_pos == s2_len) {
#line 95
        tmp___2 = 0;
      } else {
#line 95
        tmp___1 = order((unsigned char )*(s2 + s2_pos));
#line 95
        tmp___2 = tmp___1;
      }
#line 95
      s2_c = tmp___2;
#line 96
      if (s1_c != s2_c) {
#line 97
        return (s1_c - s2_c);
      }
#line 98
      s1_pos ++;
#line 99
      s2_pos ++;
    }
#line 101
    while ((int const   )*(s1 + s1_pos) == 48) {
#line 102
      s1_pos ++;
    }
#line 103
    while ((int const   )*(s2 + s2_pos) == 48) {
#line 104
      s2_pos ++;
    }
#line 105
    while (1) {
#line 105
      tmp___5 = c_isdigit((int )*(s1 + s1_pos));
#line 105
      if (tmp___5) {
#line 105
        tmp___6 = c_isdigit((int )*(s2 + s2_pos));
#line 105
        if (! tmp___6) {
#line 105
          break;
        }
      } else {
#line 105
        break;
      }
#line 107
      if (! first_diff) {
#line 108
        first_diff = (int )((int const   )*(s1 + s1_pos) - (int const   )*(s2 + s2_pos));
      }
#line 109
      s1_pos ++;
#line 110
      s2_pos ++;
    }
#line 112
    tmp___7 = c_isdigit((int )*(s1 + s1_pos));
#line 112
    if (tmp___7) {
#line 113
      return (1);
    }
#line 114
    tmp___8 = c_isdigit((int )*(s2 + s2_pos));
#line 114
    if (tmp___8) {
#line 115
      return (-1);
    }
#line 116
    if (first_diff) {
#line 117
      return (first_diff);
    }
  }
#line 119
  return (0);
}
}
#line 124 "/home/wslee/project/coreutils-8.1/lib/filevercmp.c"
int filevercmp(char const   *s1 , char const   *s2 ) 
{ 
  char const   *s1_pos ;
  char const   *s2_pos ;
  char const   *s1_suffix ;
  char const   *s2_suffix ;
  size_t s1_len ;
  size_t s2_len ;
  int result ;
  int simple_cmp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 134
  tmp = strcmp(s1, s2);
#line 134
  simple_cmp = tmp;
#line 135
  if (simple_cmp == 0) {
#line 136
    return (0);
  }
#line 139
  if (! *s1) {
#line 140
    return (-1);
  }
#line 141
  if (! *s2) {
#line 142
    return (1);
  }
#line 143
  tmp___0 = strcmp(".", s1);
#line 143
  if (0 == tmp___0) {
#line 144
    return (-1);
  }
#line 145
  tmp___1 = strcmp(".", s2);
#line 145
  if (0 == tmp___1) {
#line 146
    return (1);
  }
#line 147
  tmp___2 = strcmp("..", s1);
#line 147
  if (0 == tmp___2) {
#line 148
    return (-1);
  }
#line 149
  tmp___3 = strcmp("..", s2);
#line 149
  if (0 == tmp___3) {
#line 150
    return (1);
  }
#line 153
  if ((int const   )*s1 == 46) {
#line 153
    if ((int const   )*s2 != 46) {
#line 154
      return (-1);
    }
  }
#line 155
  if ((int const   )*s1 != 46) {
#line 155
    if ((int const   )*s2 == 46) {
#line 156
      return (1);
    }
  }
#line 157
  if ((int const   )*s1 == 46) {
#line 157
    if ((int const   )*s2 == 46) {
#line 159
      s1 ++;
#line 160
      s2 ++;
    }
  }
#line 164
  s1_pos = s1;
#line 165
  s2_pos = s2;
#line 166
  s1_suffix = match_suffix(& s1_pos);
#line 167
  s2_suffix = match_suffix(& s2_pos);
#line 168
  if (s1_suffix) {
#line 168
    tmp___4 = s1_suffix;
  } else {
#line 168
    tmp___4 = s1_pos;
  }
#line 168
  s1_len = (size_t )(tmp___4 - s1);
#line 169
  if (s2_suffix) {
#line 169
    tmp___5 = s2_suffix;
  } else {
#line 169
    tmp___5 = s2_pos;
  }
#line 169
  s2_len = (size_t )(tmp___5 - s2);
#line 172
  if (s1_suffix) {
#line 172
    goto _L;
  } else
#line 172
  if (s2_suffix) {
    _L: /* CIL Label */ 
#line 172
    if (s1_len == s2_len) {
#line 172
      tmp___6 = strncmp(s1, s2, s1_len);
#line 172
      if (0 == tmp___6) {
#line 175
        s1_len = (size_t )(s1_pos - s1);
#line 176
        s2_len = (size_t )(s2_pos - s2);
      }
    }
  }
#line 179
  result = verrevcmp(s1, s1_len, s2, s2_len);
#line 180
  if (result == 0) {
#line 180
    tmp___7 = simple_cmp;
  } else {
#line 180
    tmp___7 = result;
  }
#line 180
  return (tmp___7);
}
}
#line 1 "cil-WIsmBhpQ.o"
#pragma merger("0","../lib/fopen-safer.o.i","")
#line 306 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 23 "/home/wslee/project/coreutils-8.1/lib/stdio-safer.h"
FILE *fopen_safer(char const   *file , char const   *mode ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/fopen-safer.c"
FILE *fopen_safer(char const   *file , char const   *mode ) 
{ 
  FILE *fp ;
  FILE *tmp ;
  int fd ;
  int tmp___0 ;
  int f ;
  int tmp___1 ;
  int e ;
  int *tmp___2 ;
  int *tmp___3 ;
  int e___0 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 34
  tmp = fopen((char const   * __restrict  )file, (char const   * __restrict  )mode);
#line 34
  fp = tmp;
#line 36
  if (fp) {
#line 38
    tmp___0 = fileno(fp);
#line 38
    fd = tmp___0;
#line 40
    if (0 <= fd) {
#line 40
      if (fd <= 2) {
#line 42
        tmp___1 = dup_safer(fd);
#line 42
        f = tmp___1;
#line 44
        if (f < 0) {
#line 46
          tmp___2 = __errno_location();
#line 46
          e = *tmp___2;
#line 47
          fclose(fp);
#line 48
          tmp___3 = __errno_location();
#line 48
          *tmp___3 = e;
#line 49
          return ((FILE *)((void *)0));
        }
#line 52
        tmp___6 = fclose(fp);
#line 52
        if (tmp___6 != 0) {
#line 52
          goto _L;
        } else {
#line 52
          fp = fdopen(f, mode);
#line 52
          if (! fp) {
            _L: /* CIL Label */ 
#line 55
            tmp___4 = __errno_location();
#line 55
            e___0 = *tmp___4;
#line 56
            close(f);
#line 57
            tmp___5 = __errno_location();
#line 57
            *tmp___5 = e___0;
#line 58
            return ((FILE *)((void *)0));
          }
        }
      }
    }
  }
#line 63
  return (fp);
}
}
#line 1 "cil-hoGqTGRa.o"
#pragma merger("0","../lib/fprintftime.o.i","")
#line 35 "/home/wslee/project/coreutils-8.1/lib/ignore-value.h"
__inline static void ignore_value(int i ) 
{ 


  {
#line 35
  return;
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 296 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
static void fwrite_lowcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 299
  while (1) {
#line 299
    tmp___0 = len;
#line 299
    len --;
#line 299
    if (! (tmp___0 > 0UL)) {
#line 299
      break;
    }
#line 301
    tmp = tolower((int )((unsigned char )*src));
#line 301
    fputc(tmp, fp);
#line 302
    src ++;
  }
#line 304
  return;
}
}
#line 306 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
static void fwrite_uppcase(FILE *fp , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 309
  while (1) {
#line 309
    tmp___0 = len;
#line 309
    len --;
#line 309
    if (! (tmp___0 > 0UL)) {
#line 309
      break;
    }
#line 311
    tmp = toupper((int )((unsigned char )*src));
#line 311
    fputc(tmp, fp);
#line 312
    src ++;
  }
#line 314
  return;
}
}
#line 372 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
__inline static int iso_week_days(int yday , int wday ) 
{ 
  int big_enough_multiple_of_7 ;

  {
#line 378
  big_enough_multiple_of_7 = 378;
#line 379
  return (((yday - (((yday - wday) + 4) + big_enough_multiple_of_7) % 7) + 4) - 1);
}
}
#line 420 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
static size_t strftime_case_(_Bool upcase , FILE *s , char const   *format , struct tm  const  *tp ,
                             int ut , int ns ) 
{ 
  size_t maxsize ;
  int hour12 ;
  char const   *zone ;
  size_t i ;
  FILE *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___0[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  size_t _i ;
  size_t _i___0 ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t _i___1 ;
  size_t _i___2 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  size_t _i___3 ;
  size_t _i___4 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  size_t _i___5 ;
  size_t _i___6 ;
  size_t tmp___9 ;
  int century ;
  int tmp___10 ;
  int tmp___11 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___12 ;
  size_t _i___7 ;
  size_t _i___8 ;
  int padding ;
  size_t _i___9 ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___13 ;
  size_t _i___10 ;
  size_t _i___11 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___14 ;
  size_t _i___12 ;
  size_t _i___13 ;
  size_t _i___14 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___15 ;
  size_t _i___15 ;
  size_t _i___16 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___16 ;
  size_t _i___17 ;
  size_t _i___18 ;
  size_t tmp___17 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___18 ;
  size_t _i___19 ;
  size_t _i___20 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___19 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___20 ;
  size_t _i___21 ;
  size_t _i___22 ;
  int year___0 ;
  int tmp___21 ;
  int year_adjust ;
  int days ;
  int tmp___22 ;
  int tmp___23 ;
  int d___0 ;
  int tmp___24 ;
  int tmp___25 ;
  int yy ;
  int tmp___26 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___27 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___28 ;
  size_t _i___23 ;
  size_t _i___24 ;
  size_t tmp___29 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___30 ;
  size_t _i___25 ;
  size_t _i___26 ;
  size_t tmp___31 ;

  {
#line 430
  maxsize = (size_t )-1;
#line 433
  hour12 = (int )tp->tm_hour;
#line 458
  i = (size_t )0;
#line 459
  p = s;
#line 474
  zone = (char const   *)((void *)0);
#line 482
  zone = (char const   *)tp->tm_zone;
#line 500
  if (hour12 > 12) {
#line 501
    hour12 -= 12;
  } else
#line 503
  if (hour12 == 0) {
#line 504
    hour12 = 12;
  }
#line 506
  f = format;
#line 506
  while ((int const   )*f != 0) {
#line 508
    pad = 0;
#line 510
    digits = 0;
#line 524
    width = -1;
#line 525
    to_lowcase = (_Bool)0;
#line 526
    to_uppcase = upcase;
#line 528
    change_case = (_Bool)0;
#line 611
    if ((int const   )*f != 37) {
#line 613
      while (1) {
#line 613
        _n = 1;
#line 613
        _delta = width - _n;
#line 613
        if (_delta > 0) {
#line 613
          tmp = _delta;
        } else {
#line 613
          tmp = 0;
        }
#line 613
        _incr = _n + tmp;
#line 613
        if ((size_t )_incr >= maxsize - i) {
#line 613
          return ((size_t )0);
        }
#line 613
        if (p) {
#line 613
          if (digits == 0) {
#line 613
            if (_delta > 0) {
#line 613
              if (pad == 48) {
#line 613
                while (1) {
#line 613
                  _i = (size_t )0;
#line 613
                  while (_i < (size_t )_delta) {
#line 613
                    fputc('0', p);
#line 613
                    _i ++;
                  }
#line 613
                  break;
                }
              } else {
#line 613
                while (1) {
#line 613
                  _i___0 = (size_t )0;
#line 613
                  while (_i___0 < (size_t )_delta) {
#line 613
                    fputc(' ', p);
#line 613
                    _i___0 ++;
                  }
#line 613
                  break;
                }
              }
            }
          }
#line 613
          fputc((int )*f, p);
        }
#line 613
        i += (size_t )_incr;
#line 613
        break;
      }
#line 614
      goto __Cont;
    }
#line 620
    while (1) {
#line 622
      f ++;
#line 622
      switch ((int const   )*f) {
      case 48: 
      case 45: 
      case 95: 
#line 628
      pad = (int )*f;
#line 629
      continue;
      case 94: 
#line 633
      to_uppcase = (_Bool)1;
#line 634
      continue;
      case 35: 
#line 636
      change_case = (_Bool)1;
#line 637
      continue;
      default: 
#line 640
      break;
      }
#line 642
      break;
    }
#line 646
    if ((unsigned int )*f - 48U <= 9U) {
#line 648
      width = 0;
#line 649
      while (1) {
#line 651
        if (width > 214748364) {
#line 654
          width = 2147483647;
        } else
#line 651
        if (width == 214748364) {
#line 651
          if ((int const   )*f - 48 > 7) {
#line 654
            width = 2147483647;
          } else {
#line 657
            width *= 10;
#line 658
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 657
          width *= 10;
#line 658
          width += (int )((int const   )*f - 48);
        }
#line 660
        f ++;
#line 649
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 649
          break;
        }
      }
    }
#line 666
    switch ((int const   )*f) {
    case 79: 
    case 69: 
#line 670
    tmp___0 = f;
#line 670
    f ++;
#line 670
    modifier = (int )*tmp___0;
#line 671
    break;
    default: 
#line 674
    modifier = 0;
#line 675
    break;
    }
#line 679
    format_char = (int )*f;
#line 680
    switch (format_char) {
    case 37: 
#line 703
    if (modifier != 0) {
#line 704
      goto bad_format;
    }
#line 705
    while (1) {
#line 705
      _n___0 = 1;
#line 705
      _delta___0 = width - _n___0;
#line 705
      if (_delta___0 > 0) {
#line 705
        tmp___1 = _delta___0;
      } else {
#line 705
        tmp___1 = 0;
      }
#line 705
      _incr___0 = _n___0 + tmp___1;
#line 705
      if ((size_t )_incr___0 >= maxsize - i) {
#line 705
        return ((size_t )0);
      }
#line 705
      if (p) {
#line 705
        if (digits == 0) {
#line 705
          if (_delta___0 > 0) {
#line 705
            if (pad == 48) {
#line 705
              while (1) {
#line 705
                _i___1 = (size_t )0;
#line 705
                while (_i___1 < (size_t )_delta___0) {
#line 705
                  fputc('0', p);
#line 705
                  _i___1 ++;
                }
#line 705
                break;
              }
            } else {
#line 705
              while (1) {
#line 705
                _i___2 = (size_t )0;
#line 705
                while (_i___2 < (size_t )_delta___0) {
#line 705
                  fputc(' ', p);
#line 705
                  _i___2 ++;
                }
#line 705
                break;
              }
            }
          }
        }
#line 705
        fputc((int )*f, p);
      }
#line 705
      i += (size_t )_incr___0;
#line 705
      break;
    }
#line 706
    break;
    case 97: 
#line 709
    if (modifier != 0) {
#line 710
      goto bad_format;
    }
#line 711
    if (change_case) {
#line 713
      to_uppcase = (_Bool)1;
#line 714
      to_lowcase = (_Bool)0;
    }
#line 720
    goto underlying_strftime;
    case 65: 
#line 724
    if (modifier != 0) {
#line 725
      goto bad_format;
    }
#line 726
    if (change_case) {
#line 728
      to_uppcase = (_Bool)1;
#line 729
      to_lowcase = (_Bool)0;
    }
#line 735
    goto underlying_strftime;
    case 104: 
    case 98: 
#line 740
    if (change_case) {
#line 742
      to_uppcase = (_Bool)1;
#line 743
      to_lowcase = (_Bool)0;
    }
#line 745
    if (modifier != 0) {
#line 746
      goto bad_format;
    }
#line 751
    goto underlying_strftime;
    case 66: 
#line 755
    if (modifier != 0) {
#line 756
      goto bad_format;
    }
#line 757
    if (change_case) {
#line 759
      to_uppcase = (_Bool)1;
#line 760
      to_lowcase = (_Bool)0;
    }
#line 766
    goto underlying_strftime;
    case 99: 
#line 770
    if (modifier == 79) {
#line 771
      goto bad_format;
    }
#line 780
    goto underlying_strftime;
    subformat: 
#line 785
    tmp___2 = strftime_case_(to_uppcase, (FILE *)((void *)0), subfmt, tp, ut, ns);
#line 785
    len = tmp___2;
#line 789
    while (1) {
#line 789
      _n___1 = (int )len;
#line 789
      _delta___1 = width - _n___1;
#line 789
      if (_delta___1 > 0) {
#line 789
        tmp___3 = _delta___1;
      } else {
#line 789
        tmp___3 = 0;
      }
#line 789
      _incr___1 = _n___1 + tmp___3;
#line 789
      if ((size_t )_incr___1 >= maxsize - i) {
#line 789
        return ((size_t )0);
      }
#line 789
      if (p) {
#line 789
        if (digits == 0) {
#line 789
          if (_delta___1 > 0) {
#line 789
            if (pad == 48) {
#line 789
              while (1) {
#line 789
                _i___3 = (size_t )0;
#line 789
                while (_i___3 < (size_t )_delta___1) {
#line 789
                  fputc('0', p);
#line 789
                  _i___3 ++;
                }
#line 789
                break;
              }
            } else {
#line 789
              while (1) {
#line 789
                _i___4 = (size_t )0;
#line 789
                while (_i___4 < (size_t )_delta___1) {
#line 789
                  fputc(' ', p);
#line 789
                  _i___4 ++;
                }
#line 789
                break;
              }
            }
          }
        }
#line 789
        strftime_case_(to_uppcase, p, subfmt, tp, ut, ns);
      }
#line 789
      i += (size_t )_incr___1;
#line 789
      break;
    }
#line 794
    break;
    underlying_strftime: 
#line 802
    u = ufmt;
#line 815
    tmp___4 = u;
#line 815
    u ++;
#line 815
    *tmp___4 = (char )' ';
#line 816
    tmp___5 = u;
#line 816
    u ++;
#line 816
    *tmp___5 = (char )'%';
#line 817
    if (modifier != 0) {
#line 818
      tmp___6 = u;
#line 818
      u ++;
#line 818
      *tmp___6 = (char )modifier;
    }
#line 819
    tmp___7 = u;
#line 819
    u ++;
#line 819
    *tmp___7 = (char )format_char;
#line 820
    *u = (char )'\000';
#line 821
    len___0 = strftime((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )(ufmt),
                       (struct tm  const  * __restrict  )tp);
#line 822
    if (len___0 != 0UL) {
#line 823
      while (1) {
#line 823
        _n___2 = (int )(len___0 - 1UL);
#line 823
        _delta___2 = width - _n___2;
#line 823
        if (_delta___2 > 0) {
#line 823
          tmp___8 = _delta___2;
        } else {
#line 823
          tmp___8 = 0;
        }
#line 823
        _incr___2 = _n___2 + tmp___8;
#line 823
        if ((size_t )_incr___2 >= maxsize - i) {
#line 823
          return ((size_t )0);
        }
#line 823
        if (p) {
#line 823
          if (digits == 0) {
#line 823
            if (_delta___2 > 0) {
#line 823
              if (pad == 48) {
#line 823
                while (1) {
#line 823
                  _i___5 = (size_t )0;
#line 823
                  while (_i___5 < (size_t )_delta___2) {
#line 823
                    fputc('0', p);
#line 823
                    _i___5 ++;
                  }
#line 823
                  break;
                }
              } else {
#line 823
                while (1) {
#line 823
                  _i___6 = (size_t )0;
#line 823
                  while (_i___6 < (size_t )_delta___2) {
#line 823
                    fputc(' ', p);
#line 823
                    _i___6 ++;
                  }
#line 823
                  break;
                }
              }
            }
          }
#line 823
          while (1) {
#line 823
            if (to_lowcase) {
#line 823
              fwrite_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            } else
#line 823
            if (to_uppcase) {
#line 823
              fwrite_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
            } else {
#line 823
              tmp___9 = fwrite((void const   * __restrict  )(ubuf + 1), (size_t )_n___2,
                               (size_t )1, (FILE * __restrict  )p);
#line 823
              ignore_value((int )tmp___9);
            }
#line 823
            break;
          }
        }
#line 823
        i += (size_t )_incr___2;
#line 823
        break;
      }
    }
#line 825
    break;
    case 67: 
#line 829
    if (modifier == 79) {
#line 830
      goto bad_format;
    }
#line 831
    if (modifier == 69) {
#line 847
      goto underlying_strftime;
    }
#line 852
    century = (int )(tp->tm_year / 100 + 19);
#line 853
    if (tp->tm_year % 100 < 0) {
#line 853
      if (0 < century) {
#line 853
        tmp___10 = 1;
      } else {
#line 853
        tmp___10 = 0;
      }
    } else {
#line 853
      tmp___10 = 0;
    }
#line 853
    century -= tmp___10;
#line 854
    digits = 2;
#line 854
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 854
    u_number_value = (unsigned int )century;
#line 854
    goto do_signed_number;
    case 120: 
#line 858
    if (modifier == 79) {
#line 859
      goto bad_format;
    }
#line 868
    goto underlying_strftime;
    case 68: 
#line 871
    if (modifier != 0) {
#line 872
      goto bad_format;
    }
#line 873
    subfmt = "%m/%d/%y";
#line 874
    goto subformat;
    case 100: 
#line 877
    if (modifier == 69) {
#line 878
      goto bad_format;
    }
#line 880
    digits = 2;
#line 880
    number_value = (int )tp->tm_mday;
#line 880
    goto do_number;
    case 101: 
#line 883
    if (modifier == 69) {
#line 884
      goto bad_format;
    }
#line 886
    digits = 2;
#line 886
    number_value = (int )tp->tm_mday;
#line 886
    goto do_number_spacepad;
    do_tz_offset: 
#line 892
    always_output_a_sign = (_Bool)1;
#line 893
    goto do_number_body;
    do_number_spacepad: 
#line 897
    if (pad != 48) {
#line 897
      if (pad != 45) {
#line 898
        pad = '_';
      }
    }
    do_number: 
#line 902
    negative_number = (_Bool )(number_value < 0);
#line 903
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 906
    always_output_a_sign = (_Bool)0;
#line 907
    tz_colon_mask = 0;
    do_number_body: 
#line 915
    if (modifier == 79) {
#line 915
      if (! negative_number) {
#line 933
        goto underlying_strftime;
      }
    }
#line 937
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 939
    if (negative_number) {
#line 940
      u_number_value = - u_number_value;
    }
#line 942
    while (1) {
#line 944
      if (tz_colon_mask & 1) {
#line 945
        bufp --;
#line 945
        *bufp = (char )':';
      }
#line 946
      tz_colon_mask >>= 1;
#line 947
      bufp --;
#line 947
      *bufp = (char )(u_number_value % 10U + 48U);
#line 948
      u_number_value /= 10U;
#line 942
      if (! (u_number_value != 0U)) {
#line 942
        if (! (tz_colon_mask != 0)) {
#line 942
          break;
        }
      }
    }
    do_number_sign_and_padding: 
#line 953
    if (digits < width) {
#line 954
      digits = width;
    }
#line 956
    if (negative_number) {
#line 956
      sign_char = (char )'-';
    } else {
#line 956
      if (always_output_a_sign) {
#line 956
        tmp___11 = '+';
      } else {
#line 956
        tmp___11 = 0;
      }
#line 956
      sign_char = (char )tmp___11;
    }
#line 960
    if (pad == 45) {
#line 962
      if (sign_char) {
#line 963
        while (1) {
#line 963
          _n___3 = 1;
#line 963
          _delta___3 = width - _n___3;
#line 963
          if (_delta___3 > 0) {
#line 963
            tmp___12 = _delta___3;
          } else {
#line 963
            tmp___12 = 0;
          }
#line 963
          _incr___3 = _n___3 + tmp___12;
#line 963
          if ((size_t )_incr___3 >= maxsize - i) {
#line 963
            return ((size_t )0);
          }
#line 963
          if (p) {
#line 963
            if (digits == 0) {
#line 963
              if (_delta___3 > 0) {
#line 963
                if (pad == 48) {
#line 963
                  while (1) {
#line 963
                    _i___7 = (size_t )0;
#line 963
                    while (_i___7 < (size_t )_delta___3) {
#line 963
                      fputc('0', p);
#line 963
                      _i___7 ++;
                    }
#line 963
                    break;
                  }
                } else {
#line 963
                  while (1) {
#line 963
                    _i___8 = (size_t )0;
#line 963
                    while (_i___8 < (size_t )_delta___3) {
#line 963
                      fputc(' ', p);
#line 963
                      _i___8 ++;
                    }
#line 963
                    break;
                  }
                }
              }
            }
#line 963
            fputc((int )sign_char, p);
          }
#line 963
          i += (size_t )_incr___3;
#line 963
          break;
        }
      }
    } else {
#line 967
      padding = (int )(((long )digits - ((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp)) - (long )(! (! sign_char)));
#line 970
      if (padding > 0) {
#line 972
        if (pad == 95) {
#line 974
          if ((size_t )padding >= maxsize - i) {
#line 975
            return ((size_t )0);
          }
#line 977
          if (p) {
#line 978
            while (1) {
#line 978
              _i___9 = (size_t )0;
#line 978
              while (_i___9 < (size_t )padding) {
#line 978
                fputc(' ', p);
#line 978
                _i___9 ++;
              }
#line 978
              break;
            }
          }
#line 979
          i += (size_t )padding;
#line 980
          if (width > padding) {
#line 980
            width -= padding;
          } else {
#line 980
            width = 0;
          }
#line 981
          if (sign_char) {
#line 982
            while (1) {
#line 982
              _n___4 = 1;
#line 982
              _delta___4 = width - _n___4;
#line 982
              if (_delta___4 > 0) {
#line 982
                tmp___13 = _delta___4;
              } else {
#line 982
                tmp___13 = 0;
              }
#line 982
              _incr___4 = _n___4 + tmp___13;
#line 982
              if ((size_t )_incr___4 >= maxsize - i) {
#line 982
                return ((size_t )0);
              }
#line 982
              if (p) {
#line 982
                if (digits == 0) {
#line 982
                  if (_delta___4 > 0) {
#line 982
                    if (pad == 48) {
#line 982
                      while (1) {
#line 982
                        _i___10 = (size_t )0;
#line 982
                        while (_i___10 < (size_t )_delta___4) {
#line 982
                          fputc('0', p);
#line 982
                          _i___10 ++;
                        }
#line 982
                        break;
                      }
                    } else {
#line 982
                      while (1) {
#line 982
                        _i___11 = (size_t )0;
#line 982
                        while (_i___11 < (size_t )_delta___4) {
#line 982
                          fputc(' ', p);
#line 982
                          _i___11 ++;
                        }
#line 982
                        break;
                      }
                    }
                  }
                }
#line 982
                fputc((int )sign_char, p);
              }
#line 982
              i += (size_t )_incr___4;
#line 982
              break;
            }
          }
        } else {
#line 986
          if ((size_t )digits >= maxsize - i) {
#line 987
            return ((size_t )0);
          }
#line 989
          if (sign_char) {
#line 990
            while (1) {
#line 990
              _n___5 = 1;
#line 990
              _delta___5 = width - _n___5;
#line 990
              if (_delta___5 > 0) {
#line 990
                tmp___14 = _delta___5;
              } else {
#line 990
                tmp___14 = 0;
              }
#line 990
              _incr___5 = _n___5 + tmp___14;
#line 990
              if ((size_t )_incr___5 >= maxsize - i) {
#line 990
                return ((size_t )0);
              }
#line 990
              if (p) {
#line 990
                if (digits == 0) {
#line 990
                  if (_delta___5 > 0) {
#line 990
                    if (pad == 48) {
#line 990
                      while (1) {
#line 990
                        _i___12 = (size_t )0;
#line 990
                        while (_i___12 < (size_t )_delta___5) {
#line 990
                          fputc('0', p);
#line 990
                          _i___12 ++;
                        }
#line 990
                        break;
                      }
                    } else {
#line 990
                      while (1) {
#line 990
                        _i___13 = (size_t )0;
#line 990
                        while (_i___13 < (size_t )_delta___5) {
#line 990
                          fputc(' ', p);
#line 990
                          _i___13 ++;
                        }
#line 990
                        break;
                      }
                    }
                  }
                }
#line 990
                fputc((int )sign_char, p);
              }
#line 990
              i += (size_t )_incr___5;
#line 990
              break;
            }
          }
#line 992
          if (p) {
#line 993
            while (1) {
#line 993
              _i___14 = (size_t )0;
#line 993
              while (_i___14 < (size_t )padding) {
#line 993
                fputc('0', p);
#line 993
                _i___14 ++;
              }
#line 993
              break;
            }
          }
#line 994
          i += (size_t )padding;
#line 995
          width = 0;
        }
      } else
#line 1000
      if (sign_char) {
#line 1001
        while (1) {
#line 1001
          _n___6 = 1;
#line 1001
          _delta___6 = width - _n___6;
#line 1001
          if (_delta___6 > 0) {
#line 1001
            tmp___15 = _delta___6;
          } else {
#line 1001
            tmp___15 = 0;
          }
#line 1001
          _incr___6 = _n___6 + tmp___15;
#line 1001
          if ((size_t )_incr___6 >= maxsize - i) {
#line 1001
            return ((size_t )0);
          }
#line 1001
          if (p) {
#line 1001
            if (digits == 0) {
#line 1001
              if (_delta___6 > 0) {
#line 1001
                if (pad == 48) {
#line 1001
                  while (1) {
#line 1001
                    _i___15 = (size_t )0;
#line 1001
                    while (_i___15 < (size_t )_delta___6) {
#line 1001
                      fputc('0', p);
#line 1001
                      _i___15 ++;
                    }
#line 1001
                    break;
                  }
                } else {
#line 1001
                  while (1) {
#line 1001
                    _i___16 = (size_t )0;
#line 1001
                    while (_i___16 < (size_t )_delta___6) {
#line 1001
                      fputc(' ', p);
#line 1001
                      _i___16 ++;
                    }
#line 1001
                    break;
                  }
                }
              }
            }
#line 1001
            fputc((int )sign_char, p);
          }
#line 1001
          i += (size_t )_incr___6;
#line 1001
          break;
        }
      }
    }
#line 1005
    while (1) {
#line 1005
      _n___7 = (int )((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp);
#line 1005
      _delta___7 = width - _n___7;
#line 1005
      if (_delta___7 > 0) {
#line 1005
        tmp___16 = _delta___7;
      } else {
#line 1005
        tmp___16 = 0;
      }
#line 1005
      _incr___7 = _n___7 + tmp___16;
#line 1005
      if ((size_t )_incr___7 >= maxsize - i) {
#line 1005
        return ((size_t )0);
      }
#line 1005
      if (p) {
#line 1005
        if (digits == 0) {
#line 1005
          if (_delta___7 > 0) {
#line 1005
            if (pad == 48) {
#line 1005
              while (1) {
#line 1005
                _i___17 = (size_t )0;
#line 1005
                while (_i___17 < (size_t )_delta___7) {
#line 1005
                  fputc('0', p);
#line 1005
                  _i___17 ++;
                }
#line 1005
                break;
              }
            } else {
#line 1005
              while (1) {
#line 1005
                _i___18 = (size_t )0;
#line 1005
                while (_i___18 < (size_t )_delta___7) {
#line 1005
                  fputc(' ', p);
#line 1005
                  _i___18 ++;
                }
#line 1005
                break;
              }
            }
          }
        }
#line 1005
        while (1) {
#line 1005
          if (to_lowcase) {
#line 1005
            fwrite_lowcase(p, (char const   *)bufp, (size_t )_n___7);
          } else
#line 1005
          if (to_uppcase) {
#line 1005
            fwrite_uppcase(p, (char const   *)bufp, (size_t )_n___7);
          } else {
#line 1005
            tmp___17 = fwrite((void const   * __restrict  )bufp, (size_t )_n___7,
                              (size_t )1, (FILE * __restrict  )p);
#line 1005
            ignore_value((int )tmp___17);
          }
#line 1005
          break;
        }
      }
#line 1005
      i += (size_t )_incr___7;
#line 1005
      break;
    }
#line 1006
    break;
    case 70: 
#line 1009
    if (modifier != 0) {
#line 1010
      goto bad_format;
    }
#line 1011
    subfmt = "%Y-%m-%d";
#line 1012
    goto subformat;
    case 72: 
#line 1015
    if (modifier == 69) {
#line 1016
      goto bad_format;
    }
#line 1018
    digits = 2;
#line 1018
    number_value = (int )tp->tm_hour;
#line 1018
    goto do_number;
    case 73: 
#line 1021
    if (modifier == 69) {
#line 1022
      goto bad_format;
    }
#line 1024
    digits = 2;
#line 1024
    number_value = hour12;
#line 1024
    goto do_number;
    case 107: 
#line 1027
    if (modifier == 69) {
#line 1028
      goto bad_format;
    }
#line 1030
    digits = 2;
#line 1030
    number_value = (int )tp->tm_hour;
#line 1030
    goto do_number_spacepad;
    case 108: 
#line 1033
    if (modifier == 69) {
#line 1034
      goto bad_format;
    }
#line 1036
    digits = 2;
#line 1036
    number_value = hour12;
#line 1036
    goto do_number_spacepad;
    case 106: 
#line 1039
    if (modifier == 69) {
#line 1040
      goto bad_format;
    }
#line 1042
    digits = 3;
#line 1042
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1042
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1042
    goto do_signed_number;
    case 77: 
#line 1045
    if (modifier == 69) {
#line 1046
      goto bad_format;
    }
#line 1048
    digits = 2;
#line 1048
    number_value = (int )tp->tm_min;
#line 1048
    goto do_number;
    case 109: 
#line 1051
    if (modifier == 69) {
#line 1052
      goto bad_format;
    }
#line 1054
    digits = 2;
#line 1054
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1054
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1054
    goto do_signed_number;
    case 78: 
#line 1058
    if (modifier == 69) {
#line 1059
      goto bad_format;
    }
#line 1061
    number_value = ns;
#line 1062
    if (width == -1) {
#line 1063
      width = 9;
    } else {
#line 1068
      j = width;
#line 1068
      while (j < 9) {
#line 1069
        number_value /= 10;
#line 1068
        j ++;
      }
    }
#line 1072
    digits = width;
#line 1072
    number_value = number_value;
#line 1072
    goto do_number;
    case 110: 
#line 1076
    while (1) {
#line 1076
      _n___8 = 1;
#line 1076
      _delta___8 = width - _n___8;
#line 1076
      if (_delta___8 > 0) {
#line 1076
        tmp___18 = _delta___8;
      } else {
#line 1076
        tmp___18 = 0;
      }
#line 1076
      _incr___8 = _n___8 + tmp___18;
#line 1076
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1076
        return ((size_t )0);
      }
#line 1076
      if (p) {
#line 1076
        if (digits == 0) {
#line 1076
          if (_delta___8 > 0) {
#line 1076
            if (pad == 48) {
#line 1076
              while (1) {
#line 1076
                _i___19 = (size_t )0;
#line 1076
                while (_i___19 < (size_t )_delta___8) {
#line 1076
                  fputc('0', p);
#line 1076
                  _i___19 ++;
                }
#line 1076
                break;
              }
            } else {
#line 1076
              while (1) {
#line 1076
                _i___20 = (size_t )0;
#line 1076
                while (_i___20 < (size_t )_delta___8) {
#line 1076
                  fputc(' ', p);
#line 1076
                  _i___20 ++;
                }
#line 1076
                break;
              }
            }
          }
        }
#line 1076
        fputc('\n', p);
      }
#line 1076
      i += (size_t )_incr___8;
#line 1076
      break;
    }
#line 1077
    break;
    case 80: 
#line 1080
    to_lowcase = (_Bool)1;
#line 1082
    format_char = 'p';
    case 112: 
#line 1087
    if (change_case) {
#line 1089
      to_uppcase = (_Bool)0;
#line 1090
      to_lowcase = (_Bool)1;
    }
#line 1096
    goto underlying_strftime;
    case 82: 
#line 1100
    subfmt = "%H:%M";
#line 1101
    goto subformat;
    case 114: 
#line 1111
    goto underlying_strftime;
    case 83: 
#line 1115
    if (modifier == 69) {
#line 1116
      goto bad_format;
    }
#line 1118
    digits = 2;
#line 1118
    number_value = (int )tp->tm_sec;
#line 1118
    goto do_number;
    case 115: 
#line 1125
    ltm = (struct tm )*tp;
#line 1126
    t = mktime(& ltm);
#line 1131
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 1132
    negative_number = (_Bool )(t < 0L);
#line 1134
    while (1) {
#line 1136
      d = (int )(t % 10L);
#line 1137
      t /= 10L;
#line 1138
      bufp --;
#line 1138
      if (negative_number) {
#line 1138
        tmp___19 = - d;
      } else {
#line 1138
        tmp___19 = d;
      }
#line 1138
      *bufp = (char )(tmp___19 + 48);
#line 1134
      if (! (t != 0L)) {
#line 1134
        break;
      }
    }
#line 1142
    digits = 1;
#line 1143
    always_output_a_sign = (_Bool)0;
#line 1144
    goto do_number_sign_and_padding;
    case 88: 
#line 1148
    if (modifier == 79) {
#line 1149
      goto bad_format;
    }
#line 1158
    goto underlying_strftime;
    case 84: 
#line 1161
    subfmt = "%H:%M:%S";
#line 1162
    goto subformat;
    case 116: 
#line 1165
    while (1) {
#line 1165
      _n___9 = 1;
#line 1165
      _delta___9 = width - _n___9;
#line 1165
      if (_delta___9 > 0) {
#line 1165
        tmp___20 = _delta___9;
      } else {
#line 1165
        tmp___20 = 0;
      }
#line 1165
      _incr___9 = _n___9 + tmp___20;
#line 1165
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1165
        return ((size_t )0);
      }
#line 1165
      if (p) {
#line 1165
        if (digits == 0) {
#line 1165
          if (_delta___9 > 0) {
#line 1165
            if (pad == 48) {
#line 1165
              while (1) {
#line 1165
                _i___21 = (size_t )0;
#line 1165
                while (_i___21 < (size_t )_delta___9) {
#line 1165
                  fputc('0', p);
#line 1165
                  _i___21 ++;
                }
#line 1165
                break;
              }
            } else {
#line 1165
              while (1) {
#line 1165
                _i___22 = (size_t )0;
#line 1165
                while (_i___22 < (size_t )_delta___9) {
#line 1165
                  fputc(' ', p);
#line 1165
                  _i___22 ++;
                }
#line 1165
                break;
              }
            }
          }
        }
#line 1165
        fputc('\t', p);
      }
#line 1165
      i += (size_t )_incr___9;
#line 1165
      break;
    }
#line 1166
    break;
    case 117: 
#line 1169
    digits = 1;
#line 1169
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1169
    goto do_number;
    case 85: 
#line 1172
    if (modifier == 69) {
#line 1173
      goto bad_format;
    }
#line 1175
    digits = 2;
#line 1175
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1175
    goto do_number;
    case 71: 
    case 103: 
    case 86: 
#line 1180
    if (modifier == 69) {
#line 1181
      goto bad_format;
    }
#line 1187
    if (tp->tm_year < 0) {
#line 1187
      tmp___21 = 300;
    } else {
#line 1187
      tmp___21 = -100;
    }
#line 1187
    year___0 = (int )(tp->tm_year + (int const   )tmp___21);
#line 1191
    year_adjust = 0;
#line 1192
    tmp___22 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1192
    days = tmp___22;
#line 1194
    if (days < 0) {
#line 1197
      year_adjust = -1;
#line 1198
      if ((year___0 - 1) % 4 == 0) {
#line 1198
        if ((year___0 - 1) % 100 != 0) {
#line 1198
          tmp___23 = 1;
        } else
#line 1198
        if ((year___0 - 1) % 400 == 0) {
#line 1198
          tmp___23 = 1;
        } else {
#line 1198
          tmp___23 = 0;
        }
      } else {
#line 1198
        tmp___23 = 0;
      }
#line 1198
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___23)), (int )tp->tm_wday);
    } else {
#line 1203
      if (year___0 % 4 == 0) {
#line 1203
        if (year___0 % 100 != 0) {
#line 1203
          tmp___24 = 1;
        } else
#line 1203
        if (year___0 % 400 == 0) {
#line 1203
          tmp___24 = 1;
        } else {
#line 1203
          tmp___24 = 0;
        }
      } else {
#line 1203
        tmp___24 = 0;
      }
#line 1203
      tmp___25 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___24)),
                               (int )tp->tm_wday);
#line 1203
      d___0 = tmp___25;
#line 1205
      if (0 <= d___0) {
#line 1208
        year_adjust = 1;
#line 1209
        days = d___0;
      }
    }
#line 1213
    switch ((int const   )*f) {
    case 103: 
#line 1217
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1218
    digits = 2;
#line 1218
    if (0 <= yy) {
#line 1218
      number_value = yy;
    } else {
#line 1218
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1218
        tmp___26 = - yy;
      } else {
#line 1218
        tmp___26 = yy + 100;
      }
#line 1218
      number_value = tmp___26;
    }
#line 1218
    goto do_number;
    case 71: 
#line 1226
    digits = 4;
#line 1226
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1226
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1226
    goto do_signed_number;
    default: 
#line 1231
    digits = 2;
#line 1231
    number_value = days / 7 + 1;
#line 1231
    goto do_number;
    }
    case 87: 
#line 1236
    if (modifier == 69) {
#line 1237
      goto bad_format;
    }
#line 1239
    digits = 2;
#line 1239
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1239
    goto do_number;
    case 119: 
#line 1242
    if (modifier == 69) {
#line 1243
      goto bad_format;
    }
#line 1245
    digits = 1;
#line 1245
    number_value = (int )tp->tm_wday;
#line 1245
    goto do_number;
    case 89: 
#line 1248
    if (modifier == 69) {
#line 1262
      goto underlying_strftime;
    }
#line 1265
    if (modifier == 79) {
#line 1266
      goto bad_format;
    } else {
#line 1268
      digits = 4;
    }
#line 1268
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1268
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1268
    goto do_signed_number;
    case 121: 
#line 1272
    if (modifier == 69) {
#line 1283
      goto underlying_strftime;
    }
#line 1288
    yy___0 = (int )(tp->tm_year % 100);
#line 1289
    if (yy___0 < 0) {
#line 1290
      if (tp->tm_year < -1900) {
#line 1290
        yy___0 = - yy___0;
      } else {
#line 1290
        yy___0 += 100;
      }
    }
#line 1291
    digits = 2;
#line 1291
    number_value = yy___0;
#line 1291
    goto do_number;
    case 90: 
#line 1295
    if (change_case) {
#line 1297
      to_uppcase = (_Bool)0;
#line 1298
      to_lowcase = (_Bool)1;
    }
#line 1306
    if (! zone) {
#line 1307
      zone = "";
    }
#line 1319
    while (1) {
#line 1319
      tmp___27 = strlen(zone);
#line 1319
      _n___10 = (int )tmp___27;
#line 1319
      _delta___10 = width - _n___10;
#line 1319
      if (_delta___10 > 0) {
#line 1319
        tmp___28 = _delta___10;
      } else {
#line 1319
        tmp___28 = 0;
      }
#line 1319
      _incr___10 = _n___10 + tmp___28;
#line 1319
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1319
        return ((size_t )0);
      }
#line 1319
      if (p) {
#line 1319
        if (digits == 0) {
#line 1319
          if (_delta___10 > 0) {
#line 1319
            if (pad == 48) {
#line 1319
              while (1) {
#line 1319
                _i___23 = (size_t )0;
#line 1319
                while (_i___23 < (size_t )_delta___10) {
#line 1319
                  fputc('0', p);
#line 1319
                  _i___23 ++;
                }
#line 1319
                break;
              }
            } else {
#line 1319
              while (1) {
#line 1319
                _i___24 = (size_t )0;
#line 1319
                while (_i___24 < (size_t )_delta___10) {
#line 1319
                  fputc(' ', p);
#line 1319
                  _i___24 ++;
                }
#line 1319
                break;
              }
            }
          }
        }
#line 1319
        while (1) {
#line 1319
          if (to_lowcase) {
#line 1319
            fwrite_lowcase(p, zone, (size_t )_n___10);
          } else
#line 1319
          if (to_uppcase) {
#line 1319
            fwrite_uppcase(p, zone, (size_t )_n___10);
          } else {
#line 1319
            tmp___29 = fwrite((void const   * __restrict  )zone, (size_t )_n___10,
                              (size_t )1, (FILE * __restrict  )p);
#line 1319
            ignore_value((int )tmp___29);
          }
#line 1319
          break;
        }
      }
#line 1319
      i += (size_t )_incr___10;
#line 1319
      break;
    }
#line 1321
    break;
    case 58: 
#line 1326
    colons = (size_t )1;
#line 1326
    while ((int const   )*(f + colons) == 58) {
#line 1327
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1326
      colons ++;
    }
#line 1328
    if ((int const   )*(f + colons) != 122) {
#line 1329
      goto bad_format;
    }
#line 1330
    f += colons;
#line 1331
    goto do_z_conversion;
    case 122: 
#line 1334
    colons = (size_t )0;
    do_z_conversion: 
#line 1337
    if (tp->tm_isdst < 0) {
#line 1338
      break;
    }
#line 1346
    diff = (int )tp->tm_gmtoff;
#line 1383
    hour_diff = (diff / 60) / 60;
#line 1384
    min_diff = (diff / 60) % 60;
#line 1385
    sec_diff = diff % 60;
#line 1387
    switch (colons) {
    case 0UL: 
#line 1390
    digits = 5;
#line 1390
    negative_number = (_Bool )(diff < 0);
#line 1390
    tz_colon_mask = 0;
#line 1390
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1390
    goto do_tz_offset;
    tz_hh_mm: 
    case 1UL: 
#line 1393
    digits = 6;
#line 1393
    negative_number = (_Bool )(diff < 0);
#line 1393
    tz_colon_mask = 4;
#line 1393
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1393
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2UL: 
#line 1396
    digits = 9;
#line 1396
    negative_number = (_Bool )(diff < 0);
#line 1396
    tz_colon_mask = 20;
#line 1396
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1396
    goto do_tz_offset;
    case 3UL: 
#line 1400
    if (sec_diff != 0) {
#line 1401
      goto tz_hh_mm_ss;
    }
#line 1402
    if (min_diff != 0) {
#line 1403
      goto tz_hh_mm;
    }
#line 1404
    digits = 3;
#line 1404
    negative_number = (_Bool )(diff < 0);
#line 1404
    tz_colon_mask = 0;
#line 1404
    u_number_value = (unsigned int )hour_diff;
#line 1404
    goto do_tz_offset;
    default: 
#line 1407
    goto bad_format;
    }
    case 0: 
#line 1412
    f --;
    bad_format: 
    default: 
#line 1421
    flen = 1;
#line 1421
    while ((int const   )*(f + (1 - flen)) != 37) {
#line 1422
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1421
      flen ++;
    }
#line 1423
    while (1) {
#line 1423
      _n___11 = flen;
#line 1423
      _delta___11 = width - _n___11;
#line 1423
      if (_delta___11 > 0) {
#line 1423
        tmp___30 = _delta___11;
      } else {
#line 1423
        tmp___30 = 0;
      }
#line 1423
      _incr___11 = _n___11 + tmp___30;
#line 1423
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1423
        return ((size_t )0);
      }
#line 1423
      if (p) {
#line 1423
        if (digits == 0) {
#line 1423
          if (_delta___11 > 0) {
#line 1423
            if (pad == 48) {
#line 1423
              while (1) {
#line 1423
                _i___25 = (size_t )0;
#line 1423
                while (_i___25 < (size_t )_delta___11) {
#line 1423
                  fputc('0', p);
#line 1423
                  _i___25 ++;
                }
#line 1423
                break;
              }
            } else {
#line 1423
              while (1) {
#line 1423
                _i___26 = (size_t )0;
#line 1423
                while (_i___26 < (size_t )_delta___11) {
#line 1423
                  fputc(' ', p);
#line 1423
                  _i___26 ++;
                }
#line 1423
                break;
              }
            }
          }
        }
#line 1423
        while (1) {
#line 1423
          if (to_lowcase) {
#line 1423
            fwrite_lowcase(p, f + (1 - flen), (size_t )_n___11);
          } else
#line 1423
          if (to_uppcase) {
#line 1423
            fwrite_uppcase(p, f + (1 - flen), (size_t )_n___11);
          } else {
#line 1423
            tmp___31 = fwrite((void const   * __restrict  )(f + (1 - flen)), (size_t )_n___11,
                              (size_t )1, (FILE * __restrict  )p);
#line 1423
            ignore_value((int )tmp___31);
          }
#line 1423
          break;
        }
      }
#line 1423
      i += (size_t )_incr___11;
#line 1423
      break;
    }
#line 1425
    break;
    }
    __Cont: /* CIL Label */ 
#line 506
    f ++;
  }
#line 1434
  return (i);
}
}
#line 1443 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
size_t fprintftime(FILE *s , char const   *format , struct tm  const  *tp , int ut ,
                   int ns ) 
{ 
  size_t tmp ;

  {
#line 1448
  tmp = strftime_case_((_Bool)0, s, format, tp, ut, ns);
#line 1448
  return (tmp);
}
}
#line 1 "cil-99HMWAGg.o"
#pragma merger("0","../lib/fpurge.o.i","")
#line 194 "./stdio.h"
int fpurge(FILE *fp ) ;
#line 72 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) __fpurge)(FILE *__fp ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/fpurge.c"
int fpurge(FILE *fp ) 
{ 


  {
#line 34
  __fpurge(fp);
#line 36
  return (0);
}
}
#line 1 "cil-5MzbpK0_.o"
#pragma merger("0","../lib/freadahead.o.i","")
#line 25 "/home/wslee/project/coreutils-8.1/lib/freadahead.c"
size_t freadahead(FILE *fp ) 
{ 
  long tmp ;

  {
#line 29
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
#line 30
    return ((size_t )0);
  }
#line 31
  if (fp->_flags & 256) {
#line 31
    tmp = fp->_IO_save_end - fp->_IO_save_base;
  } else {
#line 31
    tmp = 0L;
  }
#line 31
  return ((size_t )((fp->_IO_read_end - fp->_IO_read_ptr) + tmp));
}
}
#line 1 "cil-XpLSdC6R.o"
#pragma merger("0","../lib/freading.o.i","")
#line 1 "cil-HGA4h3z_.o"
#pragma merger("0","../lib/freadptr.o.i","")
#line 35 "/home/wslee/project/coreutils-8.1/lib/freadptr.h"
char const   *freadptr(FILE *fp , size_t *sizep ) ;
#line 26 "/home/wslee/project/coreutils-8.1/lib/freadptr.c"
char const   *freadptr(FILE *fp , size_t *sizep ) 
{ 
  size_t size ;

  {
#line 33
  if ((unsigned long )fp->_IO_write_ptr > (unsigned long )fp->_IO_write_base) {
#line 34
    return ((char const   *)((void *)0));
  }
#line 35
  size = (size_t )(fp->_IO_read_end - fp->_IO_read_ptr);
#line 36
  if (size == 0UL) {
#line 37
    return ((char const   *)((void *)0));
  }
#line 38
  *sizep = size;
#line 39
  return ((char const   *)fp->_IO_read_ptr);
}
}
#line 1 "cil-54HxWLb8.o"
#pragma merger("0","../lib/freadseek.o.i","")
#line 531 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 38 "/home/wslee/project/coreutils-8.1/lib/freadseek.h"
int freadseek(FILE *fp , size_t offset ) ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/freadseek.c"
__inline static void freadptrinc(FILE *fp , size_t increment ) 
{ 


  {
#line 38
  fp->_IO_read_ptr += increment;
#line 62
  return;
}
}
#line 64 "/home/wslee/project/coreutils-8.1/lib/freadseek.c"
int freadseek(FILE *fp , size_t offset ) 
{ 
  size_t total_buffered ;
  int fd ;
  size_t buffered ;
  size_t increment ;
  size_t tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char buf___0[4096] ;
  size_t count ;
  unsigned long tmp___3 ;
  size_t tmp___4 ;
  __off_t tmp___5 ;
  int tmp___6 ;

  {
#line 70
  if (offset == 0UL) {
#line 71
    return (0);
  }
#line 75
  total_buffered = freadahead(fp);
#line 78
  while (total_buffered > 0UL) {
#line 82
    tmp___0 = freadptr(fp, & buffered);
#line 82
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 82
      if (buffered > 0UL) {
#line 84
        if (buffered < offset) {
#line 84
          tmp = buffered;
        } else {
#line 84
          tmp = offset;
        }
#line 84
        increment = tmp;
#line 86
        freadptrinc(fp, increment);
#line 87
        offset -= increment;
#line 88
        if (offset == 0UL) {
#line 89
          return (0);
        }
#line 90
        total_buffered -= increment;
#line 91
        if (total_buffered == 0UL) {
#line 92
          break;
        }
      }
    }
#line 96
    tmp___1 = fgetc(fp);
#line 96
    if (tmp___1 == -1) {
#line 97
      goto eof;
    }
#line 98
    offset --;
#line 99
    if (offset == 0UL) {
#line 100
      return (0);
    }
#line 101
    total_buffered --;
  }
#line 105
  fd = fileno(fp);
#line 106
  if (fd >= 0) {
#line 106
    tmp___5 = lseek(fd, (__off_t )0, 1);
#line 106
    if (tmp___5 >= 0L) {
#line 109
      tmp___2 = rpl_fseeko(fp, (off_t )offset, 1);
#line 109
      return (tmp___2);
    } else {
#line 106
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 117
    while (1) {
#line 119
      if (sizeof(buf___0) < offset) {
#line 119
        tmp___3 = sizeof(buf___0);
      } else {
#line 119
        tmp___3 = offset;
      }
#line 119
      count = tmp___3;
#line 120
      tmp___4 = fread((void * __restrict  )(buf___0), (size_t )1, count, (FILE * __restrict  )fp);
#line 120
      if (tmp___4 < count) {
#line 121
        goto eof;
      }
#line 122
      offset -= count;
#line 117
      if (! (offset > 0UL)) {
#line 117
        break;
      }
    }
#line 126
    return (0);
  }
  eof: 
#line 131
  tmp___6 = ferror(fp);
#line 131
  if (tmp___6) {
#line 132
    return (-1);
  } else {
#line 135
    return (0);
  }
}
}
#line 1 "cil-hu2ASl3C.o"
#pragma merger("0","../lib/freopen-safer.o.i","")
#line 278 "/usr/include/stdio.h"
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/freopen-safer.c"
static _Bool protect_fd(int fd ) 
{ 
  int value ;
  int tmp ;
  int *tmp___0 ;

  {
#line 34
  tmp = open("/dev/null", 0);
#line 34
  value = tmp;
#line 35
  if (value != fd) {
#line 37
    if (0 <= value) {
#line 39
      close(value);
#line 40
      tmp___0 = __errno_location();
#line 40
      *tmp___0 = 9;
    }
#line 42
    return ((_Bool)0);
  }
#line 44
  return ((_Bool)1);
}
}
#line 53 "/home/wslee/project/coreutils-8.1/lib/freopen-safer.c"
FILE *freopen_safer(char const   *name , char const   *mode , FILE *f ) 
{ 
  _Bool protect_in ;
  _Bool protect_out ;
  _Bool protect_err ;
  int saved_errno ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  _Bool tmp___3 ;
  _Bool tmp___4 ;
  _Bool tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 62
  protect_in = (_Bool)0;
#line 63
  protect_out = (_Bool)0;
#line 64
  protect_err = (_Bool)0;
#line 67
  tmp = fileno(f);
#line 67
  switch (tmp) {
  default: 
#line 70
  tmp___0 = dup2(2, 2);
#line 70
  if (tmp___0 != 2) {
#line 71
    protect_err = (_Bool)1;
  }
  case 2: 
#line 74
  tmp___1 = dup2(1, 1);
#line 74
  if (tmp___1 != 1) {
#line 75
    protect_out = (_Bool)1;
  }
  case 1: 
#line 78
  tmp___2 = dup2(0, 0);
#line 78
  if (tmp___2 != 0) {
#line 79
    protect_in = (_Bool)1;
  }
  case 0: 
#line 83
  break;
  }
#line 85
  if (protect_in) {
#line 85
    tmp___5 = protect_fd(0);
#line 85
    if (tmp___5) {
#line 85
      goto _L___0;
    } else {
#line 86
      f = (FILE *)((void *)0);
    }
  } else
  _L___0: /* CIL Label */ 
#line 87
  if (protect_out) {
#line 87
    tmp___4 = protect_fd(1);
#line 87
    if (tmp___4) {
#line 87
      goto _L;
    } else {
#line 88
      f = (FILE *)((void *)0);
    }
  } else
  _L: /* CIL Label */ 
#line 89
  if (protect_err) {
#line 89
    tmp___3 = protect_fd(2);
#line 89
    if (tmp___3) {
#line 92
      f = freopen((char const   * __restrict  )name, (char const   * __restrict  )mode,
                  (FILE * __restrict  )f);
    } else {
#line 90
      f = (FILE *)((void *)0);
    }
  } else {
#line 92
    f = freopen((char const   * __restrict  )name, (char const   * __restrict  )mode,
                (FILE * __restrict  )f);
  }
#line 93
  tmp___6 = __errno_location();
#line 93
  saved_errno = *tmp___6;
#line 94
  if (protect_err) {
#line 95
    close(2);
  }
#line 96
  if (protect_out) {
#line 97
    close(1);
  }
#line 98
  if (protect_in) {
#line 99
    close(0);
  }
#line 100
  if (! f) {
#line 101
    tmp___7 = __errno_location();
#line 101
    *tmp___7 = saved_errno;
  }
#line 102
  return (f);
}
}
#line 1 "cil-NfqtXrcN.o"
#pragma merger("0","../lib/fseeko.o.i","")
#line 773 "/usr/include/stdio.h"
extern int fseeko(FILE *__stream , __off_t __off , int __whence ) ;
#line 34 "/home/wslee/project/coreutils-8.1/lib/fseeko.c"
int rpl_fseeko(FILE *fp , off_t offset , int whence ) 
{ 
  off_t pos ;
  off_t tmp ;
  int tmp___0 ;
  __off_t tmp___1 ;
  int tmp___2 ;

  {
#line 45
  if ((unsigned long )fp->_IO_read_end == (unsigned long )fp->_IO_read_ptr) {
#line 45
    if ((unsigned long )fp->_IO_write_ptr == (unsigned long )fp->_IO_write_base) {
#line 45
      if ((unsigned long )fp->_IO_save_base == (unsigned long )((void *)0)) {
#line 98
        if (whence == 2) {
#line 98
          if (offset > 0L) {
#line 98
            tmp = (off_t )0;
          } else {
#line 98
            tmp = offset;
          }
        } else {
#line 98
          tmp = offset;
        }
#line 98
        tmp___0 = fileno(fp);
#line 98
        tmp___1 = lseek(tmp___0, tmp, whence);
#line 98
        pos = tmp___1;
#line 102
        if (pos == -1L) {
#line 107
          return (-1);
        }
#line 111
        fp->_flags &= -17;
#line 126
        if (whence == 2) {
#line 126
          if (! (offset > 0L)) {
#line 127
            return (0);
          }
        } else {
#line 127
          return (0);
        }
      }
    }
  }
#line 129
  tmp___2 = fseeko(fp, offset, whence);
#line 129
  return (tmp___2);
}
}
#line 1 "cil-Zu7c1NrT.o"
#pragma merger("0","../lib/fseterr.o.i","")
#line 30 "/home/wslee/project/coreutils-8.1/lib/fseterr.h"
void fseterr(FILE *fp ) ;
#line 26 "/home/wslee/project/coreutils-8.1/lib/fseterr.c"
void fseterr(FILE *fp ) 
{ 


  {
#line 33
  fp->_flags |= 32;
#line 74
  return;
}
}
#line 1 "cil-_nG_pWzJ.o"
#pragma merger("0","../lib/fsusage.o.i","")
#line 38 "/home/wslee/project/coreutils-8.1/lib/fsusage.h"
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) ;
#line 31 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf ) ;
#line 94 "/home/wslee/project/coreutils-8.1/lib/fsusage.c"
int get_fs_usage(char const   *file , char const   *disk , struct fs_usage *fsp ) 
{ 
  struct statfs fsd ;
  int tmp ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___9 ;

  {
#line 172
  tmp = statfs(file, & fsd);
#line 172
  if (tmp < 0) {
#line 173
    return (-1);
  }
#line 175
  if (sizeof(fsd.f_bsize) < sizeof(uintmax_t )) {
#line 175
    if (sizeof(fsd.f_bsize) < sizeof(int )) {
#line 175
      tmp___1 = - (1 << sizeof(fsd.f_bsize) * 8UL);
    } else {
#line 175
      tmp___1 = 0;
    }
#line 175
    if (~ fsd.f_bsize == (__fsword_t )tmp___1) {
#line 175
      fsp->fsu_blocksize = 0xffffffffffffffffUL;
    } else {
#line 175
      fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
    }
  } else {
#line 175
    fsp->fsu_blocksize = (uintmax_t )fsd.f_bsize;
  }
#line 226
  if (sizeof(fsd.f_blocks) < sizeof(uintmax_t )) {
#line 226
    if (sizeof(fsd.f_blocks) < sizeof(int )) {
#line 226
      tmp___3 = - (1 << sizeof(fsd.f_blocks) * 8UL);
    } else {
#line 226
      tmp___3 = 0;
    }
#line 226
    if (~ fsd.f_blocks == (__fsblkcnt_t )tmp___3) {
#line 226
      fsp->fsu_blocks = 0xffffffffffffffffUL;
    } else {
#line 226
      fsp->fsu_blocks = fsd.f_blocks;
    }
  } else {
#line 226
    fsp->fsu_blocks = fsd.f_blocks;
  }
#line 227
  if (sizeof(fsd.f_bfree) < sizeof(uintmax_t )) {
#line 227
    if (sizeof(fsd.f_bfree) < sizeof(int )) {
#line 227
      tmp___5 = - (1 << sizeof(fsd.f_bfree) * 8UL);
    } else {
#line 227
      tmp___5 = 0;
    }
#line 227
    if (~ fsd.f_bfree == (__fsblkcnt_t )tmp___5) {
#line 227
      fsp->fsu_bfree = 0xffffffffffffffffUL;
    } else {
#line 227
      fsp->fsu_bfree = fsd.f_bfree;
    }
  } else {
#line 227
    fsp->fsu_bfree = fsd.f_bfree;
  }
#line 228
  fsp->fsu_bavail = fsd.f_bavail | ~ ((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) - 1UL);
#line 229
  fsp->fsu_bavail_top_bit_set = (_Bool )((fsd.f_bavail & (1UL << (sizeof(fsd.f_bavail) * 8UL - 1UL))) != 0UL);
#line 230
  if (sizeof(fsd.f_files) < sizeof(uintmax_t )) {
#line 230
    if (sizeof(fsd.f_files) < sizeof(int )) {
#line 230
      tmp___7 = - (1 << sizeof(fsd.f_files) * 8UL);
    } else {
#line 230
      tmp___7 = 0;
    }
#line 230
    if (~ fsd.f_files == (__fsfilcnt_t )tmp___7) {
#line 230
      fsp->fsu_files = 0xffffffffffffffffUL;
    } else {
#line 230
      fsp->fsu_files = fsd.f_files;
    }
  } else {
#line 230
    fsp->fsu_files = fsd.f_files;
  }
#line 231
  if (sizeof(fsd.f_ffree) < sizeof(uintmax_t )) {
#line 231
    if (sizeof(fsd.f_ffree) < sizeof(int )) {
#line 231
      tmp___9 = - (1 << sizeof(fsd.f_ffree) * 8UL);
    } else {
#line 231
      tmp___9 = 0;
    }
#line 231
    if (~ fsd.f_ffree == (__fsfilcnt_t )tmp___9) {
#line 231
      fsp->fsu_ffree = 0xffffffffffffffffUL;
    } else {
#line 231
      fsp->fsu_ffree = fsd.f_ffree;
    }
  } else {
#line 231
    fsp->fsu_ffree = fsd.f_ffree;
  }
#line 236
  return (0);
}
}
#line 1 "cil-lq00buuj.o"
#pragma merger("0","../lib/fts.o.i","")
#line 237 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag ) ;
#line 41 "/home/wslee/project/coreutils-8.1/lib/i-ring.h"
void i_ring_init(I_ring *ir , int default_val ) ;
#line 42
int i_ring_push(I_ring *ir , int val ) ;
#line 43
int i_ring_pop(I_ring *ir ) ;
#line 44
_Bool i_ring_empty(I_ring const   *ir ) ;
#line 254 "/home/wslee/project/coreutils-8.1/lib/fts_.h"
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 256
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 764 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 22 "/home/wslee/project/coreutils-8.1/lib/fcntl-safer.h"
int open_safer(char const   *file , int flags  , ...) ;
#line 26
int openat_safer(int fd , char const   *file , int flags  , ...) ;
#line 223 "/usr/include/dirent.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) dirfd)(DIR *__dirp ) ;
#line 196 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) ;
#line 197
static FTSENT *fts_build(FTS *sp , int type ) ;
#line 198
static void fts_lfree(FTSENT *head ) ;
#line 199
static void fts_load(FTS *sp , FTSENT *p ) ;
#line 200
static size_t fts_maxarglen(char * const  *argv ) ;
#line 201
static void fts_padjust(FTS *sp , FTSENT *head ) ;
#line 202
static _Bool fts_palloc(FTS *sp , size_t more ) ;
#line 203
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) ;
#line 204
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) ;
#line 205
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) ;
#line 90 "/home/wslee/project/coreutils-8.1/lib/hash.h"
void *hash_delete(Hash_table *table , void const   *entry ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/fts-cycle.c"
static _Bool AD_compare(void const   *x , void const   *y ) 
{ 
  struct Active_dir  const  *ax ;
  struct Active_dir  const  *ay ;
  int tmp ;

  {
#line 34
  ax = (struct Active_dir  const  *)x;
#line 35
  ay = (struct Active_dir  const  *)y;
#line 36
  if (ax->ino == ay->ino) {
#line 36
    if (ax->dev == ay->dev) {
#line 36
      tmp = 1;
    } else {
#line 36
      tmp = 0;
    }
  } else {
#line 36
    tmp = 0;
  }
#line 36
  return ((_Bool )tmp);
}
}
#line 40 "/home/wslee/project/coreutils-8.1/lib/fts-cycle.c"
static size_t AD_hash(void const   *x , size_t table_size ) 
{ 
  struct Active_dir  const  *ax ;

  {
#line 43
  ax = (struct Active_dir  const  *)x;
#line 44
  return ((uintmax_t )ax->ino % table_size);
}
}
#line 49 "/home/wslee/project/coreutils-8.1/lib/fts-cycle.c"
static _Bool setup_dir(FTS *fts ) 
{ 
  void *tmp ;

  {
#line 52
  if (fts->fts_options & 258) {
#line 55
    fts->fts_cycle.ht = hash_initialize((size_t )31, (Hash_tuning const   *)((void *)0),
                                        & AD_hash, & AD_compare, (void (*)(void * ))(& free));
#line 57
    if (! fts->fts_cycle.ht) {
#line 58
      return ((_Bool)0);
    }
  } else {
#line 62
    tmp = malloc(sizeof(*(fts->fts_cycle.state)));
#line 62
    fts->fts_cycle.state = (struct cycle_check_state *)tmp;
#line 63
    if (! fts->fts_cycle.state) {
#line 64
      return ((_Bool)0);
    }
#line 65
    cycle_check_init(fts->fts_cycle.state);
  }
#line 68
  return ((_Bool)1);
}
}
#line 73 "/home/wslee/project/coreutils-8.1/lib/fts-cycle.c"
static _Bool enter_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir *ad ;
  void *tmp ;
  struct Active_dir *ad_from_table ;
  void *tmp___0 ;
  _Bool tmp___1 ;

  {
#line 76
  if (fts->fts_options & 258) {
#line 78
    st = (struct stat  const  *)(ent->fts_statp);
#line 79
    tmp = malloc(sizeof(*ad));
#line 79
    ad = (struct Active_dir *)tmp;
#line 82
    if (! ad) {
#line 83
      return ((_Bool)0);
    }
#line 85
    ad->dev = (dev_t )st->st_dev;
#line 86
    ad->ino = (ino_t )st->st_ino;
#line 87
    ad->fts_ent = ent;
#line 92
    tmp___0 = hash_insert(fts->fts_cycle.ht, (void const   *)ad);
#line 92
    ad_from_table = (struct Active_dir *)tmp___0;
#line 94
    if ((unsigned long )ad_from_table != (unsigned long )ad) {
#line 96
      free((void *)ad);
#line 97
      if (! ad_from_table) {
#line 98
        return ((_Bool)0);
      }
#line 102
      ent->fts_cycle = ad_from_table->fts_ent;
#line 103
      ent->fts_info = (unsigned short)2;
    }
  } else {
#line 108
    tmp___1 = cycle_check(fts->fts_cycle.state, (struct stat  const  *)(ent->fts_statp));
#line 108
    if (tmp___1) {
#line 114
      ent->fts_cycle = ent;
#line 115
      ent->fts_info = (unsigned short)2;
    }
  }
#line 119
  return ((_Bool)1);
}
}
#line 124 "/home/wslee/project/coreutils-8.1/lib/fts-cycle.c"
static void leave_dir(FTS *fts , FTSENT *ent ) 
{ 
  struct stat  const  *st ;
  struct Active_dir obj ;
  void *found ;
  FTSENT *parent ;

  {
#line 127
  st = (struct stat  const  *)(ent->fts_statp);
#line 128
  if (fts->fts_options & 258) {
#line 132
    obj.dev = (dev_t )st->st_dev;
#line 133
    obj.ino = (ino_t )st->st_ino;
#line 134
    found = hash_delete(fts->fts_cycle.ht, (void const   *)(& obj));
#line 135
    if (! found) {
#line 136
      abort();
    }
#line 137
    free(found);
  } else {
#line 141
    parent = ent->fts_parent;
#line 142
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 142
      if (0L <= parent->fts_level) {
#line 143
        while (1) {
#line 143
          if ((fts->fts_cycle.state)->chdir_counter == 0UL) {
#line 143
            abort();
          }
#line 143
          if ((fts->fts_cycle.state)->dev_ino.st_ino == (ino_t )st->st_ino) {
#line 143
            if ((fts->fts_cycle.state)->dev_ino.st_dev == (dev_t )st->st_dev) {
#line 143
              (fts->fts_cycle.state)->dev_ino.st_dev = parent->fts_statp[0].st_dev;
#line 143
              (fts->fts_cycle.state)->dev_ino.st_ino = parent->fts_statp[0].st_ino;
            }
          }
#line 143
          break;
        }
      }
    }
  }
#line 146
  return;
}
}
#line 150 "/home/wslee/project/coreutils-8.1/lib/fts-cycle.c"
static void free_dir(FTS *sp ) 
{ 


  {
#line 153
  if (sp->fts_options & 258) {
#line 155
    if (sp->fts_cycle.ht) {
#line 156
      hash_free(sp->fts_cycle.ht);
    }
  } else {
#line 159
    free((void *)sp->fts_cycle.state);
  }
#line 160
  return;
}
}
#line 273 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static void fd_ring_clear(I_ring *fd_ring ) 
{ 
  int fd ;
  int tmp ;
  _Bool tmp___0 ;

  {
#line 276
  while (1) {
#line 276
    tmp___0 = i_ring_empty((I_ring const   *)fd_ring);
#line 276
    if (tmp___0) {
#line 276
      break;
    }
#line 278
    tmp = i_ring_pop(fd_ring);
#line 278
    fd = tmp;
#line 279
    if (0 <= fd) {
#line 280
      close(fd);
    }
  }
#line 282
  return;
}
}
#line 287 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static void fts_set_stat_required(FTSENT *p , _Bool required ) 
{ 


  {
#line 290
  while (1) {
#line 290
    if (! ((int )p->fts_info == 11)) {
#line 290
      abort();
    }
#line 290
    break;
  }
#line 291
  if (required) {
#line 291
    p->fts_statp[0].st_size = (__off_t )2;
  } else {
#line 291
    p->fts_statp[0].st_size = (__off_t )1;
  }
#line 294
  return;
}
}
#line 298 "/home/wslee/project/coreutils-8.1/lib/fts.c"
__inline static DIR *opendirat(int fd , char const   *dir ) 
{ 
  int new_fd ;
  int tmp ;
  DIR *dirp ;
  int saved_errno ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 302
  tmp = openat_safer(fd, dir, 67840);
#line 302
  new_fd = tmp;
#line 306
  if (new_fd < 0) {
#line 307
    return ((DIR *)((void *)0));
  }
#line 308
  set_cloexec_flag(new_fd, (_Bool)1);
#line 309
  dirp = rpl_fdopendir(new_fd);
#line 310
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 312
    tmp___0 = __errno_location();
#line 312
    saved_errno = *tmp___0;
#line 313
    close(new_fd);
#line 314
    tmp___1 = __errno_location();
#line 314
    *tmp___1 = saved_errno;
  }
#line 316
  return (dirp);
}
}
#line 324 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static void cwd_advance_fd(FTS *sp , int fd , _Bool chdir_down_one ) 
{ 
  int old ;
  int prev_fd_in_slot ;
  int tmp ;

  {
#line 328
  old = sp->fts_cwd_fd;
#line 329
  while (1) {
#line 329
    if (! (old != fd)) {
#line 329
      if (! (old == -100)) {
#line 329
        abort();
      }
    }
#line 329
    break;
  }
#line 331
  if (chdir_down_one) {
#line 335
    tmp = i_ring_push(& sp->fts_fd_ring, old);
#line 335
    prev_fd_in_slot = tmp;
#line 337
    if (0 <= prev_fd_in_slot) {
#line 338
      close(prev_fd_in_slot);
    }
  } else
#line 340
  if (! (sp->fts_options & 4)) {
#line 342
    if (0 <= old) {
#line 343
      close(old);
    }
  }
#line 346
  sp->fts_cwd_fd = fd;
#line 347
  return;
}
}
#line 353 "/home/wslee/project/coreutils-8.1/lib/fts.c"
__inline static int diropen(FTS const   *sp , char const   *dir ) 
{ 
  int open_flags ;
  int tmp ;
  int fd ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 357
  if (sp->fts_options & 16) {
#line 357
    tmp = 131072;
  } else {
#line 357
    tmp = 0;
  }
#line 357
  open_flags = 67840 | tmp;
#line 360
  if (sp->fts_options & 512) {
#line 360
    tmp___0 = openat_safer((int )sp->fts_cwd_fd, dir, open_flags);
#line 360
    tmp___2 = tmp___0;
  } else {
#line 360
    tmp___1 = open_safer(dir, open_flags);
#line 360
    tmp___2 = tmp___1;
  }
#line 360
  fd = tmp___2;
#line 363
  if (0 <= fd) {
#line 364
    set_cloexec_flag(fd, (_Bool)1);
  }
#line 365
  return (fd);
}
}
#line 368
 __attribute__((__nothrow__)) FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                                                 int options ,
                                                                                                 int (*compar)(FTSENT const   ** ,
                                                                                                               FTSENT const   ** ) ) ;
#line 368 "/home/wslee/project/coreutils-8.1/lib/fts.c"
FTS *( __attribute__((__warn_unused_result__, __leaf__)) fts_open)(char * const  *argv ,
                                                                   int options , int (*compar)(FTSENT const   ** ,
                                                                                               FTSENT const   ** ) ) 
{ 
  register FTS *sp ;
  register FTSENT *p ;
  register FTSENT *root ;
  register size_t nitems ;
  FTSENT *parent ;
  FTSENT *tmp ;
  size_t len ;
  _Bool defer_stat ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  size_t maxarglen ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  _Bool tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  struct _ftsent *tmp___10 ;
  _Bool tmp___11 ;
  int tmp___12 ;

  {
#line 376
  parent = (FTSENT *)((void *)0);
#line 377
  tmp = (FTSENT *)((void *)0);
#line 382
  if (options & -2048) {
#line 383
    tmp___0 = __errno_location();
#line 383
    *tmp___0 = 22;
#line 384
    return ((FTS *)((void *)0));
  }
#line 386
  if (options & 4) {
#line 386
    if (options & 512) {
#line 387
      tmp___1 = __errno_location();
#line 387
      *tmp___1 = 22;
#line 388
      return ((FTS *)((void *)0));
    }
  }
#line 390
  if (! (options & 18)) {
#line 391
    tmp___2 = __errno_location();
#line 391
    *tmp___2 = 22;
#line 392
    return ((FTS *)((void *)0));
  }
#line 396
  tmp___3 = malloc(sizeof(FTS ));
#line 396
  sp = (FTS *)tmp___3;
#line 396
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 397
    return ((FTS *)((void *)0));
  }
#line 398
  memset((void *)sp, 0, sizeof(FTS ));
#line 399
  sp->fts_compar = compar;
#line 400
  sp->fts_options = options;
#line 403
  if (sp->fts_options & 2) {
#line 404
    sp->fts_options |= 4;
#line 405
    sp->fts_options &= -513;
  }
#line 409
  sp->fts_cwd_fd = -100;
#line 410
  if (sp->fts_options & 512) {

  }
#line 450
  tmp___5 = fts_maxarglen(argv);
#line 450
  maxarglen = tmp___5;
#line 451
  if (maxarglen > 4096UL) {
#line 451
    tmp___6 = maxarglen;
  } else {
#line 451
    tmp___6 = (size_t )4096;
  }
#line 451
  tmp___7 = fts_palloc(sp, tmp___6);
#line 451
  if (! tmp___7) {
#line 452
    goto mem1;
  }
#line 456
  if ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 457
    parent = fts_alloc(sp, "", (size_t )0);
#line 457
    if ((unsigned long )parent == (unsigned long )((void *)0)) {
#line 458
      goto mem2;
    }
#line 459
    parent->fts_level = (ptrdiff_t )-1;
  }
#line 473
  if ((unsigned long )compar == (unsigned long )((void *)0)) {
#line 473
    tmp___8 = 1;
  } else
#line 473
  if (sp->fts_options & 1024) {
#line 473
    tmp___8 = 1;
  } else {
#line 473
    tmp___8 = 0;
  }
#line 473
  defer_stat = (_Bool )tmp___8;
#line 476
  root = (FTSENT *)((void *)0);
#line 476
  nitems = (size_t )0;
#line 476
  while ((unsigned long )*argv != (unsigned long )((void *)0)) {
#line 478
    len = strlen((char const   *)*argv);
#line 478
    if (len == 0UL) {
#line 479
      tmp___9 = __errno_location();
#line 479
      *tmp___9 = 2;
#line 480
      goto mem3;
    }
#line 483
    p = fts_alloc(sp, (char const   *)*argv, len);
#line 483
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 484
      goto mem3;
    }
#line 485
    p->fts_level = (ptrdiff_t )0;
#line 486
    p->fts_parent = parent;
#line 487
    p->fts_accpath = p->fts_name;
#line 491
    if (defer_stat) {
#line 491
      if ((unsigned long )root != (unsigned long )((void *)0)) {
#line 492
        p->fts_info = (unsigned short)11;
#line 493
        fts_set_stat_required(p, (_Bool)1);
      } else {
#line 495
        p->fts_info = fts_stat(sp, p, (_Bool)0);
      }
    } else {
#line 495
      p->fts_info = fts_stat(sp, p, (_Bool)0);
    }
#line 502
    if (compar) {
#line 503
      p->fts_link = root;
#line 504
      root = p;
    } else {
#line 506
      p->fts_link = (struct _ftsent *)((void *)0);
#line 507
      if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 508
        root = p;
#line 508
        tmp = root;
      } else {
#line 510
        tmp->fts_link = p;
#line 511
        tmp = p;
      }
    }
#line 476
    argv ++;
#line 476
    nitems ++;
  }
#line 515
  if (compar) {
#line 515
    if (nitems > 1UL) {
#line 516
      root = fts_sort(sp, root, nitems);
    }
  }
#line 523
  tmp___10 = fts_alloc(sp, "", (size_t )0);
#line 523
  sp->fts_cur = tmp___10;
#line 523
  if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
#line 524
    goto mem3;
  }
#line 525
  (sp->fts_cur)->fts_link = root;
#line 526
  (sp->fts_cur)->fts_info = (unsigned short)9;
#line 527
  tmp___11 = setup_dir(sp);
#line 527
  if (! tmp___11) {
#line 528
    goto mem3;
  }
#line 537
  if (! (sp->fts_options & 4)) {
#line 537
    if (! (sp->fts_options & 512)) {
#line 537
      tmp___12 = diropen((FTS const   *)sp, ".");
#line 537
      sp->fts_rfd = tmp___12;
#line 537
      if (tmp___12 < 0) {
#line 539
        sp->fts_options |= 4;
      }
    }
  }
#line 541
  i_ring_init(& sp->fts_fd_ring, -1);
#line 542
  return (sp);
  mem3: 
#line 544
  fts_lfree(root);
#line 545
  free((void *)parent);
  mem2: 
#line 546
  free((void *)sp->fts_path);
  mem1: 
#line 547
  free((void *)sp);
#line 548
  return ((FTS *)((void *)0));
}
}
#line 551 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static void fts_load(FTS *sp , FTSENT *p ) 
{ 
  register size_t len ;
  register char *cp ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 565
  tmp = p->fts_namelen;
#line 565
  p->fts_pathlen = tmp;
#line 565
  len = tmp;
#line 566
  memmove((void *)sp->fts_path, (void const   *)(p->fts_name), len + 1UL);
#line 567
  cp = strrchr((char const   *)(p->fts_name), '/');
#line 567
  if (cp) {
#line 567
    if ((unsigned long )cp != (unsigned long )(p->fts_name)) {
#line 568
      cp ++;
#line 568
      len = strlen((char const   *)cp);
#line 569
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 570
      p->fts_namelen = len;
    } else
#line 567
    if (*(cp + 1)) {
#line 568
      cp ++;
#line 568
      len = strlen((char const   *)cp);
#line 569
      memmove((void *)(p->fts_name), (void const   *)cp, len + 1UL);
#line 570
      p->fts_namelen = len;
    }
  }
#line 572
  tmp___0 = sp->fts_path;
#line 572
  p->fts_path = tmp___0;
#line 572
  p->fts_accpath = tmp___0;
#line 573
  return;
}
}
#line 575
 __attribute__((__nothrow__)) int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) ;
#line 575 "/home/wslee/project/coreutils-8.1/lib/fts.c"
int ( __attribute__((__warn_unused_result__, __leaf__)) fts_close)(FTS *sp ) 
{ 
  register FTSENT *freep ;
  register FTSENT *p ;
  int saved_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 579
  saved_errno = 0;
#line 586
  if (sp->fts_cur) {
#line 587
    p = sp->fts_cur;
#line 587
    while (p->fts_level >= 0L) {
#line 588
      freep = p;
#line 589
      if ((unsigned long )p->fts_link != (unsigned long )((void *)0)) {
#line 589
        p = p->fts_link;
      } else {
#line 589
        p = p->fts_parent;
      }
#line 590
      free((void *)freep);
    }
#line 592
    free((void *)p);
  }
#line 596
  if (sp->fts_child) {
#line 597
    fts_lfree(sp->fts_child);
  }
#line 598
  free((void *)sp->fts_array);
#line 599
  free((void *)sp->fts_path);
#line 601
  if (sp->fts_options & 512) {
#line 603
    if (0 <= sp->fts_cwd_fd) {
#line 604
      tmp___0 = close(sp->fts_cwd_fd);
#line 604
      if (tmp___0) {
#line 605
        tmp = __errno_location();
#line 605
        saved_errno = *tmp;
      }
    }
  } else
#line 607
  if (! (sp->fts_options & 4)) {
#line 610
    tmp___2 = fchdir(sp->fts_rfd);
#line 610
    if (tmp___2) {
#line 611
      tmp___1 = __errno_location();
#line 611
      saved_errno = *tmp___1;
    }
#line 615
    tmp___4 = close(sp->fts_rfd);
#line 615
    if (tmp___4) {
#line 616
      if (saved_errno == 0) {
#line 617
        tmp___3 = __errno_location();
#line 617
        saved_errno = *tmp___3;
      }
    }
  }
#line 620
  fd_ring_clear(& sp->fts_fd_ring);
#line 623
  if (sp->fts_leaf_optimization_works_ht) {
#line 624
    hash_free(sp->fts_leaf_optimization_works_ht);
  }
#line 627
  free_dir(sp);
#line 630
  free((void *)sp);
#line 633
  if (saved_errno) {
#line 634
    tmp___5 = __errno_location();
#line 634
    *tmp___5 = saved_errno;
#line 635
    return (-1);
  }
#line 638
  return (0);
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstatfs)(int __fildes ,
                                                                                              struct statfs *__buf ) ;
#line 656 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static _Bool dirent_inode_sort_may_be_useful(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
#line 667
  tmp = fstatfs(dir_fd, & fs_buf);
#line 667
  if (tmp != 0) {
#line 668
    return ((_Bool)1);
  }
#line 672
  switch (fs_buf.f_type) {
  case 26985L: 
  case 16914836L: 
#line 678
  return ((_Bool)0);
  default: 
#line 681
  return ((_Bool)1);
  }
}
}
#line 688 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static _Bool leaf_optimization_applies(int dir_fd ) 
{ 
  struct statfs fs_buf ;
  int tmp ;

  {
#line 694
  tmp = fstatfs(dir_fd, & fs_buf);
#line 694
  if (tmp != 0) {
#line 695
    return ((_Bool)0);
  }
#line 700
  switch (fs_buf.f_type) {
  case 1382369651L: 
#line 705
  return ((_Bool)1);
  default: 
#line 714
  return ((_Bool)0);
  }
}
}
#line 739 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static size_t LCO_hash(void const   *x , size_t table_size ) 
{ 
  struct LCO_ent  const  *ax ;

  {
#line 742
  ax = (struct LCO_ent  const  *)x;
#line 743
  return ((uintmax_t )ax->st_dev % table_size);
}
}
#line 746 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static _Bool LCO_compare(void const   *x , void const   *y ) 
{ 
  struct LCO_ent  const  *ax ;
  struct LCO_ent  const  *ay ;

  {
#line 749
  ax = (struct LCO_ent  const  *)x;
#line 750
  ay = (struct LCO_ent  const  *)y;
#line 751
  return ((_Bool )(ax->st_dev == ay->st_dev));
}
}
#line 757 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static _Bool link_count_optimize_ok(FTSENT const   *p ) 
{ 
  FTS *sp ;
  Hash_table *h ;
  struct LCO_ent tmp ;
  struct LCO_ent *ent ;
  _Bool opt_ok ;
  struct LCO_ent *t2 ;
  struct hash_table *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
#line 760
  sp = (FTS *)p->fts_fts;
#line 761
  h = sp->fts_leaf_optimization_works_ht;
#line 769
  if (! (sp->fts_options & 512)) {
#line 770
    return ((_Bool)0);
  }
#line 773
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 775
    tmp___0 = hash_initialize((size_t )13, (Hash_tuning const   *)((void *)0), & LCO_hash,
                              & LCO_compare, (void (*)(void * ))(& free));
#line 775
    sp->fts_leaf_optimization_works_ht = tmp___0;
#line 775
    h = tmp___0;
#line 778
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 779
      return ((_Bool)0);
    }
  }
#line 781
  tmp.st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 782
  tmp___1 = hash_lookup((Hash_table const   *)h, (void const   *)(& tmp));
#line 782
  ent = (struct LCO_ent *)tmp___1;
#line 783
  if (ent) {
#line 784
    return (ent->opt_ok);
  }
#line 787
  tmp___2 = malloc(sizeof(*t2));
#line 787
  t2 = (struct LCO_ent *)tmp___2;
#line 788
  if ((unsigned long )t2 == (unsigned long )((void *)0)) {
#line 789
    return ((_Bool)0);
  }
#line 792
  opt_ok = leaf_optimization_applies(sp->fts_cwd_fd);
#line 793
  t2->opt_ok = opt_ok;
#line 794
  t2->st_dev = (dev_t )p->fts_statp[0].st_dev;
#line 796
  tmp___3 = hash_insert(h, (void const   *)t2);
#line 796
  ent = (struct LCO_ent *)tmp___3;
#line 797
  if ((unsigned long )ent == (unsigned long )((void *)0)) {
#line 800
    free((void *)t2);
#line 801
    return ((_Bool)0);
  }
#line 803
  while (1) {
#line 803
    if (! ((unsigned long )ent == (unsigned long )t2)) {
#line 803
      abort();
    }
#line 803
    break;
  }
#line 805
  return (opt_ok);
}
}
#line 817
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) ;
#line 817 "/home/wslee/project/coreutils-8.1/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_read)(FTS *sp ) 
{ 
  register FTSENT *p ;
  register FTSENT *tmp ;
  register unsigned short instr ;
  register char *t ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  struct _ftsent *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;
  char *tmp___13 ;
  FTSENT *parent ;
  _Bool tmp___14 ;
  int *tmp___15 ;
  _Bool tmp___16 ;
  int *tmp___17 ;
  struct _ftsent *tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int saved_errno ;
  int *tmp___25 ;
  int *tmp___26 ;
  int *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int *tmp___30 ;
  int tmp___31 ;
  FTSENT *tmp___32 ;

  {
#line 825
  if ((unsigned long )sp->fts_cur == (unsigned long )((void *)0)) {
#line 826
    return ((FTSENT *)((void *)0));
  } else
#line 825
  if (sp->fts_options & 8192) {
#line 826
    return ((FTSENT *)((void *)0));
  }
#line 829
  p = sp->fts_cur;
#line 832
  instr = p->fts_instr;
#line 833
  p->fts_instr = (unsigned short)3;
#line 836
  if ((int )instr == 1) {
#line 837
    p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 838
    return (p);
  }
#line 849
  if ((int )instr == 2) {
#line 849
    if ((int )p->fts_info == 12) {
#line 849
      goto _L;
    } else
#line 849
    if ((int )p->fts_info == 13) {
      _L: /* CIL Label */ 
#line 851
      p->fts_info = fts_stat(sp, p, (_Bool)1);
#line 852
      if ((int )p->fts_info == 1) {
#line 852
        if (! (sp->fts_options & 4)) {
#line 853
          tmp___1 = diropen((FTS const   *)sp, ".");
#line 853
          p->fts_symfd = tmp___1;
#line 853
          if (tmp___1 < 0) {
#line 854
            tmp___0 = __errno_location();
#line 854
            p->fts_errno = *tmp___0;
#line 855
            p->fts_info = (unsigned short)7;
          } else {
#line 857
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 859
      goto check_for_dir;
    }
  }
#line 863
  if ((int )p->fts_info == 1) {
#line 865
    if ((int )instr == 4) {
#line 865
      goto _L___0;
    } else
#line 865
    if (sp->fts_options & 64) {
#line 865
      if (p->fts_statp[0].st_dev != sp->fts_dev) {
        _L___0: /* CIL Label */ 
#line 867
        if ((int )p->fts_flags & 2) {
#line 868
          close(p->fts_symfd);
        }
#line 869
        if (sp->fts_child) {
#line 870
          fts_lfree(sp->fts_child);
#line 871
          sp->fts_child = (struct _ftsent *)((void *)0);
        }
#line 873
        p->fts_info = (unsigned short)6;
#line 874
        while (1) {
#line 874
          leave_dir(sp, p);
#line 874
          break;
        }
#line 875
        return (p);
      }
    }
#line 879
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 879
      if (sp->fts_options & 4096) {
#line 880
        sp->fts_options &= -4097;
#line 881
        fts_lfree(sp->fts_child);
#line 882
        sp->fts_child = (struct _ftsent *)((void *)0);
      }
    }
#line 897
    if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 898
      tmp___3 = fts_safe_changedir(sp, p, -1, (char const   *)p->fts_accpath);
#line 898
      if (tmp___3) {
#line 899
        tmp___2 = __errno_location();
#line 899
        p->fts_errno = *tmp___2;
#line 900
        p->fts_flags = (unsigned short )((int )p->fts_flags | 1);
#line 901
        p = sp->fts_child;
#line 901
        while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 903
          p->fts_accpath = (p->fts_parent)->fts_accpath;
#line 901
          p = p->fts_link;
        }
      }
    } else {
#line 906
      tmp___4 = fts_build(sp, 3);
#line 906
      sp->fts_child = tmp___4;
#line 906
      if ((unsigned long )tmp___4 == (unsigned long )((void *)0)) {
#line 907
        if (sp->fts_options & 8192) {
#line 908
          return ((FTSENT *)((void *)0));
        }
#line 912
        if (p->fts_errno) {
#line 912
          if ((int )p->fts_info != 4) {
#line 913
            p->fts_info = (unsigned short)7;
          }
        }
#line 914
        while (1) {
#line 914
          leave_dir(sp, p);
#line 914
          break;
        }
#line 915
        return (p);
      }
    }
#line 917
    p = sp->fts_child;
#line 918
    sp->fts_child = (struct _ftsent *)((void *)0);
#line 919
    goto name;
  }
  next: 
#line 923
  tmp = p;
#line 924
  p = p->fts_link;
#line 924
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 925
    sp->fts_cur = p;
#line 926
    free((void *)tmp);
#line 933
    if (p->fts_level == 0L) {
#line 934
      fd_ring_clear(& sp->fts_fd_ring);
#line 934
      if (! (sp->fts_options & 4)) {
#line 934
        if (sp->fts_options & 512) {
#line 934
          if (sp->fts_options & 512) {
#line 934
            tmp___5 = -100;
          } else {
#line 934
            tmp___5 = sp->fts_rfd;
          }
#line 934
          cwd_advance_fd(sp, tmp___5, (_Bool)1);
#line 934
          tmp___8 = 0;
        } else {
#line 934
          if (sp->fts_options & 512) {
#line 934
            tmp___6 = -100;
          } else {
#line 934
            tmp___6 = sp->fts_rfd;
          }
#line 934
          tmp___7 = fchdir(tmp___6);
#line 934
          tmp___8 = tmp___7;
        }
#line 934
        if (tmp___8) {
#line 934
          tmp___9 = 1;
        } else {
#line 934
          tmp___9 = 0;
        }
      } else {
#line 934
        tmp___9 = 0;
      }
#line 934
      if (tmp___9) {
#line 935
        sp->fts_options |= 8192;
#line 936
        return ((FTSENT *)((void *)0));
      }
#line 938
      free_dir(sp);
#line 939
      fts_load(sp, p);
#line 940
      setup_dir(sp);
#line 941
      goto check_for_dir;
    }
#line 949
    if ((int )p->fts_instr == 4) {
#line 950
      goto next;
    }
#line 951
    if ((int )p->fts_instr == 2) {
#line 952
      p->fts_info = fts_stat(sp, p, (_Bool)1);
#line 953
      if ((int )p->fts_info == 1) {
#line 953
        if (! (sp->fts_options & 4)) {
#line 954
          tmp___11 = diropen((FTS const   *)sp, ".");
#line 954
          p->fts_symfd = tmp___11;
#line 954
          if (tmp___11 < 0) {
#line 955
            tmp___10 = __errno_location();
#line 955
            p->fts_errno = *tmp___10;
#line 956
            p->fts_info = (unsigned short)7;
          } else {
#line 958
            p->fts_flags = (unsigned short )((int )p->fts_flags | 2);
          }
        }
      }
#line 960
      p->fts_instr = (unsigned short)3;
    }
    name: 
#line 963
    if ((int )*((p->fts_parent)->fts_path + ((p->fts_parent)->fts_pathlen - 1UL)) == 47) {
#line 963
      tmp___12 = (p->fts_parent)->fts_pathlen - 1UL;
    } else {
#line 963
      tmp___12 = (p->fts_parent)->fts_pathlen;
    }
#line 963
    t = sp->fts_path + tmp___12;
#line 964
    tmp___13 = t;
#line 964
    t ++;
#line 964
    *tmp___13 = (char )'/';
#line 965
    memmove((void *)t, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    check_for_dir: 
#line 967
    sp->fts_cur = p;
#line 968
    if ((int )p->fts_info == 11) {
#line 970
      if (p->fts_statp[0].st_size == 2L) {
#line 972
        parent = p->fts_parent;
#line 973
        if (0L < p->fts_level) {
#line 973
          if (parent->fts_n_dirs_remaining == 0UL) {
#line 973
            if (sp->fts_options & 8) {
#line 973
              if (sp->fts_options & 16) {
#line 973
                tmp___14 = link_count_optimize_ok((FTSENT const   *)parent);
#line 973
                if (! tmp___14) {
#line 973
                  goto _L___4;
                }
              } else {
#line 973
                goto _L___4;
              }
            } else {
#line 973
              goto _L___4;
            }
          } else {
#line 973
            goto _L___4;
          }
        } else {
          _L___4: /* CIL Label */ 
#line 985
          p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 986
          if ((p->fts_statp[0].st_mode & 61440U) == 16384U) {
#line 986
            if (p->fts_level != 0L) {
#line 986
              if (parent->fts_n_dirs_remaining) {
#line 989
                (parent->fts_n_dirs_remaining) --;
              }
            }
          }
        }
      } else {
#line 993
        while (1) {
#line 993
          if (! (p->fts_statp[0].st_size == 1L)) {
#line 993
            abort();
          }
#line 993
          break;
        }
      }
    }
#line 996
    if ((int )p->fts_info == 1) {
#line 1001
      if (p->fts_level == 0L) {
#line 1002
        sp->fts_dev = p->fts_statp[0].st_dev;
      }
#line 1004
      tmp___16 = enter_dir(sp, p);
#line 1004
      if (! tmp___16) {
#line 1006
        tmp___15 = __errno_location();
#line 1006
        *tmp___15 = 12;
#line 1007
        return ((FTSENT *)((void *)0));
      }
    }
#line 1010
    return (p);
  }
#line 1014
  p = tmp->fts_parent;
#line 1015
  sp->fts_cur = p;
#line 1016
  free((void *)tmp);
#line 1018
  if (p->fts_level == -1L) {
#line 1023
    free((void *)p);
#line 1024
    tmp___17 = __errno_location();
#line 1024
    *tmp___17 = 0;
#line 1025
    tmp___18 = (struct _ftsent *)((void *)0);
#line 1025
    sp->fts_cur = tmp___18;
#line 1025
    return (tmp___18);
  }
#line 1028
  while (1) {
#line 1028
    if (! ((int )p->fts_info != 11)) {
#line 1028
      abort();
    }
#line 1028
    break;
  }
#line 1031
  *(sp->fts_path + p->fts_pathlen) = (char )'\000';
#line 1039
  if (p->fts_level == 0L) {
#line 1040
    fd_ring_clear(& sp->fts_fd_ring);
#line 1040
    if (! (sp->fts_options & 4)) {
#line 1040
      if (sp->fts_options & 512) {
#line 1040
        if (sp->fts_options & 512) {
#line 1040
          tmp___20 = -100;
        } else {
#line 1040
          tmp___20 = sp->fts_rfd;
        }
#line 1040
        cwd_advance_fd(sp, tmp___20, (_Bool)1);
#line 1040
        tmp___23 = 0;
      } else {
#line 1040
        if (sp->fts_options & 512) {
#line 1040
          tmp___21 = -100;
        } else {
#line 1040
          tmp___21 = sp->fts_rfd;
        }
#line 1040
        tmp___22 = fchdir(tmp___21);
#line 1040
        tmp___23 = tmp___22;
      }
#line 1040
      if (tmp___23) {
#line 1040
        tmp___24 = 1;
      } else {
#line 1040
        tmp___24 = 0;
      }
    } else {
#line 1040
      tmp___24 = 0;
    }
#line 1040
    if (tmp___24) {
#line 1041
      tmp___19 = __errno_location();
#line 1041
      p->fts_errno = *tmp___19;
#line 1042
      sp->fts_options |= 8192;
    }
  } else
#line 1044
  if ((int )p->fts_flags & 2) {
#line 1045
    if (! (sp->fts_options & 4)) {
#line 1045
      if (sp->fts_options & 512) {
#line 1045
        cwd_advance_fd(sp, p->fts_symfd, (_Bool)1);
#line 1045
        tmp___29 = 0;
      } else {
#line 1045
        tmp___28 = fchdir(p->fts_symfd);
#line 1045
        tmp___29 = tmp___28;
      }
#line 1045
      if (tmp___29) {
#line 1046
        tmp___25 = __errno_location();
#line 1046
        saved_errno = *tmp___25;
#line 1047
        close(p->fts_symfd);
#line 1048
        tmp___26 = __errno_location();
#line 1048
        *tmp___26 = saved_errno;
#line 1049
        tmp___27 = __errno_location();
#line 1049
        p->fts_errno = *tmp___27;
#line 1050
        sp->fts_options |= 8192;
      }
    }
#line 1052
    close(p->fts_symfd);
  } else
#line 1053
  if (! ((int )p->fts_flags & 1)) {
#line 1053
    tmp___31 = fts_safe_changedir(sp, p->fts_parent, -1, "..");
#line 1053
    if (tmp___31) {
#line 1055
      tmp___30 = __errno_location();
#line 1055
      p->fts_errno = *tmp___30;
#line 1056
      sp->fts_options |= 8192;
    }
  }
#line 1058
  if (p->fts_errno) {
#line 1058
    p->fts_info = (unsigned short)7;
  } else {
#line 1058
    p->fts_info = (unsigned short)6;
  }
#line 1059
  if (p->fts_errno == 0) {
#line 1060
    while (1) {
#line 1060
      leave_dir(sp, p);
#line 1060
      break;
    }
  }
#line 1061
  if (sp->fts_options & 8192) {
#line 1061
    tmp___32 = (FTSENT *)((void *)0);
  } else {
#line 1061
    tmp___32 = p;
  }
#line 1061
  return (tmp___32);
}
}
#line 1071
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) ,
                                                                       FTSENT *p ,
                                                                       int instr ) ;
#line 1071 "/home/wslee/project/coreutils-8.1/lib/fts.c"
int ( __attribute__((__leaf__)) fts_set)(FTS *sp  __attribute__((__unused__)) , FTSENT *p ,
                                         int instr ) 
{ 
  int *tmp ;

  {
#line 1074
  if (instr != 0) {
#line 1074
    if (instr != 1) {
#line 1074
      if (instr != 2) {
#line 1074
        if (instr != 3) {
#line 1074
          if (instr != 4) {
#line 1076
            tmp = __errno_location();
#line 1076
            *tmp = 22;
#line 1077
            return (1);
          }
        }
      }
    }
  }
#line 1079
  p->fts_instr = (unsigned short )instr;
#line 1080
  return (0);
}
}
#line 1083
 __attribute__((__nothrow__)) FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                                                        int instr ) ;
#line 1083 "/home/wslee/project/coreutils-8.1/lib/fts.c"
FTSENT *( __attribute__((__warn_unused_result__, __leaf__)) fts_children)(FTS *sp ,
                                                                          int instr ) 
{ 
  register FTSENT *p ;
  int fd ;
  int *tmp ;
  int *tmp___0 ;
  struct _ftsent *tmp___1 ;
  struct _ftsent *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 1089
  if (instr != 0) {
#line 1089
    if (instr != 4096) {
#line 1090
      tmp = __errno_location();
#line 1090
      *tmp = 22;
#line 1091
      return ((FTSENT *)((void *)0));
    }
  }
#line 1095
  p = sp->fts_cur;
#line 1101
  tmp___0 = __errno_location();
#line 1101
  *tmp___0 = 0;
#line 1104
  if (sp->fts_options & 8192) {
#line 1105
    return ((FTSENT *)((void *)0));
  }
#line 1108
  if ((int )p->fts_info == 9) {
#line 1109
    return (p->fts_link);
  }
#line 1116
  if ((int )p->fts_info != 1) {
#line 1117
    return ((FTSENT *)((void *)0));
  }
#line 1120
  if ((unsigned long )sp->fts_child != (unsigned long )((void *)0)) {
#line 1121
    fts_lfree(sp->fts_child);
  }
#line 1123
  if (instr == 4096) {
#line 1124
    sp->fts_options |= 4096;
#line 1125
    instr = 2;
  } else {
#line 1127
    instr = 1;
  }
#line 1136
  if (p->fts_level != 0L) {
#line 1138
    tmp___1 = fts_build(sp, instr);
#line 1138
    sp->fts_child = tmp___1;
#line 1138
    return (tmp___1);
  } else
#line 1136
  if ((int )*(p->fts_accpath + 0) == 47) {
#line 1138
    tmp___1 = fts_build(sp, instr);
#line 1138
    sp->fts_child = tmp___1;
#line 1138
    return (tmp___1);
  } else
#line 1136
  if (sp->fts_options & 4) {
#line 1138
    tmp___1 = fts_build(sp, instr);
#line 1138
    sp->fts_child = tmp___1;
#line 1138
    return (tmp___1);
  }
#line 1140
  fd = diropen((FTS const   *)sp, ".");
#line 1140
  if (fd < 0) {
#line 1141
    tmp___2 = (struct _ftsent *)((void *)0);
#line 1141
    sp->fts_child = tmp___2;
#line 1141
    return (tmp___2);
  }
#line 1142
  sp->fts_child = fts_build(sp, instr);
#line 1143
  if (sp->fts_options & 512) {
#line 1145
    cwd_advance_fd(sp, fd, (_Bool)1);
  } else {
#line 1149
    tmp___5 = fchdir(fd);
#line 1149
    if (tmp___5) {
#line 1151
      tmp___3 = __errno_location();
#line 1151
      saved_errno = *tmp___3;
#line 1152
      close(fd);
#line 1153
      tmp___4 = __errno_location();
#line 1153
      *tmp___4 = saved_errno;
#line 1154
      return ((FTSENT *)((void *)0));
    }
#line 1156
    close(fd);
  }
#line 1158
  return (sp->fts_child);
}
}
#line 1166 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static int fts_compare_ino(struct _ftsent  const  **a , struct _ftsent  const  **b ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1169
  if ((*(a + 0))->fts_statp[0].st_ino < (*(b + 0))->fts_statp[0].st_ino) {
#line 1169
    tmp___0 = -1;
  } else {
#line 1169
    if ((*(b + 0))->fts_statp[0].st_ino < (*(a + 0))->fts_statp[0].st_ino) {
#line 1169
      tmp = 1;
    } else {
#line 1169
      tmp = 0;
    }
#line 1169
    tmp___0 = tmp;
  }
#line 1169
  return (tmp___0);
}
}
#line 1175 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static void set_stat_type(struct stat *st , unsigned int dtype ) 
{ 
  mode_t type ;

  {
#line 1179
  switch (dtype) {
  case 6U: 
#line 1182
  type = (mode_t )24576;
#line 1183
  break;
  case 2U: 
#line 1185
  type = (mode_t )8192;
#line 1186
  break;
  case 4U: 
#line 1188
  type = (mode_t )16384;
#line 1189
  break;
  case 1U: 
#line 1191
  type = (mode_t )4096;
#line 1192
  break;
  case 10U: 
#line 1194
  type = (mode_t )40960;
#line 1195
  break;
  case 8U: 
#line 1197
  type = (mode_t )32768;
#line 1198
  break;
  case 12U: 
#line 1200
  type = (mode_t )49152;
#line 1201
  break;
  default: 
#line 1203
  type = (mode_t )0;
  }
#line 1205
  st->st_mode = type;
#line 1206
  return;
}
}
#line 1222 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static FTSENT *fts_build(FTS *sp , int type ) 
{ 
  register struct dirent *dp ;
  register FTSENT *p ;
  register FTSENT *head ;
  register size_t nitems ;
  FTSENT *cur ;
  FTSENT *tail ;
  DIR *dirp ;
  void *oldaddr ;
  int saved_errno ;
  _Bool descend ;
  _Bool doadjust ;
  ptrdiff_t level ;
  nlink_t nlinks ;
  _Bool nostat ;
  size_t len ;
  size_t maxlen ;
  size_t new_len ;
  char *cp ;
  int *tmp ;
  DIR *tmp___0 ;
  DIR *tmp___1 ;
  int *tmp___2 ;
  _Bool tmp___3 ;
  int tmp___4 ;
  int dir_fd ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  _Bool is_dir ;
  size_t tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  size_t tmp___12 ;
  _Bool tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  int *tmp___16 ;
  _Bool skip_stat ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  _Bool tmp___27 ;

  {
#line 1242
  cur = sp->fts_cur;
#line 1259
  if (! (sp->fts_options & 4)) {
#line 1259
    if (sp->fts_options & 512) {
#line 1259
      tmp___0 = opendirat(sp->fts_cwd_fd, (char const   *)cur->fts_accpath);
#line 1259
      dirp = tmp___0;
    } else {
#line 1259
      tmp___1 = opendir_safer((char const   *)cur->fts_accpath);
#line 1259
      dirp = tmp___1;
    }
  } else {
#line 1259
    tmp___1 = opendir_safer((char const   *)cur->fts_accpath);
#line 1259
    dirp = tmp___1;
  }
#line 1259
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 1260
    if (type == 3) {
#line 1261
      cur->fts_info = (unsigned short)4;
#line 1262
      tmp = __errno_location();
#line 1262
      cur->fts_errno = *tmp;
    }
#line 1264
    return ((FTSENT *)((void *)0));
  }
#line 1269
  if ((int )cur->fts_info == 11) {
#line 1270
    cur->fts_info = fts_stat(sp, cur, (_Bool)0);
  } else
#line 1271
  if (sp->fts_options & 256) {
#line 1278
    while (1) {
#line 1278
      leave_dir(sp, cur);
#line 1278
      break;
    }
#line 1279
    fts_stat(sp, cur, (_Bool)0);
#line 1280
    tmp___3 = enter_dir(sp, cur);
#line 1280
    if (! tmp___3) {
#line 1281
      tmp___2 = __errno_location();
#line 1281
      *tmp___2 = 12;
#line 1282
      return ((FTSENT *)((void *)0));
    }
  }
#line 1291
  if (type == 2) {
#line 1292
    nlinks = (nlink_t )0;
#line 1294
    nostat = (_Bool)0;
  } else
#line 1295
  if (sp->fts_options & 8) {
#line 1295
    if (sp->fts_options & 16) {
#line 1296
      if (sp->fts_options & 32) {
#line 1296
        tmp___4 = 0;
      } else {
#line 1296
        tmp___4 = 2;
      }
#line 1296
      nlinks = cur->fts_statp[0].st_nlink - (__nlink_t )tmp___4;
#line 1298
      nostat = (_Bool)1;
    } else {
#line 1300
      nlinks = (nlink_t )-1;
#line 1301
      nostat = (_Bool)0;
    }
  } else {
#line 1300
    nlinks = (nlink_t )-1;
#line 1301
    nostat = (_Bool)0;
  }
#line 1319
  if (nlinks) {
#line 1319
    goto _L___0;
  } else
#line 1319
  if (type == 3) {
    _L___0: /* CIL Label */ 
#line 1320
    tmp___5 = dirfd(dirp);
#line 1320
    dir_fd = tmp___5;
#line 1321
    if (sp->fts_options & 512) {
#line 1321
      if (0 <= dir_fd) {
#line 1323
        dir_fd = dup_safer(dir_fd);
#line 1324
        set_cloexec_flag(dir_fd, (_Bool)1);
      }
    }
#line 1326
    if (dir_fd < 0) {
#line 1326
      goto _L;
    } else {
#line 1326
      tmp___7 = fts_safe_changedir(sp, cur, dir_fd, (char const   *)((void *)0));
#line 1326
      if (tmp___7) {
        _L: /* CIL Label */ 
#line 1327
        if (nlinks) {
#line 1327
          if (type == 3) {
#line 1328
            tmp___6 = __errno_location();
#line 1328
            cur->fts_errno = *tmp___6;
          }
        }
#line 1329
        cur->fts_flags = (unsigned short )((int )cur->fts_flags | 1);
#line 1330
        descend = (_Bool)0;
#line 1331
        closedir(dirp);
#line 1332
        if (sp->fts_options & 512) {
#line 1332
          if (0 <= dir_fd) {
#line 1333
            close(dir_fd);
          }
        }
#line 1334
        dirp = (DIR *)((void *)0);
      } else {
#line 1336
        descend = (_Bool)1;
      }
    }
  } else {
#line 1338
    descend = (_Bool)0;
  }
#line 1350
  if ((int )*(cur->fts_path + (cur->fts_pathlen - 1UL)) == 47) {
#line 1350
    len = cur->fts_pathlen - 1UL;
  } else {
#line 1350
    len = cur->fts_pathlen;
  }
#line 1351
  if (sp->fts_options & 4) {
#line 1352
    cp = sp->fts_path + len;
#line 1353
    tmp___8 = cp;
#line 1353
    cp ++;
#line 1353
    *tmp___8 = (char )'/';
  } else {
#line 1356
    cp = (char *)((void *)0);
  }
#line 1358
  len ++;
#line 1359
  maxlen = sp->fts_pathlen - len;
#line 1361
  level = cur->fts_level + 1L;
#line 1364
  doadjust = (_Bool)0;
#line 1365
  tail = (FTSENT *)((void *)0);
#line 1365
  head = tail;
#line 1365
  nitems = (size_t )0;
#line 1365
  while (1) {
#line 1365
    if (dirp) {
#line 1365
      dp = readdir(dirp);
#line 1365
      if (! dp) {
#line 1365
        break;
      }
    } else {
#line 1365
      break;
    }
#line 1368
    if (! (sp->fts_options & 32)) {
#line 1368
      if ((int )dp->d_name[0] == 46) {
#line 1368
        if (! dp->d_name[1]) {
#line 1369
          goto __Cont;
        } else
#line 1368
        if ((int )dp->d_name[1] == 46) {
#line 1368
          if (! dp->d_name[2]) {
#line 1369
            goto __Cont;
          }
        }
      }
    }
#line 1371
    tmp___9 = strlen((char const   *)(dp->d_name));
#line 1371
    p = fts_alloc(sp, (char const   *)(dp->d_name), tmp___9);
#line 1371
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1373
      goto mem1;
    }
#line 1374
    tmp___14 = strlen((char const   *)(dp->d_name));
#line 1374
    if (tmp___14 >= maxlen) {
#line 1376
      oldaddr = (void *)sp->fts_path;
#line 1377
      tmp___12 = strlen((char const   *)(dp->d_name));
#line 1377
      tmp___13 = fts_palloc(sp, (tmp___12 + len) + 1UL);
#line 1377
      if (! tmp___13) {
        mem1: 
#line 1383
        tmp___10 = __errno_location();
#line 1383
        saved_errno = *tmp___10;
#line 1384
        free((void *)p);
#line 1385
        fts_lfree(head);
#line 1386
        closedir(dirp);
#line 1387
        cur->fts_info = (unsigned short)7;
#line 1388
        sp->fts_options |= 8192;
#line 1389
        tmp___11 = __errno_location();
#line 1389
        *tmp___11 = saved_errno;
#line 1390
        return ((FTSENT *)((void *)0));
      }
#line 1393
      if ((unsigned long )oldaddr != (unsigned long )sp->fts_path) {
#line 1394
        doadjust = (_Bool)1;
#line 1395
        if (sp->fts_options & 4) {
#line 1396
          cp = sp->fts_path + len;
        }
      }
#line 1398
      maxlen = sp->fts_pathlen - len;
    }
#line 1401
    tmp___15 = strlen((char const   *)(dp->d_name));
#line 1401
    new_len = len + tmp___15;
#line 1402
    if (new_len < len) {
#line 1409
      free((void *)p);
#line 1410
      fts_lfree(head);
#line 1411
      closedir(dirp);
#line 1412
      cur->fts_info = (unsigned short)7;
#line 1413
      sp->fts_options |= 8192;
#line 1414
      tmp___16 = __errno_location();
#line 1414
      *tmp___16 = 36;
#line 1415
      return ((FTSENT *)((void *)0));
    }
#line 1417
    p->fts_level = level;
#line 1418
    p->fts_parent = sp->fts_cur;
#line 1419
    p->fts_pathlen = new_len;
#line 1427
    p->fts_statp[0].st_ino = dp->d_ino;
#line 1430
    if (sp->fts_options & 4) {
#line 1431
      p->fts_accpath = p->fts_path;
#line 1432
      memmove((void *)cp, (void const   *)(p->fts_name), p->fts_namelen + 1UL);
    } else {
#line 1434
      p->fts_accpath = p->fts_name;
    }
#line 1436
    if ((unsigned long )sp->fts_compar == (unsigned long )((void *)0)) {
#line 1436
      goto _L___1;
    } else
#line 1436
    if (sp->fts_options & 1024) {
      _L___1: /* CIL Label */ 
#line 1449
      if (sp->fts_options & 16) {
#line 1449
        if (sp->fts_options & 8) {
#line 1449
          if ((int )dp->d_type != 0) {
#line 1449
            if (! ((int )dp->d_type == 4)) {
#line 1449
              tmp___17 = 1;
            } else {
#line 1449
              tmp___17 = 0;
            }
          } else {
#line 1449
            tmp___17 = 0;
          }
        } else {
#line 1449
          tmp___17 = 0;
        }
      } else {
#line 1449
        tmp___17 = 0;
      }
#line 1449
      skip_stat = (_Bool )tmp___17;
#line 1453
      p->fts_info = (unsigned short)11;
#line 1456
      set_stat_type(p->fts_statp, (unsigned int )dp->d_type);
#line 1457
      fts_set_stat_required(p, (_Bool )(! skip_stat));
#line 1458
      if (sp->fts_options & 16) {
#line 1458
        if ((int )dp->d_type == 4) {
#line 1458
          tmp___18 = 1;
        } else {
#line 1458
          tmp___18 = 0;
        }
      } else {
#line 1458
        tmp___18 = 0;
      }
#line 1458
      is_dir = (_Bool )tmp___18;
    } else {
#line 1461
      p->fts_info = fts_stat(sp, p, (_Bool)0);
#line 1462
      if ((int )p->fts_info == 1) {
#line 1462
        tmp___19 = 1;
      } else
#line 1462
      if ((int )p->fts_info == 2) {
#line 1462
        tmp___19 = 1;
      } else
#line 1462
      if ((int )p->fts_info == 5) {
#line 1462
        tmp___19 = 1;
      } else {
#line 1462
        tmp___19 = 0;
      }
#line 1462
      is_dir = (_Bool )tmp___19;
    }
#line 1468
    if (nlinks > 0UL) {
#line 1468
      if (is_dir) {
#line 1469
        nlinks -= (nlink_t )nostat;
      }
    }
#line 1472
    p->fts_link = (struct _ftsent *)((void *)0);
#line 1473
    if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 1474
      tail = p;
#line 1474
      head = tail;
    } else {
#line 1476
      tail->fts_link = p;
#line 1477
      tail = p;
    }
#line 1479
    nitems ++;
    __Cont: /* CIL Label */ ;
  }
#line 1481
  if (dirp) {
#line 1482
    closedir(dirp);
  }
#line 1488
  if (doadjust) {
#line 1489
    fts_padjust(sp, head);
  }
#line 1495
  if (sp->fts_options & 4) {
#line 1496
    if (len == sp->fts_pathlen) {
#line 1497
      cp --;
    } else
#line 1496
    if (nitems == 0UL) {
#line 1497
      cp --;
    }
#line 1498
    *cp = (char )'\000';
  }
#line 1508
  if (descend) {
#line 1508
    if (type == 1) {
#line 1508
      goto _L___2;
    } else
#line 1508
    if (! nitems) {
      _L___2: /* CIL Label */ 
#line 1508
      if (cur->fts_level == 0L) {
#line 1508
        fd_ring_clear(& sp->fts_fd_ring);
#line 1508
        if (! (sp->fts_options & 4)) {
#line 1508
          if (sp->fts_options & 512) {
#line 1508
            if (sp->fts_options & 512) {
#line 1508
              tmp___20 = -100;
            } else {
#line 1508
              tmp___20 = sp->fts_rfd;
            }
#line 1508
            cwd_advance_fd(sp, tmp___20, (_Bool)1);
#line 1508
            tmp___23 = 0;
          } else {
#line 1508
            if (sp->fts_options & 512) {
#line 1508
              tmp___21 = -100;
            } else {
#line 1508
              tmp___21 = sp->fts_rfd;
            }
#line 1508
            tmp___22 = fchdir(tmp___21);
#line 1508
            tmp___23 = tmp___22;
          }
#line 1508
          if (tmp___23) {
#line 1508
            tmp___24 = 1;
          } else {
#line 1508
            tmp___24 = 0;
          }
        } else {
#line 1508
          tmp___24 = 0;
        }
#line 1508
        tmp___26 = tmp___24;
      } else {
#line 1508
        tmp___25 = fts_safe_changedir(sp, cur->fts_parent, -1, "..");
#line 1508
        tmp___26 = tmp___25;
      }
#line 1508
      if (tmp___26) {
#line 1512
        cur->fts_info = (unsigned short)7;
#line 1513
        sp->fts_options |= 8192;
#line 1514
        fts_lfree(head);
#line 1515
        return ((FTSENT *)((void *)0));
      }
    }
  }
#line 1519
  if (! nitems) {
#line 1520
    if (type == 3) {
#line 1521
      cur->fts_info = (unsigned short)6;
    }
#line 1522
    fts_lfree(head);
#line 1523
    return ((FTSENT *)((void *)0));
  }
#line 1530
  if (nitems > 10000UL) {
#line 1530
    if (! sp->fts_compar) {
#line 1530
      if (sp->fts_options & 512) {
#line 1530
        tmp___27 = dirent_inode_sort_may_be_useful(sp->fts_cwd_fd);
#line 1530
        if (tmp___27) {
#line 1534
          sp->fts_compar = & fts_compare_ino;
#line 1535
          head = fts_sort(sp, head, nitems);
#line 1536
          sp->fts_compar = (int (*)(struct _ftsent  const  ** , struct _ftsent  const  ** ))((void *)0);
        }
      }
    }
  }
#line 1540
  if (sp->fts_compar) {
#line 1540
    if (nitems > 1UL) {
#line 1541
      head = fts_sort(sp, head, nitems);
    }
  }
#line 1542
  return (head);
}
}
#line 1689 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static unsigned short fts_stat(FTS *sp , FTSENT *p , _Bool follow ) 
{ 
  struct stat *sbp ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1693
  sbp = p->fts_statp;
#line 1696
  if (p->fts_level == 0L) {
#line 1696
    if (sp->fts_options & 1) {
#line 1697
      follow = (_Bool)1;
    }
  }
#line 1713
  if (sp->fts_options & 2) {
#line 1713
    goto _L;
  } else
#line 1713
  if (follow) {
    _L: /* CIL Label */ 
#line 1714
    tmp___3 = stat((char const   * __restrict  )p->fts_accpath, (struct stat * __restrict  )sbp);
#line 1714
    if (tmp___3) {
#line 1715
      tmp = __errno_location();
#line 1715
      saved_errno = *tmp;
#line 1716
      tmp___1 = __errno_location();
#line 1716
      if (*tmp___1 == 2) {
#line 1716
        tmp___2 = lstat((char const   * __restrict  )p->fts_accpath, (struct stat * __restrict  )sbp);
#line 1716
        if (tmp___2 == 0) {
#line 1718
          tmp___0 = __errno_location();
#line 1718
          *tmp___0 = 0;
#line 1719
          return ((unsigned short)13);
        }
      }
#line 1721
      p->fts_errno = saved_errno;
#line 1722
      goto err;
    }
  } else {
#line 1724
    tmp___5 = fstatat(sp->fts_cwd_fd, (char const   * __restrict  )p->fts_accpath,
                      (struct stat * __restrict  )sbp, 256);
#line 1724
    if (tmp___5) {
#line 1726
      tmp___4 = __errno_location();
#line 1726
      p->fts_errno = *tmp___4;
      err: 
#line 1727
      memset((void *)sbp, 0, sizeof(struct stat ));
#line 1728
      return ((unsigned short)10);
    }
  }
#line 1731
  if ((sbp->st_mode & 61440U) == 16384U) {
#line 1732
    if (sp->fts_options & 32) {
#line 1732
      tmp___6 = 0;
    } else {
#line 1732
      tmp___6 = 2;
    }
#line 1732
    p->fts_n_dirs_remaining = sbp->st_nlink - (__nlink_t )tmp___6;
#line 1734
    if ((int )p->fts_name[0] == 46) {
#line 1734
      if (! p->fts_name[1]) {
#line 1734
        goto _L___0;
      } else
#line 1734
      if ((int )p->fts_name[1] == 46) {
#line 1734
        if (! p->fts_name[2]) {
          _L___0: /* CIL Label */ 
#line 1736
          if (p->fts_level == 0L) {
#line 1736
            tmp___7 = 1;
          } else {
#line 1736
            tmp___7 = 5;
          }
#line 1736
          return ((unsigned short )tmp___7);
        }
      }
    }
#line 1760
    return ((unsigned short)1);
  }
#line 1762
  if ((sbp->st_mode & 61440U) == 40960U) {
#line 1763
    return ((unsigned short)12);
  }
#line 1764
  if ((sbp->st_mode & 61440U) == 32768U) {
#line 1765
    return ((unsigned short)8);
  }
#line 1766
  return ((unsigned short)3);
}
}
#line 1769 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static int fts_compar(void const   *a , void const   *b ) 
{ 
  FTSENT const   **pa ;
  FTSENT const   **pb ;
  int tmp ;

  {
#line 1777
  pa = (FTSENT const   **)a;
#line 1778
  pb = (FTSENT const   **)b;
#line 1779
  tmp = (*(((*(pa + 0))->fts_fts)->fts_compar))(pa, pb);
#line 1779
  return (tmp);
}
}
#line 1782 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static FTSENT *fts_sort(FTS *sp , FTSENT *head , size_t nitems ) 
{ 
  register FTSENT **ap ;
  register FTSENT *p ;
  FTSENT *dummy ;
  int (*compare)(void const   * , void const   * ) ;
  int (*tmp)(void const   * , void const   * ) ;
  FTSENT **a ;
  void *tmp___0 ;
  FTSENT **tmp___1 ;

  {
#line 1796
  if (sizeof(& dummy) == sizeof(void *)) {
#line 1796
    if ((long )(& dummy) == (long )((void *)(& dummy))) {
#line 1796
      tmp = (int (*)(void const   * , void const   * ))sp->fts_compar;
    } else {
#line 1796
      tmp = & fts_compar;
    }
  } else {
#line 1796
    tmp = & fts_compar;
  }
#line 1796
  compare = tmp;
#line 1809
  if (nitems > sp->fts_nitems) {
#line 1812
    sp->fts_nitems = nitems + 40UL;
#line 1813
    if (0xffffffffffffffffUL / sizeof(*a) < sp->fts_nitems) {
#line 1816
      free((void *)sp->fts_array);
#line 1817
      sp->fts_array = (struct _ftsent **)((void *)0);
#line 1818
      sp->fts_nitems = (size_t )0;
#line 1819
      return (head);
    } else {
#line 1813
      tmp___0 = realloc((void *)sp->fts_array, sp->fts_nitems * sizeof(*a));
#line 1813
      a = (FTSENT **)tmp___0;
#line 1813
      if (! a) {
#line 1816
        free((void *)sp->fts_array);
#line 1817
        sp->fts_array = (struct _ftsent **)((void *)0);
#line 1818
        sp->fts_nitems = (size_t )0;
#line 1819
        return (head);
      }
    }
#line 1821
    sp->fts_array = a;
  }
#line 1823
  ap = sp->fts_array;
#line 1823
  p = head;
#line 1823
  while (p) {
#line 1824
    tmp___1 = ap;
#line 1824
    ap ++;
#line 1824
    *tmp___1 = p;
#line 1823
    p = p->fts_link;
  }
#line 1825
  qsort((void *)sp->fts_array, nitems, sizeof(FTSENT *), compare);
#line 1826
  ap = sp->fts_array;
#line 1826
  head = *ap;
#line 1826
  while (1) {
#line 1826
    nitems --;
#line 1826
    if (! nitems) {
#line 1826
      break;
    }
#line 1827
    (*(ap + 0))->fts_link = *(ap + 1);
#line 1826
    ap ++;
  }
#line 1828
  (*(ap + 0))->fts_link = (struct _ftsent *)((void *)0);
#line 1829
  return (head);
}
}
#line 1832 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static FTSENT *fts_alloc(FTS *sp , char const   *name , size_t namelen ) 
{ 
  register FTSENT *p ;
  size_t len ;
  void *tmp ;

  {
#line 1843
  len = sizeof(FTSENT ) + namelen;
#line 1844
  tmp = malloc(len);
#line 1844
  p = (FTSENT *)tmp;
#line 1844
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1845
    return ((FTSENT *)((void *)0));
  }
#line 1848
  memmove((void *)(p->fts_name), (void const   *)name, namelen);
#line 1849
  p->fts_name[namelen] = (char )'\000';
#line 1851
  p->fts_namelen = namelen;
#line 1852
  p->fts_fts = sp;
#line 1853
  p->fts_path = sp->fts_path;
#line 1854
  p->fts_errno = 0;
#line 1855
  p->fts_flags = (unsigned short)0;
#line 1856
  p->fts_instr = (unsigned short)3;
#line 1857
  p->fts_number = 0L;
#line 1858
  p->fts_pointer = (void *)0;
#line 1859
  return (p);
}
}
#line 1862 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static void fts_lfree(FTSENT *head ) 
{ 
  register FTSENT *p ;

  {
#line 1869
  while (1) {
#line 1869
    p = head;
#line 1869
    if (! p) {
#line 1869
      break;
    }
#line 1870
    head = head->fts_link;
#line 1871
    free((void *)p);
  }
#line 1873
  return;
}
}
#line 1882 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static _Bool fts_palloc(FTS *sp , size_t more ) 
{ 
  char *p ;
  size_t new_len ;
  int *tmp ;
  void *tmp___0 ;

  {
#line 1887
  new_len = (sp->fts_pathlen + more) + 256UL;
#line 1892
  if (new_len < sp->fts_pathlen) {
#line 1893
    free((void *)sp->fts_path);
#line 1894
    sp->fts_path = (char *)((void *)0);
#line 1895
    tmp = __errno_location();
#line 1895
    *tmp = 36;
#line 1896
    return ((_Bool)0);
  }
#line 1898
  sp->fts_pathlen = new_len;
#line 1899
  tmp___0 = realloc((void *)sp->fts_path, sp->fts_pathlen);
#line 1899
  p = (char *)tmp___0;
#line 1900
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1901
    free((void *)sp->fts_path);
#line 1902
    sp->fts_path = (char *)((void *)0);
#line 1903
    return ((_Bool)0);
  }
#line 1905
  sp->fts_path = p;
#line 1906
  return ((_Bool)1);
}
}
#line 1913 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static void fts_padjust(FTS *sp , FTSENT *head ) 
{ 
  FTSENT *p ;
  char *addr ;

  {
#line 1918
  addr = sp->fts_path;
#line 1928
  p = sp->fts_child;
#line 1928
  while (p) {
#line 1929
    while (1) {
#line 1929
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1929
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1929
      p->fts_path = addr;
#line 1929
      break;
    }
#line 1928
    p = p->fts_link;
  }
#line 1932
  p = head;
#line 1932
  while (p->fts_level >= 0L) {
#line 1933
    while (1) {
#line 1933
      if ((unsigned long )p->fts_accpath != (unsigned long )(p->fts_name)) {
#line 1933
        p->fts_accpath = addr + (p->fts_accpath - p->fts_path);
      }
#line 1933
      p->fts_path = addr;
#line 1933
      break;
    }
#line 1934
    if (p->fts_link) {
#line 1934
      p = p->fts_link;
    } else {
#line 1934
      p = p->fts_parent;
    }
  }
#line 1936
  return;
}
}
#line 1938 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static size_t fts_maxarglen(char * const  *argv ) 
{ 
  size_t len ;
  size_t max ;

  {
#line 1944
  max = (size_t )0;
#line 1944
  while (*argv) {
#line 1945
    len = strlen((char const   *)*argv);
#line 1945
    if (len > max) {
#line 1946
      max = len;
    }
#line 1944
    argv ++;
  }
#line 1947
  return (max + 1UL);
}
}
#line 1959 "/home/wslee/project/coreutils-8.1/lib/fts.c"
static int fts_safe_changedir(FTS *sp , FTSENT *p , int fd , char const   *dir ) 
{ 
  int ret ;
  _Bool is_dotdot ;
  int tmp ;
  int tmp___0 ;
  int newfd ;
  int parent_fd ;
  _Bool tmp___1 ;
  struct stat sb ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int oerrno ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 1964
  if (dir) {
#line 1964
    tmp = strcmp(dir, "..");
#line 1964
    if (tmp == 0) {
#line 1964
      tmp___0 = 1;
    } else {
#line 1964
      tmp___0 = 0;
    }
  } else {
#line 1964
    tmp___0 = 0;
  }
#line 1964
  is_dotdot = (_Bool )tmp___0;
#line 1971
  if (sp->fts_options & 4) {
#line 1973
    if (sp->fts_options & 512) {
#line 1973
      if (0 <= fd) {
#line 1974
        close(fd);
      }
    }
#line 1975
    return (0);
  }
#line 1978
  if (fd < 0) {
#line 1978
    if (is_dotdot) {
#line 1978
      if (sp->fts_options & 512) {
#line 1985
        tmp___1 = i_ring_empty((I_ring const   *)(& sp->fts_fd_ring));
#line 1985
        if (! tmp___1) {
#line 1989
          parent_fd = i_ring_pop(& sp->fts_fd_ring);
#line 1990
          is_dotdot = (_Bool)1;
#line 1991
          if (0 <= parent_fd) {
#line 1993
            fd = parent_fd;
#line 1994
            dir = (char const   *)((void *)0);
          }
        }
      }
    }
  }
#line 1999
  newfd = fd;
#line 2000
  if (fd < 0) {
#line 2000
    newfd = diropen((FTS const   *)sp, dir);
#line 2000
    if (newfd < 0) {
#line 2001
      return (-1);
    }
  }
#line 2010
  if (sp->fts_options & 2) {
#line 2010
    goto _L;
  } else
#line 2010
  if (dir) {
#line 2010
    tmp___4 = strcmp(dir, "..");
#line 2010
    if (tmp___4 == 0) {
      _L: /* CIL Label */ 
#line 2014
      tmp___2 = fstat(newfd, & sb);
#line 2014
      if (tmp___2) {
#line 2016
        ret = -1;
#line 2017
        goto bail;
      }
#line 2019
      if (p->fts_statp[0].st_dev != sb.st_dev) {
#line 2022
        tmp___3 = __errno_location();
#line 2022
        *tmp___3 = 2;
#line 2023
        ret = -1;
#line 2024
        goto bail;
      } else
#line 2019
      if (p->fts_statp[0].st_ino != sb.st_ino) {
#line 2022
        tmp___3 = __errno_location();
#line 2022
        *tmp___3 = 2;
#line 2023
        ret = -1;
#line 2024
        goto bail;
      }
    }
  }
#line 2028
  if (sp->fts_options & 512) {
#line 2030
    cwd_advance_fd(sp, newfd, (_Bool )(! is_dotdot));
#line 2031
    return (0);
  }
#line 2034
  ret = fchdir(newfd);
  bail: 
#line 2036
  if (fd < 0) {
#line 2038
    tmp___5 = __errno_location();
#line 2038
    oerrno = *tmp___5;
#line 2039
    close(newfd);
#line 2040
    tmp___6 = __errno_location();
#line 2040
    *tmp___6 = oerrno;
  }
#line 2042
  return (ret);
}
}
#line 1 "cil-LrBWqvz9.o"
#pragma merger("0","../lib/full-read.o.i","")
#line 24 "/home/wslee/project/coreutils-8.1/lib/full-read.h"
size_t full_read(int fd , void *buf___0 , size_t count ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/safe-read.h"
size_t safe_read(int fd , void *buf___0 , size_t count ) ;
#line 58 "/home/wslee/project/coreutils-8.1/lib/full-write.c"
size_t full_read(int fd , void *buf___0 , size_t count ) 
{ 
  size_t total ;
  char *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 61
  total = (size_t )0;
#line 62
  ptr = (char *)buf___0;
#line 64
  while (count > 0UL) {
#line 66
    tmp = safe_read(fd, (void *)ptr, count);
#line 66
    n_rw = tmp;
#line 67
    if (n_rw == 0xffffffffffffffffUL) {
#line 68
      break;
    }
#line 69
    if (n_rw == 0UL) {
#line 71
      tmp___0 = __errno_location();
#line 71
      *tmp___0 = 0;
#line 72
      break;
    }
#line 74
    total += n_rw;
#line 75
    ptr += n_rw;
#line 76
    count -= n_rw;
  }
#line 79
  return (total);
}
}
#line 1 "cil-YAvCKam0.o"
#pragma merger("0","../lib/full-write.o.i","")
#line 29 "/home/wslee/project/coreutils-8.1/lib/full-write.h"
size_t full_write(int fd , void const   *buf___0 , size_t count ) ;
#line 24 "/home/wslee/project/coreutils-8.1/lib/safe-write.h"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) ;
#line 58 "/home/wslee/project/coreutils-8.1/lib/full-write.c"
size_t full_write(int fd , void const   *buf___0 , size_t count ) 
{ 
  size_t total ;
  char const   *ptr ;
  size_t n_rw ;
  size_t tmp ;
  int *tmp___0 ;

  {
#line 61
  total = (size_t )0;
#line 62
  ptr = (char const   *)buf___0;
#line 64
  while (count > 0UL) {
#line 66
    tmp = safe_write(fd, (void const   *)ptr, count);
#line 66
    n_rw = tmp;
#line 67
    if (n_rw == 0xffffffffffffffffUL) {
#line 68
      break;
    }
#line 69
    if (n_rw == 0UL) {
#line 71
      tmp___0 = __errno_location();
#line 71
      *tmp___0 = 28;
#line 72
      break;
    }
#line 74
    total += n_rw;
#line 75
    ptr += n_rw;
#line 76
    count -= n_rw;
  }
#line 79
  return (total);
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 1 "cil-KQizUtV9.o"
#pragma merger("0","../lib/getdate.o.i","")
#line 22 "/home/wslee/project/coreutils-8.1/lib/getdate.h"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) ;
#line 35 "/home/wslee/project/coreutils-8.1/lib/timespec.h"
void gettime(struct timespec *ts ) ;
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 584 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 588
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unsetenv)(char const   *__name ) ;
#line 774
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 60 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 205 "getdate.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) ;
#line 206
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) ;
#line 207
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) ;
#line 212 "getdate.y"
static void digits_to_date_time(parser_control *pc , textint text_int ) 
{ 


  {
#line 215
  if (pc->dates_seen) {
#line 215
    if (! pc->year.digits) {
#line 215
      if (! pc->rels_seen) {
#line 215
        if (pc->times_seen) {
#line 217
          pc->year = text_int;
        } else
#line 215
        if (2UL < text_int.digits) {
#line 217
          pc->year = text_int;
        } else {
#line 215
          goto _L___1;
        }
      } else {
#line 215
        goto _L___1;
      }
    } else {
#line 215
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 220
  if (4UL < text_int.digits) {
#line 222
    (pc->dates_seen) ++;
#line 223
    pc->day = text_int.value % 100L;
#line 224
    pc->month = (text_int.value / 100L) % 100L;
#line 225
    pc->year.value = text_int.value / 10000L;
#line 226
    pc->year.digits = text_int.digits - 4UL;
  } else {
#line 230
    (pc->times_seen) ++;
#line 231
    if (text_int.digits <= 2UL) {
#line 233
      pc->hour = text_int.value;
#line 234
      pc->minutes = 0L;
    } else {
#line 238
      pc->hour = text_int.value / 100L;
#line 239
      pc->minutes = text_int.value % 100L;
    }
#line 241
    pc->seconds.tv_sec = (__time_t )0;
#line 242
    pc->seconds.tv_nsec = (__syscall_slong_t )0;
#line 243
    pc->meridian = 2;
  }
#line 246
  return;
}
}
#line 249 "getdate.y"
static void apply_relative_time(parser_control *pc , relative_time rel , int factor ) 
{ 


  {
#line 252
  pc->rel.ns += (long )factor * rel.ns;
#line 253
  pc->rel.seconds += (long_time_t )factor * rel.seconds;
#line 254
  pc->rel.minutes += (long )factor * rel.minutes;
#line 255
  pc->rel.hour += (long )factor * rel.hour;
#line 256
  pc->rel.day += (long )factor * rel.day;
#line 257
  pc->rel.month += (long )factor * rel.month;
#line 258
  pc->rel.year += (long )factor * rel.year;
#line 259
  pc->rels_seen = (_Bool)1;
#line 260
  return;
}
}
#line 263 "getdate.y"
static void set_hhmmss(parser_control *pc , long hour , long minutes , time_t sec ,
                       long nsec ) 
{ 


  {
#line 267
  pc->hour = hour;
#line 268
  pc->minutes = minutes;
#line 269
  pc->seconds.tv_sec = sec;
#line 270
  pc->seconds.tv_nsec = nsec;
#line 271
  return;
}
}
#line 681 "getdate.c"
static yytype_uint8 const   yytranslate[278]  = 
#line 681 "getdate.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )24,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22};
#line 802 "getdate.c"
static yytype_uint8 const   yyr1[83]  = 
#line 802
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )47};
#line 816 "getdate.c"
static yytype_uint8 const   yyr2[83]  = 
#line 816
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )4,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1};
#line 832 "getdate.c"
static yytype_uint8 const   yydefact[100]  = 
#line 832
  {      (yytype_uint8 const   )5,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )74,      (yytype_uint8 const   )76,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )4,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )45,      (yytype_uint8 const   )48,      (yytype_uint8 const   )54, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )62,      (yytype_uint8 const   )51,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )27,      (yytype_uint8 const   )25,      (yytype_uint8 const   )20,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )11,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )41,      (yytype_uint8 const   )63,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )28,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )36,      (yytype_uint8 const   )43,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )52,      (yytype_uint8 const   )55,      (yytype_uint8 const   )58,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )26,      (yytype_uint8 const   )79,      (yytype_uint8 const   )23, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )66,      (yytype_uint8 const   )44,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )56,      (yytype_uint8 const   )59,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )15,      (yytype_uint8 const   )38,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )40,      (yytype_uint8 const   )35,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )24,      (yytype_uint8 const   )34,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )81,      (yytype_uint8 const   )31,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )82,      (yytype_uint8 const   )79,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )0,      (yytype_uint8 const   )17,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )79,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19};
#line 847 "getdate.c"
static yytype_int8 const   yydefgoto[21]  = 
#line 847
  {      (yytype_int8 const   )-1,      (yytype_int8 const   )2,      (yytype_int8 const   )3,      (yytype_int8 const   )4, 
        (yytype_int8 const   )30,      (yytype_int8 const   )31,      (yytype_int8 const   )32,      (yytype_int8 const   )33, 
        (yytype_int8 const   )34,      (yytype_int8 const   )35,      (yytype_int8 const   )36,      (yytype_int8 const   )37, 
        (yytype_int8 const   )38,      (yytype_int8 const   )39,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )11,      (yytype_int8 const   )40,      (yytype_int8 const   )41,      (yytype_int8 const   )81, 
        (yytype_int8 const   )92};
#line 857 "getdate.c"
static yytype_int8 const   yypact[100]  = 
#line 857
  {      (yytype_int8 const   )-17,      (yytype_int8 const   )56,      (yytype_int8 const   )15,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )26,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )36,      (yytype_int8 const   )-82,      (yytype_int8 const   )68,      (yytype_int8 const   )10, 
        (yytype_int8 const   )50,      (yytype_int8 const   )9,      (yytype_int8 const   )59,      (yytype_int8 const   )-5, 
        (yytype_int8 const   )72,      (yytype_int8 const   )73,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )80,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )65,      (yytype_int8 const   )61,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )17,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )60,      (yytype_int8 const   )44, 
        (yytype_int8 const   )67,      (yytype_int8 const   )69,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )70, 
        (yytype_int8 const   )71,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-7,      (yytype_int8 const   )62,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-2, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )75,      (yytype_int8 const   )-82,      (yytype_int8 const   )55, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )74,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82};
#line 872 "getdate.c"
static yytype_int8 const   yypgoto[21]  = 
#line 872
  {      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )46,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82, 
        (yytype_int8 const   )-6,      (yytype_int8 const   )-82,      (yytype_int8 const   )-82,      (yytype_int8 const   )-81, 
        (yytype_int8 const   )-3};
#line 883 "getdate.c"
static yytype_uint8 const   yytable[99]  = 
#line 883
  {      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )67,      (yytype_uint8 const   )1,      (yytype_uint8 const   )68, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )94,      (yytype_uint8 const   )69,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )90,      (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )91,      (yytype_uint8 const   )6,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )73,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )54,      (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )13, 
        (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )80,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58, 
        (yytype_uint8 const   )59,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )48,      (yytype_uint8 const   )49,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )42,      (yytype_uint8 const   )52,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )89,      (yytype_uint8 const   )55, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )74,      (yytype_uint8 const   )97,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )95,      (yytype_uint8 const   )79,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )96, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )80};
#line 903 "getdate.c"
static yytype_int8 const   yycheck[99]  = 
#line 903
  {      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )23,      (yytype_int8 const   )12, 
        (yytype_int8 const   )15,      (yytype_int8 const   )90,      (yytype_int8 const   )15,      (yytype_int8 const   )16, 
        (yytype_int8 const   )19,      (yytype_int8 const   )4,      (yytype_int8 const   )19,      (yytype_int8 const   )0, 
        (yytype_int8 const   )97,      (yytype_int8 const   )24,      (yytype_int8 const   )20,      (yytype_int8 const   )24, 
        (yytype_int8 const   )22,      (yytype_int8 const   )26,      (yytype_int8 const   )5,      (yytype_int8 const   )6, 
        (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10, 
        (yytype_int8 const   )19,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )11,      (yytype_int8 const   )12,      (yytype_int8 const   )13, 
        (yytype_int8 const   )14,      (yytype_int8 const   )24,      (yytype_int8 const   )16,      (yytype_int8 const   )17, 
        (yytype_int8 const   )18,      (yytype_int8 const   )19,      (yytype_int8 const   )20,      (yytype_int8 const   )21, 
        (yytype_int8 const   )22,      (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7, 
        (yytype_int8 const   )8,      (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )5, 
        (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8,      (yytype_int8 const   )9, 
        (yytype_int8 const   )10,      (yytype_int8 const   )25,      (yytype_int8 const   )12,      (yytype_int8 const   )19, 
        (yytype_int8 const   )5,      (yytype_int8 const   )6,      (yytype_int8 const   )7,      (yytype_int8 const   )8, 
        (yytype_int8 const   )9,      (yytype_int8 const   )10,      (yytype_int8 const   )15,      (yytype_int8 const   )25, 
        (yytype_int8 const   )4,      (yytype_int8 const   )27,      (yytype_int8 const   )19,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )21,      (yytype_int8 const   )22,      (yytype_int8 const   )19, 
        (yytype_int8 const   )20,      (yytype_int8 const   )9,      (yytype_int8 const   )9,      (yytype_int8 const   )3, 
        (yytype_int8 const   )19,      (yytype_int8 const   )91,      (yytype_int8 const   )25,      (yytype_int8 const   )20, 
        (yytype_int8 const   )26,      (yytype_int8 const   )20,      (yytype_int8 const   )20,      (yytype_int8 const   )20, 
        (yytype_int8 const   )95,      (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )20, 
        (yytype_int8 const   )-1,      (yytype_int8 const   )-1,      (yytype_int8 const   )24};
#line 919 "getdate.c"
static yytype_uint8 const   yystos[100]  = 
#line 919
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )23,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )30,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )25,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )4,      (yytype_uint8 const   )19,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )5,      (yytype_uint8 const   )6, 
        (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )26,      (yytype_uint8 const   )39,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )3,      (yytype_uint8 const   )19,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )24,      (yytype_uint8 const   )46,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )15,      (yytype_uint8 const   )19,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )26,      (yytype_uint8 const   )46,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )19,      (yytype_uint8 const   )47,      (yytype_uint8 const   )46};
#line 1437 "getdate.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep , parser_control *pc ) 
{ 


  {
#line 1451
  if (! yymsg) {
#line 1452
    yymsg = "Deleting";
  }
#line 1455
  switch (yytype) {
  default: 
#line 1459
  break;
  }
#line 1461
  return;
}
}
#line 1473
int yyparse(parser_control *pc ) ;
#line 1497 "getdate.c"
int yyparse(parser_control *pc ) 
{ 
  int yychar ;
  YYSTYPE yylval ;
  int yynerrs ;
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[20] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[20] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  long tmp___0 ;
  relative_time __constr_expr_0 ;
  relative_time __constr_expr_1 ;
  relative_time __constr_expr_2 ;
  relative_time __constr_expr_3 ;
  relative_time __constr_expr_4 ;
  relative_time __constr_expr_5 ;
  relative_time __constr_expr_6 ;
  relative_time __constr_expr_7 ;
  relative_time __constr_expr_8 ;
  relative_time __constr_expr_9 ;
  relative_time __constr_expr_10 ;
  relative_time __constr_expr_11 ;
  relative_time __constr_expr_12 ;
  relative_time __constr_expr_13 ;
  relative_time __constr_expr_14 ;
  relative_time __constr_expr_15 ;
  relative_time __constr_expr_16 ;
  relative_time __constr_expr_17 ;
  relative_time __constr_expr_18 ;
  relative_time __constr_expr_19 ;
  relative_time __constr_expr_20 ;
  relative_time __constr_expr_21 ;
  relative_time __constr_expr_22 ;
  relative_time __constr_expr_23 ;
  relative_time __constr_expr_24 ;
  relative_time __constr_expr_25 ;
  relative_time __constr_expr_26 ;

  {
#line 1557
  yylen = 0;
#line 1559
  yytoken = 0;
#line 1560
  yyss = yyssa;
#line 1561
  yyvs = yyvsa;
#line 1562
  yystacksize = 20UL;
#line 1566
  yystate = 0;
#line 1567
  yyerrstatus = 0;
#line 1568
  yynerrs = 0;
#line 1569
  yychar = -2;
#line 1575
  yyssp = yyss;
#line 1576
  yyvsp = yyvs;
#line 1578
  goto yysetstate;
  yynewstate: 
#line 1586
  yyssp ++;
  yysetstate: 
#line 1589
  *yyssp = (yytype_int16 )yystate;
#line 1591
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1594
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1621
    if (20UL <= yystacksize) {
#line 1622
      goto yyexhaustedlab;
    }
#line 1623
    yystacksize *= 2UL;
#line 1624
    if (20UL < yystacksize) {
#line 1625
      yystacksize = 20UL;
    }
#line 1628
    yyss1 = yyss;
#line 1629
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1629
    yyptr = (union yyalloc *)tmp;
#line 1631
    if (! yyptr) {
#line 1632
      goto yyexhaustedlab;
    }
#line 1633
    while (1) {
#line 1633
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1633
      yyss = & yyptr->yyss_alloc;
#line 1633
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1633
      yyptr += yynewbytes / sizeof(*yyptr);
#line 1633
      break;
    }
#line 1634
    while (1) {
#line 1634
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1634
      yyvs = & yyptr->yyvs_alloc;
#line 1634
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1634
      yyptr += yynewbytes___0 / sizeof(*yyptr);
#line 1634
      break;
    }
#line 1636
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
#line 1637
      free((void *)yyss1);
    }
#line 1642
    yyssp = (yyss + yysize) - 1;
#line 1643
    yyvsp = (yyvs + yysize) - 1;
#line 1648
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1649
      goto yyabortlab;
    }
  }
#line 1654
  if (yystate == 12) {
#line 1655
    goto yyacceptlab;
  }
#line 1657
  goto yybackup;
  yybackup: 
#line 1668
  yyn = (int )yypact[yystate];
#line 1669
  if (yyn == -82) {
#line 1670
    goto yydefault;
  }
#line 1675
  if (yychar == -2) {
#line 1678
    yychar = yylex(& yylval, pc);
  }
#line 1681
  if (yychar <= 0) {
#line 1683
    yytoken = 0;
#line 1683
    yychar = yytoken;
  } else
#line 1688
  if ((unsigned int )yychar <= 277U) {
#line 1688
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1688
    yytoken = 2;
  }
#line 1694
  yyn += yytoken;
#line 1695
  if (yyn < 0) {
#line 1696
    goto yydefault;
  } else
#line 1695
  if (98 < yyn) {
#line 1696
    goto yydefault;
  } else
#line 1695
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1696
    goto yydefault;
  }
#line 1697
  yyn = (int )yytable[yyn];
#line 1698
  if (yyn <= 0) {
#line 1702
    yyn = - yyn;
#line 1703
    goto yyreduce;
  }
#line 1708
  if (yyerrstatus) {
#line 1709
    yyerrstatus --;
  }
#line 1715
  yychar = -2;
#line 1717
  yystate = yyn;
#line 1718
  yyvsp ++;
#line 1718
  *yyvsp = yylval;
#line 1720
  goto yynewstate;
  yydefault: 
#line 1727
  yyn = (int )yydefact[yystate];
#line 1728
  if (yyn == 0) {
#line 1729
    goto yyerrlab;
  }
#line 1730
  goto yyreduce;
  yyreduce: 
#line 1738
  yylen = (int )yyr2[yyn];
#line 1748
  yyval = *(yyvsp + (1 - yylen));
#line 1752
  switch (yyn) {
  case 4: 
#line 318 "getdate.y"
  pc->seconds = (yyvsp + 0)->timespec;
#line 319
  pc->timespec_seen = (_Bool)1;
#line 321
  break;
  case 7: 
#line 330
  (pc->times_seen) ++;
#line 331
  break;
  case 8: 
#line 332
  (pc->local_zones_seen) ++;
#line 333
  break;
  case 9: 
#line 334
  (pc->zones_seen) ++;
#line 335
  break;
  case 10: 
#line 336
  (pc->dates_seen) ++;
#line 337
  break;
  case 11: 
#line 338
  (pc->days_seen) ++;
#line 339
  break;
  case 15: 
#line 347
  set_hhmmss(pc, (yyvsp + -1)->textintval.value, 0L, (time_t )0, 0L);
#line 348
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 350
  break;
  case 16: 
#line 352
  set_hhmmss(pc, (yyvsp + -3)->textintval.value, (yyvsp + -1)->textintval.value, (time_t )0,
             0L);
#line 353
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 355
  break;
  case 17: 
#line 357
  set_hhmmss(pc, (yyvsp + -4)->textintval.value, (yyvsp + -2)->textintval.value, (time_t )0,
             0L);
#line 358
  pc->meridian = 2;
#line 359
  (pc->zones_seen) ++;
#line 360
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 362
  break;
  case 18: 
#line 364
  set_hhmmss(pc, (yyvsp + -5)->textintval.value, (yyvsp + -3)->textintval.value, (yyvsp + -1)->timespec.tv_sec,
             (yyvsp + -1)->timespec.tv_nsec);
#line 365
  pc->meridian = (int )(yyvsp + 0)->intval;
#line 367
  break;
  case 19: 
#line 369
  set_hhmmss(pc, (yyvsp + -6)->textintval.value, (yyvsp + -4)->textintval.value, (yyvsp + -2)->timespec.tv_sec,
             (yyvsp + -2)->timespec.tv_nsec);
#line 370
  pc->meridian = 2;
#line 371
  (pc->zones_seen) ++;
#line 372
  pc->time_zone = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 374
  break;
  case 20: 
#line 379
  pc->local_isdst = (int )(yyvsp + 0)->intval;
#line 380
  pc->dsts_seen += (size_t )(0L < (yyvsp + 0)->intval);
#line 382
  break;
  case 21: 
#line 384
  pc->local_isdst = 1;
#line 385
  pc->dsts_seen += (size_t )((0L < (yyvsp + -1)->intval) + 1);
#line 387
  break;
  case 22: 
#line 391
  pc->time_zone = (yyvsp + 0)->intval;
#line 392
  break;
  case 23: 
#line 393
  pc->time_zone = (yyvsp + -1)->intval;
#line 394
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 395
  break;
  case 24: 
#line 396
  tmp___0 = time_zone_hhmm(pc, (yyvsp + -1)->textintval, (yyvsp + 0)->intval);
#line 396
  pc->time_zone = (yyvsp + -2)->intval + tmp___0;
#line 397
  break;
  case 25: 
#line 398
  pc->time_zone = (yyvsp + 0)->intval + 60L;
#line 399
  break;
  case 26: 
#line 400
  pc->time_zone = (yyvsp + -1)->intval + 60L;
#line 401
  break;
  case 27: 
#line 406
  pc->day_ordinal = 0L;
#line 407
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 409
  break;
  case 28: 
#line 411
  pc->day_ordinal = 0L;
#line 412
  pc->day_number = (int )(yyvsp + -1)->intval;
#line 414
  break;
  case 29: 
#line 416
  pc->day_ordinal = (yyvsp + -1)->intval;
#line 417
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 419
  break;
  case 30: 
#line 421
  pc->day_ordinal = (yyvsp + -1)->textintval.value;
#line 422
  pc->day_number = (int )(yyvsp + 0)->intval;
#line 424
  break;
  case 31: 
#line 429
  pc->month = (yyvsp + -2)->textintval.value;
#line 430
  pc->day = (yyvsp + 0)->textintval.value;
#line 432
  break;
  case 32: 
#line 439
  if (4UL <= (yyvsp + -4)->textintval.digits) {
#line 441
    pc->year = (yyvsp + -4)->textintval;
#line 442
    pc->month = (yyvsp + -2)->textintval.value;
#line 443
    pc->day = (yyvsp + 0)->textintval.value;
  } else {
#line 447
    pc->month = (yyvsp + -4)->textintval.value;
#line 448
    pc->day = (yyvsp + -2)->textintval.value;
#line 449
    pc->year = (yyvsp + 0)->textintval;
  }
#line 452
  break;
  case 33: 
#line 455
  pc->year = (yyvsp + -2)->textintval;
#line 456
  pc->month = - (yyvsp + -1)->textintval.value;
#line 457
  pc->day = - (yyvsp + 0)->textintval.value;
#line 459
  break;
  case 34: 
#line 462
  pc->day = (yyvsp + -2)->textintval.value;
#line 463
  pc->month = (yyvsp + -1)->intval;
#line 464
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 465
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 467
  break;
  case 35: 
#line 470
  pc->month = (yyvsp + -2)->intval;
#line 471
  pc->day = - (yyvsp + -1)->textintval.value;
#line 472
  pc->year.value = - (yyvsp + 0)->textintval.value;
#line 473
  pc->year.digits = (yyvsp + 0)->textintval.digits;
#line 475
  break;
  case 36: 
#line 477
  pc->month = (yyvsp + -1)->intval;
#line 478
  pc->day = (yyvsp + 0)->textintval.value;
#line 480
  break;
  case 37: 
#line 482
  pc->month = (yyvsp + -3)->intval;
#line 483
  pc->day = (yyvsp + -2)->textintval.value;
#line 484
  pc->year = (yyvsp + 0)->textintval;
#line 486
  break;
  case 38: 
#line 488
  pc->day = (yyvsp + -1)->textintval.value;
#line 489
  pc->month = (yyvsp + 0)->intval;
#line 491
  break;
  case 39: 
#line 493
  pc->day = (yyvsp + -2)->textintval.value;
#line 494
  pc->month = (yyvsp + -1)->intval;
#line 495
  pc->year = (yyvsp + 0)->textintval;
#line 497
  break;
  case 40: 
#line 501
  apply_relative_time(pc, (yyvsp + -1)->rel, -1);
#line 502
  break;
  case 41: 
#line 503
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 504
  break;
  case 42: 
#line 505
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 506
  break;
  case 43: 
#line 510
  __constr_expr_0.year = 0L;
#line 510
  __constr_expr_0.month = 0L;
#line 510
  __constr_expr_0.day = 0L;
#line 510
  __constr_expr_0.hour = 0L;
#line 510
  __constr_expr_0.minutes = 0L;
#line 510
  __constr_expr_0.seconds = (long_time_t )0;
#line 510
  __constr_expr_0.ns = 0L;
#line 510
  yyval.rel = __constr_expr_0;
#line 510
  yyval.rel.year = (yyvsp + -1)->intval;
#line 511
  break;
  case 44: 
#line 512
  __constr_expr_1.year = 0L;
#line 512
  __constr_expr_1.month = 0L;
#line 512
  __constr_expr_1.day = 0L;
#line 512
  __constr_expr_1.hour = 0L;
#line 512
  __constr_expr_1.minutes = 0L;
#line 512
  __constr_expr_1.seconds = (long_time_t )0;
#line 512
  __constr_expr_1.ns = 0L;
#line 512
  yyval.rel = __constr_expr_1;
#line 512
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 513
  break;
  case 45: 
#line 514
  __constr_expr_2.year = 0L;
#line 514
  __constr_expr_2.month = 0L;
#line 514
  __constr_expr_2.day = 0L;
#line 514
  __constr_expr_2.hour = 0L;
#line 514
  __constr_expr_2.minutes = 0L;
#line 514
  __constr_expr_2.seconds = (long_time_t )0;
#line 514
  __constr_expr_2.ns = 0L;
#line 514
  yyval.rel = __constr_expr_2;
#line 514
  yyval.rel.year = 1L;
#line 515
  break;
  case 46: 
#line 516
  __constr_expr_3.year = 0L;
#line 516
  __constr_expr_3.month = 0L;
#line 516
  __constr_expr_3.day = 0L;
#line 516
  __constr_expr_3.hour = 0L;
#line 516
  __constr_expr_3.minutes = 0L;
#line 516
  __constr_expr_3.seconds = (long_time_t )0;
#line 516
  __constr_expr_3.ns = 0L;
#line 516
  yyval.rel = __constr_expr_3;
#line 516
  yyval.rel.month = (yyvsp + -1)->intval;
#line 517
  break;
  case 47: 
#line 518
  __constr_expr_4.year = 0L;
#line 518
  __constr_expr_4.month = 0L;
#line 518
  __constr_expr_4.day = 0L;
#line 518
  __constr_expr_4.hour = 0L;
#line 518
  __constr_expr_4.minutes = 0L;
#line 518
  __constr_expr_4.seconds = (long_time_t )0;
#line 518
  __constr_expr_4.ns = 0L;
#line 518
  yyval.rel = __constr_expr_4;
#line 518
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 519
  break;
  case 48: 
#line 520
  __constr_expr_5.year = 0L;
#line 520
  __constr_expr_5.month = 0L;
#line 520
  __constr_expr_5.day = 0L;
#line 520
  __constr_expr_5.hour = 0L;
#line 520
  __constr_expr_5.minutes = 0L;
#line 520
  __constr_expr_5.seconds = (long_time_t )0;
#line 520
  __constr_expr_5.ns = 0L;
#line 520
  yyval.rel = __constr_expr_5;
#line 520
  yyval.rel.month = 1L;
#line 521
  break;
  case 49: 
#line 522
  __constr_expr_6.year = 0L;
#line 522
  __constr_expr_6.month = 0L;
#line 522
  __constr_expr_6.day = 0L;
#line 522
  __constr_expr_6.hour = 0L;
#line 522
  __constr_expr_6.minutes = 0L;
#line 522
  __constr_expr_6.seconds = (long_time_t )0;
#line 522
  __constr_expr_6.ns = 0L;
#line 522
  yyval.rel = __constr_expr_6;
#line 522
  yyval.rel.day = (yyvsp + -1)->intval * (yyvsp + 0)->intval;
#line 523
  break;
  case 50: 
#line 524
  __constr_expr_7.year = 0L;
#line 524
  __constr_expr_7.month = 0L;
#line 524
  __constr_expr_7.day = 0L;
#line 524
  __constr_expr_7.hour = 0L;
#line 524
  __constr_expr_7.minutes = 0L;
#line 524
  __constr_expr_7.seconds = (long_time_t )0;
#line 524
  __constr_expr_7.ns = 0L;
#line 524
  yyval.rel = __constr_expr_7;
#line 524
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 525
  break;
  case 51: 
#line 526
  __constr_expr_8.year = 0L;
#line 526
  __constr_expr_8.month = 0L;
#line 526
  __constr_expr_8.day = 0L;
#line 526
  __constr_expr_8.hour = 0L;
#line 526
  __constr_expr_8.minutes = 0L;
#line 526
  __constr_expr_8.seconds = (long_time_t )0;
#line 526
  __constr_expr_8.ns = 0L;
#line 526
  yyval.rel = __constr_expr_8;
#line 526
  yyval.rel.day = (yyvsp + 0)->intval;
#line 527
  break;
  case 52: 
#line 528
  __constr_expr_9.year = 0L;
#line 528
  __constr_expr_9.month = 0L;
#line 528
  __constr_expr_9.day = 0L;
#line 528
  __constr_expr_9.hour = 0L;
#line 528
  __constr_expr_9.minutes = 0L;
#line 528
  __constr_expr_9.seconds = (long_time_t )0;
#line 528
  __constr_expr_9.ns = 0L;
#line 528
  yyval.rel = __constr_expr_9;
#line 528
  yyval.rel.hour = (yyvsp + -1)->intval;
#line 529
  break;
  case 53: 
#line 530
  __constr_expr_10.year = 0L;
#line 530
  __constr_expr_10.month = 0L;
#line 530
  __constr_expr_10.day = 0L;
#line 530
  __constr_expr_10.hour = 0L;
#line 530
  __constr_expr_10.minutes = 0L;
#line 530
  __constr_expr_10.seconds = (long_time_t )0;
#line 530
  __constr_expr_10.ns = 0L;
#line 530
  yyval.rel = __constr_expr_10;
#line 530
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 531
  break;
  case 54: 
#line 532
  __constr_expr_11.year = 0L;
#line 532
  __constr_expr_11.month = 0L;
#line 532
  __constr_expr_11.day = 0L;
#line 532
  __constr_expr_11.hour = 0L;
#line 532
  __constr_expr_11.minutes = 0L;
#line 532
  __constr_expr_11.seconds = (long_time_t )0;
#line 532
  __constr_expr_11.ns = 0L;
#line 532
  yyval.rel = __constr_expr_11;
#line 532
  yyval.rel.hour = 1L;
#line 533
  break;
  case 55: 
#line 534
  __constr_expr_12.year = 0L;
#line 534
  __constr_expr_12.month = 0L;
#line 534
  __constr_expr_12.day = 0L;
#line 534
  __constr_expr_12.hour = 0L;
#line 534
  __constr_expr_12.minutes = 0L;
#line 534
  __constr_expr_12.seconds = (long_time_t )0;
#line 534
  __constr_expr_12.ns = 0L;
#line 534
  yyval.rel = __constr_expr_12;
#line 534
  yyval.rel.minutes = (yyvsp + -1)->intval;
#line 535
  break;
  case 56: 
#line 536
  __constr_expr_13.year = 0L;
#line 536
  __constr_expr_13.month = 0L;
#line 536
  __constr_expr_13.day = 0L;
#line 536
  __constr_expr_13.hour = 0L;
#line 536
  __constr_expr_13.minutes = 0L;
#line 536
  __constr_expr_13.seconds = (long_time_t )0;
#line 536
  __constr_expr_13.ns = 0L;
#line 536
  yyval.rel = __constr_expr_13;
#line 536
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 537
  break;
  case 57: 
#line 538
  __constr_expr_14.year = 0L;
#line 538
  __constr_expr_14.month = 0L;
#line 538
  __constr_expr_14.day = 0L;
#line 538
  __constr_expr_14.hour = 0L;
#line 538
  __constr_expr_14.minutes = 0L;
#line 538
  __constr_expr_14.seconds = (long_time_t )0;
#line 538
  __constr_expr_14.ns = 0L;
#line 538
  yyval.rel = __constr_expr_14;
#line 538
  yyval.rel.minutes = 1L;
#line 539
  break;
  case 58: 
#line 540
  __constr_expr_15.year = 0L;
#line 540
  __constr_expr_15.month = 0L;
#line 540
  __constr_expr_15.day = 0L;
#line 540
  __constr_expr_15.hour = 0L;
#line 540
  __constr_expr_15.minutes = 0L;
#line 540
  __constr_expr_15.seconds = (long_time_t )0;
#line 540
  __constr_expr_15.ns = 0L;
#line 540
  yyval.rel = __constr_expr_15;
#line 540
  yyval.rel.seconds = (yyvsp + -1)->intval;
#line 541
  break;
  case 59: 
#line 542
  __constr_expr_16.year = 0L;
#line 542
  __constr_expr_16.month = 0L;
#line 542
  __constr_expr_16.day = 0L;
#line 542
  __constr_expr_16.hour = 0L;
#line 542
  __constr_expr_16.minutes = 0L;
#line 542
  __constr_expr_16.seconds = (long_time_t )0;
#line 542
  __constr_expr_16.ns = 0L;
#line 542
  yyval.rel = __constr_expr_16;
#line 542
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 543
  break;
  case 60: 
#line 544
  __constr_expr_17.year = 0L;
#line 544
  __constr_expr_17.month = 0L;
#line 544
  __constr_expr_17.day = 0L;
#line 544
  __constr_expr_17.hour = 0L;
#line 544
  __constr_expr_17.minutes = 0L;
#line 544
  __constr_expr_17.seconds = (long_time_t )0;
#line 544
  __constr_expr_17.ns = 0L;
#line 544
  yyval.rel = __constr_expr_17;
#line 544
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 544
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 545
  break;
  case 61: 
#line 546
  __constr_expr_18.year = 0L;
#line 546
  __constr_expr_18.month = 0L;
#line 546
  __constr_expr_18.day = 0L;
#line 546
  __constr_expr_18.hour = 0L;
#line 546
  __constr_expr_18.minutes = 0L;
#line 546
  __constr_expr_18.seconds = (long_time_t )0;
#line 546
  __constr_expr_18.ns = 0L;
#line 546
  yyval.rel = __constr_expr_18;
#line 546
  yyval.rel.seconds = (yyvsp + -1)->timespec.tv_sec;
#line 546
  yyval.rel.ns = (yyvsp + -1)->timespec.tv_nsec;
#line 547
  break;
  case 62: 
#line 548
  __constr_expr_19.year = 0L;
#line 548
  __constr_expr_19.month = 0L;
#line 548
  __constr_expr_19.day = 0L;
#line 548
  __constr_expr_19.hour = 0L;
#line 548
  __constr_expr_19.minutes = 0L;
#line 548
  __constr_expr_19.seconds = (long_time_t )0;
#line 548
  __constr_expr_19.ns = 0L;
#line 548
  yyval.rel = __constr_expr_19;
#line 548
  yyval.rel.seconds = (long_time_t )1;
#line 549
  break;
  case 64: 
#line 554
  __constr_expr_20.year = 0L;
#line 554
  __constr_expr_20.month = 0L;
#line 554
  __constr_expr_20.day = 0L;
#line 554
  __constr_expr_20.hour = 0L;
#line 554
  __constr_expr_20.minutes = 0L;
#line 554
  __constr_expr_20.seconds = (long_time_t )0;
#line 554
  __constr_expr_20.ns = 0L;
#line 554
  yyval.rel = __constr_expr_20;
#line 554
  yyval.rel.year = (yyvsp + -1)->textintval.value;
#line 555
  break;
  case 65: 
#line 556
  __constr_expr_21.year = 0L;
#line 556
  __constr_expr_21.month = 0L;
#line 556
  __constr_expr_21.day = 0L;
#line 556
  __constr_expr_21.hour = 0L;
#line 556
  __constr_expr_21.minutes = 0L;
#line 556
  __constr_expr_21.seconds = (long_time_t )0;
#line 556
  __constr_expr_21.ns = 0L;
#line 556
  yyval.rel = __constr_expr_21;
#line 556
  yyval.rel.month = (yyvsp + -1)->textintval.value;
#line 557
  break;
  case 66: 
#line 558
  __constr_expr_22.year = 0L;
#line 558
  __constr_expr_22.month = 0L;
#line 558
  __constr_expr_22.day = 0L;
#line 558
  __constr_expr_22.hour = 0L;
#line 558
  __constr_expr_22.minutes = 0L;
#line 558
  __constr_expr_22.seconds = (long_time_t )0;
#line 558
  __constr_expr_22.ns = 0L;
#line 558
  yyval.rel = __constr_expr_22;
#line 558
  yyval.rel.day = (yyvsp + -1)->textintval.value * (yyvsp + 0)->intval;
#line 559
  break;
  case 67: 
#line 560
  __constr_expr_23.year = 0L;
#line 560
  __constr_expr_23.month = 0L;
#line 560
  __constr_expr_23.day = 0L;
#line 560
  __constr_expr_23.hour = 0L;
#line 560
  __constr_expr_23.minutes = 0L;
#line 560
  __constr_expr_23.seconds = (long_time_t )0;
#line 560
  __constr_expr_23.ns = 0L;
#line 560
  yyval.rel = __constr_expr_23;
#line 560
  yyval.rel.hour = (yyvsp + -1)->textintval.value;
#line 561
  break;
  case 68: 
#line 562
  __constr_expr_24.year = 0L;
#line 562
  __constr_expr_24.month = 0L;
#line 562
  __constr_expr_24.day = 0L;
#line 562
  __constr_expr_24.hour = 0L;
#line 562
  __constr_expr_24.minutes = 0L;
#line 562
  __constr_expr_24.seconds = (long_time_t )0;
#line 562
  __constr_expr_24.ns = 0L;
#line 562
  yyval.rel = __constr_expr_24;
#line 562
  yyval.rel.minutes = (yyvsp + -1)->textintval.value;
#line 563
  break;
  case 69: 
#line 564
  __constr_expr_25.year = 0L;
#line 564
  __constr_expr_25.month = 0L;
#line 564
  __constr_expr_25.day = 0L;
#line 564
  __constr_expr_25.hour = 0L;
#line 564
  __constr_expr_25.minutes = 0L;
#line 564
  __constr_expr_25.seconds = (long_time_t )0;
#line 564
  __constr_expr_25.ns = 0L;
#line 564
  yyval.rel = __constr_expr_25;
#line 564
  yyval.rel.seconds = (yyvsp + -1)->textintval.value;
#line 565
  break;
  case 70: 
#line 569
  __constr_expr_26.year = 0L;
#line 569
  __constr_expr_26.month = 0L;
#line 569
  __constr_expr_26.day = 0L;
#line 569
  __constr_expr_26.hour = 0L;
#line 569
  __constr_expr_26.minutes = 0L;
#line 569
  __constr_expr_26.seconds = (long_time_t )0;
#line 569
  __constr_expr_26.ns = 0L;
#line 569
  yyval.rel = __constr_expr_26;
#line 569
  yyval.rel.day = (yyvsp + 0)->intval;
#line 570
  break;
  case 74: 
#line 577
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 577
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 578
  break;
  case 76: 
#line 583
  yyval.timespec.tv_sec = (yyvsp + 0)->textintval.value;
#line 583
  yyval.timespec.tv_nsec = (__syscall_slong_t )0;
#line 584
  break;
  case 77: 
#line 588
  digits_to_date_time(pc, (yyvsp + 0)->textintval);
#line 589
  break;
  case 78: 
#line 596
  digits_to_date_time(pc, (yyvsp + -1)->textintval);
#line 597
  apply_relative_time(pc, (yyvsp + 0)->rel, 1);
#line 599
  break;
  case 79: 
#line 603
  yyval.intval = -1L;
#line 604
  break;
  case 80: 
#line 605
  yyval.intval = (yyvsp + 0)->textintval.value;
#line 606
  break;
  case 81: 
#line 610
  yyval.intval = 2L;
#line 611
  break;
  case 82: 
#line 612
  yyval.intval = (yyvsp + 0)->intval;
#line 613
  break;
  default: 
#line 2339 "getdate.c"
  break;
  }
#line 2343
  yyvsp -= yylen;
#line 2343
  yyssp -= yylen;
#line 2344
  yylen = 0;
#line 2347
  yyvsp ++;
#line 2347
  *yyvsp = yyval;
#line 2353
  yyn = (int )yyr1[yyn];
#line 2355
  yystate = (int )((int const   )yypgoto[yyn - 27] + (int const   )*yyssp);
#line 2356
  if (0 <= yystate) {
#line 2356
    if (yystate <= 98) {
#line 2356
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2357
        yystate = (int )yytable[yystate];
      } else {
#line 2359
        yystate = (int )yydefgoto[yyn - 27];
      }
    } else {
#line 2359
      yystate = (int )yydefgoto[yyn - 27];
    }
  } else {
#line 2359
    yystate = (int )yydefgoto[yyn - 27];
  }
#line 2361
  goto yynewstate;
  yyerrlab: 
#line 2369
  if (! yyerrstatus) {
#line 2371
    yynerrs ++;
#line 2373
    yyerror((parser_control const   *)pc, "syntax error");
  }
#line 2402
  if (yyerrstatus == 3) {
#line 2407
    if (yychar <= 0) {
#line 2410
      if (yychar == 0) {
#line 2411
        goto yyabortlab;
      }
    } else {
#line 2415
      yydestruct("Error: discarding", yytoken, & yylval, pc);
#line 2417
      yychar = -2;
    }
  }
#line 2423
  goto yyerrlab1;
#line 2439
  yyvsp -= yylen;
#line 2439
  yyssp -= yylen;
#line 2440
  yylen = 0;
#line 2442
  yystate = (int )*yyssp;
#line 2443
  goto yyerrlab1;
  yyerrlab1: 
#line 2450
  yyerrstatus = 3;
#line 2452
  while (1) {
#line 2454
    yyn = (int )yypact[yystate];
#line 2455
    if (! (yyn == -82)) {
#line 2457
      yyn ++;
#line 2458
      if (0 <= yyn) {
#line 2458
        if (yyn <= 98) {
#line 2458
          if ((int const   )yycheck[yyn] == 1) {
#line 2460
            yyn = (int )yytable[yyn];
#line 2461
            if (0 < yyn) {
#line 2462
              break;
            }
          }
        }
      }
    }
#line 2467
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 2468
      goto yyabortlab;
    }
#line 2471
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp, pc);
#line 2473
    yyvsp --;
#line 2473
    yyssp --;
#line 2474
    yystate = (int )*yyssp;
  }
#line 2478
  yyvsp ++;
#line 2478
  *yyvsp = yylval;
#line 2484
  yystate = yyn;
#line 2485
  goto yynewstate;
  yyacceptlab: 
#line 2492
  yyresult = 0;
#line 2493
  goto yyreturn;
  yyabortlab: 
#line 2499
  yyresult = 1;
#line 2500
  goto yyreturn;
  yyexhaustedlab: 
#line 2507
  yyerror((parser_control const   *)pc, "memory exhausted");
#line 2508
  yyresult = 2;
  yyreturn: 
#line 2513
  if (yychar != -2) {
#line 2514
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval, pc);
  }
#line 2518
  yyvsp -= yylen;
#line 2518
  yyssp -= yylen;
#line 2520
  while ((unsigned long )yyssp != (unsigned long )yyss) {
#line 2522
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp, pc);
#line 2524
    yyvsp --;
#line 2524
    yyssp --;
  }
#line 2527
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
#line 2528
    free((void *)yyss);
  }
#line 2535
  return (yyresult);
}
}
#line 617 "getdate.y"
static table const   meridian_table[5]  = {      {"AM", 270, 0}, 
        {"A.M.", 270, 0}, 
        {"PM", 270, 1}, 
        {"P.M.", 270, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 626 "getdate.y"
static table const   dst_table[1]  = {      {"DST", 259, 0}};
#line 631 "getdate.y"
static table const   month_and_day_table[25]  = 
#line 631
  {      {"JANUARY", 271, 1}, 
        {"FEBRUARY", 271, 2}, 
        {"MARCH", 271, 3}, 
        {"APRIL", 271, 4}, 
        {"MAY", 271, 5}, 
        {"JUNE", 271, 6}, 
        {"JULY", 271, 7}, 
        {"AUGUST", 271, 8}, 
        {"SEPTEMBER", 271, 9}, 
        {"SEPT", 271, 9}, 
        {"OCTOBER", 271, 10}, 
        {"NOVEMBER", 271, 11}, 
        {"DECEMBER", 271, 12}, 
        {"SUNDAY", 267, 0}, 
        {"MONDAY", 267, 1}, 
        {"TUESDAY", 267, 2}, 
        {"TUES", 267, 2}, 
        {"WEDNESDAY", 267, 3}, 
        {"WEDNES", 267, 3}, 
        {"THURSDAY", 267, 4}, 
        {"THUR", 267, 4}, 
        {"THURS", 267, 4}, 
        {"FRIDAY", 267, 5}, 
        {"SATURDAY", 267, 6}, 
        {(char const   *)((void *)0), 0, 0}};
#line 660 "getdate.y"
static table const   time_units_table[11]  = 
#line 660
  {      {"YEAR", 260, 1}, 
        {"MONTH", 261, 1}, 
        {"FORTNIGHT", 265, 14}, 
        {"WEEK", 265, 7}, 
        {"DAY", 265, 1}, 
        {"HOUR", 262, 1}, 
        {"MINUTE", 263, 1}, 
        {"MIN", 263, 1}, 
        {"SECOND", 264, 1}, 
        {"SEC", 264, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 676 "getdate.y"
static table const   relative_time_table[20]  = 
#line 676
  {      {"TOMORROW", 266, 1}, 
        {"YESTERDAY", 266, -1}, 
        {"TODAY", 266, 0}, 
        {"NOW", 266, 0}, 
        {"LAST", 272, -1}, 
        {"THIS", 272, 0}, 
        {"NEXT", 272, 1}, 
        {"FIRST", 272, 1}, 
        {"THIRD", 272, 3}, 
        {"FOURTH", 272, 4}, 
        {"FIFTH", 272, 5}, 
        {"SIXTH", 272, 6}, 
        {"SEVENTH", 272, 7}, 
        {"EIGHTH", 272, 8}, 
        {"NINTH", 272, 9}, 
        {"TENTH", 272, 10}, 
        {"ELEVENTH", 272, 11}, 
        {"TWELFTH", 272, 12}, 
        {"AGO", 258, 1}, 
        {(char const   *)((void *)0), 0, 0}};
#line 704 "getdate.y"
static table const   universal_time_zone_table[4]  = {      {"GMT", 273, 0}, 
        {"UT", 273, 0}, 
        {"UTC", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 717 "getdate.y"
static table const   time_zone_table[48]  = 
#line 717
  {      {"WET", 273, 0}, 
        {"WEST", 268, 0}, 
        {"BST", 268, 0}, 
        {"ART", 273, -180}, 
        {"BRT", 273, -180}, 
        {"BRST", 268, -180}, 
        {"NST", 273, -210}, 
        {"NDT", 268, -210}, 
        {"AST", 273, -240}, 
        {"ADT", 268, -240}, 
        {"CLT", 273, -240}, 
        {"CLST", 268, -240}, 
        {"EST", 273, -300}, 
        {"EDT", 268, -300}, 
        {"CST", 273, -360}, 
        {"CDT", 268, -360}, 
        {"MST", 273, -420}, 
        {"MDT", 268, -420}, 
        {"PST", 273, -480}, 
        {"PDT", 268, -480}, 
        {"AKST", 273, -540}, 
        {"AKDT", 268, -540}, 
        {"HST", 273, -600}, 
        {"HAST", 273, -600}, 
        {"HADT", 268, -600}, 
        {"SST", 273, -720}, 
        {"WAT", 273, 60}, 
        {"CET", 273, 60}, 
        {"CEST", 268, 60}, 
        {"MET", 273, 60}, 
        {"MEZ", 273, 60}, 
        {"MEST", 268, 60}, 
        {"MESZ", 268, 60}, 
        {"EET", 273, 120}, 
        {"EEST", 268, 120}, 
        {"CAT", 273, 120}, 
        {"SAST", 273, 120}, 
        {"EAT", 273, 180}, 
        {"MSK", 273, 180}, 
        {"MSD", 268, 180}, 
        {"IST", 273, 330}, 
        {"SGT", 273, 480}, 
        {"KST", 273, 540}, 
        {"JST", 273, 540}, 
        {"GST", 273, 600}, 
        {"NZST", 273, 720}, 
        {"NZDT", 268, 720}, 
        {(char const   *)((void *)0), 0, 0}};
#line 770 "getdate.y"
static table const   military_table[26]  = 
#line 770
  {      {"A", 273, -60}, 
        {"B", 273, -120}, 
        {"C", 273, -180}, 
        {"D", 273, -240}, 
        {"E", 273, -300}, 
        {"F", 273, -360}, 
        {"G", 273, -420}, 
        {"H", 273, -480}, 
        {"I", 273, -540}, 
        {"K", 273, -600}, 
        {"L", 273, -660}, 
        {"M", 273, -720}, 
        {"N", 273, 60}, 
        {"O", 273, 120}, 
        {"P", 273, 180}, 
        {"Q", 273, 240}, 
        {"R", 273, 300}, 
        {"S", 273, 360}, 
        {"T", 273, 420}, 
        {"U", 273, 480}, 
        {"V", 273, 540}, 
        {"W", 273, 600}, 
        {"X", 273, 660}, 
        {"Y", 273, 720}, 
        {"Z", 273, 0}, 
        {(char const   *)((void *)0), 0, 0}};
#line 809 "getdate.y"
static long time_zone_hhmm(parser_control *pc , textint s , long mm ) 
{ 
  long n_minutes ;
  long tmp ;
  int tmp___0 ;

  {
#line 816
  if (s.digits <= 2UL) {
#line 816
    if (mm < 0L) {
#line 817
      s.value *= 100L;
    }
  }
#line 819
  if (mm < 0L) {
#line 820
    n_minutes = (s.value / 100L) * 60L + s.value % 100L;
  } else {
#line 822
    if (s.negative) {
#line 822
      tmp = - mm;
    } else {
#line 822
      tmp = mm;
    }
#line 822
    n_minutes = s.value * 60L + tmp;
  }
#line 827
  tmp___0 = abs((int )n_minutes);
#line 827
  if (1440 < tmp___0) {
#line 828
    (pc->zones_seen) ++;
  }
#line 830
  return (n_minutes);
}
}
#line 833 "getdate.y"
static int to_hour(long hours , int meridian ) 
{ 
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;

  {
#line 836
  switch (meridian) {
  default: 
#line 840
  if (0L <= hours) {
#line 840
    if (hours < 24L) {
#line 840
      tmp = hours;
    } else {
#line 840
      tmp = -1L;
    }
  } else {
#line 840
    tmp = -1L;
  }
#line 840
  return ((int )tmp);
  case 0: 
#line 842
  if (0L < hours) {
#line 842
    if (hours < 12L) {
#line 842
      tmp___1 = hours;
    } else {
#line 842
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 842
    if (hours == 12L) {
#line 842
      tmp___0 = 0;
    } else {
#line 842
      tmp___0 = -1;
    }
#line 842
    tmp___1 = (long )tmp___0;
  }
#line 842
  return ((int )tmp___1);
  case 1: 
#line 844
  if (0L < hours) {
#line 844
    if (hours < 12L) {
#line 844
      tmp___3 = hours + 12L;
    } else {
#line 844
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 844
    if (hours == 12L) {
#line 844
      tmp___2 = 12;
    } else {
#line 844
      tmp___2 = -1;
    }
#line 844
    tmp___3 = (long )tmp___2;
  }
#line 844
  return ((int )tmp___3);
  }
}
}
#line 848 "getdate.y"
static long to_year(textint textyear ) 
{ 
  long year___0 ;
  int tmp ;

  {
#line 851
  year___0 = textyear.value;
#line 853
  if (year___0 < 0L) {
#line 854
    year___0 = - year___0;
  } else
#line 858
  if (textyear.digits == 2UL) {
#line 859
    if (year___0 < 69L) {
#line 859
      tmp = 2000;
    } else {
#line 859
      tmp = 1900;
    }
#line 859
    year___0 += (long )tmp;
  }
#line 861
  return (year___0);
}
}
#line 864 "getdate.y"
static table const   *lookup_zone(parser_control const   *pc , char const   *name ) 
{ 
  table const   *tp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 869
  tp = universal_time_zone_table;
#line 869
  while (tp->name) {
#line 870
    tmp = strcmp(name, (char const   *)tp->name);
#line 870
    if (tmp == 0) {
#line 871
      return (tp);
    }
#line 869
    tp ++;
  }
#line 875
  tp = (table const   *)(pc->local_time_zone_table);
#line 875
  while (tp->name) {
#line 876
    tmp___0 = strcmp(name, (char const   *)tp->name);
#line 876
    if (tmp___0 == 0) {
#line 877
      return (tp);
    }
#line 875
    tp ++;
  }
#line 879
  tp = time_zone_table;
#line 879
  while (tp->name) {
#line 880
    tmp___1 = strcmp(name, (char const   *)tp->name);
#line 880
    if (tmp___1 == 0) {
#line 881
      return (tp);
    }
#line 879
    tp ++;
  }
#line 883
  return ((table const   *)((void *)0));
}
}
#line 913 "getdate.y"
static table const   *lookup_word(parser_control const   *pc , char *word ) 
{ 
  char *p ;
  char *q ;
  size_t wordlen ;
  table const   *tp ;
  _Bool period_found ;
  _Bool abbrev ;
  unsigned char ch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char tmp___9 ;

  {
#line 924
  p = word;
#line 924
  while (*p) {
#line 926
    ch = (unsigned char )*p;
#line 927
    tmp = c_toupper((int )ch);
#line 927
    *p = (char )tmp;
#line 924
    p ++;
  }
#line 930
  tp = meridian_table;
#line 930
  while (tp->name) {
#line 931
    tmp___0 = strcmp((char const   *)word, (char const   *)tp->name);
#line 931
    if (tmp___0 == 0) {
#line 932
      return (tp);
    }
#line 930
    tp ++;
  }
#line 935
  wordlen = strlen((char const   *)word);
#line 936
  if (wordlen == 3UL) {
#line 936
    tmp___1 = 1;
  } else
#line 936
  if (wordlen == 4UL) {
#line 936
    if ((int )*(word + 3) == 46) {
#line 936
      tmp___1 = 1;
    } else {
#line 936
      tmp___1 = 0;
    }
  } else {
#line 936
    tmp___1 = 0;
  }
#line 936
  abbrev = (_Bool )tmp___1;
#line 938
  tp = month_and_day_table;
#line 938
  while (tp->name) {
#line 939
    if (abbrev) {
#line 939
      tmp___2 = strncmp((char const   *)word, (char const   *)tp->name, (size_t )3);
#line 939
      tmp___4 = tmp___2;
    } else {
#line 939
      tmp___3 = strcmp((char const   *)word, (char const   *)tp->name);
#line 939
      tmp___4 = tmp___3;
    }
#line 939
    if (tmp___4 == 0) {
#line 940
      return (tp);
    }
#line 938
    tp ++;
  }
#line 942
  tp = lookup_zone(pc, (char const   *)word);
#line 942
  if (tp) {
#line 943
    return (tp);
  }
#line 945
  tmp___5 = strcmp((char const   *)word, (char const   *)dst_table[0].name);
#line 945
  if (tmp___5 == 0) {
#line 946
    return (dst_table);
  }
#line 948
  tp = time_units_table;
#line 948
  while (tp->name) {
#line 949
    tmp___6 = strcmp((char const   *)word, (char const   *)tp->name);
#line 949
    if (tmp___6 == 0) {
#line 950
      return (tp);
    }
#line 948
    tp ++;
  }
#line 953
  if ((int )*(word + (wordlen - 1UL)) == 83) {
#line 955
    *(word + (wordlen - 1UL)) = (char )'\000';
#line 956
    tp = time_units_table;
#line 956
    while (tp->name) {
#line 957
      tmp___7 = strcmp((char const   *)word, (char const   *)tp->name);
#line 957
      if (tmp___7 == 0) {
#line 958
        return (tp);
      }
#line 956
      tp ++;
    }
#line 959
    *(word + (wordlen - 1UL)) = (char )'S';
  }
#line 962
  tp = relative_time_table;
#line 962
  while (tp->name) {
#line 963
    tmp___8 = strcmp((char const   *)word, (char const   *)tp->name);
#line 963
    if (tmp___8 == 0) {
#line 964
      return (tp);
    }
#line 962
    tp ++;
  }
#line 967
  if (wordlen == 1UL) {
#line 968
    tp = military_table;
#line 968
    while (tp->name) {
#line 969
      if ((int )*(word + 0) == (int )*(tp->name + 0)) {
#line 970
        return (tp);
      }
#line 968
      tp ++;
    }
  }
#line 973
  period_found = (_Bool)0;
#line 973
  q = word;
#line 973
  p = q;
#line 973
  while (1) {
#line 973
    tmp___9 = *q;
#line 973
    *p = tmp___9;
#line 973
    if (! tmp___9) {
#line 973
      break;
    }
#line 974
    if ((int )*q == 46) {
#line 975
      period_found = (_Bool)1;
    } else {
#line 977
      p ++;
    }
#line 973
    q ++;
  }
#line 978
  if (period_found) {
#line 978
    tp = lookup_zone(pc, (char const   *)word);
#line 978
    if (tp) {
#line 979
      return (tp);
    }
  }
#line 981
  return ((table const   *)((void *)0));
}
}
#line 984 "getdate.y"
static int yylex(union YYSTYPE *lvalp , parser_control *pc ) 
{ 
  unsigned char c ;
  size_t count ;
  _Bool tmp ;
  char const   *p ;
  int sign ;
  unsigned long value ;
  _Bool tmp___0 ;
  unsigned long value1 ;
  time_t s ;
  int ns ;
  int digits ;
  unsigned long value1___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char buff[20] ;
  char *p___0 ;
  table const   *tp ;
  char *tmp___5 ;
  _Bool tmp___6 ;
  _Bool tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;

  {
#line 990
  while (1) {
#line 992
    while (1) {
#line 992
      c = (unsigned char )*(pc->input);
#line 992
      tmp = c_isspace((int )c);
#line 992
      if (! tmp) {
#line 992
        break;
      }
#line 993
      (pc->input) ++;
    }
#line 995
    if ((unsigned int )c - 48U <= 9U) {
#line 995
      goto _L___2;
    } else
#line 995
    if ((int )c == 45) {
#line 995
      goto _L___2;
    } else
#line 995
    if ((int )c == 43) {
      _L___2: /* CIL Label */ 
#line 1000
      if ((int )c == 45) {
#line 1000
        goto _L;
      } else
#line 1000
      if ((int )c == 43) {
        _L: /* CIL Label */ 
#line 1002
        if ((int )c == 45) {
#line 1002
          sign = -1;
        } else {
#line 1002
          sign = 1;
        }
#line 1003
        while (1) {
#line 1003
          (pc->input) ++;
#line 1003
          c = (unsigned char )*(pc->input);
#line 1003
          tmp___0 = c_isspace((int )c);
#line 1003
          if (! tmp___0) {
#line 1003
            break;
          }
#line 1004
          continue;
        }
#line 1005
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1007
          goto __Cont;
        }
      } else {
#line 1010
        sign = 0;
      }
#line 1011
      p = pc->input;
#line 1012
      value = 0UL;
#line 1012
      while (1) {
#line 1014
        value1 = value + (unsigned long )((int )c - 48);
#line 1015
        if (value1 < value) {
#line 1016
          return ('?');
        }
#line 1017
        value = value1;
#line 1018
        p ++;
#line 1018
        c = (unsigned char )*p;
#line 1019
        if (! ((unsigned int )c - 48U <= 9U)) {
#line 1020
          break;
        }
#line 1021
        if (1844674407370955161UL < value) {
#line 1022
          return ('?');
        }
#line 1012
        value *= 10UL;
      }
#line 1024
      if ((int )c == 46) {
#line 1024
        goto _L___1;
      } else
#line 1024
      if ((int )c == 44) {
        _L___1: /* CIL Label */ 
#line 1024
        if ((unsigned int )*(p + 1) - 48U <= 9U) {
#line 1032
          if (sign < 0) {
#line 1034
            s = (time_t )(- value);
#line 1035
            if (0L < s) {
#line 1036
              return ('?');
            }
#line 1037
            value1___0 = (unsigned long )(- s);
          } else {
#line 1041
            s = (time_t )value;
#line 1042
            if (s < 0L) {
#line 1043
              return ('?');
            }
#line 1044
            value1___0 = (unsigned long )s;
          }
#line 1046
          if (value != value1___0) {
#line 1047
            return ('?');
          }
#line 1050
          p ++;
#line 1051
          tmp___1 = p;
#line 1051
          p ++;
#line 1051
          ns = (int )((int const   )*tmp___1 - 48);
#line 1052
          digits = 2;
#line 1052
          while (digits <= 9) {
#line 1054
            ns *= 10;
#line 1055
            if ((unsigned int )*p - 48U <= 9U) {
#line 1056
              tmp___2 = p;
#line 1056
              p ++;
#line 1056
              ns += (int )((int const   )*tmp___2 - 48);
            }
#line 1052
            digits ++;
          }
#line 1060
          if (sign < 0) {
#line 1061
            while ((unsigned int )*p - 48U <= 9U) {
#line 1062
              if ((int const   )*p != 48) {
#line 1064
                ns ++;
#line 1065
                break;
              }
#line 1061
              p ++;
            }
          }
#line 1067
          while ((unsigned int )*p - 48U <= 9U) {
#line 1068
            p ++;
          }
#line 1073
          if (sign < 0) {
#line 1073
            if (ns) {
#line 1075
              s --;
#line 1076
              if (! (s < 0L)) {
#line 1077
                return ('?');
              }
#line 1078
              ns = 1000000000 - ns;
            }
          }
#line 1081
          lvalp->timespec.tv_sec = s;
#line 1082
          lvalp->timespec.tv_nsec = (__syscall_slong_t )ns;
#line 1083
          pc->input = p;
#line 1084
          if (sign) {
#line 1084
            tmp___3 = 276;
          } else {
#line 1084
            tmp___3 = 277;
          }
#line 1084
          return (tmp___3);
        } else {
#line 1024
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 1088
        lvalp->textintval.negative = (_Bool )(sign < 0);
#line 1089
        if (sign < 0) {
#line 1091
          lvalp->textintval.value = (long )(- value);
#line 1092
          if (0L < lvalp->textintval.value) {
#line 1093
            return ('?');
          }
        } else {
#line 1097
          lvalp->textintval.value = (long )value;
#line 1098
          if (lvalp->textintval.value < 0L) {
#line 1099
            return ('?');
          }
        }
#line 1101
        lvalp->textintval.digits = (size_t )(p - pc->input);
#line 1102
        pc->input = p;
#line 1103
        if (sign) {
#line 1103
          tmp___4 = 274;
        } else {
#line 1103
          tmp___4 = 275;
        }
#line 1103
        return (tmp___4);
      }
    }
#line 1107
    tmp___7 = c_isalpha((int )c);
#line 1107
    if (tmp___7) {
#line 1110
      p___0 = buff;
#line 1113
      while (1) {
#line 1115
        if ((unsigned long )p___0 < (unsigned long )((buff + sizeof(buff)) - 1)) {
#line 1116
          tmp___5 = p___0;
#line 1116
          p___0 ++;
#line 1116
          *tmp___5 = (char )c;
        }
#line 1117
        (pc->input) ++;
#line 1117
        c = (unsigned char )*(pc->input);
#line 1113
        tmp___6 = c_isalpha((int )c);
#line 1113
        if (! tmp___6) {
#line 1113
          if (! ((int )c == 46)) {
#line 1113
            break;
          }
        }
      }
#line 1121
      *p___0 = (char )'\000';
#line 1122
      tp = lookup_word((parser_control const   *)pc, buff);
#line 1123
      if (! tp) {
#line 1124
        return ('?');
      }
#line 1125
      lvalp->intval = (long )tp->value;
#line 1126
      return ((int )tp->type);
    }
#line 1129
    if ((int )c != 40) {
#line 1130
      tmp___8 = pc->input;
#line 1130
      (pc->input) ++;
#line 1130
      return ((int )*tmp___8);
    }
#line 1131
    count = (size_t )0;
#line 1132
    while (1) {
#line 1134
      tmp___9 = pc->input;
#line 1134
      (pc->input) ++;
#line 1134
      c = (unsigned char )*tmp___9;
#line 1135
      if ((int )c == 0) {
#line 1136
        return ((int )c);
      }
#line 1137
      if ((int )c == 40) {
#line 1138
        count ++;
      } else
#line 1139
      if ((int )c == 41) {
#line 1140
        count --;
      }
#line 1132
      if (! (count != 0UL)) {
#line 1132
        break;
      }
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 1147 "getdate.y"
static int yyerror(parser_control const   *pc  __attribute__((__unused__)) , char const   *s  __attribute__((__unused__)) ) 
{ 


  {
#line 1151
  return (0);
}
}
#line 1158 "getdate.y"
static _Bool mktime_ok(struct tm  const  *tm0 , struct tm  const  *tm1 , time_t t ) 
{ 
  struct tm *tmp ;

  {
#line 1161
  if (t == -1L) {
#line 1166
    tmp = localtime((time_t const   *)(& t));
#line 1166
    tm1 = (struct tm  const  *)tmp;
#line 1167
    if (! tm1) {
#line 1168
      return ((_Bool)0);
    }
  }
#line 1171
  return ((_Bool )(! ((((((tm0->tm_sec ^ tm1->tm_sec) | (tm0->tm_min ^ tm1->tm_min)) | (tm0->tm_hour ^ tm1->tm_hour)) | (tm0->tm_mday ^ tm1->tm_mday)) | (tm0->tm_mon ^ tm1->tm_mon)) | (tm0->tm_year ^ tm1->tm_year))));
}
}
#line 1185 "getdate.y"
static char *get_tz(char *tzbuf ) 
{ 
  char *tz ;
  char *tmp ;
  size_t tzsize ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 1188
  tmp = getenv("TZ");
#line 1188
  tz = tmp;
#line 1189
  if (tz) {
#line 1191
    tmp___0 = strlen((char const   *)tz);
#line 1191
    tzsize = tmp___0 + 1UL;
#line 1192
    if (tzsize <= 100UL) {
#line 1192
      tmp___1 = memcpy((void * __restrict  )tzbuf, (void const   * __restrict  )tz,
                       tzsize);
#line 1192
      tz = (char *)tmp___1;
    } else {
#line 1192
      tmp___2 = xmemdup((void const   *)tz, tzsize);
#line 1192
      tz = (char *)tmp___2;
    }
  }
#line 1196
  return (tz);
}
}
#line 1203 "getdate.y"
_Bool get_date(struct timespec *result , char const   *p , struct timespec  const  *now ) 
{ 
  time_t Start ;
  long Start_ns ;
  struct tm  const  *tmp ;
  struct tm tm ;
  struct tm tm0 ;
  parser_control pc ;
  struct timespec gettime_buffer ;
  unsigned char c ;
  _Bool tz_was_altered ;
  char *tz0 ;
  char tz0buf[100] ;
  _Bool ok ;
  struct tm *tmp___0 ;
  _Bool tmp___1 ;
  char const   *tzbase ;
  size_t tzsize ;
  char const   *s ;
  char *z ;
  char *tz1 ;
  char tz1buf[100] ;
  _Bool large_tz ;
  _Bool setenv_ok ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  relative_time __constr_expr_27 ;
  int quarter ;
  time_t probe ;
  struct tm  const  *probe_tm ;
  struct tm *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long time_zone ;
  long abs_time_zone ;
  long tmp___10 ;
  long abs_time_zone_hour ;
  int abs_time_zone_min ;
  char tz1buf___0[sizeof("XXX+0:00") + (sizeof(pc.time_zone) * 8UL) / 3UL] ;
  int tmp___11 ;
  _Bool tmp___12 ;
  _Bool tmp___13 ;
  int tmp___14 ;
  int year___0 ;
  int month ;
  int day ;
  long delta ;
  time_t t1 ;
  long sum_ns ;
  long normalized_ns ;
  time_t t0 ;
  long d1 ;
  time_t t1___0 ;
  long d2 ;
  time_t t2 ;
  long_time_t d3 ;
  long_time_t t3 ;
  long d4 ;
  long_time_t t4 ;
  time_t t5 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 1214
  tz_was_altered = (_Bool)0;
#line 1215
  tz0 = (char *)((void *)0);
#line 1217
  ok = (_Bool)1;
#line 1219
  if (! now) {
#line 1221
    gettime(& gettime_buffer);
#line 1222
    now = (struct timespec  const  *)(& gettime_buffer);
  }
#line 1225
  Start = (time_t )now->tv_sec;
#line 1226
  Start_ns = (long )now->tv_nsec;
#line 1228
  tmp___0 = localtime(& now->tv_sec);
#line 1228
  tmp = (struct tm  const  *)tmp___0;
#line 1229
  if (! tmp) {
#line 1230
    return ((_Bool)0);
  }
#line 1232
  while (1) {
#line 1232
    c = (unsigned char )*p;
#line 1232
    tmp___1 = c_isspace((int )c);
#line 1232
    if (! tmp___1) {
#line 1232
      break;
    }
#line 1233
    p ++;
  }
#line 1235
  tmp___5 = strncmp(p, "TZ=\"", (size_t )4);
#line 1235
  if (tmp___5 == 0) {
#line 1237
    tzbase = p + 4;
#line 1238
    tzsize = (size_t )1;
#line 1241
    s = tzbase;
#line 1241
    while (*s) {
#line 1242
      if ((int const   )*s == 92) {
#line 1244
        s ++;
#line 1245
        if (! ((int const   )*s == 92)) {
#line 1245
          if (! ((int const   )*s == 34)) {
#line 1246
            break;
          }
        }
      } else
#line 1248
      if ((int const   )*s == 34) {
#line 1253
        large_tz = (_Bool )(100UL < tzsize);
#line 1255
        tz0 = get_tz((char *)(tz0buf));
#line 1256
        if (large_tz) {
#line 1256
          tmp___2 = xmalloc(tzsize);
#line 1256
          tz1 = (char *)tmp___2;
        } else {
#line 1256
          tz1 = tz1buf;
        }
#line 1256
        z = tz1;
#line 1257
        s = tzbase;
#line 1257
        while ((int const   )*s != 34) {
#line 1258
          tmp___3 = z;
#line 1258
          z ++;
#line 1258
          s += (int const   )*s == 92;
#line 1258
          *tmp___3 = (char )*s;
#line 1257
          s ++;
        }
#line 1259
        *z = (char )'\000';
#line 1260
        tmp___4 = setenv("TZ", (char const   *)tz1, 1);
#line 1260
        setenv_ok = (_Bool )(tmp___4 == 0);
#line 1261
        if (large_tz) {
#line 1262
          free((void *)tz1);
        }
#line 1263
        if (! setenv_ok) {
#line 1264
          goto fail;
        }
#line 1265
        tz_was_altered = (_Bool)1;
#line 1266
        p = s + 1;
      }
#line 1241
      s ++;
#line 1241
      tzsize ++;
    }
  }
#line 1273
  if ((int const   )*p == 0) {
#line 1274
    p = "0";
  }
#line 1276
  pc.input = p;
#line 1277
  pc.year.value = (long )tmp->tm_year;
#line 1278
  pc.year.value += 1900L;
#line 1279
  pc.year.digits = (size_t )0;
#line 1280
  pc.month = (long )(tmp->tm_mon + 1);
#line 1281
  pc.day = (long )tmp->tm_mday;
#line 1282
  pc.hour = (long )tmp->tm_hour;
#line 1283
  pc.minutes = (long )tmp->tm_min;
#line 1284
  pc.seconds.tv_sec = (__time_t )tmp->tm_sec;
#line 1285
  pc.seconds.tv_nsec = Start_ns;
#line 1286
  tm.tm_isdst = (int )tmp->tm_isdst;
#line 1288
  pc.meridian = 2;
#line 1289
  __constr_expr_27.year = 0L;
#line 1289
  __constr_expr_27.month = 0L;
#line 1289
  __constr_expr_27.day = 0L;
#line 1289
  __constr_expr_27.hour = 0L;
#line 1289
  __constr_expr_27.minutes = 0L;
#line 1289
  __constr_expr_27.seconds = (long_time_t )0;
#line 1289
  __constr_expr_27.ns = 0L;
#line 1289
  pc.rel = __constr_expr_27;
#line 1290
  pc.timespec_seen = (_Bool)0;
#line 1291
  pc.rels_seen = (_Bool)0;
#line 1292
  pc.dates_seen = (size_t )0;
#line 1293
  pc.days_seen = (size_t )0;
#line 1294
  pc.times_seen = (size_t )0;
#line 1295
  pc.local_zones_seen = (size_t )0;
#line 1296
  pc.dsts_seen = (size_t )0;
#line 1297
  pc.zones_seen = (size_t )0;
#line 1300
  pc.local_time_zone_table[0].name = (char const   *)tmp->tm_zone;
#line 1301
  pc.local_time_zone_table[0].type = 269;
#line 1302
  pc.local_time_zone_table[0].value = (int )tmp->tm_isdst;
#line 1303
  pc.local_time_zone_table[1].name = (char const   *)((void *)0);
#line 1309
  quarter = 1;
#line 1309
  while (quarter <= 3) {
#line 1311
    probe = Start + (time_t )(quarter * 7776000);
#line 1312
    tmp___6 = localtime((time_t const   *)(& probe));
#line 1312
    probe_tm = (struct tm  const  *)tmp___6;
#line 1313
    if (probe_tm) {
#line 1313
      if (probe_tm->tm_zone) {
#line 1313
        if (probe_tm->tm_isdst != (int const   )pc.local_time_zone_table[0].value) {
#line 1317
          pc.local_time_zone_table[1].name = (char const   *)probe_tm->tm_zone;
#line 1318
          pc.local_time_zone_table[1].type = 269;
#line 1319
          pc.local_time_zone_table[1].value = (int )probe_tm->tm_isdst;
#line 1320
          pc.local_time_zone_table[2].name = (char const   *)((void *)0);
#line 1322
          break;
        }
      }
    }
#line 1309
    quarter ++;
  }
#line 1346
  if (pc.local_time_zone_table[0].name) {
#line 1346
    if (pc.local_time_zone_table[1].name) {
#line 1346
      tmp___7 = strcmp(pc.local_time_zone_table[0].name, pc.local_time_zone_table[1].name);
#line 1346
      if (! tmp___7) {
#line 1353
        pc.local_time_zone_table[0].value = -1;
#line 1354
        pc.local_time_zone_table[1].name = (char const   *)((void *)0);
      }
    }
  }
#line 1357
  tmp___8 = yyparse(& pc);
#line 1357
  if (tmp___8 != 0) {
#line 1358
    goto fail;
  }
#line 1360
  if (pc.timespec_seen) {
#line 1361
    *result = pc.seconds;
  } else {
#line 1364
    if (1UL < ((((pc.times_seen | pc.dates_seen) | pc.days_seen) | pc.dsts_seen) | (pc.local_zones_seen + pc.zones_seen))) {
#line 1366
      goto fail;
    }
#line 1368
    tmp___9 = to_year(pc.year);
#line 1368
    tm.tm_year = (int )(tmp___9 - 1900L);
#line 1369
    tm.tm_mon = (int )(pc.month - 1L);
#line 1370
    tm.tm_mday = (int )pc.day;
#line 1371
    if (pc.times_seen) {
#line 1371
      goto _L;
    } else
#line 1371
    if (pc.rels_seen) {
#line 1371
      if (! pc.dates_seen) {
#line 1371
        if (! pc.days_seen) {
          _L: /* CIL Label */ 
#line 1373
          tm.tm_hour = to_hour(pc.hour, pc.meridian);
#line 1374
          if (tm.tm_hour < 0) {
#line 1375
            goto fail;
          }
#line 1376
          tm.tm_min = (int )pc.minutes;
#line 1377
          tm.tm_sec = (int )pc.seconds.tv_sec;
        } else {
#line 1381
          tm.tm_sec = 0;
#line 1381
          tm.tm_min = tm.tm_sec;
#line 1381
          tm.tm_hour = tm.tm_min;
#line 1382
          pc.seconds.tv_nsec = (__syscall_slong_t )0;
        }
      } else {
#line 1381
        tm.tm_sec = 0;
#line 1381
        tm.tm_min = tm.tm_sec;
#line 1381
        tm.tm_hour = tm.tm_min;
#line 1382
        pc.seconds.tv_nsec = (__syscall_slong_t )0;
      }
    } else {
#line 1381
      tm.tm_sec = 0;
#line 1381
      tm.tm_min = tm.tm_sec;
#line 1381
      tm.tm_hour = tm.tm_min;
#line 1382
      pc.seconds.tv_nsec = (__syscall_slong_t )0;
    }
#line 1386
    if ((pc.dates_seen | pc.days_seen) | pc.times_seen) {
#line 1387
      tm.tm_isdst = -1;
    }
#line 1391
    if (pc.local_zones_seen) {
#line 1392
      tm.tm_isdst = pc.local_isdst;
    }
#line 1394
    tm0 = tm;
#line 1396
    Start = mktime(& tm);
#line 1398
    tmp___13 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                         Start);
#line 1398
    if (! tmp___13) {
#line 1400
      if (! pc.zones_seen) {
#line 1401
        goto fail;
      } else {
#line 1414
        time_zone = pc.time_zone;
#line 1415
        if (time_zone < 0L) {
#line 1415
          tmp___10 = - time_zone;
        } else {
#line 1415
          tmp___10 = time_zone;
        }
#line 1415
        abs_time_zone = tmp___10;
#line 1416
        abs_time_zone_hour = abs_time_zone / 60L;
#line 1417
        abs_time_zone_min = (int )(abs_time_zone % 60L);
#line 1420
        if (! tz_was_altered) {
#line 1421
          tz0 = get_tz((char *)(tz0buf));
        }
#line 1422
        sprintf((char * __restrict  )(tz1buf___0), (char const   * __restrict  )"XXX%s%ld:%02d",
                "-" + (time_zone < 0L), abs_time_zone_hour, abs_time_zone_min);
#line 1424
        tmp___11 = setenv("TZ", (char const   *)(tz1buf___0), 1);
#line 1424
        if (tmp___11 != 0) {
#line 1425
          goto fail;
        }
#line 1426
        tz_was_altered = (_Bool)1;
#line 1427
        tm = tm0;
#line 1428
        Start = mktime(& tm);
#line 1429
        tmp___12 = mktime_ok((struct tm  const  *)(& tm0), (struct tm  const  *)(& tm),
                             Start);
#line 1429
        if (! tmp___12) {
#line 1430
          goto fail;
        }
      }
    }
#line 1434
    if (pc.days_seen) {
#line 1434
      if (! pc.dates_seen) {
#line 1436
        if (0L < pc.day_ordinal) {
#line 1436
          if (tm.tm_wday != pc.day_number) {
#line 1436
            tmp___14 = 1;
          } else {
#line 1436
            tmp___14 = 0;
          }
        } else {
#line 1436
          tmp___14 = 0;
        }
#line 1436
        tm.tm_mday = (int )((long )tm.tm_mday + ((long )(((pc.day_number - tm.tm_wday) + 7) % 7) + 7L * (pc.day_ordinal - (long )tmp___14)));
#line 1440
        tm.tm_isdst = -1;
#line 1441
        Start = mktime(& tm);
#line 1442
        if (Start == -1L) {
#line 1443
          goto fail;
        }
      }
    }
#line 1447
    if ((pc.rel.year | pc.rel.month) | pc.rel.day) {
#line 1449
      year___0 = (int )((long )tm.tm_year + pc.rel.year);
#line 1450
      month = (int )((long )tm.tm_mon + pc.rel.month);
#line 1451
      day = (int )((long )tm.tm_mday + pc.rel.day);
#line 1452
      if ((((year___0 < tm.tm_year) ^ (pc.rel.year < 0L)) | ((month < tm.tm_mon) ^ (pc.rel.month < 0L))) | ((day < tm.tm_mday) ^ (pc.rel.day < 0L))) {
#line 1455
        goto fail;
      }
#line 1456
      tm.tm_year = year___0;
#line 1457
      tm.tm_mon = month;
#line 1458
      tm.tm_mday = day;
#line 1459
      tm.tm_hour = tm0.tm_hour;
#line 1460
      tm.tm_min = tm0.tm_min;
#line 1461
      tm.tm_sec = tm0.tm_sec;
#line 1462
      tm.tm_isdst = tm0.tm_isdst;
#line 1463
      Start = mktime(& tm);
#line 1464
      if (Start == -1L) {
#line 1465
        goto fail;
      }
    }
#line 1470
    if (pc.zones_seen) {
#line 1472
      delta = pc.time_zone * 60L;
#line 1475
      delta -= tm.tm_gmtoff;
#line 1483
      t1 = Start - delta;
#line 1484
      if ((Start < t1) != (delta < 0L)) {
#line 1485
        goto fail;
      }
#line 1486
      Start = t1;
    }
#line 1497
    sum_ns = pc.seconds.tv_nsec + pc.rel.ns;
#line 1498
    normalized_ns = (sum_ns % 1000000000L + 1000000000L) % 1000000000L;
#line 1499
    t0 = Start;
#line 1500
    d1 = 3600L * pc.rel.hour;
#line 1501
    t1___0 = t0 + d1;
#line 1502
    d2 = 60L * pc.rel.minutes;
#line 1503
    t2 = t1___0 + d2;
#line 1504
    d3 = pc.rel.seconds;
#line 1505
    t3 = t2 + d3;
#line 1506
    d4 = (sum_ns - normalized_ns) / 1000000000L;
#line 1507
    t4 = t3 + d4;
#line 1508
    t5 = t4;
#line 1510
    if (((((((d1 / 3600L ^ pc.rel.hour) | (d2 / 60L ^ pc.rel.minutes)) | (long )((t1___0 < t0) ^ (d1 < 0L))) | (long )((t2 < t1___0) ^ (d2 < 0L))) | (long )((t3 < t2) ^ (d3 < 0L))) | (long )((t4 < t3) ^ (d4 < 0L))) | (long )(t5 != t4)) {
#line 1517
      goto fail;
    }
#line 1519
    result->tv_sec = t5;
#line 1520
    result->tv_nsec = normalized_ns;
  }
#line 1524
  goto done;
  fail: 
#line 1527
  ok = (_Bool)0;
  done: 
#line 1529
  if (tz_was_altered) {
#line 1530
    if (tz0) {
#line 1530
      tmp___15 = setenv("TZ", (char const   *)tz0, 1);
#line 1530
      tmp___17 = tmp___15;
    } else {
#line 1530
      tmp___16 = unsetenv("TZ");
#line 1530
      tmp___17 = tmp___16;
    }
#line 1530
    ok = (_Bool )((int )ok & (tmp___17 == 0));
  }
#line 1531
  if ((unsigned long )tz0 != (unsigned long )(tz0buf)) {
#line 1532
    free((void *)tz0);
  }
#line 1533
  return (ok);
}
}
#line 1 "cil-Utwoy4Az.o"
#pragma merger("0","../lib/gethrxtime.o.i","")
#line 42 "/home/wslee/project/coreutils-8.1/lib/xtime.h"
__inline static xtime_t xtime_make(xtime_t s , long ns ) 
{ 


  {
#line 48
  return (1000000000LL * s + (xtime_t )ns);
}
}
#line 34 "/home/wslee/project/coreutils-8.1/lib/gethrxtime.h"
xtime_t gethrxtime(void) ;
#line 342 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_gettime)(clockid_t __clock_id ,
                                                                                    struct timespec *__tp ) ;
#line 32 "/home/wslee/project/coreutils-8.1/lib/gethrxtime.c"
xtime_t gethrxtime(void) 
{ 
  struct timespec ts ;
  xtime_t tmp ;
  int tmp___0 ;
  struct timespec ts___0 ;
  xtime_t tmp___1 ;

  {
#line 46
  tmp___0 = clock_gettime(1, & ts);
#line 46
  if (tmp___0 == 0) {
#line 47
    tmp = xtime_make((xtime_t )ts.tv_sec, ts.tv_nsec);
#line 47
    return (tmp);
  }
#line 63
  gettime(& ts___0);
#line 64
  tmp___1 = xtime_make((xtime_t )ts___0.tv_sec, ts___0.tv_nsec);
#line 64
  return (tmp___1);
}
}
#line 1 "cil-DNlUbGvF.o"
#pragma merger("0","../lib/getndelim2.o.i","")
#line 38 "/home/wslee/project/coreutils-8.1/lib/getndelim2.h"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) ;
#line 27 "/home/wslee/project/coreutils-8.1/lib/memchr2.h"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) ;
#line 70 "/home/wslee/project/coreutils-8.1/lib/getndelim2.c"
ssize_t getndelim2(char **lineptr , size_t *linesize , size_t offset , size_t nmax ,
                   int delim1 , int delim2 , FILE *stream ) 
{ 
  size_t nbytes_avail ;
  char *read_pos ;
  ssize_t bytes_stored ;
  char *ptr ;
  size_t size ;
  _Bool found_delimiter ;
  void *tmp ;
  int c ;
  char const   *buffer ;
  size_t buffer_len ;
  char const   *end ;
  void *tmp___0 ;
  size_t newsize ;
  size_t tmp___1 ;
  char *newptr ;
  size_t newsizemax ;
  void *tmp___2 ;
  size_t copy_len ;
  int tmp___3 ;
  ssize_t tmp___4 ;

  {
#line 76
  bytes_stored = (ssize_t )-1;
#line 77
  ptr = *lineptr;
#line 78
  size = *linesize;
#line 81
  if (! ptr) {
#line 83
    if (nmax < 64UL) {
#line 83
      size = nmax;
    } else {
#line 83
      size = (size_t )64;
    }
#line 84
    tmp = malloc(size);
#line 84
    ptr = (char *)tmp;
#line 85
    if (! ptr) {
#line 86
      return ((ssize_t )-1);
    }
  }
#line 89
  if (size < offset) {
#line 90
    goto done;
  }
#line 92
  nbytes_avail = size - offset;
#line 93
  read_pos = ptr + offset;
#line 95
  if (nbytes_avail == 0UL) {
#line 95
    if (nmax <= size) {
#line 96
      goto done;
    }
  }
#line 99
  if (delim1 == -1) {
#line 100
    delim1 = delim2;
  } else
#line 101
  if (delim2 == -1) {
#line 102
    delim2 = delim1;
  }
#line 106
  found_delimiter = (_Bool)0;
#line 107
  while (1) {
#line 116
    buffer = freadptr(stream, & buffer_len);
#line 117
    if (buffer) {
#line 119
      if (delim1 != -1) {
#line 121
        tmp___0 = memchr2((void const   *)buffer, delim1, delim2, buffer_len);
#line 121
        end = (char const   *)tmp___0;
#line 122
        if (end) {
#line 124
          buffer_len = (size_t )((end - buffer) + 1L);
#line 125
          found_delimiter = (_Bool)1;
        }
      }
    } else {
#line 131
      c = getc_unlocked(stream);
#line 132
      if (c == -1) {
#line 135
        if ((unsigned long )read_pos == (unsigned long )ptr) {
#line 136
          goto unlock_done;
        } else {
#line 138
          break;
        }
      }
#line 140
      if (c == delim1) {
#line 141
        found_delimiter = (_Bool)1;
      } else
#line 140
      if (c == delim2) {
#line 141
        found_delimiter = (_Bool)1;
      }
#line 142
      buffer_len = (size_t )1;
    }
#line 149
    if (nbytes_avail < buffer_len + 1UL) {
#line 149
      if (size < nmax) {
#line 153
        if (size < 64UL) {
#line 153
          tmp___1 = size + 64UL;
        } else {
#line 153
          tmp___1 = 2UL * size;
        }
#line 153
        newsize = tmp___1;
#line 158
        if (newsize - (size_t )(read_pos - ptr) < buffer_len + 1UL) {
#line 159
          newsize = ((size_t )(read_pos - ptr) + buffer_len) + 1UL;
        }
#line 161
        if (size < newsize) {
#line 161
          if (! (newsize <= nmax)) {
#line 162
            newsize = nmax;
          }
        } else {
#line 162
          newsize = nmax;
        }
#line 164
        if (9223372036854775807UL < newsize - offset) {
#line 166
          newsizemax = (offset + 9223372036854775807UL) + 1UL;
#line 167
          if (size == newsizemax) {
#line 168
            goto unlock_done;
          }
#line 169
          newsize = newsizemax;
        }
#line 172
        nbytes_avail = newsize - (size_t )(read_pos - ptr);
#line 173
        tmp___2 = realloc((void *)ptr, newsize);
#line 173
        newptr = (char *)tmp___2;
#line 174
        if (! newptr) {
#line 175
          goto unlock_done;
        }
#line 176
        ptr = newptr;
#line 177
        size = newsize;
#line 178
        read_pos = ptr + (size - nbytes_avail);
      }
    }
#line 184
    if (1UL < nbytes_avail) {
#line 186
      copy_len = nbytes_avail - 1UL;
#line 187
      if (buffer_len < copy_len) {
#line 188
        copy_len = buffer_len;
      }
#line 189
      if (buffer) {
#line 190
        memcpy((void * __restrict  )read_pos, (void const   * __restrict  )buffer,
               copy_len);
      } else {
#line 192
        *read_pos = (char )c;
      }
#line 193
      read_pos += copy_len;
#line 194
      nbytes_avail -= copy_len;
    }
#line 199
    if (buffer) {
#line 199
      tmp___3 = freadseek(stream, buffer_len);
#line 199
      if (tmp___3) {
#line 200
        goto unlock_done;
      }
    }
#line 107
    if (! (! found_delimiter)) {
#line 107
      break;
    }
  }
#line 206
  *read_pos = (char )'\000';
#line 208
  bytes_stored = read_pos - (ptr + offset);
  unlock_done: ;
  done: 
#line 214
  *lineptr = ptr;
#line 215
  *linesize = size;
#line 216
  if (bytes_stored) {
#line 216
    tmp___4 = bytes_stored;
  } else {
#line 216
    tmp___4 = (ssize_t )-1;
  }
#line 216
  return (tmp___4);
}
}
#line 1 "cil-y6LgvsMD.o"
#pragma merger("0","../lib/getpass.o.i","")
#line 951 "/usr/include/unistd.h"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt ) ;
#line 678 "/usr/include/stdio.h"
extern __ssize_t getline(char ** __restrict  __lineptr , size_t * __restrict  __n ,
                         FILE * __restrict  __stream ) ;
#line 82 "/usr/include/stdio_ext.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __fsetlocking)(FILE *__fp ,
                                                                                    int __type ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 78 "/home/wslee/project/coreutils-8.1/lib/getpass.c"
static void call_fclose(void *arg ) 
{ 


  {
#line 81
  if ((unsigned long )arg != (unsigned long )((void *)0)) {
#line 82
    fclose((FILE *)arg);
  }
#line 83
  return;
}
}
#line 92 "/home/wslee/project/coreutils-8.1/lib/getpass.c"
static char *buf  ;
#line 93 "/home/wslee/project/coreutils-8.1/lib/getpass.c"
static size_t bufsize  ;
#line 85 "/home/wslee/project/coreutils-8.1/lib/getpass.c"
char *( __attribute__((__nonnull__(1))) gnu_getpass)(char const   *prompt ) 
{ 
  FILE *tty ;
  FILE *in ;
  FILE *out ;
  struct termios s ;
  struct termios t ;
  _Bool tty_changed ;
  ssize_t nread ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 91
  tty_changed = (_Bool)0;
#line 99
  tty = fopen((char const   * __restrict  )"/dev/tty", (char const   * __restrict  )"w+");
#line 100
  if ((unsigned long )tty == (unsigned long )((void *)0)) {
#line 102
    in = stdin;
#line 103
    out = stderr;
  } else {
#line 108
    __fsetlocking(tty, 2);
#line 110
    in = tty;
#line 110
    out = in;
  }
#line 117
  tmp___1 = fileno(in);
#line 117
  tmp___2 = tcgetattr(tmp___1, & t);
#line 117
  if (tmp___2 == 0) {
#line 120
    s = t;
#line 122
    t.c_lflag &= 4294967286U;
#line 123
    tmp = fileno(in);
#line 123
    tmp___0 = tcsetattr(tmp, 2, (struct termios  const  *)(& t));
#line 123
    tty_changed = (_Bool )(tmp___0 == 0);
  }
#line 128
  fputs_unlocked((char const   * __restrict  )prompt, (FILE * __restrict  )out);
#line 129
  fflush_unlocked(out);
#line 132
  nread = getline((char ** __restrict  )(& buf), (size_t * __restrict  )(& bufsize),
                  (FILE * __restrict  )in);
#line 143
  rpl_fseeko(out, (off_t )0, 1);
#line 145
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 147
    if (nread < 0L) {
#line 148
      *(buf + 0) = (char )'\000';
    } else
#line 149
    if ((int )*(buf + (nread - 1L)) == 10) {
#line 152
      *(buf + (nread - 1L)) = (char )'\000';
#line 153
      if (tty_changed) {
#line 156
        putc_unlocked('\n', out);
      }
    }
  }
#line 163
  if (tty_changed) {
#line 164
    tmp___3 = fileno(in);
#line 164
    tcsetattr(tmp___3, 2, (struct termios  const  *)(& s));
  }
#line 169
  call_fclose((void *)tty);
#line 171
  return (buf);
}
}
#line 1 "cil-Nz6MeynJ.o"
#pragma merger("0","../lib/gettime.o.i","")
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 28 "/home/wslee/project/coreutils-8.1/lib/gettime.c"
void gettime(struct timespec *ts ) 
{ 
  int tmp ;
  struct timeval tv ;

  {
#line 36
  tmp = clock_gettime(0, ts);
#line 36
  if (tmp == 0) {
#line 37
    return;
  }
#line 42
  gettimeofday((struct timeval * __restrict  )(& tv), (__timezone_ptr_t )((void *)0));
#line 43
  ts->tv_sec = tv.tv_sec;
#line 44
  ts->tv_nsec = tv.tv_usec * 1000L;
#line 48
  return;
}
}
#line 1 "cil-LckKVX2i.o"
#pragma merger("0","../lib/getugroups.o.i","")
#line 18 "/home/wslee/project/coreutils-8.1/lib/getugroups.h"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) ;
#line 62 "/usr/include/grp.h"
extern void setgrent(void) ;
#line 68
extern void endgrent(void) ;
#line 74
extern struct group *getgrent(void) ;
#line 57 "/home/wslee/project/coreutils-8.1/lib/getugroups.c"
int getugroups(int maxcount , gid_t *grouplist , char const   *username , gid_t gid ) 
{ 
  int count ;
  char **cp ;
  struct group *grp ;
  int *tmp ;
  int n ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 61
  count = 0;
#line 63
  if (gid != 4294967295U) {
#line 65
    if (maxcount != 0) {
#line 66
      *(grouplist + count) = gid;
    }
#line 67
    count ++;
  }
#line 70
  setgrent();
#line 71
  while (1) {
#line 76
    tmp = __errno_location();
#line 76
    *tmp = 0;
#line 77
    grp = getgrent();
#line 78
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
#line 79
      break;
    }
#line 81
    cp = grp->gr_mem;
#line 81
    while (*cp) {
#line 85
      tmp___0 = strcmp(username, (char const   *)*cp);
#line 85
      if (! (tmp___0 == 0)) {
#line 86
        goto __Cont;
      }
#line 89
      n = 0;
#line 89
      while (n < count) {
#line 90
        if (grouplist) {
#line 90
          if (*(grouplist + n) == grp->gr_gid) {
#line 91
            break;
          }
        }
#line 89
        n ++;
      }
#line 94
      if (n == count) {
#line 96
        if (maxcount != 0) {
#line 98
          if (count >= maxcount) {
#line 99
            goto done;
          }
#line 100
          *(grouplist + count) = grp->gr_gid;
        }
#line 102
        if (count == 2147483647) {
#line 104
          tmp___1 = __errno_location();
#line 104
          *tmp___1 = 75;
#line 105
          goto done;
        }
#line 107
        count ++;
      }
      __Cont: /* CIL Label */ 
#line 81
      cp ++;
    }
  }
#line 112
  tmp___2 = __errno_location();
#line 112
  if (*tmp___2 != 0) {
#line 113
    count = -1;
  }
  done: 
#line 117
  tmp___3 = __errno_location();
#line 117
  saved_errno = *tmp___3;
#line 118
  endgrent();
#line 119
  tmp___4 = __errno_location();
#line 119
  *tmp___4 = saved_errno;
#line 122
  return (count);
}
}
#line 1 "cil-Pwnu71Iw.o"
#pragma merger("0","../lib/hard-locale.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/hard-locale.h"
_Bool hard_locale(int category ) ;
#line 35 "/home/wslee/project/coreutils-8.1/lib/hard-locale.c"
_Bool hard_locale(int category ) 
{ 
  _Bool hard ;
  char const   *p ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *locale ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
#line 38
  hard = (_Bool)1;
#line 39
  tmp = setlocale(category, (char const   *)((void *)0));
#line 39
  p = (char const   *)tmp;
#line 41
  if (p) {
#line 43
    if (1) {
#line 45
      tmp___0 = strcmp(p, "C");
#line 45
      if (tmp___0 == 0) {
#line 46
        hard = (_Bool)0;
      } else {
#line 45
        tmp___1 = strcmp(p, "POSIX");
#line 45
        if (tmp___1 == 0) {
#line 46
          hard = (_Bool)0;
        }
      }
    } else {
#line 50
      tmp___2 = strdup(p);
#line 50
      locale = tmp___2;
#line 51
      if (locale) {
#line 56
        tmp___3 = setlocale(category, "C");
#line 56
        p = (char const   *)tmp___3;
#line 56
        if (p) {
#line 56
          tmp___4 = strcmp(p, (char const   *)locale);
#line 56
          if (tmp___4 == 0) {
#line 60
            hard = (_Bool)0;
          } else {
#line 56
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 56
          tmp___5 = setlocale(category, "POSIX");
#line 56
          p = (char const   *)tmp___5;
#line 56
          if (p) {
#line 56
            tmp___6 = strcmp(p, (char const   *)locale);
#line 56
            if (tmp___6 == 0) {
#line 60
              hard = (_Bool)0;
            }
          }
        }
#line 63
        setlocale(category, (char const   *)locale);
#line 64
        free((void *)locale);
      }
    }
  }
#line 69
  return (hard);
}
}
#line 1 "cil-ZSWamyTj.o"
#pragma merger("0","../lib/hash-pjw.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/hash-pjw.h"
size_t hash_pjw(void const   *x , size_t tablesize ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/hash-pjw.c"
size_t hash_pjw(void const   *x , size_t tablesize ) 
{ 
  char const   *s ;
  size_t h ;

  {
#line 34
  h = (size_t )0;
#line 36
  s = (char const   *)x;
#line 36
  while (*s) {
#line 37
    h = (unsigned long )*s + ((h << 9) | (h >> (sizeof(size_t ) * 8UL - 9UL)));
#line 36
    s ++;
  }
#line 39
  return (h % tablesize);
}
}
#line 1 "cil-hNB9n9mh.o"
#pragma merger("0","../lib/hash-triple.o.i","")
#line 17 "/home/wslee/project/coreutils-8.1/lib/hash-triple.h"
size_t triple_hash_no_name(void const   *x , size_t table_size ) ;
#line 18
_Bool triple_compare(void const   *x , void const   *y ) ;
#line 24 "/home/wslee/project/coreutils-8.1/lib/same.h"
_Bool same_name(char const   *source , char const   *dest ) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/hash-triple.c"
size_t triple_hash(void const   *x , size_t table_size ) 
{ 
  struct F_triple  const  *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 36
  p = (struct F_triple  const  *)x;
#line 37
  tmp___0 = hash_pjw((void const   *)p->name, table_size);
#line 37
  tmp = tmp___0;
#line 40
  return ((tmp ^ (unsigned long )p->st_ino) % table_size);
}
}
#line 44 "/home/wslee/project/coreutils-8.1/lib/hash-triple.c"
size_t triple_hash_no_name(void const   *x , size_t table_size ) 
{ 
  struct F_triple  const  *p ;

  {
#line 47
  p = (struct F_triple  const  *)x;
#line 50
  return ((size_t )(p->st_ino % (unsigned long const   )table_size));
}
}
#line 54 "/home/wslee/project/coreutils-8.1/lib/hash-triple.c"
_Bool triple_compare(void const   *x , void const   *y ) 
{ 
  struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 57
  a = (struct F_triple  const  *)x;
#line 58
  b = (struct F_triple  const  *)y;
#line 59
  if (a->st_ino == b->st_ino) {
#line 59
    if (a->st_dev == b->st_dev) {
#line 59
      tmp___1 = same_name((char const   *)a->name, (char const   *)b->name);
#line 59
      if (tmp___1) {
#line 59
        tmp___0 = 1;
      } else {
#line 59
        tmp___0 = 0;
      }
    } else {
#line 59
      tmp___0 = 0;
    }
  } else {
#line 59
    tmp___0 = 0;
  }
#line 59
  return ((_Bool )tmp___0);
}
}
#line 62 "/home/wslee/project/coreutils-8.1/lib/hash-triple.c"
_Bool triple_compare_ino_str(void const   *x , void const   *y ) 
{ 
  struct F_triple  const  *a ;
  struct F_triple  const  *b ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 65
  a = (struct F_triple  const  *)x;
#line 66
  b = (struct F_triple  const  *)y;
#line 67
  if (a->st_ino == b->st_ino) {
#line 67
    if (a->st_dev == b->st_dev) {
#line 67
      tmp___1 = strcmp((char const   *)a->name, (char const   *)b->name);
#line 67
      if (tmp___1 == 0) {
#line 67
        tmp___0 = 1;
      } else {
#line 67
        tmp___0 = 0;
      }
    } else {
#line 67
      tmp___0 = 0;
    }
  } else {
#line 67
    tmp___0 = 0;
  }
#line 67
  return ((_Bool )tmp___0);
}
}
#line 71 "/home/wslee/project/coreutils-8.1/lib/hash-triple.c"
void triple_free(void *x ) 
{ 
  struct F_triple *a ;

  {
#line 74
  a = (struct F_triple *)x;
#line 75
  free((void *)a->name);
#line 76
  free((void *)a);
#line 77
  return;
}
}
#line 1 "cil-gY3Vhmpf.o"
#pragma merger("0","../lib/hash.o.i","")
#line 64 "/home/wslee/project/coreutils-8.1/lib/hash.h"
size_t hash_get_n_buckets(Hash_table const   *table ) ;
#line 65
size_t hash_get_n_buckets_used(Hash_table const   *table ) ;
#line 66
size_t hash_get_n_entries(Hash_table const   *table ) ;
#line 67
size_t hash_get_max_bucket_length(Hash_table const   *table ) ;
#line 68
_Bool hash_table_ok(Hash_table const   *table ) ;
#line 69
void hash_print_statistics(Hash_table const   *table , FILE *stream ) ;
#line 73
void *hash_get_first(Hash_table const   *table ) ;
#line 74
void *hash_get_next(Hash_table const   *table , void const   *entry ) ;
#line 75
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) ;
#line 76
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) ;
#line 80
void hash_reset_tuning(Hash_tuning *tuning ) ;
#line 84
void hash_clear(Hash_table *table ) ;
#line 88
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) ;
#line 76 "/home/wslee/project/coreutils-8.1/lib/bitrotate.h"
__inline static size_t rotr_sz(size_t x , int n ) 
{ 


  {
#line 79
  return (((x >> n) | (x << (8UL * sizeof(x) - (unsigned long )n))) & 0xffffffffffffffffUL);
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 131 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static struct hash_tuning  const  default_tuning  =    {(float )0.0, (float )1.0, (float )0.8, (float )1.414, (_Bool)0};
#line 150 "/home/wslee/project/coreutils-8.1/lib/hash.c"
size_t hash_get_n_buckets(Hash_table const   *table ) 
{ 


  {
#line 153
  return ((size_t )table->n_buckets);
}
}
#line 158 "/home/wslee/project/coreutils-8.1/lib/hash.c"
size_t hash_get_n_buckets_used(Hash_table const   *table ) 
{ 


  {
#line 161
  return ((size_t )table->n_buckets_used);
}
}
#line 166 "/home/wslee/project/coreutils-8.1/lib/hash.c"
size_t hash_get_n_entries(Hash_table const   *table ) 
{ 


  {
#line 169
  return ((size_t )table->n_entries);
}
}
#line 174 "/home/wslee/project/coreutils-8.1/lib/hash.c"
size_t hash_get_max_bucket_length(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t max_bucket_length ;
  struct hash_entry  const  *cursor ;
  size_t bucket_length ;

  {
#line 178
  max_bucket_length = (size_t )0;
#line 180
  bucket = (struct hash_entry  const  *)table->bucket;
#line 180
  while ((unsigned long )bucket < (unsigned long )table->bucket_limit) {
#line 182
    if (bucket->data) {
#line 184
      cursor = bucket;
#line 185
      bucket_length = (size_t )1;
#line 187
      while (1) {
#line 187
        cursor = (struct hash_entry  const  *)cursor->next;
#line 187
        if (! cursor) {
#line 187
          break;
        }
#line 188
        bucket_length ++;
      }
#line 190
      if (bucket_length > max_bucket_length) {
#line 191
        max_bucket_length = bucket_length;
      }
    }
#line 180
    bucket ++;
  }
#line 195
  return (max_bucket_length);
}
}
#line 201 "/home/wslee/project/coreutils-8.1/lib/hash.c"
_Bool hash_table_ok(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t n_buckets_used ;
  size_t n_entries ;
  struct hash_entry  const  *cursor ;

  {
#line 205
  n_buckets_used = (size_t )0;
#line 206
  n_entries = (size_t )0;
#line 208
  bucket = (struct hash_entry  const  *)table->bucket;
#line 208
  while ((unsigned long )bucket < (unsigned long )table->bucket_limit) {
#line 210
    if (bucket->data) {
#line 212
      cursor = bucket;
#line 215
      n_buckets_used ++;
#line 216
      n_entries ++;
#line 219
      while (1) {
#line 219
        cursor = (struct hash_entry  const  *)cursor->next;
#line 219
        if (! cursor) {
#line 219
          break;
        }
#line 220
        n_entries ++;
      }
    }
#line 208
    bucket ++;
  }
#line 224
  if (n_buckets_used == (size_t )table->n_buckets_used) {
#line 224
    if (n_entries == (size_t )table->n_entries) {
#line 225
      return ((_Bool)1);
    }
  }
#line 227
  return ((_Bool)0);
}
}
#line 230 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void hash_print_statistics(Hash_table const   *table , FILE *stream ) 
{ 
  size_t n_entries ;
  size_t tmp ;
  size_t n_buckets ;
  size_t tmp___0 ;
  size_t n_buckets_used ;
  size_t tmp___1 ;
  size_t max_bucket_length ;
  size_t tmp___2 ;

  {
#line 233
  tmp = hash_get_n_entries(table);
#line 233
  n_entries = tmp;
#line 234
  tmp___0 = hash_get_n_buckets(table);
#line 234
  n_buckets = tmp___0;
#line 235
  tmp___1 = hash_get_n_buckets_used(table);
#line 235
  n_buckets_used = tmp___1;
#line 236
  tmp___2 = hash_get_max_bucket_length(table);
#line 236
  max_bucket_length = tmp___2;
#line 238
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# entries:         %lu\n",
          n_entries);
#line 239
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# buckets:         %lu\n",
          n_buckets);
#line 240
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"# buckets used:    %lu (%.2f%%)\n",
          n_buckets_used, (100.0 * (double )n_buckets_used) / (double )n_buckets);
#line 243
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"max bucket length: %lu\n",
          max_bucket_length);
#line 245
  return;
}
}
#line 250 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void *hash_lookup(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;
  _Bool tmp___0 ;

  {
#line 253
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 253
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
#line 257
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 258
    abort();
  }
#line 260
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 261
    return ((void *)0);
  }
#line 263
  cursor = bucket;
#line 263
  while (cursor) {
#line 264
    if ((unsigned long )entry == (unsigned long )cursor->data) {
#line 265
      return ((void *)cursor->data);
    } else {
#line 264
      tmp___0 = (*(table->comparator))(entry, (void const   *)cursor->data);
#line 264
      if (tmp___0) {
#line 265
        return ((void *)cursor->data);
      }
    }
#line 263
    cursor = (struct hash_entry  const  *)cursor->next;
  }
#line 267
  return ((void *)0);
}
}
#line 281 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void *hash_get_first(Hash_table const   *table ) 
{ 
  struct hash_entry  const  *bucket ;

  {
#line 286
  if (table->n_entries == 0UL) {
#line 287
    return ((void *)0);
  }
#line 289
  bucket = (struct hash_entry  const  *)table->bucket;
#line 289
  while (1) {
#line 290
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 291
      abort();
    } else
#line 292
    if (bucket->data) {
#line 293
      return ((void *)bucket->data);
    }
#line 289
    bucket ++;
  }
}
}
#line 300 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void *hash_get_next(Hash_table const   *table , void const   *entry ) 
{ 
  struct hash_entry  const  *bucket ;
  size_t tmp ;
  struct hash_entry  const  *cursor ;

  {
#line 303
  tmp = (*(table->hasher))(entry, (size_t )table->n_buckets);
#line 303
  bucket = (struct hash_entry  const  *)(table->bucket + tmp);
#line 307
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 308
    abort();
  }
#line 311
  cursor = bucket;
#line 311
  while (cursor) {
#line 312
    if ((unsigned long )cursor->data == (unsigned long )entry) {
#line 312
      if (cursor->next) {
#line 313
        return ((cursor->next)->data);
      }
    }
#line 311
    cursor = (struct hash_entry  const  *)cursor->next;
  }
#line 316
  while (1) {
#line 316
    bucket ++;
#line 316
    if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 316
      break;
    }
#line 317
    if (bucket->data) {
#line 318
      return ((void *)bucket->data);
    }
  }
#line 321
  return ((void *)0);
}
}
#line 328 "/home/wslee/project/coreutils-8.1/lib/hash.c"
size_t hash_get_entries(Hash_table const   *table , void **buffer , size_t buffer_size ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  size_t tmp ;

  {
#line 332
  counter = (size_t )0;
#line 336
  bucket = (struct hash_entry  const  *)table->bucket;
#line 336
  while ((unsigned long )bucket < (unsigned long )table->bucket_limit) {
#line 338
    if (bucket->data) {
#line 340
      cursor = bucket;
#line 340
      while (cursor) {
#line 342
        if (counter >= buffer_size) {
#line 343
          return (counter);
        }
#line 344
        tmp = counter;
#line 344
        counter ++;
#line 344
        *(buffer + tmp) = (void *)cursor->data;
#line 340
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
#line 336
    bucket ++;
  }
#line 349
  return (counter);
}
}
#line 360 "/home/wslee/project/coreutils-8.1/lib/hash.c"
size_t hash_do_for_each(Hash_table const   *table , _Bool (*processor)(void * , void * ) ,
                        void *processor_data ) 
{ 
  size_t counter ;
  struct hash_entry  const  *bucket ;
  struct hash_entry  const  *cursor ;
  _Bool tmp ;

  {
#line 364
  counter = (size_t )0;
#line 368
  bucket = (struct hash_entry  const  *)table->bucket;
#line 368
  while ((unsigned long )bucket < (unsigned long )table->bucket_limit) {
#line 370
    if (bucket->data) {
#line 372
      cursor = bucket;
#line 372
      while (cursor) {
#line 374
        tmp = (*processor)((void *)cursor->data, processor_data);
#line 374
        if (! tmp) {
#line 375
          return (counter);
        }
#line 376
        counter ++;
#line 372
        cursor = (struct hash_entry  const  *)cursor->next;
      }
    }
#line 368
    bucket ++;
  }
#line 381
  return (counter);
}
}
#line 420 "/home/wslee/project/coreutils-8.1/lib/hash.c"
size_t hash_string(char const   *string , size_t n_buckets ) 
{ 
  size_t value ;
  unsigned char ch ;

  {
#line 423
  value = (size_t )0;
#line 426
  while (1) {
#line 426
    ch = (unsigned char )*string;
#line 426
    if (! ch) {
#line 426
      break;
    }
#line 427
    value = (value * 31UL + (size_t )ch) % n_buckets;
#line 426
    string ++;
  }
#line 428
  return (value);
}
}
#line 436 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static _Bool is_prime(size_t candidate ) 
{ 
  size_t divisor ;
  size_t square ;
  int tmp ;

  {
#line 439
  divisor = (size_t )3;
#line 440
  square = divisor * divisor;
#line 442
  while (1) {
#line 442
    if (square < candidate) {
#line 442
      if (! (candidate % divisor)) {
#line 442
        break;
      }
    } else {
#line 442
      break;
    }
#line 444
    divisor ++;
#line 445
    square += 4UL * divisor;
#line 446
    divisor ++;
  }
#line 449
  if (candidate % divisor) {
#line 449
    tmp = 1;
  } else {
#line 449
    tmp = 0;
  }
#line 449
  return ((_Bool )tmp);
}
}
#line 455 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static size_t next_prime(size_t candidate ) 
{ 
  _Bool tmp ;

  {
#line 459
  if (candidate < 10UL) {
#line 460
    candidate = (size_t )10;
  }
#line 463
  candidate |= 1UL;
#line 465
  while (1) {
#line 465
    if (0xffffffffffffffffUL != candidate) {
#line 465
      tmp = is_prime(candidate);
#line 465
      if (tmp) {
#line 465
        break;
      }
    } else {
#line 465
      break;
    }
#line 466
    candidate += 2UL;
  }
#line 468
  return (candidate);
}
}
#line 471 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void hash_reset_tuning(Hash_tuning *tuning ) 
{ 


  {
#line 474
  *tuning = (Hash_tuning )default_tuning;
#line 475
  return;
}
}
#line 478 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static size_t raw_hasher(void const   *data , size_t n ) 
{ 
  size_t val ;
  size_t tmp ;

  {
#line 486
  tmp = rotr_sz((size_t )data, 3);
#line 486
  val = tmp;
#line 487
  return (val % n);
}
}
#line 491 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static _Bool raw_comparator(void const   *a , void const   *b ) 
{ 


  {
#line 494
  return ((_Bool )((unsigned long )a == (unsigned long )b));
}
}
#line 504 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static _Bool check_tuning(Hash_table *table ) 
{ 
  Hash_tuning const   *tuning ;
  float epsilon ;

  {
#line 507
  tuning = table->tuning;
#line 509
  if ((unsigned long )tuning == (unsigned long )(& default_tuning)) {
#line 510
    return ((_Bool)1);
  }
#line 517
  epsilon = 0.1f;
#line 519
  if (epsilon < (float )tuning->growth_threshold) {
#line 519
    if (tuning->growth_threshold < (float const   )((float )1 - epsilon)) {
#line 519
      if ((float )1 + epsilon < (float )tuning->growth_factor) {
#line 519
        if ((float const   )0 <= tuning->shrink_threshold) {
#line 519
          if (tuning->shrink_threshold + (float const   )epsilon < tuning->shrink_factor) {
#line 519
            if (tuning->shrink_factor <= (float const   )1) {
#line 519
              if (tuning->shrink_threshold + (float const   )epsilon < tuning->growth_threshold) {
#line 526
                return ((_Bool)1);
              }
            }
          }
        }
      }
    }
  }
#line 528
  table->tuning = & default_tuning;
#line 529
  return ((_Bool)0);
}
}
#line 536 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static size_t compute_bucket_size(size_t candidate , Hash_tuning const   *tuning ) 
{ 
  float new_candidate ;
  int tmp ;

  {
#line 539
  if (! tuning->is_n_buckets) {
#line 541
    new_candidate = (float )((float const   )candidate / tuning->growth_threshold);
#line 542
    if ((float )0xffffffffffffffffUL <= new_candidate) {
#line 543
      return ((size_t )0);
    }
#line 544
    candidate = (size_t )new_candidate;
  }
#line 546
  candidate = next_prime(candidate);
#line 547
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 547
    tmp = -1;
  } else {
#line 547
    tmp = -2;
  }
#line 547
  if ((size_t )tmp / sizeof(struct hash_entry *) < candidate) {
#line 548
    return ((size_t )0);
  }
#line 549
  return (candidate);
}
}
#line 586 "/home/wslee/project/coreutils-8.1/lib/hash.c"
Hash_table *( __attribute__((__warn_unused_result__)) hash_initialize)(size_t candidate ,
                                                                       Hash_tuning const   *tuning ,
                                                                       size_t (*hasher)(void const   * ,
                                                                                        size_t  ) ,
                                                                       _Bool (*comparator)(void const   * ,
                                                                                           void const   * ) ,
                                                                       void (*data_freer)(void * ) ) 
{ 
  Hash_table *table ;
  void *tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;

  {
#line 593
  if ((unsigned long )hasher == (unsigned long )((void *)0)) {
#line 594
    hasher = & raw_hasher;
  }
#line 595
  if ((unsigned long )comparator == (unsigned long )((void *)0)) {
#line 596
    comparator = & raw_comparator;
  }
#line 598
  tmp = malloc(sizeof(*table));
#line 598
  table = (Hash_table *)tmp;
#line 599
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 600
    return ((Hash_table *)((void *)0));
  }
#line 602
  if (! tuning) {
#line 603
    tuning = & default_tuning;
  }
#line 604
  table->tuning = tuning;
#line 605
  tmp___0 = check_tuning(table);
#line 605
  if (! tmp___0) {
#line 612
    goto fail;
  }
#line 615
  table->n_buckets = compute_bucket_size(candidate, tuning);
#line 616
  if (! table->n_buckets) {
#line 617
    goto fail;
  }
#line 619
  tmp___1 = calloc(table->n_buckets, sizeof(*(table->bucket)));
#line 619
  table->bucket = (struct hash_entry *)tmp___1;
#line 620
  if ((unsigned long )table->bucket == (unsigned long )((void *)0)) {
#line 621
    goto fail;
  }
#line 622
  table->bucket_limit = (struct hash_entry  const  *)(table->bucket + table->n_buckets);
#line 623
  table->n_buckets_used = (size_t )0;
#line 624
  table->n_entries = (size_t )0;
#line 626
  table->hasher = hasher;
#line 627
  table->comparator = comparator;
#line 628
  table->data_freer = data_freer;
#line 630
  table->free_entry_list = (struct hash_entry *)((void *)0);
#line 634
  return (table);
  fail: 
#line 637
  free((void *)table);
#line 638
  return ((Hash_table *)((void *)0));
}
}
#line 645 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void hash_clear(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 650
  bucket = table->bucket;
#line 650
  while ((unsigned long )bucket < (unsigned long )table->bucket_limit) {
#line 652
    if (bucket->data) {
#line 658
      cursor = bucket->next;
#line 658
      while (cursor) {
#line 660
        if (table->data_freer) {
#line 661
          (*(table->data_freer))(cursor->data);
        }
#line 662
        cursor->data = (void *)0;
#line 664
        next = cursor->next;
#line 667
        cursor->next = table->free_entry_list;
#line 668
        table->free_entry_list = cursor;
#line 658
        cursor = next;
      }
#line 672
      if (table->data_freer) {
#line 673
        (*(table->data_freer))(bucket->data);
      }
#line 674
      bucket->data = (void *)0;
#line 675
      bucket->next = (struct hash_entry *)((void *)0);
    }
#line 650
    bucket ++;
  }
#line 679
  table->n_buckets_used = (size_t )0;
#line 680
  table->n_entries = (size_t )0;
#line 681
  return;
}
}
#line 688 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void hash_free(Hash_table *table ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;

  {
#line 696
  if (table->data_freer) {
#line 696
    if (table->n_entries) {
#line 698
      bucket = table->bucket;
#line 698
      while ((unsigned long )bucket < (unsigned long )table->bucket_limit) {
#line 700
        if (bucket->data) {
#line 702
          cursor = bucket;
#line 702
          while (cursor) {
#line 703
            (*(table->data_freer))(cursor->data);
#line 702
            cursor = cursor->next;
          }
        }
#line 698
        bucket ++;
      }
    }
  }
#line 715
  bucket = table->bucket;
#line 715
  while ((unsigned long )bucket < (unsigned long )table->bucket_limit) {
#line 717
    cursor = bucket->next;
#line 717
    while (cursor) {
#line 719
      next = cursor->next;
#line 720
      free((void *)cursor);
#line 717
      cursor = next;
    }
#line 715
    bucket ++;
  }
#line 725
  cursor = table->free_entry_list;
#line 725
  while (cursor) {
#line 727
    next = cursor->next;
#line 728
    free((void *)cursor);
#line 725
    cursor = next;
  }
#line 734
  free((void *)table->bucket);
#line 735
  free((void *)table);
#line 736
  return;
}
}
#line 743 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static struct hash_entry *allocate_entry(Hash_table *table ) 
{ 
  struct hash_entry *new ;
  void *tmp ;

  {
#line 748
  if (table->free_entry_list) {
#line 750
    new = table->free_entry_list;
#line 751
    table->free_entry_list = new->next;
  } else {
#line 758
    tmp = malloc(sizeof(*new));
#line 758
    new = (struct hash_entry *)tmp;
  }
#line 762
  return (new);
}
}
#line 768 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static void free_entry(Hash_table *table , struct hash_entry *entry ) 
{ 


  {
#line 771
  entry->data = (void *)0;
#line 772
  entry->next = table->free_entry_list;
#line 773
  table->free_entry_list = entry;
#line 774
  return;
}
}
#line 782 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static void *hash_find_entry(Hash_table *table , void const   *entry , struct hash_entry **bucket_head ,
                             _Bool delete ) 
{ 
  struct hash_entry *bucket ;
  size_t tmp ;
  struct hash_entry *cursor ;
  void *data ;
  struct hash_entry *next ;
  _Bool tmp___0 ;
  void *data___0 ;
  struct hash_entry *next___0 ;
  _Bool tmp___1 ;

  {
#line 786
  tmp = (*(table->hasher))(entry, table->n_buckets);
#line 786
  bucket = table->bucket + tmp;
#line 790
  if (! ((unsigned long )bucket < (unsigned long )table->bucket_limit)) {
#line 791
    abort();
  }
#line 793
  *bucket_head = bucket;
#line 796
  if ((unsigned long )bucket->data == (unsigned long )((void *)0)) {
#line 797
    return ((void *)0);
  }
#line 800
  if ((unsigned long )entry == (unsigned long )bucket->data) {
#line 800
    goto _L;
  } else {
#line 800
    tmp___0 = (*(table->comparator))(entry, (void const   *)bucket->data);
#line 800
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 802
      data = bucket->data;
#line 804
      if (delete) {
#line 806
        if (bucket->next) {
#line 808
          next = bucket->next;
#line 812
          *bucket = *next;
#line 813
          free_entry(table, next);
        } else {
#line 817
          bucket->data = (void *)0;
        }
      }
#line 821
      return (data);
    }
  }
#line 825
  cursor = bucket;
#line 825
  while (cursor->next) {
#line 827
    if ((unsigned long )entry == (unsigned long )(cursor->next)->data) {
#line 827
      goto _L___0;
    } else {
#line 827
      tmp___1 = (*(table->comparator))(entry, (void const   *)(cursor->next)->data);
#line 827
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 830
        data___0 = (cursor->next)->data;
#line 832
        if (delete) {
#line 834
          next___0 = cursor->next;
#line 838
          cursor->next = next___0->next;
#line 839
          free_entry(table, next___0);
        }
#line 842
        return (data___0);
      }
    }
#line 825
    cursor = cursor->next;
  }
#line 847
  return ((void *)0);
}
}
#line 856 "/home/wslee/project/coreutils-8.1/lib/hash.c"
static _Bool transfer_entries(Hash_table *dst , Hash_table *src , _Bool safe ) 
{ 
  struct hash_entry *bucket ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  void *data ;
  struct hash_entry *new_bucket ;
  size_t tmp ;
  size_t tmp___0 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___1 ;

  {
#line 862
  bucket = src->bucket;
#line 862
  while ((unsigned long )bucket < (unsigned long )src->bucket_limit) {
#line 863
    if (bucket->data) {
#line 874
      cursor = bucket->next;
#line 874
      while (cursor) {
#line 876
        data = cursor->data;
#line 877
        tmp = (*(dst->hasher))((void const   *)data, dst->n_buckets);
#line 877
        new_bucket = dst->bucket + tmp;
#line 879
        if (! ((unsigned long )new_bucket < (unsigned long )dst->bucket_limit)) {
#line 880
          abort();
        }
#line 882
        next = cursor->next;
#line 884
        if (new_bucket->data) {
#line 888
          cursor->next = new_bucket->next;
#line 889
          new_bucket->next = cursor;
        } else {
#line 895
          new_bucket->data = data;
#line 896
          (dst->n_buckets_used) ++;
#line 897
          free_entry(dst, cursor);
        }
#line 874
        cursor = next;
      }
#line 903
      data = bucket->data;
#line 904
      bucket->next = (struct hash_entry *)((void *)0);
#line 905
      if (safe) {
#line 906
        goto __Cont;
      }
#line 907
      tmp___0 = (*(dst->hasher))((void const   *)data, dst->n_buckets);
#line 907
      new_bucket = dst->bucket + tmp___0;
#line 909
      if (! ((unsigned long )new_bucket < (unsigned long )dst->bucket_limit)) {
#line 910
        abort();
      }
#line 912
      if (new_bucket->data) {
#line 916
        tmp___1 = allocate_entry(dst);
#line 916
        new_entry = tmp___1;
#line 918
        if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 919
          return ((_Bool)0);
        }
#line 921
        new_entry->data = data;
#line 922
        new_entry->next = new_bucket->next;
#line 923
        new_bucket->next = new_entry;
      } else {
#line 928
        new_bucket->data = data;
#line 929
        (dst->n_buckets_used) ++;
      }
#line 931
      bucket->data = (void *)0;
#line 932
      (src->n_buckets_used) --;
    }
    __Cont: /* CIL Label */ 
#line 862
    bucket ++;
  }
#line 934
  return ((_Bool)1);
}
}
#line 945 "/home/wslee/project/coreutils-8.1/lib/hash.c"
_Bool ( __attribute__((__warn_unused_result__)) hash_rehash)(Hash_table *table , size_t candidate ) 
{ 
  Hash_table storage ;
  Hash_table *new_table ;
  size_t new_size ;
  size_t tmp ;
  void *tmp___0 ;
  _Bool tmp___1 ;
  _Bool tmp___2 ;
  _Bool tmp___3 ;

  {
#line 950
  tmp = compute_bucket_size(candidate, table->tuning);
#line 950
  new_size = tmp;
#line 952
  if (! new_size) {
#line 953
    return ((_Bool)0);
  }
#line 954
  if (new_size == table->n_buckets) {
#line 955
    return ((_Bool)1);
  }
#line 956
  new_table = & storage;
#line 957
  tmp___0 = calloc(new_size, sizeof(*(new_table->bucket)));
#line 957
  new_table->bucket = (struct hash_entry *)tmp___0;
#line 958
  if ((unsigned long )new_table->bucket == (unsigned long )((void *)0)) {
#line 959
    return ((_Bool)0);
  }
#line 960
  new_table->n_buckets = new_size;
#line 961
  new_table->bucket_limit = (struct hash_entry  const  *)(new_table->bucket + new_size);
#line 962
  new_table->n_buckets_used = (size_t )0;
#line 963
  new_table->n_entries = (size_t )0;
#line 964
  new_table->tuning = table->tuning;
#line 965
  new_table->hasher = table->hasher;
#line 966
  new_table->comparator = table->comparator;
#line 967
  new_table->data_freer = table->data_freer;
#line 987
  new_table->free_entry_list = table->free_entry_list;
#line 989
  tmp___1 = transfer_entries(new_table, table, (_Bool)0);
#line 989
  if (tmp___1) {
#line 992
    free((void *)table->bucket);
#line 993
    table->bucket = new_table->bucket;
#line 994
    table->bucket_limit = new_table->bucket_limit;
#line 995
    table->n_buckets = new_table->n_buckets;
#line 996
    table->n_buckets_used = new_table->n_buckets_used;
#line 997
    table->free_entry_list = new_table->free_entry_list;
#line 999
    return ((_Bool)1);
  }
#line 1015
  table->free_entry_list = new_table->free_entry_list;
#line 1016
  tmp___2 = transfer_entries(table, new_table, (_Bool)1);
#line 1016
  if (tmp___2) {
#line 1016
    tmp___3 = transfer_entries(table, new_table, (_Bool)0);
#line 1016
    if (! tmp___3) {
#line 1018
      abort();
    }
  } else {
#line 1018
    abort();
  }
#line 1020
  free((void *)new_table->bucket);
#line 1021
  return ((_Bool)0);
}
}
#line 1030 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void *( __attribute__((__warn_unused_result__)) hash_insert)(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  float candidate ;
  float tmp ;
  _Bool tmp___0 ;
  void *tmp___1 ;
  struct hash_entry *new_entry ;
  struct hash_entry *tmp___2 ;

  {
#line 1037
  if (! entry) {
#line 1038
    abort();
  }
#line 1041
  data = hash_find_entry(table, entry, & bucket, (_Bool)0);
#line 1041
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 1042
    return (data);
  }
#line 1049
  if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1054
    check_tuning(table);
#line 1055
    if ((float const   )table->n_buckets_used > (table->tuning)->growth_threshold * (float const   )table->n_buckets) {
#line 1058
      tuning = table->tuning;
#line 1059
      if (tuning->is_n_buckets) {
#line 1059
        tmp = (float const   )table->n_buckets * tuning->growth_factor;
      } else {
#line 1059
        tmp = ((float const   )table->n_buckets * tuning->growth_factor) * tuning->growth_threshold;
      }
#line 1059
      candidate = (float )tmp;
#line 1065
      if ((float )0xffffffffffffffffUL <= candidate) {
#line 1066
        return ((void *)0);
      }
#line 1069
      tmp___0 = hash_rehash(table, (size_t )candidate);
#line 1069
      if (! tmp___0) {
#line 1070
        return ((void *)0);
      }
#line 1073
      tmp___1 = hash_find_entry(table, entry, & bucket, (_Bool)0);
#line 1073
      if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1074
        abort();
      }
    }
  }
#line 1080
  if (bucket->data) {
#line 1082
    tmp___2 = allocate_entry(table);
#line 1082
    new_entry = tmp___2;
#line 1084
    if ((unsigned long )new_entry == (unsigned long )((void *)0)) {
#line 1085
      return ((void *)0);
    }
#line 1089
    new_entry->data = (void *)entry;
#line 1090
    new_entry->next = bucket->next;
#line 1091
    bucket->next = new_entry;
#line 1092
    (table->n_entries) ++;
#line 1093
    return ((void *)entry);
  }
#line 1098
  bucket->data = (void *)entry;
#line 1099
  (table->n_entries) ++;
#line 1100
  (table->n_buckets_used) ++;
#line 1102
  return ((void *)entry);
}
}
#line 1109 "/home/wslee/project/coreutils-8.1/lib/hash.c"
void *hash_delete(Hash_table *table , void const   *entry ) 
{ 
  void *data ;
  struct hash_entry *bucket ;
  Hash_tuning const   *tuning ;
  size_t candidate ;
  float tmp ;
  struct hash_entry *cursor ;
  struct hash_entry *next ;
  _Bool tmp___0 ;

  {
#line 1115
  data = hash_find_entry(table, entry, & bucket, (_Bool)1);
#line 1116
  if (! data) {
#line 1117
    return ((void *)0);
  }
#line 1119
  (table->n_entries) --;
#line 1120
  if (! bucket->data) {
#line 1122
    (table->n_buckets_used) --;
#line 1127
    if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1132
      check_tuning(table);
#line 1133
      if ((float const   )table->n_buckets_used < (table->tuning)->shrink_threshold * (float const   )table->n_buckets) {
#line 1136
        tuning = table->tuning;
#line 1137
        if (tuning->is_n_buckets) {
#line 1137
          tmp = (float const   )table->n_buckets * tuning->shrink_factor;
        } else {
#line 1137
          tmp = ((float const   )table->n_buckets * tuning->shrink_factor) * tuning->growth_threshold;
        }
#line 1137
        candidate = (size_t )tmp;
#line 1143
        tmp___0 = hash_rehash(table, candidate);
#line 1143
        if (! tmp___0) {
#line 1151
          cursor = table->free_entry_list;
#line 1153
          while (cursor) {
#line 1155
            next = cursor->next;
#line 1156
            free((void *)cursor);
#line 1157
            cursor = next;
          }
#line 1159
          table->free_entry_list = (struct hash_entry *)((void *)0);
        }
      }
    }
  }
#line 1166
  return (data);
}
}
#line 1 "cil-uPId23ap.o"
#pragma merger("0","../lib/human.o.i","")
#line 47 "./xstrtol.h"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 127 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) struct lconv *( __attribute__((__leaf__)) localeconv)(void) ;
#line 37 "/home/wslee/project/coreutils-8.1/lib/human.c"
static char const   power_letter[9]  = 
#line 37 "/home/wslee/project/coreutils-8.1/lib/human.c"
  {      (char const   )0,      (char const   )'K',      (char const   )'M',      (char const   )'G', 
        (char const   )'T',      (char const   )'P',      (char const   )'E',      (char const   )'Z', 
        (char const   )'Y'};
#line 54 "/home/wslee/project/coreutils-8.1/lib/human.c"
static long double adjust_value(int inexact_style , long double value ) 
{ 
  uintmax_t u ;
  int tmp ;

  {
#line 61
  if (inexact_style != 1) {
#line 61
    if (value < (long double )0xffffffffffffffffUL) {
#line 63
      u = (uintmax_t )value;
#line 64
      if (inexact_style == 0) {
#line 64
        if ((long double )u != value) {
#line 64
          tmp = 1;
        } else {
#line 64
          tmp = 0;
        }
      } else {
#line 64
        tmp = 0;
      }
#line 64
      value = (long double )(u + (uintmax_t )tmp);
    }
  }
#line 67
  return (value);
}
}
#line 79 "/home/wslee/project/coreutils-8.1/lib/human.c"
static char *group_number(char *number , size_t numberlen , char const   *grouping ,
                          char const   *thousands_sep ) 
{ 
  register char *d ;
  size_t grouplen ;
  size_t thousands_seplen ;
  size_t tmp ;
  size_t i ;
  char buf___0[2UL * (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  unsigned char g ;

  {
#line 84
  grouplen = 0xffffffffffffffffUL;
#line 85
  tmp = strlen(thousands_sep);
#line 85
  thousands_seplen = tmp;
#line 86
  i = numberlen;
#line 92
  memcpy((void * __restrict  )(buf___0), (void const   * __restrict  )number, numberlen);
#line 93
  d = number + numberlen;
#line 95
  while (1) {
#line 97
    g = (unsigned char )*grouping;
#line 99
    if (g) {
#line 101
      if ((int )g < 127) {
#line 101
        grouplen = (size_t )g;
      } else {
#line 101
        grouplen = i;
      }
#line 102
      grouping ++;
    }
#line 105
    if (i < grouplen) {
#line 106
      grouplen = i;
    }
#line 108
    d -= grouplen;
#line 109
    i -= grouplen;
#line 110
    memcpy((void * __restrict  )d, (void const   * __restrict  )(buf___0 + i), grouplen);
#line 111
    if (i == 0UL) {
#line 112
      return (d);
    }
#line 114
    d -= thousands_seplen;
#line 115
    memcpy((void * __restrict  )d, (void const   * __restrict  )thousands_sep, thousands_seplen);
  }
}
}
#line 153 "/home/wslee/project/coreutils-8.1/lib/human.c"
char *human_readable(uintmax_t n , char *buf___0 , int opts , uintmax_t from_block_size ,
                     uintmax_t to_block_size ) 
{ 
  int inexact_style ;
  unsigned int base ;
  int tmp ;
  uintmax_t amt ;
  int tenths ;
  int exponent ;
  int exponent_max ;
  char *p ;
  char *psuffix ;
  char const   *integerlim ;
  int rounding ;
  char const   *decimal_point ;
  size_t decimal_pointlen ;
  char const   *grouping ;
  char const   *thousands_sep ;
  struct lconv  const  *l ;
  struct lconv *tmp___0 ;
  size_t pointlen ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  uintmax_t multiplier ;
  uintmax_t divisor ;
  uintmax_t r10 ;
  uintmax_t r2 ;
  long double dto_block_size ;
  long double damt ;
  size_t buflen ;
  size_t nonintegerlen ;
  long double tmp___3 ;
  long double e ;
  long double tmp___4 ;
  long double tmp___5 ;
  unsigned int r10___0 ;
  unsigned int r2___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int digit ;
  uintmax_t power ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 157
  inexact_style = opts & 3;
#line 159
  if (opts & 32) {
#line 159
    tmp = 1024;
  } else {
#line 159
    tmp = 1000;
  }
#line 159
  base = (unsigned int )tmp;
#line 162
  exponent = -1;
#line 163
  exponent_max = (int )(sizeof(power_letter) - 1UL);
#line 174
  decimal_point = ".";
#line 175
  decimal_pointlen = (size_t )1;
#line 176
  grouping = "";
#line 177
  thousands_sep = "";
#line 178
  tmp___0 = localeconv();
#line 178
  l = (struct lconv  const  *)tmp___0;
#line 179
  tmp___1 = strlen((char const   *)l->decimal_point);
#line 179
  pointlen = tmp___1;
#line 180
  if (0UL < pointlen) {
#line 180
    if (pointlen <= 16UL) {
#line 182
      decimal_point = (char const   *)l->decimal_point;
#line 183
      decimal_pointlen = pointlen;
    }
  }
#line 185
  grouping = (char const   *)l->grouping;
#line 186
  tmp___2 = strlen((char const   *)l->thousands_sep);
#line 186
  if (tmp___2 <= 16UL) {
#line 187
    thousands_sep = (char const   *)l->thousands_sep;
  }
#line 189
  psuffix = (buf___0 + (((((((2UL * sizeof(uintmax_t )) * 8UL) * 146UL) / 485UL + 1UL) * 17UL - 16UL) + 1UL) + 3UL)) - 3;
#line 190
  p = psuffix;
#line 195
  if (to_block_size <= from_block_size) {
#line 197
    if (from_block_size % to_block_size == 0UL) {
#line 199
      multiplier = from_block_size / to_block_size;
#line 200
      amt = n * multiplier;
#line 201
      if (amt / multiplier == n) {
#line 203
        tenths = 0;
#line 204
        rounding = 0;
#line 205
        goto use_integer_arithmetic;
      }
    }
  } else
#line 209
  if (from_block_size != 0UL) {
#line 209
    if (to_block_size % from_block_size == 0UL) {
#line 211
      divisor = to_block_size / from_block_size;
#line 212
      r10 = (n % divisor) * 10UL;
#line 213
      r2 = (r10 % divisor) * 2UL;
#line 214
      amt = n / divisor;
#line 215
      tenths = (int )(r10 / divisor);
#line 216
      if (r2 < divisor) {
#line 216
        rounding = 0UL < r2;
      } else {
#line 216
        rounding = 2 + (divisor < r2);
      }
#line 217
      goto use_integer_arithmetic;
    }
  }
#line 225
  dto_block_size = (long double )to_block_size;
#line 226
  damt = (long double )n * ((long double )from_block_size / dto_block_size);
#line 230
  if (! (opts & 16)) {
#line 232
    tmp___3 = adjust_value(inexact_style, damt);
#line 232
    sprintf((char * __restrict  )buf___0, (char const   * __restrict  )"%.0Lf", tmp___3);
#line 233
    buflen = strlen((char const   *)buf___0);
#line 234
    nonintegerlen = (size_t )0;
  } else {
#line 238
    e = (long double )1;
#line 239
    exponent = 0;
#line 241
    while (1) {
#line 243
      e *= (long double )base;
#line 244
      exponent ++;
#line 241
      if (e * (long double )base <= damt) {
#line 241
        if (! (exponent < exponent_max)) {
#line 241
          break;
        }
      } else {
#line 241
        break;
      }
    }
#line 248
    damt /= e;
#line 250
    tmp___4 = adjust_value(inexact_style, damt);
#line 250
    sprintf((char * __restrict  )buf___0, (char const   * __restrict  )"%.1Lf", tmp___4);
#line 251
    buflen = strlen((char const   *)buf___0);
#line 252
    nonintegerlen = decimal_pointlen + 1UL;
#line 254
    if ((1UL + nonintegerlen) + (size_t )(! (opts & 32)) < buflen) {
#line 258
      tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 258
      sprintf((char * __restrict  )buf___0, (char const   * __restrict  )"%.0Lf",
              tmp___5 / (long double )10);
#line 260
      buflen = strlen((char const   *)buf___0);
#line 261
      nonintegerlen = (size_t )0;
    } else
#line 254
    if (opts & 8) {
#line 254
      if ((int )*(buf___0 + (buflen - 1UL)) == 48) {
#line 258
        tmp___5 = adjust_value(inexact_style, damt * (long double )10);
#line 258
        sprintf((char * __restrict  )buf___0, (char const   * __restrict  )"%.0Lf",
                tmp___5 / (long double )10);
#line 260
        buflen = strlen((char const   *)buf___0);
#line 261
        nonintegerlen = (size_t )0;
      }
    }
  }
#line 265
  p = psuffix - buflen;
#line 266
  memmove((void *)p, (void const   *)buf___0, buflen);
#line 267
  integerlim = (char const   *)((p + buflen) - nonintegerlen);
#line 269
  goto do_grouping;
  use_integer_arithmetic: 
#line 278
  if (opts & 16) {
#line 280
    exponent = 0;
#line 282
    if ((uintmax_t )base <= amt) {
#line 284
      while (1) {
#line 286
        r10___0 = (unsigned int )((amt % (unsigned long )base) * 10UL + (unsigned long )tenths);
#line 287
        r2___0 = (r10___0 % base) * 2U + (unsigned int )(rounding >> 1);
#line 288
        amt /= (uintmax_t )base;
#line 289
        tenths = (int )(r10___0 / base);
#line 290
        if (r2___0 < base) {
#line 290
          rounding = r2___0 + (unsigned int )rounding != 0U;
        } else {
#line 290
          rounding = 2 + (base < r2___0 + (unsigned int )rounding);
        }
#line 293
        exponent ++;
#line 284
        if ((uintmax_t )base <= amt) {
#line 284
          if (! (exponent < exponent_max)) {
#line 284
            break;
          }
        } else {
#line 284
          break;
        }
      }
#line 297
      if (amt < 10UL) {
#line 299
        if (inexact_style == 1) {
#line 299
          tmp___7 = 2 < rounding + (tenths & 1);
        } else {
#line 299
          if (inexact_style == 0) {
#line 299
            if (0 < rounding) {
#line 299
              tmp___6 = 1;
            } else {
#line 299
              tmp___6 = 0;
            }
          } else {
#line 299
            tmp___6 = 0;
          }
#line 299
          tmp___7 = tmp___6;
        }
#line 299
        if (tmp___7) {
#line 303
          tenths ++;
#line 304
          rounding = 0;
#line 306
          if (tenths == 10) {
#line 308
            amt ++;
#line 309
            tenths = 0;
          }
        }
#line 313
        if (amt < 10UL) {
#line 313
          if (tenths) {
#line 313
            goto _L;
          } else
#line 313
          if (! (opts & 8)) {
            _L: /* CIL Label */ 
#line 316
            p --;
#line 316
            *p = (char )(48 + tenths);
#line 317
            p -= decimal_pointlen;
#line 318
            memcpy((void * __restrict  )p, (void const   * __restrict  )decimal_point,
                   decimal_pointlen);
#line 319
            rounding = 0;
#line 319
            tenths = rounding;
          }
        }
      }
    }
  }
#line 325
  if (inexact_style == 1) {
#line 325
    tmp___9 = 5 < tenths + (0UL < (unsigned long )rounding + (amt & 1UL));
  } else {
#line 325
    if (inexact_style == 0) {
#line 325
      if (0 < tenths + rounding) {
#line 325
        tmp___8 = 1;
      } else {
#line 325
        tmp___8 = 0;
      }
    } else {
#line 325
      tmp___8 = 0;
    }
#line 325
    tmp___9 = tmp___8;
  }
#line 325
  if (tmp___9) {
#line 329
    amt ++;
#line 331
    if (opts & 16) {
#line 331
      if (amt == (uintmax_t )base) {
#line 331
        if (exponent < exponent_max) {
#line 334
          exponent ++;
#line 335
          if (! (opts & 8)) {
#line 337
            p --;
#line 337
            *p = (char )'0';
#line 338
            p -= decimal_pointlen;
#line 339
            memcpy((void * __restrict  )p, (void const   * __restrict  )decimal_point,
                   decimal_pointlen);
          }
#line 341
          amt = (uintmax_t )1;
        }
      }
    }
  }
#line 345
  integerlim = (char const   *)p;
#line 347
  while (1) {
#line 349
    digit = (int )(amt % 10UL);
#line 350
    p --;
#line 350
    *p = (char )(digit + 48);
#line 347
    amt /= 10UL;
#line 347
    if (! (amt != 0UL)) {
#line 347
      break;
    }
  }
  do_grouping: 
#line 356
  if (opts & 4) {
#line 357
    p = group_number(p, (size_t )(integerlim - (char const   *)p), grouping, thousands_sep);
  }
#line 359
  if (opts & 128) {
#line 361
    if (exponent < 0) {
#line 364
      exponent = 0;
#line 365
      power = (uintmax_t )1;
#line 365
      while (power < to_block_size) {
#line 366
        exponent ++;
#line 366
        if (exponent == exponent_max) {
#line 367
          break;
        }
#line 365
        power *= (uintmax_t )base;
      }
    }
#line 370
    if (exponent | (opts & 256)) {
#line 370
      if (opts & 64) {
#line 371
        tmp___10 = psuffix;
#line 371
        psuffix ++;
#line 371
        *tmp___10 = (char )' ';
      }
    }
#line 373
    if (exponent) {
#line 374
      tmp___11 = psuffix;
#line 374
      psuffix ++;
#line 374
      if (! (opts & 32)) {
#line 374
        if (exponent == 1) {
#line 374
          *tmp___11 = (char )'k';
        } else {
#line 374
          *tmp___11 = (char )power_letter[exponent];
        }
      } else {
#line 374
        *tmp___11 = (char )power_letter[exponent];
      }
    }
#line 378
    if (opts & 256) {
#line 380
      if (opts & 32) {
#line 380
        if (exponent) {
#line 381
          tmp___12 = psuffix;
#line 381
          psuffix ++;
#line 381
          *tmp___12 = (char )'i';
        }
      }
#line 382
      tmp___13 = psuffix;
#line 382
      psuffix ++;
#line 382
      *tmp___13 = (char )'B';
    }
  }
#line 386
  *psuffix = (char )'\000';
#line 388
  return (p);
}
}
#line 398 "/home/wslee/project/coreutils-8.1/lib/human.c"
static char const   * const  block_size_args[3]  = {      (char const   * const  )"human-readable",      (char const   * const  )"si",      (char const   * const  )0};
#line 399 "/home/wslee/project/coreutils-8.1/lib/human.c"
static int const   block_size_opts[2]  = {      (int const   )176,      (int const   )144};
#line 405 "/home/wslee/project/coreutils-8.1/lib/human.c"
static uintmax_t default_block_size(void) 
{ 
  int tmp___0 ;
  char *tmp___1 ;

  {
#line 408
  tmp___1 = getenv("POSIXLY_CORRECT");
#line 408
  if (tmp___1) {
#line 408
    tmp___0 = 512;
  } else {
#line 408
    tmp___0 = 1024;
  }
#line 408
  return ((uintmax_t )tmp___0);
}
}
#line 411 "/home/wslee/project/coreutils-8.1/lib/human.c"
static strtol_error humblock(char const   *spec , uintmax_t *block_size , int *options ) 
{ 
  int i ;
  int opts ;
  char *ptr ;
  strtol_error e ;
  strtol_error tmp ;
  ptrdiff_t tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 415
  opts = 0;
#line 417
  if (! spec) {
#line 417
    tmp___1 = getenv("BLOCK_SIZE");
#line 417
    spec = (char const   *)tmp___1;
#line 417
    if (spec) {
#line 417
      goto _L___0;
    } else {
#line 417
      tmp___2 = getenv("BLOCKSIZE");
#line 417
      spec = (char const   *)tmp___2;
#line 417
      if (spec) {
#line 417
        goto _L___0;
      } else {
#line 420
        *block_size = default_block_size();
      }
    }
  } else {
    _L___0: /* CIL Label */ 
#line 423
    if ((int const   )*spec == 39) {
#line 425
      opts |= 4;
#line 426
      spec ++;
    }
#line 429
    tmp___0 = argmatch(spec, block_size_args, (char const   *)(block_size_opts), sizeof(block_size_opts[0]));
#line 429
    i = (int )tmp___0;
#line 429
    if (0 <= i) {
#line 431
      opts |= (int )block_size_opts[i];
#line 432
      *block_size = (uintmax_t )1;
    } else {
#line 437
      tmp = xstrtoumax(spec, & ptr, 0, block_size, "eEgGkKmMpPtTyYzZ0");
#line 437
      e = tmp;
#line 439
      if ((unsigned int )e != 0U) {
#line 441
        *options = 0;
#line 442
        return (e);
      }
#line 444
      while (1) {
#line 444
        if (48 <= (int )*spec) {
#line 444
          if ((int const   )*spec <= 57) {
#line 444
            break;
          }
        }
#line 445
        if ((unsigned long )spec == (unsigned long )ptr) {
#line 447
          opts |= 128;
#line 448
          if ((int )*(ptr + -1) == 66) {
#line 449
            opts |= 256;
          }
#line 450
          if ((int )*(ptr + -1) != 66) {
#line 451
            opts |= 32;
          } else
#line 450
          if ((int )*(ptr + -2) == 105) {
#line 451
            opts |= 32;
          }
#line 452
          break;
        }
#line 444
        spec ++;
      }
    }
  }
#line 457
  *options = opts;
#line 458
  return ((strtol_error )0);
}
}
#line 461 "/home/wslee/project/coreutils-8.1/lib/human.c"
enum strtol_error human_options(char const   *spec , int *opts , uintmax_t *block_size ) 
{ 
  strtol_error e ;
  strtol_error tmp ;

  {
#line 464
  tmp = humblock(spec, block_size, opts);
#line 464
  e = tmp;
#line 465
  if (*block_size == 0UL) {
#line 467
    *block_size = default_block_size();
#line 468
    e = (strtol_error )4;
  }
#line 470
  return (e);
}
}
#line 1 "cil-m8j0QwiN.o"
#pragma merger("0","../lib/i-ring.o.i","")
#line 24 "/home/wslee/project/coreutils-8.1/lib/i-ring.c"
void i_ring_init(I_ring *ir , int default_val ) 
{ 
  int i ;

  {
#line 28
  ir->ir_empty = (_Bool)1;
#line 29
  ir->ir_front = 0U;
#line 30
  ir->ir_back = 0U;
#line 31
  i = 0;
#line 31
  while (i < 4) {
#line 32
    ir->ir_data[i] = default_val;
#line 31
    i ++;
  }
#line 33
  ir->ir_default_val = default_val;
#line 34
  return;
}
}
#line 36 "/home/wslee/project/coreutils-8.1/lib/i-ring.c"
_Bool i_ring_empty(I_ring const   *ir ) 
{ 


  {
#line 39
  return ((_Bool )ir->ir_empty);
}
}
#line 42 "/home/wslee/project/coreutils-8.1/lib/i-ring.c"
int i_ring_push(I_ring *ir , int val ) 
{ 
  unsigned int dest_idx ;
  int old_val ;

  {
#line 45
  dest_idx = (ir->ir_front + (unsigned int )(! ir->ir_empty)) % 4U;
#line 46
  old_val = ir->ir_data[dest_idx];
#line 47
  ir->ir_data[dest_idx] = val;
#line 48
  ir->ir_front = dest_idx;
#line 49
  if (dest_idx == ir->ir_back) {
#line 50
    ir->ir_back = (ir->ir_back + (unsigned int )(! ir->ir_empty)) % 4U;
  }
#line 51
  ir->ir_empty = (_Bool)0;
#line 52
  return (old_val);
}
}
#line 55 "/home/wslee/project/coreutils-8.1/lib/i-ring.c"
int i_ring_pop(I_ring *ir ) 
{ 
  int top_val ;
  _Bool tmp ;

  {
#line 59
  tmp = i_ring_empty((I_ring const   *)ir);
#line 59
  if (tmp) {
#line 60
    abort();
  }
#line 61
  top_val = ir->ir_data[ir->ir_front];
#line 62
  ir->ir_data[ir->ir_front] = ir->ir_default_val;
#line 63
  if (ir->ir_front == ir->ir_back) {
#line 64
    ir->ir_empty = (_Bool)1;
  } else {
#line 66
    ir->ir_front = ((ir->ir_front + 4U) - 1U) % 4U;
  }
#line 67
  return (top_val);
}
}
#line 1 "cil-5ePjTLXj.o"
#pragma merger("0","../lib/idcache.o.i","")
#line 6 "/home/wslee/project/coreutils-8.1/lib/idcache.h"
char *getuser(uid_t uid ) ;
#line 7
char *getgroup(gid_t gid ) ;
#line 8
uid_t *getuidbyname(char const   *user ) ;
#line 9
gid_t *getgidbyname(char const   *group ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *( __attribute__((__nonnull__(1))) getpwnam)(char const   *__name ) ;
#line 102 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 108
extern struct group *getgrnam(char const   *__name ) ;
#line 54 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
static struct userid *user_alist  ;
#line 57 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
static struct userid *nouser_alist  ;
#line 60 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
static struct userid *group_alist  ;
#line 63 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
static struct userid *nogroup_alist  ;
#line 67 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
char *getuser(uid_t uid ) 
{ 
  struct userid *tail ;
  struct userid *match ;
  struct passwd *pwent ;
  struct passwd *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 71
  match = (struct userid *)((void *)0);
#line 73
  tail = user_alist;
#line 73
  while (tail) {
#line 75
    if (tail->id.u == uid) {
#line 77
      match = tail;
#line 78
      break;
    }
#line 73
    tail = tail->next;
  }
#line 82
  if ((unsigned long )match == (unsigned long )((void *)0)) {
#line 84
    tmp = getpwuid(uid);
#line 84
    pwent = tmp;
#line 85
    if (pwent) {
#line 85
      tmp___0 = (char const   *)pwent->pw_name;
    } else {
#line 85
      tmp___0 = "";
    }
#line 85
    name = tmp___0;
#line 86
    tmp___1 = strlen(name);
#line 86
    tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 86
    match = (struct userid *)tmp___2;
#line 87
    match->id.u = uid;
#line 88
    strcpy((char * __restrict  )(match->name), (char const   * __restrict  )name);
#line 91
    match->next = user_alist;
#line 92
    user_alist = match;
  }
#line 95
  if (match->name[0]) {
#line 95
    tmp___3 = match->name;
  } else {
#line 95
    tmp___3 = (char *)((void *)0);
  }
#line 95
  return (tmp___3);
}
}
#line 103 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
uid_t *getuidbyname(char const   *user ) 
{ 
  struct userid *tail ;
  struct passwd *pwent ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 109
  tail = user_alist;
#line 109
  while (tail) {
#line 111
    if ((int )tail->name[0] == (int )*user) {
#line 111
      tmp = strcmp((char const   *)(tail->name), user);
#line 111
      if (! tmp) {
#line 112
        return (& tail->id.u);
      }
    }
#line 109
    tail = tail->next;
  }
#line 114
  tail = nouser_alist;
#line 114
  while (tail) {
#line 116
    if ((int )tail->name[0] == (int )*user) {
#line 116
      tmp___0 = strcmp((char const   *)(tail->name), user);
#line 116
      if (! tmp___0) {
#line 117
        return ((uid_t *)((void *)0));
      }
    }
#line 114
    tail = tail->next;
  }
#line 119
  pwent = getpwnam(user);
#line 130
  tmp___1 = strlen(user);
#line 130
  tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 130
  tail = (struct userid *)tmp___2;
#line 131
  strcpy((char * __restrict  )(tail->name), (char const   * __restrict  )user);
#line 134
  if (pwent) {
#line 136
    tail->id.u = pwent->pw_uid;
#line 137
    tail->next = user_alist;
#line 138
    user_alist = tail;
#line 139
    return (& tail->id.u);
  }
#line 142
  tail->next = nouser_alist;
#line 143
  nouser_alist = tail;
#line 144
  return ((uid_t *)((void *)0));
}
}
#line 149 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
char *getgroup(gid_t gid ) 
{ 
  struct userid *tail ;
  struct userid *match ;
  struct group *grent ;
  struct group *tmp ;
  char const   *name ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 153
  match = (struct userid *)((void *)0);
#line 155
  tail = group_alist;
#line 155
  while (tail) {
#line 157
    if (tail->id.g == gid) {
#line 159
      match = tail;
#line 160
      break;
    }
#line 155
    tail = tail->next;
  }
#line 164
  if ((unsigned long )match == (unsigned long )((void *)0)) {
#line 166
    tmp = getgrgid(gid);
#line 166
    grent = tmp;
#line 167
    if (grent) {
#line 167
      tmp___0 = (char const   *)grent->gr_name;
    } else {
#line 167
      tmp___0 = "";
    }
#line 167
    name = tmp___0;
#line 168
    tmp___1 = strlen(name);
#line 168
    tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 168
    match = (struct userid *)tmp___2;
#line 169
    match->id.g = gid;
#line 170
    strcpy((char * __restrict  )(match->name), (char const   * __restrict  )name);
#line 173
    match->next = group_alist;
#line 174
    group_alist = match;
  }
#line 177
  if (match->name[0]) {
#line 177
    tmp___3 = match->name;
  } else {
#line 177
    tmp___3 = (char *)((void *)0);
  }
#line 177
  return (tmp___3);
}
}
#line 185 "/home/wslee/project/coreutils-8.1/lib/idcache.c"
gid_t *getgidbyname(char const   *group ) 
{ 
  struct userid *tail ;
  struct group *grent ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 191
  tail = group_alist;
#line 191
  while (tail) {
#line 193
    if ((int )tail->name[0] == (int )*group) {
#line 193
      tmp = strcmp((char const   *)(tail->name), group);
#line 193
      if (! tmp) {
#line 194
        return (& tail->id.g);
      }
    }
#line 191
    tail = tail->next;
  }
#line 196
  tail = nogroup_alist;
#line 196
  while (tail) {
#line 198
    if ((int )tail->name[0] == (int )*group) {
#line 198
      tmp___0 = strcmp((char const   *)(tail->name), group);
#line 198
      if (! tmp___0) {
#line 199
        return ((gid_t *)((void *)0));
      }
    }
#line 196
    tail = tail->next;
  }
#line 201
  grent = getgrnam(group);
#line 212
  tmp___1 = strlen(group);
#line 212
  tmp___2 = xmalloc(((unsigned long )(& ((struct userid *)0)->name) + tmp___1) + 1UL);
#line 212
  tail = (struct userid *)tmp___2;
#line 213
  strcpy((char * __restrict  )(tail->name), (char const   * __restrict  )group);
#line 216
  if (grent) {
#line 218
    tail->id.g = grent->gr_gid;
#line 219
    tail->next = group_alist;
#line 220
    group_alist = tail;
#line 221
    return (& tail->id.g);
  }
#line 224
  tail->next = nogroup_alist;
#line 225
  nogroup_alist = tail;
#line 226
  return ((gid_t *)((void *)0));
}
}
#line 1 "cil-1jb9lqFP.o"
#pragma merger("0","../lib/imaxtostr.o.i","")
#line 29 "/home/wslee/project/coreutils-8.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) imaxtostr)(intmax_t i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 32
  p = buf___0 + ((((sizeof(intmax_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 33
  *p = (char)0;
#line 37
  if (i < 0L) {
#line 39
    while (1) {
#line 40
      p --;
#line 40
      *p = (char )(48L - i % 10L);
#line 39
      i /= 10L;
#line 39
      if (! (i != 0L)) {
#line 39
        break;
      }
    }
#line 43
    p --;
#line 43
    *p = (char )'-';
  } else {
#line 48
    while (1) {
#line 49
      p --;
#line 49
      *p = (char )(48L + i % 10L);
#line 48
      i /= 10L;
#line 48
      if (! (i != 0L)) {
#line 48
        break;
      }
    }
  }
#line 53
  return (p);
}
}
#line 1 "cil-SuMr_0R7.o"
#pragma merger("0","../lib/isapipe.o.i","")
#line 6 "/home/wslee/project/coreutils-8.1/lib/isapipe.h"
int isapipe(int fd ) ;
#line 68 "/home/wslee/project/coreutils-8.1/lib/isapipe.c"
int isapipe(int fd ) 
{ 
  nlink_t pipe_link_count_max ;
  _Bool check_for_fifo ;
  struct stat st ;
  int fstat_result ;
  int tmp ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 71
  pipe_link_count_max = (nlink_t )1;
#line 72
  check_for_fifo = (_Bool)1;
#line 74
  tmp = fstat(fd, & st);
#line 74
  fstat_result = tmp;
#line 76
  if (fstat_result != 0) {
#line 77
    return (fstat_result);
  }
#line 114
  if (st.st_nlink <= pipe_link_count_max) {
#line 114
    if (check_for_fifo) {
#line 114
      tmp___4 = (st.st_mode & 61440U) == 4096U;
    } else {
#line 114
      tmp___4 = (st.st_mode & 61440U) == 49152U;
    }
#line 114
    if (tmp___4) {
#line 114
      tmp___5 = 1;
    } else {
#line 114
      tmp___5 = 0;
    }
  } else {
#line 114
    tmp___5 = 0;
  }
#line 114
  return (tmp___5);
}
}
#line 1 "cil-AkDLEUno.o"
#pragma merger("0","../lib/isnanl.o.i","")
#line 24 "/home/wslee/project/coreutils-8.1/lib/isnan.c"
int rpl_isnanl(long double x ) ;
#line 82 "/home/wslee/project/coreutils-8.1/lib/isnan.c"
int rpl_isnanl(long double x ) 
{ 
  memory_double m1 ;
  memory_double m2 ;
  long double tmp ;
  int tmp___0 ;

  {
#line 154
  if (x == x) {
#line 161
    memset((void *)(& m1.value), 0, (size_t )10);
#line 162
    memset((void *)(& m2.value), 0, (size_t )10);
#line 163
    m1.value = x;
#line 164
    if (x) {
#line 164
      tmp = 0.0L;
    } else {
#line 164
      tmp = - 0.0L;
    }
#line 164
    m2.value = x + tmp;
#line 165
    tmp___0 = memcmp((void const   *)(& m1.value), (void const   *)(& m2.value), (size_t )10);
#line 165
    if (tmp___0 != 0) {
#line 166
      return (1);
    }
#line 168
    return (0);
  } else {
#line 171
    return (1);
  }
}
}
#line 1 "cil-uqfblWPM.o"
#pragma merger("0","../lib/linebuffer.o.i","")
#line 836 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof_unlocked)(FILE *__stream ) ;
#line 34 "/home/wslee/project/coreutils-8.1/lib/linebuffer.h"
void initbuffer(struct linebuffer *linebuffer ) ;
#line 41
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) ;
#line 48
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) ;
#line 51
void freebuffer(struct linebuffer *linebuffer ) ;
#line 36 "/home/wslee/project/coreutils-8.1/lib/linebuffer.c"
void initbuffer(struct linebuffer *linebuffer ) 
{ 


  {
#line 39
  memset((void *)linebuffer, 0, sizeof(*linebuffer));
#line 40
  return;
}
}
#line 42 "/home/wslee/project/coreutils-8.1/lib/linebuffer.c"
struct linebuffer *readlinebuffer(struct linebuffer *linebuffer , FILE *stream ) 
{ 
  struct linebuffer *tmp ;

  {
#line 45
  tmp = readlinebuffer_delim(linebuffer, stream, (char )'\n');
#line 45
  return (tmp);
}
}
#line 58 "/home/wslee/project/coreutils-8.1/lib/linebuffer.c"
struct linebuffer *readlinebuffer_delim(struct linebuffer *linebuffer , FILE *stream ,
                                        char delimiter ) 
{ 
  int c ;
  char *buffer ;
  char *p ;
  char *end ;
  int tmp ;
  int tmp___0 ;
  size_t oldsize ;
  void *tmp___1 ;
  char *tmp___2 ;

  {
#line 63
  buffer = linebuffer->buffer;
#line 64
  p = linebuffer->buffer;
#line 65
  end = buffer + linebuffer->size;
#line 67
  tmp = feof_unlocked(stream);
#line 67
  if (tmp) {
#line 68
    return ((struct linebuffer *)((void *)0));
  }
#line 70
  while (1) {
#line 72
    c = getc_unlocked(stream);
#line 73
    if (c == -1) {
#line 75
      if ((unsigned long )p == (unsigned long )buffer) {
#line 76
        return ((struct linebuffer *)((void *)0));
      } else {
#line 75
        tmp___0 = ferror_unlocked(stream);
#line 75
        if (tmp___0) {
#line 76
          return ((struct linebuffer *)((void *)0));
        }
      }
#line 77
      if ((int )*(p + -1) == (int )delimiter) {
#line 78
        break;
      }
#line 79
      c = (int )delimiter;
    }
#line 81
    if ((unsigned long )p == (unsigned long )end) {
#line 83
      oldsize = linebuffer->size;
#line 84
      tmp___1 = x2realloc((void *)buffer, & linebuffer->size);
#line 84
      buffer = (char *)tmp___1;
#line 85
      p = buffer + oldsize;
#line 86
      linebuffer->buffer = buffer;
#line 87
      end = buffer + linebuffer->size;
    }
#line 89
    tmp___2 = p;
#line 89
    p ++;
#line 89
    *tmp___2 = (char )c;
#line 70
    if (! (c != (int )delimiter)) {
#line 70
      break;
    }
  }
#line 93
  linebuffer->length = (size_t )(p - buffer);
#line 94
  return (linebuffer);
}
}
#line 99 "/home/wslee/project/coreutils-8.1/lib/linebuffer.c"
void freebuffer(struct linebuffer *linebuffer ) 
{ 


  {
#line 102
  free((void *)linebuffer->buffer);
#line 103
  return;
}
}
#line 1 "cil-Po0uPiNl.o"
#pragma merger("0","../lib/linkat.o.i","")
#line 799 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,4), __leaf__)) linkat)(int __fromfd ,
                                                                                               char const   *__from ,
                                                                                               int __tofd ,
                                                                                               char const   *__to ,
                                                                                               int __flags ) ;
#line 644 "./unistd.h"
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag ) ;
#line 195 "/home/wslee/project/coreutils-8.1/lib/linkat.c"
static int linkat_follow(int fd1 , char const   *file1 , int fd2 , char const   *file2 ) 
{ 
  char *name ;
  char *target ;
  int result ;
  int i ;
  char *dir ;
  char *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int saved_errno ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int saved_errno___0 ;
  int *tmp___7 ;
  int *tmp___8 ;

  {
#line 198
  name = (char *)file1;
#line 201
  i = 20;
#line 204
  while (1) {
#line 204
    tmp___2 = i;
#line 204
    i --;
#line 204
    if (tmp___2) {
#line 204
      target = areadlinkat(fd1, (char const   *)name);
#line 204
      if (! target) {
#line 204
        break;
      }
    } else {
#line 204
      break;
    }
#line 206
    if ((int )*(target + 0) == 47) {
#line 206
      goto _L;
    } else
#line 206
    if (0) {
      _L: /* CIL Label */ 
#line 208
      if ((unsigned long )name != (unsigned long )file1) {
#line 209
        free((void *)name);
      }
#line 210
      name = target;
    } else {
#line 214
      tmp = mdir_name((char const   *)name);
#line 214
      dir = tmp;
#line 215
      if ((unsigned long )name != (unsigned long )file1) {
#line 216
        free((void *)name);
      }
#line 217
      if (! dir) {
#line 219
        free((void *)target);
#line 220
        tmp___0 = __errno_location();
#line 220
        *tmp___0 = 12;
#line 221
        return (-1);
      }
#line 223
      name = mfile_name_concat((char const   *)dir, (char const   *)target, (char **)((void *)0));
#line 224
      free((void *)dir);
#line 225
      free((void *)target);
#line 226
      if (! name) {
#line 228
        tmp___1 = __errno_location();
#line 228
        *tmp___1 = 12;
#line 229
        return (-1);
      }
    }
  }
#line 233
  if (i < 0) {
#line 235
    target = (char *)((void *)0);
#line 236
    tmp___3 = __errno_location();
#line 236
    *tmp___3 = 40;
  }
#line 238
  if (! target) {
#line 238
    tmp___6 = __errno_location();
#line 238
    if (*tmp___6 != 22) {
#line 240
      if ((unsigned long )name != (unsigned long )file1) {
#line 242
        tmp___4 = __errno_location();
#line 242
        saved_errno = *tmp___4;
#line 243
        free((void *)name);
#line 244
        tmp___5 = __errno_location();
#line 244
        *tmp___5 = saved_errno;
      }
#line 246
      return (-1);
    }
  }
#line 248
  result = linkat(fd1, (char const   *)name, fd2, file2, 0);
#line 249
  if ((unsigned long )name != (unsigned long )file1) {
#line 251
    tmp___7 = __errno_location();
#line 251
    saved_errno___0 = *tmp___7;
#line 252
    free((void *)name);
#line 253
    tmp___8 = __errno_location();
#line 253
    *tmp___8 = saved_errno___0;
  }
#line 255
  return (result);
}
}
#line 275 "/home/wslee/project/coreutils-8.1/lib/linkat.c"
static int have_follow_really  ;
#line 262 "/home/wslee/project/coreutils-8.1/lib/linkat.c"
int rpl_linkat(int fd1 , char const   *file1 , int fd2 , char const   *file2 , int flag ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int result ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
#line 265
  if (! flag) {
#line 266
    tmp = linkat(fd1, file1, fd2, file2, flag);
#line 266
    return (tmp);
  }
#line 267
  if (flag & -1025) {
#line 269
    tmp___0 = __errno_location();
#line 269
    *tmp___0 = 22;
#line 270
    return (-1);
  }
#line 276
  if (0 <= have_follow_really) {
#line 278
    tmp___1 = linkat(fd1, file1, fd2, file2, flag);
#line 278
    result = tmp___1;
#line 279
    if (result == -1) {
#line 279
      tmp___2 = __errno_location();
#line 279
      if (! (*tmp___2 == 22)) {
#line 281
        have_follow_really = 1;
#line 282
        return (result);
      }
    } else {
#line 281
      have_follow_really = 1;
#line 282
      return (result);
    }
#line 284
    have_follow_really = -1;
  }
#line 287
  tmp___3 = linkat_follow(fd1, file1, fd2, file2);
#line 287
  return (tmp___3);
}
}
#line 1 "cil-ZWIlKJ4Y.o"
#pragma merger("0","../lib/localcharset.o.i","")
#line 33 "/home/wslee/project/coreutils-8.1/lib/localcharset.h"
char const   *locale_charset(void) ;
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 583 "/usr/include/langinfo.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) nl_langinfo)(nl_item __item ) ;
#line 115 "/home/wslee/project/coreutils-8.1/lib/localcharset.c"
static char const   * volatile  charset_aliases  ;
#line 118 "/home/wslee/project/coreutils-8.1/lib/localcharset.c"
static char const   *get_charset_aliases(void) 
{ 
  char const   *cp ;
  char const   *dir ;
  char const   *base ;
  char *file_name___1 ;
  char *tmp ;
  size_t dir_len___0 ;
  size_t tmp___0 ;
  size_t base_len___0 ;
  size_t tmp___1 ;
  int add_slash ;
  int tmp___2 ;
  void *tmp___3 ;
  int fd ;
  FILE *fp ;
  char *res_ptr ;
  size_t res_size ;
  int c ;
  char buf1[51] ;
  char buf2[51] ;
  size_t l1 ;
  size_t l2 ;
  char *old_res_ptr ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 123
  cp = (char const   *)charset_aliases;
#line 124
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 128
    base = "charset.alias";
#line 133
    tmp = getenv("CHARSETALIASDIR");
#line 133
    dir = (char const   *)tmp;
#line 134
    if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 135
      dir = "/usr/local/lib";
    } else
#line 134
    if ((int const   )*(dir + 0) == 0) {
#line 135
      dir = "/usr/local/lib";
    }
#line 139
    tmp___0 = strlen(dir);
#line 139
    dir_len___0 = tmp___0;
#line 140
    tmp___1 = strlen(base);
#line 140
    base_len___0 = tmp___1;
#line 141
    if (dir_len___0 > 0UL) {
#line 141
      if (! ((int const   )*(dir + (dir_len___0 - 1UL)) == 47)) {
#line 141
        tmp___2 = 1;
      } else {
#line 141
        tmp___2 = 0;
      }
    } else {
#line 141
      tmp___2 = 0;
    }
#line 141
    add_slash = tmp___2;
#line 142
    tmp___3 = malloc(((dir_len___0 + (size_t )add_slash) + base_len___0) + 1UL);
#line 142
    file_name___1 = (char *)tmp___3;
#line 143
    if ((unsigned long )file_name___1 != (unsigned long )((void *)0)) {
#line 145
      memcpy((void * __restrict  )file_name___1, (void const   * __restrict  )dir,
             dir_len___0);
#line 146
      if (add_slash) {
#line 147
        *(file_name___1 + dir_len___0) = (char )'/';
      }
#line 148
      memcpy((void * __restrict  )((file_name___1 + dir_len___0) + add_slash), (void const   * __restrict  )base,
             base_len___0 + 1UL);
    }
#line 152
    if ((unsigned long )file_name___1 == (unsigned long )((void *)0)) {
#line 154
      cp = "";
    } else {
#line 166
      fd = open((char const   *)file_name___1, 131072);
#line 168
      if (fd < 0) {
#line 170
        cp = "";
      } else {
#line 175
        fp = fdopen(fd, "r");
#line 176
        if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 179
          close(fd);
#line 180
          cp = "";
        } else {
#line 185
          res_ptr = (char *)((void *)0);
#line 186
          res_size = (size_t )0;
#line 188
          while (1) {
#line 196
            c = getc_unlocked(fp);
#line 197
            if (c == -1) {
#line 198
              break;
            }
#line 199
            if (c == 10) {
#line 200
              goto __Cont;
            } else
#line 199
            if (c == 32) {
#line 200
              goto __Cont;
            } else
#line 199
            if (c == 9) {
#line 200
              goto __Cont;
            }
#line 201
            if (c == 35) {
#line 204
              while (1) {
#line 205
                c = getc_unlocked(fp);
#line 204
                if (c == -1) {
#line 204
                  break;
                } else
#line 204
                if (c == 10) {
#line 204
                  break;
                }
              }
#line 207
              if (c == -1) {
#line 208
                break;
              }
#line 209
              goto __Cont;
            }
#line 211
            ungetc(c, fp);
#line 212
            tmp___4 = fscanf((FILE * __restrict  )fp, (char const   * __restrict  )"%50s %50s",
                             buf1, buf2);
#line 212
            if (tmp___4 < 2) {
#line 213
              break;
            }
#line 214
            l1 = strlen((char const   *)(buf1));
#line 215
            l2 = strlen((char const   *)(buf2));
#line 216
            old_res_ptr = res_ptr;
#line 217
            if (res_size == 0UL) {
#line 219
              res_size = ((l1 + 1UL) + l2) + 1UL;
#line 220
              tmp___5 = malloc(res_size + 1UL);
#line 220
              res_ptr = (char *)tmp___5;
            } else {
#line 224
              res_size += ((l1 + 1UL) + l2) + 1UL;
#line 225
              tmp___6 = realloc((void *)res_ptr, res_size + 1UL);
#line 225
              res_ptr = (char *)tmp___6;
            }
#line 227
            if ((unsigned long )res_ptr == (unsigned long )((void *)0)) {
#line 230
              res_size = (size_t )0;
#line 231
              if ((unsigned long )old_res_ptr != (unsigned long )((void *)0)) {
#line 232
                free((void *)old_res_ptr);
              }
#line 233
              break;
            }
#line 235
            strcpy((char * __restrict  )(((res_ptr + res_size) - (l2 + 1UL)) - (l1 + 1UL)),
                   (char const   * __restrict  )(buf1));
#line 236
            strcpy((char * __restrict  )((res_ptr + res_size) - (l2 + 1UL)), (char const   * __restrict  )(buf2));
            __Cont: /* CIL Label */ ;
          }
#line 238
          fclose(fp);
#line 239
          if (res_size == 0UL) {
#line 240
            cp = "";
          } else {
#line 243
            *(res_ptr + res_size) = (char )'\000';
#line 244
            cp = (char const   *)res_ptr;
          }
        }
      }
#line 249
      free((void *)file_name___1);
    }
#line 343
    charset_aliases = (char const   * volatile  )cp;
  }
#line 346
  return (cp);
}
}
#line 358 "/home/wslee/project/coreutils-8.1/lib/localcharset.c"
char const   *locale_charset(void) 
{ 
  char const   *codeset ;
  char const   *aliases ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 369
  tmp = nl_langinfo(14);
#line 369
  codeset = (char const   *)tmp;
#line 511
  if ((unsigned long )codeset == (unsigned long )((void *)0)) {
#line 513
    codeset = "";
  }
#line 516
  aliases = get_charset_aliases();
#line 516
  while ((int const   )*aliases != 0) {
#line 519
    tmp___3 = strcmp(codeset, aliases);
#line 519
    if (tmp___3 == 0) {
#line 522
      tmp___2 = strlen(aliases);
#line 522
      codeset = (aliases + tmp___2) + 1;
#line 523
      break;
    } else
#line 519
    if ((int const   )*(aliases + 0) == 42) {
#line 519
      if ((int const   )*(aliases + 1) == 0) {
#line 522
        tmp___2 = strlen(aliases);
#line 522
        codeset = (aliases + tmp___2) + 1;
#line 523
        break;
      }
    }
#line 516
    tmp___0 = strlen(aliases);
#line 516
    aliases += tmp___0 + 1UL;
#line 516
    tmp___1 = strlen(aliases);
#line 516
    aliases += tmp___1 + 1UL;
  }
#line 529
  if ((int const   )*(codeset + 0) == 0) {
#line 530
    codeset = "ASCII";
  }
#line 532
  return (codeset);
}
}
#line 1 "cil-UWKXCK2x.o"
#pragma merger("0","../lib/long-options.o.i","")
#line 19 "/home/wslee/project/coreutils-8.1/lib/long-options.h"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) ;
#line 76 "/usr/include/getopt.h"
extern int opterr ;
#line 63 "/home/wslee/project/coreutils-8.1/lib/version-etc.h"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/long-options.c"
static struct option  const  long_options___0[3]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"version", 0, (int *)((void *)0), 'v'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 43 "/home/wslee/project/coreutils-8.1/lib/long-options.c"
void parse_long_options(int argc , char **argv , char const   *command_name , char const   *package ,
                        char const   *version , void (*usage_func)(int  )  , ...) 
{ 
  int c ;
  int saved_opterr ;
  va_list authors ;

  {
#line 55
  saved_opterr = opterr;
#line 58
  opterr = 0;
#line 60
  if (argc == 2) {
#line 60
    c = getopt_long(argc, (char * const  *)argv, "+", long_options___0, (int *)((void *)0));
#line 60
    if (c != -1) {
#line 63
      switch (c) {
      case 104: 
#line 66
      (*usage_func)(0);
      case 118: 
#line 71
      __builtin_va_start(authors, usage_func);
#line 72
      version_etc_va(stdout, command_name, package, version, authors);
#line 73
      exit(0);
      default: 
#line 78
      break;
      }
    }
  }
#line 83
  opterr = saved_opterr;
#line 87
  optind = 0;
#line 88
  return;
}
}
#line 1 "cil-TtHS5AwE.o"
#pragma merger("0","../lib/malloca.o.i","")
#line 64 "/home/wslee/project/coreutils-8.1/lib/malloca.h"
void *mmalloca(size_t n ) ;
#line 68
void freea(void *p ) ;
#line 60 "/home/wslee/project/coreutils-8.1/lib/malloca.c"
static void *mmalloca_results[257]  ;
#line 64 "/home/wslee/project/coreutils-8.1/lib/malloca.c"
void *mmalloca(size_t n ) 
{ 
  size_t nplus ;
  char *p ;
  void *tmp ;
  size_t slot ;

  {
#line 70
  nplus = n + (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 72
  if (nplus >= n) {
#line 74
    tmp = malloc(nplus);
#line 74
    p = (char *)tmp;
#line 76
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 80
      p += (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 83
      *((int *)p + -1) = 336984906;
#line 86
      slot = (unsigned long )p % 257UL;
#line 87
      ((struct header *)(p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next = mmalloca_results[slot];
#line 88
      mmalloca_results[slot] = (void *)p;
#line 90
      return ((void *)p);
    }
  }
#line 94
  return ((void *)0);
}
}
#line 105 "/home/wslee/project/coreutils-8.1/lib/malloca.c"
void freea(void *p ) 
{ 
  size_t slot ;
  void **chain ;
  char *p_begin ;

  {
#line 109
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 115
    if (*((int *)p + -1) == 336984906) {
#line 119
      slot = (unsigned long )p % 257UL;
#line 120
      chain = & mmalloca_results[slot];
#line 121
      while ((unsigned long )*chain != (unsigned long )((void *)0)) {
#line 123
        if ((unsigned long )*chain == (unsigned long )p) {
#line 126
          p_begin = (char *)p - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL;
#line 127
          *chain = ((struct header *)p_begin)->next;
#line 128
          free((void *)p_begin);
#line 129
          return;
        }
#line 131
        chain = & ((struct header *)((char *)*chain - (((sizeof(struct preliminary_header ) + 16UL) - 1UL) / 16UL) * 16UL))->next;
      }
    }
  }
#line 136
  return;
}
}
#line 1 "cil-aUztVtHW.o"
#pragma merger("0","../lib/mbchar.o.i","")
#line 26 "/home/wslee/project/coreutils-8.1/lib/mbchar.c"
unsigned int const   is_basic_table[8]  = {      (unsigned int const   )6656,      (unsigned int const   )4294967279U,      (unsigned int const   )4294967294U,      (unsigned int const   )2147483646};
#line 1 "cil-kdwCkTRq.o"
#pragma merger("0","../lib/mbsalign.o.i","")
#line 21 "/home/wslee/project/coreutils-8.1/lib/mbsalign.h"
size_t mbsalign(char const   *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags  __attribute__((__unused__)) ) ;
#line 873 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t * __restrict  __pwcs ,
                                                                                  char const   * __restrict  __s ,
                                                                                  size_t __n ) ;
#line 876
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcstombs)(char * __restrict  __s ,
                                                                                  wchar_t const   * __restrict  __pwcs ,
                                                                                  size_t __n ) ;
#line 442 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcwidth)(wchar_t __c ) ;
#line 136 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswprint)(wint_t __wc ) ;
#line 37 "/home/wslee/project/coreutils-8.1/lib/mbsalign.c"
static _Bool wc_ensure_printable(wchar_t *wchars ) 
{ 
  _Bool replaced ;
  wchar_t *wc ;
  int tmp ;

  {
#line 40
  replaced = (_Bool)0;
#line 41
  wc = wchars;
#line 42
  while (*wc) {
#line 44
    tmp = iswprint((wint_t )*wc);
#line 44
    if (! tmp) {
#line 46
      *wc = 65533;
#line 47
      replaced = (_Bool)1;
    }
#line 49
    wc ++;
  }
#line 51
  return (replaced);
}
}
#line 57 "/home/wslee/project/coreutils-8.1/lib/mbsalign.c"
static size_t wc_truncate(wchar_t *wc , size_t width ) 
{ 
  size_t cells ;
  int next_cells ;

  {
#line 60
  cells = (size_t )0;
#line 61
  next_cells = 0;
#line 63
  while (*wc) {
#line 65
    next_cells = wcwidth(*wc);
#line 66
    if (next_cells == -1) {
#line 68
      *wc = 65533;
#line 69
      next_cells = 1;
    }
#line 71
    if (cells + (size_t )next_cells > width) {
#line 72
      break;
    }
#line 73
    cells += (size_t )next_cells;
#line 74
    wc ++;
  }
#line 76
  *wc = 0;
#line 77
  return (cells);
}
}
#line 83 "/home/wslee/project/coreutils-8.1/lib/mbsalign.c"
static int rpl_wcswidth(wchar_t const   *s , size_t n ) 
{ 
  int ret ;
  int nwidth ;
  wchar_t const   *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;

  {
#line 86
  ret = 0;
#line 88
  while (1) {
#line 88
    tmp___1 = n;
#line 88
    n --;
#line 88
    if (tmp___1 > 0UL) {
#line 88
      if (! (*s != 0)) {
#line 88
        break;
      }
    } else {
#line 88
      break;
    }
#line 90
    tmp = s;
#line 90
    s ++;
#line 90
    tmp___0 = wcwidth((wchar_t )*tmp);
#line 90
    nwidth = tmp___0;
#line 91
    if (nwidth == -1) {
#line 92
      return (-1);
    }
#line 93
    if (ret > 2147483647 - nwidth) {
#line 94
      return (-1);
    }
#line 95
    ret += nwidth;
  }
#line 98
  return (ret);
}
}
#line 106 "/home/wslee/project/coreutils-8.1/lib/mbsalign.c"
static char *mbs_align_pad(char *dest , char const   *dest_end , size_t n_spaces ) 
{ 
  char *tmp ;
  size_t tmp___0 ;

  {
#line 111
  while (1) {
#line 111
    tmp___0 = n_spaces;
#line 111
    n_spaces --;
#line 111
    if (tmp___0) {
#line 111
      if (! ((unsigned long )dest < (unsigned long )dest_end)) {
#line 111
        break;
      }
    } else {
#line 111
      break;
    }
#line 112
    tmp = dest;
#line 112
    dest ++;
#line 112
    *tmp = (char )' ';
  }
#line 113
  *dest = (char )'\000';
#line 114
  return (dest);
}
}
#line 130 "/home/wslee/project/coreutils-8.1/lib/mbsalign.c"
size_t mbsalign(char const   *src , char *dest , size_t dest_size , size_t *width ,
                mbs_align_t align , int flags  __attribute__((__unused__)) ) 
{ 
  size_t ret ;
  size_t src_size ;
  size_t tmp ;
  char *newstr ;
  wchar_t *str_wc ;
  char const   *str_to_print ;
  size_t n_cols ;
  size_t n_used_bytes ;
  size_t n_spaces ;
  _Bool conversion ;
  _Bool wc_enabled ;
  size_t src_chars ;
  size_t tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *dest_end ;
  size_t start_spaces ;
  size_t end_spaces ;
  size_t tmp___6 ;
  void *tmp___7 ;

  {
#line 134
  ret = (size_t )-1;
#line 135
  tmp = strlen(src);
#line 135
  src_size = tmp + 1UL;
#line 136
  newstr = (char *)((void *)0);
#line 137
  str_wc = (wchar_t *)((void *)0);
#line 138
  str_to_print = src;
#line 139
  n_cols = src_size - 1UL;
#line 140
  n_used_bytes = n_cols;
#line 141
  n_spaces = (size_t )0;
#line 142
  conversion = (_Bool)0;
#line 143
  wc_enabled = (_Bool)0;
#line 148
  tmp___4 = __ctype_get_mb_cur_max();
#line 148
  if (tmp___4 > 1UL) {
#line 150
    tmp___0 = mbstowcs((wchar_t * __restrict  )((void *)0), (char const   * __restrict  )src,
                       (size_t )0);
#line 150
    src_chars = tmp___0;
#line 151
    if (src_chars == 0xffffffffffffffffUL) {
#line 152
      goto mbsalign_cleanup;
    }
#line 153
    src_chars ++;
#line 154
    tmp___1 = malloc(src_chars * sizeof(wchar_t ));
#line 154
    str_wc = (wchar_t *)tmp___1;
#line 155
    if ((unsigned long )str_wc == (unsigned long )((void *)0)) {
#line 156
      goto mbsalign_cleanup;
    }
#line 157
    tmp___3 = mbstowcs((wchar_t * __restrict  )str_wc, (char const   * __restrict  )src,
                       src_chars);
#line 157
    if (tmp___3 > 0UL) {
#line 159
      *(str_wc + (src_chars - 1UL)) = 0;
#line 160
      wc_enabled = (_Bool)1;
#line 161
      conversion = wc_ensure_printable(str_wc);
#line 162
      tmp___2 = rpl_wcswidth((wchar_t const   *)str_wc, src_chars);
#line 162
      n_cols = (size_t )tmp___2;
    }
  }
#line 168
  if (conversion) {
#line 168
    goto _L;
  } else
#line 168
  if (n_cols > *width) {
    _L: /* CIL Label */ 
#line 170
    tmp___5 = malloc(src_size);
#line 170
    newstr = (char *)tmp___5;
#line 171
    if ((unsigned long )newstr == (unsigned long )((void *)0)) {
#line 172
      goto mbsalign_cleanup;
    }
#line 173
    str_to_print = (char const   *)newstr;
#line 174
    if (wc_enabled) {
#line 176
      n_cols = wc_truncate(str_wc, *width);
#line 177
      n_used_bytes = wcstombs((char * __restrict  )newstr, (wchar_t const   * __restrict  )str_wc,
                              src_size);
    } else {
#line 181
      n_cols = *width;
#line 182
      n_used_bytes = n_cols;
#line 183
      memcpy((void * __restrict  )newstr, (void const   * __restrict  )src, n_cols);
#line 184
      *(newstr + n_cols) = (char )'\000';
    }
  }
#line 188
  if (*width > n_cols) {
#line 189
    n_spaces = *width - n_cols;
  }
#line 192
  *width = n_cols;
#line 195
  ret = n_used_bytes + n_spaces;
#line 198
  if (dest_size != 0UL) {
#line 200
    dest_end = (dest + dest_size) - 1;
#line 201
    start_spaces = n_spaces / 2UL + n_spaces % 2UL;
#line 202
    end_spaces = n_spaces / 2UL;
#line 204
    switch ((unsigned int )align) {
    case 2U: 
#line 207
    start_spaces = n_spaces / 2UL + n_spaces % 2UL;
#line 208
    end_spaces = n_spaces / 2UL;
#line 209
    break;
    case 0U: 
#line 211
    start_spaces = (size_t )0;
#line 212
    end_spaces = n_spaces;
#line 213
    break;
    case 1U: 
#line 215
    start_spaces = n_spaces;
#line 216
    end_spaces = (size_t )0;
#line 217
    break;
    }
#line 220
    dest = mbs_align_pad(dest, (char const   *)dest_end, start_spaces);
#line 221
    if (n_used_bytes < (size_t )(dest_end - dest)) {
#line 221
      tmp___6 = n_used_bytes;
    } else {
#line 221
      tmp___6 = (size_t )(dest_end - dest);
    }
#line 221
    tmp___7 = mempcpy((void * __restrict  )dest, (void const   * __restrict  )str_to_print,
                      tmp___6);
#line 221
    dest = (char *)tmp___7;
#line 222
    mbs_align_pad(dest, (char const   *)dest_end, end_spaces);
  }
  mbsalign_cleanup: 
#line 227
  free((void *)str_wc);
#line 228
  free((void *)newstr);
#line 230
  return (ret);
}
}
#line 1 "cil-ORf87Ac5.o"
#pragma merger("0","../lib/mbscasecmp.o.i","")
#line 36 "/home/wslee/project/coreutils-8.1/lib/mbscasecmp.c"
int mbscasecmp(char const   *s1 , char const   *s2 ) 
{ 
  mbui_iterator_t iter1 ;
  mbui_iterator_t iter2 ;
  int cmp ;
  wint_t tmp ;
  wint_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  unsigned char const   *p1 ;
  unsigned char const   *p2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___18 ;
  unsigned short const   **tmp___19 ;
  int tmp___21 ;
  unsigned short const   **tmp___22 ;
  size_t tmp___25 ;

  {
#line 39
  if ((unsigned long )s1 == (unsigned long )s2) {
#line 40
    return (0);
  }
#line 45
  tmp___25 = __ctype_get_mb_cur_max();
#line 45
  if (tmp___25 > 1UL) {
#line 50
    iter1.cur.ptr = s1;
#line 50
    iter1.in_shift = (_Bool)0;
#line 50
    memset((void *)(& iter1.state), '\000', sizeof(mbstate_t ));
#line 50
    iter1.next_done = (_Bool)0;
#line 51
    iter2.cur.ptr = s2;
#line 51
    iter2.in_shift = (_Bool)0;
#line 51
    memset((void *)(& iter2.state), '\000', sizeof(mbstate_t ));
#line 51
    iter2.next_done = (_Bool)0;
#line 53
    while (1) {
#line 53
      mbuiter_multi_next(& iter1);
#line 53
      if (iter1.cur.wc_valid) {
#line 53
        if (iter1.cur.wc == 0) {
#line 53
          tmp___13 = 0;
        } else {
#line 53
          tmp___13 = 1;
        }
      } else {
#line 53
        tmp___13 = 1;
      }
#line 53
      if (tmp___13) {
#line 53
        mbuiter_multi_next(& iter2);
#line 53
        if (iter2.cur.wc_valid) {
#line 53
          if (iter2.cur.wc == 0) {
#line 53
            tmp___14 = 0;
          } else {
#line 53
            tmp___14 = 1;
          }
        } else {
#line 53
          tmp___14 = 1;
        }
#line 53
        if (! tmp___14) {
#line 53
          break;
        }
      } else {
#line 53
        break;
      }
#line 55
      if (iter1.cur.wc_valid) {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp = towlower((wint_t )iter1.cur.wc);
#line 55
          tmp___0 = towlower((wint_t )iter2.cur.wc);
#line 55
          tmp___1 = (int )tmp - (int )tmp___0;
        } else {
#line 55
          tmp___1 = -1;
        }
#line 55
        tmp___12 = tmp___1;
      } else {
#line 55
        if (iter2.cur.wc_valid) {
#line 55
          tmp___11 = 1;
        } else {
#line 55
          if (iter1.cur.bytes == iter2.cur.bytes) {
#line 55
            tmp___2 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                             iter1.cur.bytes);
#line 55
            tmp___10 = tmp___2;
          } else {
#line 55
            if (iter1.cur.bytes < iter2.cur.bytes) {
#line 55
              tmp___5 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter1.cur.bytes);
#line 55
              if (tmp___5 > 0) {
#line 55
                tmp___4 = 1;
              } else {
#line 55
                tmp___4 = -1;
              }
#line 55
              tmp___9 = tmp___4;
            } else {
#line 55
              tmp___8 = memcmp((void const   *)iter1.cur.ptr, (void const   *)iter2.cur.ptr,
                               iter2.cur.bytes);
#line 55
              if (tmp___8 >= 0) {
#line 55
                tmp___7 = 1;
              } else {
#line 55
                tmp___7 = -1;
              }
#line 55
              tmp___9 = tmp___7;
            }
#line 55
            tmp___10 = tmp___9;
          }
#line 55
          tmp___11 = tmp___10;
        }
#line 55
        tmp___12 = tmp___11;
      }
#line 55
      cmp = tmp___12;
#line 57
      if (cmp != 0) {
#line 58
        return (cmp);
      }
#line 60
      iter1.cur.ptr += iter1.cur.bytes;
#line 60
      iter1.next_done = (_Bool)0;
#line 61
      iter2.cur.ptr += iter2.cur.bytes;
#line 61
      iter2.next_done = (_Bool)0;
    }
#line 63
    mbuiter_multi_next(& iter1);
#line 63
    if (iter1.cur.wc_valid) {
#line 63
      if (iter1.cur.wc == 0) {
#line 63
        tmp___15 = 0;
      } else {
#line 63
        tmp___15 = 1;
      }
    } else {
#line 63
      tmp___15 = 1;
    }
#line 63
    if (tmp___15) {
#line 65
      return (1);
    }
#line 66
    mbuiter_multi_next(& iter2);
#line 66
    if (iter2.cur.wc_valid) {
#line 66
      if (iter2.cur.wc == 0) {
#line 66
        tmp___16 = 0;
      } else {
#line 66
        tmp___16 = 1;
      }
    } else {
#line 66
      tmp___16 = 1;
    }
#line 66
    if (tmp___16) {
#line 68
      return (-1);
    }
#line 69
    return (0);
  } else {
#line 73
    p1 = (unsigned char const   *)s1;
#line 74
    p2 = (unsigned char const   *)s2;
#line 77
    while (1) {
#line 79
      tmp___19 = __ctype_b_loc();
#line 79
      if ((int const   )*(*tmp___19 + (int )*p1) & 256) {
#line 79
        tmp___18 = tolower((int )*p1);
#line 79
        c1 = (unsigned char )tmp___18;
      } else {
#line 79
        c1 = (unsigned char )*p1;
      }
#line 80
      tmp___22 = __ctype_b_loc();
#line 80
      if ((int const   )*(*tmp___22 + (int )*p2) & 256) {
#line 80
        tmp___21 = tolower((int )*p2);
#line 80
        c2 = (unsigned char )tmp___21;
      } else {
#line 80
        c2 = (unsigned char )*p2;
      }
#line 82
      if ((int )c1 == 0) {
#line 83
        break;
      }
#line 85
      p1 ++;
#line 86
      p2 ++;
#line 77
      if (! ((int )c1 == (int )c2)) {
#line 77
        break;
      }
    }
#line 91
    return ((int )c1 - (int )c2);
  }
}
}
#line 1 "cil-tGVNphGL.o"
#pragma merger("0","../lib/mbslen.o.i","")
#line 463 "./string.h"
size_t mbslen(char const   *string ) ;
#line 28 "/home/wslee/project/coreutils-8.1/lib/mbslen.c"
size_t mbslen(char const   *string ) 
{ 
  size_t count ;
  mbui_iterator_t iter ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;

  {
#line 31
  tmp___1 = __ctype_get_mb_cur_max();
#line 31
  if (tmp___1 > 1UL) {
#line 36
    count = (size_t )0;
#line 37
    iter.cur.ptr = string;
#line 37
    iter.in_shift = (_Bool)0;
#line 37
    memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 37
    iter.next_done = (_Bool)0;
#line 37
    while (1) {
#line 37
      mbuiter_multi_next(& iter);
#line 37
      if (iter.cur.wc_valid) {
#line 37
        if (iter.cur.wc == 0) {
#line 37
          tmp = 0;
        } else {
#line 37
          tmp = 1;
        }
      } else {
#line 37
        tmp = 1;
      }
#line 37
      if (! tmp) {
#line 37
        break;
      }
#line 38
      count ++;
#line 37
      iter.cur.ptr += iter.cur.bytes;
#line 37
      iter.next_done = (_Bool)0;
    }
#line 40
    return (count);
  } else {
#line 43
    tmp___0 = strlen(string);
#line 43
    return (tmp___0);
  }
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 1 "cil-9qvJ_ndu.o"
#pragma merger("0","../lib/mbsstr.o.i","")
#line 401 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strnlen)(char const   *__string ,
                                                                                                 size_t __maxlen )  __attribute__((__pure__)) ;
#line 495 "./string.h"
char *mbsstr(char const   *haystack , char const   *needle ) ;
#line 259 "/home/wslee/project/coreutils-8.1/lib/mbchar.h"
__inline static void mb_copy(mbchar_t *new_mbc , mbchar_t const   *old_mbc ) 
{ 
  _Bool tmp ;

  {
#line 262
  if ((unsigned long )old_mbc->ptr == (unsigned long )(& old_mbc->buf[0])) {
#line 264
    memcpy((void * __restrict  )(& new_mbc->buf[0]), (void const   * __restrict  )(& old_mbc->buf[0]),
           (size_t )old_mbc->bytes);
#line 265
    new_mbc->ptr = (char const   *)(& new_mbc->buf[0]);
  } else {
#line 268
    new_mbc->ptr = (char const   *)old_mbc->ptr;
  }
#line 269
  new_mbc->bytes = (size_t )old_mbc->bytes;
#line 270
  tmp = (_Bool )old_mbc->wc_valid;
#line 270
  new_mbc->wc_valid = tmp;
#line 270
  if (tmp) {
#line 271
    new_mbc->wc = (wchar_t )old_mbc->wc;
  }
#line 272
  return;
}
}
#line 31 "/home/wslee/project/coreutils-8.1/lib/str-kmp.h"
static _Bool knuth_morris_pratt_unibyte(char const   *haystack , char const   *needle ,
                                        char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  size_t *table ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  size_t i ;
  size_t j ;
  unsigned char b ;
  size_t j___0 ;
  char const   *rhaystack ;
  char const   *phaystack ;

  {
#line 35
  tmp = strlen(needle);
#line 35
  m = tmp;
#line 38
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 38
    tmp___5 = -1;
  } else {
#line 38
    tmp___5 = -2;
  }
#line 38
  if (m > (size_t )tmp___5 / sizeof(size_t )) {
#line 38
    tmp___4 = (void *)0;
  } else {
#line 38
    if (m * sizeof(size_t ) < 4016UL) {
#line 38
      tmp___1 = __builtin_alloca(m * sizeof(size_t ) + 16UL);
#line 38
      tmp___3 = (void *)((char *)tmp___1 + 16);
    } else {
#line 38
      tmp___2 = mmalloca(m * sizeof(size_t ));
#line 38
      tmp___3 = tmp___2;
    }
#line 38
    tmp___4 = tmp___3;
  }
#line 38
  table = (size_t *)tmp___4;
#line 39
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 40
    return ((_Bool)0);
  }
#line 60
  *(table + 1) = (size_t )1;
#line 61
  j = (size_t )0;
#line 63
  i = (size_t )2;
#line 63
  while (i < m) {
#line 69
    b = (unsigned char )*(needle + (i - 1UL));
#line 71
    while (1) {
#line 76
      if ((int )b == (int )((unsigned char )*(needle + j))) {
#line 79
        j ++;
#line 79
        *(table + i) = i - j;
#line 80
        break;
      }
#line 85
      if (j == 0UL) {
#line 88
        *(table + i) = i;
#line 89
        break;
      }
#line 102
      j -= *(table + j);
    }
#line 63
    i ++;
  }
#line 114
  *resultp = (char const   *)((void *)0);
#line 115
  j___0 = (size_t )0;
#line 116
  rhaystack = haystack;
#line 117
  phaystack = haystack;
#line 119
  while ((int const   )*phaystack != 0) {
#line 120
    if ((int )((unsigned char )*(needle + j___0)) == (int )((unsigned char )*phaystack)) {
#line 123
      j___0 ++;
#line 124
      phaystack ++;
#line 125
      if (j___0 == m) {
#line 128
        *resultp = rhaystack;
#line 129
        break;
      }
    } else
#line 132
    if (j___0 > 0UL) {
#line 135
      rhaystack += *(table + j___0);
#line 136
      j___0 -= *(table + j___0);
    } else {
#line 141
      rhaystack ++;
#line 142
      phaystack ++;
    }
  }
#line 146
  freea((void *)table);
#line 147
  return ((_Bool)1);
}
}
#line 38 "/home/wslee/project/coreutils-8.1/lib/mbsstr.c"
static _Bool knuth_morris_pratt_multibyte(char const   *haystack , char const   *needle ,
                                          char const   **resultp ) 
{ 
  size_t m ;
  size_t tmp ;
  mbchar_t *needle_mbchars ;
  size_t *table ;
  char *memory ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  mbui_iterator_t iter ;
  size_t j ;
  int tmp___6 ;
  size_t i ;
  size_t j___0 ;
  mbchar_t *b ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  size_t j___1 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t phaystack ;
  size_t count ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 42
  tmp = mbslen(needle);
#line 42
  m = tmp;
#line 47
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 47
    tmp___5 = -1;
  } else {
#line 47
    tmp___5 = -2;
  }
#line 47
  if (m > (size_t )tmp___5 / (sizeof(mbchar_t ) + sizeof(size_t ))) {
#line 47
    tmp___4 = (void *)0;
  } else {
#line 47
    if (m * (sizeof(mbchar_t ) + sizeof(size_t )) < 4016UL) {
#line 47
      tmp___1 = __builtin_alloca(m * (sizeof(mbchar_t ) + sizeof(size_t )) + 16UL);
#line 47
      tmp___3 = (void *)((char *)tmp___1 + 16);
    } else {
#line 47
      tmp___2 = mmalloca(m * (sizeof(mbchar_t ) + sizeof(size_t )));
#line 47
      tmp___3 = tmp___2;
    }
#line 47
    tmp___4 = tmp___3;
  }
#line 47
  memory = (char *)tmp___4;
#line 48
  if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 49
    return ((_Bool)0);
  }
#line 50
  needle_mbchars = (mbchar_t *)memory;
#line 51
  table = (size_t *)(memory + m * sizeof(mbchar_t ));
#line 58
  j = (size_t )0;
#line 59
  iter.cur.ptr = needle;
#line 59
  iter.in_shift = (_Bool)0;
#line 59
  memset((void *)(& iter.state), '\000', sizeof(mbstate_t ));
#line 59
  iter.next_done = (_Bool)0;
#line 59
  while (1) {
#line 59
    mbuiter_multi_next(& iter);
#line 59
    if (iter.cur.wc_valid) {
#line 59
      if (iter.cur.wc == 0) {
#line 59
        tmp___6 = 0;
      } else {
#line 59
        tmp___6 = 1;
      }
    } else {
#line 59
      tmp___6 = 1;
    }
#line 59
    if (! tmp___6) {
#line 59
      break;
    }
#line 60
    mb_copy(needle_mbchars + j, (mbchar_t const   *)(& iter.cur));
#line 59
    iter.cur.ptr += iter.cur.bytes;
#line 59
    iter.next_done = (_Bool)0;
#line 59
    j ++;
  }
#line 82
  *(table + 1) = (size_t )1;
#line 83
  j___0 = (size_t )0;
#line 85
  i = (size_t )2;
#line 85
  while (i < m) {
#line 91
    b = needle_mbchars + (i - 1UL);
#line 93
    while (1) {
#line 98
      if (b->wc_valid) {
#line 98
        if ((needle_mbchars + j___0)->wc_valid) {
#line 98
          tmp___9 = b->wc == (needle_mbchars + j___0)->wc;
        } else {
#line 98
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 98
        if (b->bytes == (needle_mbchars + j___0)->bytes) {
#line 98
          tmp___7 = memcmp((void const   *)b->ptr, (void const   *)(needle_mbchars + j___0)->ptr,
                           b->bytes);
#line 98
          if (tmp___7 == 0) {
#line 98
            tmp___8 = 1;
          } else {
#line 98
            tmp___8 = 0;
          }
        } else {
#line 98
          tmp___8 = 0;
        }
#line 98
        tmp___9 = tmp___8;
      }
#line 98
      if (tmp___9) {
#line 101
        j___0 ++;
#line 101
        *(table + i) = i - j___0;
#line 102
        break;
      }
#line 107
      if (j___0 == 0UL) {
#line 110
        *(table + i) = i;
#line 111
        break;
      }
#line 124
      j___0 -= *(table + j___0);
    }
#line 85
    i ++;
  }
#line 136
  *resultp = (char const   *)((void *)0);
#line 137
  j___1 = (size_t )0;
#line 138
  rhaystack.cur.ptr = haystack;
#line 138
  rhaystack.in_shift = (_Bool)0;
#line 138
  memset((void *)(& rhaystack.state), '\000', sizeof(mbstate_t ));
#line 138
  rhaystack.next_done = (_Bool)0;
#line 139
  phaystack.cur.ptr = haystack;
#line 139
  phaystack.in_shift = (_Bool)0;
#line 139
  memset((void *)(& phaystack.state), '\000', sizeof(mbstate_t ));
#line 139
  phaystack.next_done = (_Bool)0;
#line 141
  while (1) {
#line 141
    mbuiter_multi_next(& phaystack);
#line 141
    if (phaystack.cur.wc_valid) {
#line 141
      if (phaystack.cur.wc == 0) {
#line 141
        tmp___15 = 0;
      } else {
#line 141
        tmp___15 = 1;
      }
    } else {
#line 141
      tmp___15 = 1;
    }
#line 141
    if (! tmp___15) {
#line 141
      break;
    }
#line 142
    if ((needle_mbchars + j___1)->wc_valid) {
#line 142
      if (phaystack.cur.wc_valid) {
#line 142
        tmp___14 = (needle_mbchars + j___1)->wc == phaystack.cur.wc;
      } else {
#line 142
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 142
      if ((needle_mbchars + j___1)->bytes == phaystack.cur.bytes) {
#line 142
        tmp___12 = memcmp((void const   *)(needle_mbchars + j___1)->ptr, (void const   *)phaystack.cur.ptr,
                          (needle_mbchars + j___1)->bytes);
#line 142
        if (tmp___12 == 0) {
#line 142
          tmp___13 = 1;
        } else {
#line 142
          tmp___13 = 0;
        }
      } else {
#line 142
        tmp___13 = 0;
      }
#line 142
      tmp___14 = tmp___13;
    }
#line 142
    if (tmp___14) {
#line 144
      j___1 ++;
#line 145
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 145
      phaystack.next_done = (_Bool)0;
#line 146
      if (j___1 == m) {
#line 149
        *resultp = rhaystack.cur.ptr;
#line 150
        break;
      }
    } else
#line 153
    if (j___1 > 0UL) {
#line 156
      count = *(table + j___1);
#line 157
      j___1 -= count;
#line 158
      while (count > 0UL) {
#line 160
        mbuiter_multi_next(& rhaystack);
#line 160
        if (rhaystack.cur.wc_valid) {
#line 160
          if (rhaystack.cur.wc == 0) {
#line 160
            tmp___10 = 0;
          } else {
#line 160
            tmp___10 = 1;
          }
        } else {
#line 160
          tmp___10 = 1;
        }
#line 160
        if (! tmp___10) {
#line 161
          abort();
        }
#line 162
        rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 162
        rhaystack.next_done = (_Bool)0;
#line 158
        count --;
      }
    } else {
#line 168
      mbuiter_multi_next(& rhaystack);
#line 168
      if (rhaystack.cur.wc_valid) {
#line 168
        if (rhaystack.cur.wc == 0) {
#line 168
          tmp___11 = 0;
        } else {
#line 168
          tmp___11 = 1;
        }
      } else {
#line 168
        tmp___11 = 1;
      }
#line 168
      if (! tmp___11) {
#line 169
        abort();
      }
#line 170
      rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 170
      rhaystack.next_done = (_Bool)0;
#line 171
      phaystack.cur.ptr += phaystack.cur.bytes;
#line 171
      phaystack.next_done = (_Bool)0;
    }
  }
#line 175
  freea((void *)memory);
#line 176
  return ((_Bool)1);
}
}
#line 181 "/home/wslee/project/coreutils-8.1/lib/mbsstr.c"
char *mbsstr(char const   *haystack , char const   *needle ) 
{ 
  mbui_iterator_t iter_needle ;
  _Bool try_kmp ;
  size_t outer_loop_count ;
  size_t comparison_count ;
  size_t last_ccount ;
  mbui_iterator_t iter_needle_last_ccount ;
  mbui_iterator_t iter_haystack ;
  int tmp ;
  size_t count ;
  int tmp___0 ;
  char const   *result ;
  _Bool success ;
  _Bool tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t rhaystack ;
  mbui_iterator_t rneedle ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  _Bool try_kmp___0 ;
  size_t outer_loop_count___0 ;
  size_t comparison_count___0 ;
  size_t last_ccount___0 ;
  char const   *needle_last_ccount ;
  char b ;
  char const   *tmp___13 ;
  size_t tmp___14 ;
  char const   *result___0 ;
  _Bool success___0 ;
  _Bool tmp___15 ;
  char const   *rhaystack___0 ;
  char const   *rneedle___0 ;
  size_t tmp___16 ;

  {
#line 189
  tmp___16 = __ctype_get_mb_cur_max();
#line 189
  if (tmp___16 > 1UL) {
#line 193
    iter_needle.cur.ptr = needle;
#line 193
    iter_needle.in_shift = (_Bool)0;
#line 193
    memset((void *)(& iter_needle.state), '\000', sizeof(mbstate_t ));
#line 193
    iter_needle.next_done = (_Bool)0;
#line 194
    mbuiter_multi_next(& iter_needle);
#line 194
    if (iter_needle.cur.wc_valid) {
#line 194
      if (iter_needle.cur.wc == 0) {
#line 194
        tmp___12 = 0;
      } else {
#line 194
        tmp___12 = 1;
      }
    } else {
#line 194
      tmp___12 = 1;
    }
#line 194
    if (tmp___12) {
#line 210
      try_kmp = (_Bool)1;
#line 211
      outer_loop_count = (size_t )0;
#line 212
      comparison_count = (size_t )0;
#line 213
      last_ccount = (size_t )0;
#line 218
      iter_needle_last_ccount.cur.ptr = needle;
#line 218
      iter_needle_last_ccount.in_shift = (_Bool)0;
#line 218
      memset((void *)(& iter_needle_last_ccount.state), '\000', sizeof(mbstate_t ));
#line 218
      iter_needle_last_ccount.next_done = (_Bool)0;
#line 219
      iter_haystack.cur.ptr = haystack;
#line 219
      iter_haystack.in_shift = (_Bool)0;
#line 219
      memset((void *)(& iter_haystack.state), '\000', sizeof(mbstate_t ));
#line 219
      iter_haystack.next_done = (_Bool)0;
#line 220
      while (1) {
#line 222
        mbuiter_multi_next(& iter_haystack);
#line 222
        if (iter_haystack.cur.wc_valid) {
#line 222
          if (iter_haystack.cur.wc == 0) {
#line 222
            tmp = 0;
          } else {
#line 222
            tmp = 1;
          }
        } else {
#line 222
          tmp = 1;
        }
#line 222
        if (! tmp) {
#line 224
          return ((char *)((void *)0));
        }
#line 228
        if (try_kmp) {
#line 228
          if (outer_loop_count >= 10UL) {
#line 228
            if (comparison_count >= 5UL * outer_loop_count) {
#line 234
              count = comparison_count - last_ccount;
#line 235
              while (1) {
#line 235
                if (count > 0UL) {
#line 235
                  mbuiter_multi_next(& iter_needle_last_ccount);
#line 235
                  if (iter_needle_last_ccount.cur.wc_valid) {
#line 235
                    if (iter_needle_last_ccount.cur.wc == 0) {
#line 235
                      tmp___0 = 0;
                    } else {
#line 235
                      tmp___0 = 1;
                    }
                  } else {
#line 235
                    tmp___0 = 1;
                  }
#line 235
                  if (! tmp___0) {
#line 235
                    break;
                  }
                } else {
#line 235
                  break;
                }
#line 238
                iter_needle_last_ccount.cur.ptr += iter_needle_last_ccount.cur.bytes;
#line 238
                iter_needle_last_ccount.next_done = (_Bool)0;
#line 235
                count --;
              }
#line 239
              last_ccount = comparison_count;
#line 240
              mbuiter_multi_next(& iter_needle_last_ccount);
#line 240
              if (iter_needle_last_ccount.cur.wc_valid) {
#line 240
                if (iter_needle_last_ccount.cur.wc == 0) {
#line 240
                  tmp___2 = 0;
                } else {
#line 240
                  tmp___2 = 1;
                }
              } else {
#line 240
                tmp___2 = 1;
              }
#line 240
              if (! tmp___2) {
#line 244
                tmp___1 = knuth_morris_pratt_multibyte(haystack, needle, & result);
#line 244
                success = tmp___1;
#line 247
                if (success) {
#line 248
                  return ((char *)result);
                }
#line 249
                try_kmp = (_Bool)0;
              }
            }
          }
        }
#line 253
        outer_loop_count ++;
#line 254
        comparison_count ++;
#line 255
        if (iter_haystack.cur.wc_valid) {
#line 255
          if (iter_needle.cur.wc_valid) {
#line 255
            tmp___11 = iter_haystack.cur.wc == iter_needle.cur.wc;
          } else {
#line 255
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 255
          if (iter_haystack.cur.bytes == iter_needle.cur.bytes) {
#line 255
            tmp___9 = memcmp((void const   *)iter_haystack.cur.ptr, (void const   *)iter_needle.cur.ptr,
                             iter_haystack.cur.bytes);
#line 255
            if (tmp___9 == 0) {
#line 255
              tmp___10 = 1;
            } else {
#line 255
              tmp___10 = 0;
            }
          } else {
#line 255
            tmp___10 = 0;
          }
#line 255
          tmp___11 = tmp___10;
        }
#line 255
        if (tmp___11) {
#line 261
          memcpy((void * __restrict  )(& rhaystack), (void const   * __restrict  )(& iter_haystack),
                 sizeof(mbui_iterator_t ));
#line 262
          rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 262
          rhaystack.next_done = (_Bool)0;
#line 264
          rneedle.cur.ptr = needle;
#line 264
          rneedle.in_shift = (_Bool)0;
#line 264
          memset((void *)(& rneedle.state), '\000', sizeof(mbstate_t ));
#line 264
          rneedle.next_done = (_Bool)0;
#line 265
          mbuiter_multi_next(& rneedle);
#line 265
          if (rneedle.cur.wc_valid) {
#line 265
            if (rneedle.cur.wc == 0) {
#line 265
              tmp___3 = 0;
            } else {
#line 265
              tmp___3 = 1;
            }
          } else {
#line 265
            tmp___3 = 1;
          }
#line 265
          if (! tmp___3) {
#line 266
            abort();
          }
#line 267
          rneedle.cur.ptr += rneedle.cur.bytes;
#line 267
          rneedle.next_done = (_Bool)0;
#line 269
          while (1) {
#line 271
            mbuiter_multi_next(& rneedle);
#line 271
            if (rneedle.cur.wc_valid) {
#line 271
              if (rneedle.cur.wc == 0) {
#line 271
                tmp___4 = 0;
              } else {
#line 271
                tmp___4 = 1;
              }
            } else {
#line 271
              tmp___4 = 1;
            }
#line 271
            if (! tmp___4) {
#line 273
              return ((char *)iter_haystack.cur.ptr);
            }
#line 274
            mbuiter_multi_next(& rhaystack);
#line 274
            if (rhaystack.cur.wc_valid) {
#line 274
              if (rhaystack.cur.wc == 0) {
#line 274
                tmp___5 = 0;
              } else {
#line 274
                tmp___5 = 1;
              }
            } else {
#line 274
              tmp___5 = 1;
            }
#line 274
            if (! tmp___5) {
#line 276
              return ((char *)((void *)0));
            }
#line 277
            comparison_count ++;
#line 278
            if (rhaystack.cur.wc_valid) {
#line 278
              if (rneedle.cur.wc_valid) {
#line 278
                tmp___8 = rhaystack.cur.wc == rneedle.cur.wc;
              } else {
#line 278
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
#line 278
              if (rhaystack.cur.bytes == rneedle.cur.bytes) {
#line 278
                tmp___6 = memcmp((void const   *)rhaystack.cur.ptr, (void const   *)rneedle.cur.ptr,
                                 rhaystack.cur.bytes);
#line 278
                if (tmp___6 == 0) {
#line 278
                  tmp___7 = 1;
                } else {
#line 278
                  tmp___7 = 0;
                }
              } else {
#line 278
                tmp___7 = 0;
              }
#line 278
              tmp___8 = tmp___7;
            }
#line 278
            if (! tmp___8) {
#line 280
              break;
            }
#line 269
            rhaystack.cur.ptr += rhaystack.cur.bytes;
#line 269
            rhaystack.next_done = (_Bool)0;
#line 269
            rneedle.cur.ptr += rneedle.cur.bytes;
#line 269
            rneedle.next_done = (_Bool)0;
          }
        }
#line 220
        iter_haystack.cur.ptr += iter_haystack.cur.bytes;
#line 220
        iter_haystack.next_done = (_Bool)0;
      }
    } else {
#line 286
      return ((char *)haystack);
    }
  } else
#line 290
  if ((int const   )*needle != 0) {
#line 306
    try_kmp___0 = (_Bool)1;
#line 307
    outer_loop_count___0 = (size_t )0;
#line 308
    comparison_count___0 = (size_t )0;
#line 309
    last_ccount___0 = (size_t )0;
#line 310
    needle_last_ccount = needle;
#line 314
    tmp___13 = needle;
#line 314
    needle ++;
#line 314
    b = (char )*tmp___13;
#line 316
    while (1) {
#line 318
      if ((int const   )*haystack == 0) {
#line 320
        return ((char *)((void *)0));
      }
#line 324
      if (try_kmp___0) {
#line 324
        if (outer_loop_count___0 >= 10UL) {
#line 324
          if (comparison_count___0 >= 5UL * outer_loop_count___0) {
#line 330
            if ((unsigned long )needle_last_ccount != (unsigned long )((void *)0)) {
#line 332
              tmp___14 = strnlen(needle_last_ccount, comparison_count___0 - last_ccount___0);
#line 332
              needle_last_ccount += tmp___14;
#line 335
              if ((int const   )*needle_last_ccount == 0) {
#line 336
                needle_last_ccount = (char const   *)((void *)0);
              }
#line 337
              last_ccount___0 = comparison_count___0;
            }
#line 339
            if ((unsigned long )needle_last_ccount == (unsigned long )((void *)0)) {
#line 343
              tmp___15 = knuth_morris_pratt_unibyte(haystack, needle - 1, & result___0);
#line 343
              success___0 = tmp___15;
#line 346
              if (success___0) {
#line 347
                return ((char *)result___0);
              }
#line 348
              try_kmp___0 = (_Bool)0;
            }
          }
        }
      }
#line 352
      outer_loop_count___0 ++;
#line 353
      comparison_count___0 ++;
#line 354
      if ((int const   )*haystack == (int const   )b) {
#line 357
        rhaystack___0 = haystack + 1;
#line 358
        rneedle___0 = needle;
#line 360
        while (1) {
#line 362
          if ((int const   )*rneedle___0 == 0) {
#line 364
            return ((char *)haystack);
          }
#line 365
          if ((int const   )*rhaystack___0 == 0) {
#line 367
            return ((char *)((void *)0));
          }
#line 368
          comparison_count___0 ++;
#line 369
          if ((int const   )*rhaystack___0 != (int const   )*rneedle___0) {
#line 371
            break;
          }
#line 360
          rhaystack___0 ++;
#line 360
          rneedle___0 ++;
        }
      }
#line 316
      haystack ++;
    }
  } else {
#line 377
    return ((char *)haystack);
  }
}
}
#line 1 "cil-TvsXXRMh.o"
#pragma merger("0","../lib/mbswidth.o.i","")
#line 51 "/home/wslee/project/coreutils-8.1/lib/mbswidth.h"
int gnu_mbswidth(char const   *string , int flags ) ;
#line 55
int mbsnwidth(char const   *string , size_t nbytes , int flags ) ;
#line 120 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswcntrl)(wint_t __wc ) ;
#line 44 "/home/wslee/project/coreutils-8.1/lib/mbswidth.c"
int gnu_mbswidth(char const   *string , int flags ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
#line 47
  tmp = strlen(string);
#line 47
  tmp___0 = mbsnwidth(string, tmp, flags);
#line 47
  return (tmp___0);
}
}
#line 55 "/home/wslee/project/coreutils-8.1/lib/mbswidth.c"
int mbsnwidth(char const   *string , size_t nbytes , int flags ) 
{ 
  char const   *p ;
  char const   *plimit ;
  int width ;
  mbstate_t mbstate ;
  wchar_t wc ;
  size_t bytes ;
  int w ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  unsigned char c ;
  char const   *tmp___4 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  unsigned short const   **tmp___8 ;

  {
#line 58
  p = string;
#line 59
  plimit = p + nbytes;
#line 62
  width = 0;
#line 63
  tmp___3 = __ctype_get_mb_cur_max();
#line 63
  if (tmp___3 > 1UL) {
#line 65
    while ((unsigned long )p < (unsigned long )plimit) {
#line 66
      switch ((int const   )*p) {
      case 126: 
      case 125: 
      case 124: 
      case 123: 
      case 122: 
      case 121: 
      case 120: 
      case 119: 
      case 118: 
      case 117: 
      case 116: 
      case 115: 
      case 114: 
      case 113: 
      case 112: 
      case 111: 
      case 110: 
      case 109: 
      case 108: 
      case 107: 
      case 106: 
      case 105: 
      case 104: 
      case 103: 
      case 102: 
      case 101: 
      case 100: 
      case 99: 
      case 98: 
      case 97: 
      case 95: 
      case 94: 
      case 93: 
      case 92: 
      case 91: 
      case 90: 
      case 89: 
      case 88: 
      case 87: 
      case 86: 
      case 85: 
      case 84: 
      case 83: 
      case 82: 
      case 81: 
      case 80: 
      case 79: 
      case 78: 
      case 77: 
      case 76: 
      case 75: 
      case 74: 
      case 73: 
      case 72: 
      case 71: 
      case 70: 
      case 69: 
      case 68: 
      case 67: 
      case 66: 
      case 65: 
      case 63: 
      case 62: 
      case 61: 
      case 60: 
      case 59: 
      case 58: 
      case 57: 
      case 56: 
      case 55: 
      case 54: 
      case 53: 
      case 52: 
      case 51: 
      case 50: 
      case 49: 
      case 48: 
      case 47: 
      case 46: 
      case 45: 
      case 44: 
      case 43: 
      case 42: 
      case 41: 
      case 40: 
      case 39: 
      case 38: 
      case 37: 
      case 35: 
      case 34: 
      case 33: 
      case 32: 
#line 89
      p ++;
#line 90
      width ++;
#line 91
      break;
      default: 
#line 96
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 97
      while (1) {
#line 103
        bytes = mbrtowc((wchar_t * __restrict  )(& wc), (char const   * __restrict  )p,
                        (size_t )(plimit - p), (mbstate_t * __restrict  )(& mbstate));
#line 105
        if (bytes == 0xffffffffffffffffUL) {
#line 108
          if (! (flags & 1)) {
#line 110
            p ++;
#line 111
            width ++;
#line 112
            break;
          } else {
#line 115
            return (-1);
          }
        }
#line 118
        if (bytes == 0xfffffffffffffffeUL) {
#line 121
          if (! (flags & 1)) {
#line 123
            p = plimit;
#line 124
            width ++;
#line 125
            break;
          } else {
#line 128
            return (-1);
          }
        }
#line 131
        if (bytes == 0UL) {
#line 133
          bytes = (size_t )1;
        }
#line 135
        w = wcwidth(wc);
#line 136
        if (w >= 0) {
#line 138
          width += w;
        } else
#line 141
        if (! (flags & 2)) {
#line 142
          tmp___1 = iswcntrl((wint_t )wc);
#line 142
          if (tmp___1) {
#line 142
            tmp___0 = 0;
          } else {
#line 142
            tmp___0 = 1;
          }
#line 142
          width += tmp___0;
        } else {
#line 144
          return (-1);
        }
#line 146
        p += bytes;
#line 97
        tmp___2 = mbsinit((mbstate_t const   *)(& mbstate));
#line 97
        if (tmp___2) {
#line 97
          break;
        }
      }
#line 150
      break;
      }
    }
#line 152
    return (width);
  }
#line 155
  while ((unsigned long )p < (unsigned long )plimit) {
#line 157
    tmp___4 = p;
#line 157
    p ++;
#line 157
    c = (unsigned char )*tmp___4;
#line 159
    tmp___8 = __ctype_b_loc();
#line 159
    if ((int const   )*(*tmp___8 + (int )c) & 16384) {
#line 160
      width ++;
    } else
#line 161
    if (! (flags & 2)) {
#line 162
      tmp___7 = __ctype_b_loc();
#line 162
      if ((int const   )*(*tmp___7 + (int )c) & 2) {
#line 162
        tmp___6 = 0;
      } else {
#line 162
        tmp___6 = 1;
      }
#line 162
      width += tmp___6;
    } else {
#line 164
      return (-1);
    }
  }
#line 166
  return (width);
}
}
#line 1 "cil-kcWoEd_i.o"
#pragma merger("0","../lib/md5.o.i","")
#line 737 "/usr/include/stdio.h"
extern size_t fread_unlocked(void * __restrict  __ptr , size_t __size , size_t __n ,
                             FILE * __restrict  __stream ) ;
#line 81 "/home/wslee/project/coreutils-8.1/lib/md5.h"
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_init_ctx)(struct md5_ctx *ctx ) ;
#line 87
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_block)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 94
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_bytes)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 101
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_finish_ctx)(struct md5_ctx *ctx ,
                                                                                void *resbuf ) ;
#line 107
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_read_ctx)(struct md5_ctx  const  *ctx ,
                                                                              void *resbuf ) ;
#line 113
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) md5_stream)(FILE *stream ,
                                                                          void *resblock ) ;
#line 119
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_buffer)(char const   *buffer ,
                                                                            size_t len ,
                                                                            void *resblock ) ;
#line 66 "/home/wslee/project/coreutils-8.1/lib/md5.c"
static unsigned char const   fillbuf[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 71
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_init_ctx)(struct md5_ctx *ctx ) ;
#line 71 "/home/wslee/project/coreutils-8.1/lib/md5.c"
void ( __attribute__((__leaf__)) md5_init_ctx)(struct md5_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 74
  ctx->A = (uint32_t )1732584193;
#line 75
  ctx->B = 4023233417U;
#line 76
  ctx->C = 2562383102U;
#line 77
  ctx->D = (uint32_t )271733878;
#line 79
  tmp = (uint32_t )0;
#line 79
  ctx->total[1] = tmp;
#line 79
  ctx->total[0] = tmp;
#line 80
  ctx->buflen = (uint32_t )0;
#line 81
  return;
}
}
#line 86 "/home/wslee/project/coreutils-8.1/lib/md5.c"
__inline static void set_uint32(char *cp , uint32_t v ) 
{ 


  {
#line 89
  memcpy((void * __restrict  )cp, (void const   * __restrict  )(& v), sizeof(v));
#line 90
  return;
}
}
#line 94
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_read_ctx)(struct md5_ctx  const  *ctx ,
                                                                              void *resbuf ) ;
#line 94 "/home/wslee/project/coreutils-8.1/lib/md5.c"
void *( __attribute__((__leaf__)) md5_read_ctx)(struct md5_ctx  const  *ctx , void *resbuf ) 
{ 
  char *r ;

  {
#line 97
  r = (char *)resbuf;
#line 98
  set_uint32(r + 0UL, (uint32_t )ctx->A);
#line 99
  set_uint32(r + sizeof(ctx->B), (uint32_t )ctx->B);
#line 100
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )ctx->C);
#line 101
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )ctx->D);
#line 103
  return (resbuf);
}
}
#line 108
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_finish_ctx)(struct md5_ctx *ctx ,
                                                                                void *resbuf ) ;
#line 108 "/home/wslee/project/coreutils-8.1/lib/md5.c"
void *( __attribute__((__leaf__)) md5_finish_ctx)(struct md5_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 112
  bytes = ctx->buflen;
#line 113
  if (bytes < 56U) {
#line 113
    tmp = 16;
  } else {
#line 113
    tmp = 32;
  }
#line 113
  size = (size_t )tmp;
#line 116
  ctx->total[0] += bytes;
#line 117
  if (ctx->total[0] < bytes) {
#line 118
    (ctx->total[1]) ++;
  }
#line 121
  ctx->buffer[size - 2UL] = ctx->total[0] << 3;
#line 122
  ctx->buffer[size - 1UL] = (ctx->total[1] << 3) | (ctx->total[0] >> 29);
#line 124
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 127
  md5_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 129
  tmp___0 = md5_read_ctx((struct md5_ctx  const  *)ctx, resbuf);
#line 129
  return (tmp___0);
}
}
#line 135
 __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) md5_stream)(FILE *stream ,
                                                                          void *resblock ) ;
#line 135 "/home/wslee/project/coreutils-8.1/lib/md5.c"
int ( __attribute__((__leaf__)) md5_stream)(FILE *stream , void *resblock ) 
{ 
  struct md5_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 141
  tmp = malloc((size_t )32840);
#line 141
  buffer = (char *)tmp;
#line 142
  if (! buffer) {
#line 143
    return (1);
  }
#line 146
  md5_init_ctx(& ctx);
#line 149
  while (1) {
#line 155
    sum = (size_t )0;
#line 158
    while (1) {
#line 160
      n = fread_unlocked((void * __restrict  )(buffer + sum), (size_t )1, 32768UL - sum,
                         (FILE * __restrict  )stream);
#line 162
      sum += n;
#line 164
      if (sum == 32768UL) {
#line 165
        break;
      }
#line 167
      if (n == 0UL) {
#line 172
        tmp___0 = ferror_unlocked(stream);
#line 172
        if (tmp___0) {
#line 174
          free((void *)buffer);
#line 175
          return (1);
        }
#line 177
        goto process_partial_block;
      }
#line 183
      tmp___1 = feof_unlocked(stream);
#line 183
      if (tmp___1) {
#line 184
        goto process_partial_block;
      }
    }
#line 190
    md5_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: 
#line 196
  if (sum > 0UL) {
#line 197
    md5_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 200
  md5_finish_ctx(& ctx, resblock);
#line 201
  free((void *)buffer);
#line 202
  return (0);
}
}
#line 209
 __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) md5_buffer)(char const   *buffer ,
                                                                            size_t len ,
                                                                            void *resblock ) ;
#line 209 "/home/wslee/project/coreutils-8.1/lib/md5.c"
void *( __attribute__((__leaf__)) md5_buffer)(char const   *buffer , size_t len ,
                                              void *resblock ) 
{ 
  struct md5_ctx ctx ;
  void *tmp ;

  {
#line 215
  md5_init_ctx(& ctx);
#line 218
  md5_process_bytes((void const   *)buffer, len, & ctx);
#line 221
  tmp = md5_finish_ctx(& ctx, resblock);
#line 221
  return (tmp);
}
}
#line 225
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_bytes)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 225 "/home/wslee/project/coreutils-8.1/lib/md5.c"
void ( __attribute__((__leaf__)) md5_process_bytes)(void const   *buffer , size_t len ,
                                                    struct md5_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 230
  if (ctx->buflen != 0U) {
#line 232
    left_over = (size_t )ctx->buflen;
#line 233
    if (128UL - left_over > len) {
#line 233
      tmp = len;
    } else {
#line 233
      tmp = 128UL - left_over;
    }
#line 233
    add = tmp;
#line 235
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 236
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
#line 238
    if (ctx->buflen > 64U) {
#line 240
      md5_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                        ctx);
#line 242
      ctx->buflen &= 63U;
#line 244
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
    }
#line 249
    buffer = (void const   *)((char const   *)buffer + add);
#line 250
    len -= add;
  }
#line 254
  if (len >= 64UL) {
#line 259
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_833865290 *)0)->x) != 0UL) {
#line 260
      while (len > 64UL) {
#line 262
        tmp___0 = memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )buffer,
                         (size_t )64);
#line 262
        md5_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 263
        buffer = (void const   *)((char const   *)buffer + 64);
#line 264
        len -= 64UL;
      }
    } else {
#line 269
      md5_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 270
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 271
      len &= 63UL;
    }
  }
#line 276
  if (len > 0UL) {
#line 278
    left_over___0 = (size_t )ctx->buflen;
#line 280
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 281
    left_over___0 += len;
#line 282
    if (left_over___0 >= 64UL) {
#line 284
      md5_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 285
      left_over___0 -= 64UL;
#line 286
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 288
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 290
  return;
}
}
#line 305
 __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) md5_process_block)(void const   *buffer ,
                                                                                  size_t len ,
                                                                                  struct md5_ctx *ctx ) ;
#line 305 "/home/wslee/project/coreutils-8.1/lib/md5.c"
void ( __attribute__((__leaf__)) md5_process_block)(void const   *buffer , size_t len ,
                                                    struct md5_ctx *ctx ) 
{ 
  uint32_t correct_words[16] ;
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t A ;
  uint32_t B ;
  uint32_t C ;
  uint32_t D ;
  uint32_t *cwp ;
  uint32_t A_save ;
  uint32_t B_save ;
  uint32_t C_save ;
  uint32_t D_save ;
  uint32_t *tmp ;
  uint32_t tmp___0 ;
  uint32_t *tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t *tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t *tmp___5 ;
  uint32_t tmp___6 ;
  uint32_t *tmp___7 ;
  uint32_t tmp___8 ;
  uint32_t *tmp___9 ;
  uint32_t tmp___10 ;
  uint32_t *tmp___11 ;
  uint32_t tmp___12 ;
  uint32_t *tmp___13 ;
  uint32_t tmp___14 ;
  uint32_t *tmp___15 ;
  uint32_t tmp___16 ;
  uint32_t *tmp___17 ;
  uint32_t tmp___18 ;
  uint32_t *tmp___19 ;
  uint32_t tmp___20 ;
  uint32_t *tmp___21 ;
  uint32_t tmp___22 ;
  uint32_t *tmp___23 ;
  uint32_t tmp___24 ;
  uint32_t *tmp___25 ;
  uint32_t tmp___26 ;
  uint32_t *tmp___27 ;
  uint32_t tmp___28 ;
  uint32_t *tmp___29 ;
  uint32_t tmp___30 ;

  {
#line 309
  words = (uint32_t const   *)buffer;
#line 310
  nwords = len / sizeof(uint32_t );
#line 311
  endp = words + nwords;
#line 312
  A = ctx->A;
#line 313
  B = ctx->B;
#line 314
  C = ctx->C;
#line 315
  D = ctx->D;
#line 320
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 321
  if ((size_t )ctx->total[0] < len) {
#line 322
    (ctx->total[1]) ++;
  }
#line 326
  while ((unsigned long )words < (unsigned long )endp) {
#line 328
    cwp = correct_words;
#line 329
    A_save = A;
#line 330
    B_save = B;
#line 331
    C_save = C;
#line 332
    D_save = D;
#line 366
    while (1) {
#line 366
      tmp = cwp;
#line 366
      cwp ++;
#line 366
      tmp___0 = (uint32_t )*words;
#line 366
      *tmp = tmp___0;
#line 366
      A += ((D ^ (B & (C ^ D))) + tmp___0) + 3614090360U;
#line 366
      words ++;
#line 366
      A = (A << 7) | (A >> 25);
#line 366
      A += B;
#line 366
      break;
    }
#line 367
    while (1) {
#line 367
      tmp___1 = cwp;
#line 367
      cwp ++;
#line 367
      tmp___2 = (uint32_t )*words;
#line 367
      *tmp___1 = tmp___2;
#line 367
      D += ((C ^ (A & (B ^ C))) + tmp___2) + 3905402710U;
#line 367
      words ++;
#line 367
      D = (D << 12) | (D >> 20);
#line 367
      D += A;
#line 367
      break;
    }
#line 368
    while (1) {
#line 368
      tmp___3 = cwp;
#line 368
      cwp ++;
#line 368
      tmp___4 = (uint32_t )*words;
#line 368
      *tmp___3 = tmp___4;
#line 368
      C += ((B ^ (D & (A ^ B))) + tmp___4) + 606105819U;
#line 368
      words ++;
#line 368
      C = (C << 17) | (C >> 15);
#line 368
      C += D;
#line 368
      break;
    }
#line 369
    while (1) {
#line 369
      tmp___5 = cwp;
#line 369
      cwp ++;
#line 369
      tmp___6 = (uint32_t )*words;
#line 369
      *tmp___5 = tmp___6;
#line 369
      B += ((A ^ (C & (D ^ A))) + tmp___6) + 3250441966U;
#line 369
      words ++;
#line 369
      B = (B << 22) | (B >> 10);
#line 369
      B += C;
#line 369
      break;
    }
#line 370
    while (1) {
#line 370
      tmp___7 = cwp;
#line 370
      cwp ++;
#line 370
      tmp___8 = (uint32_t )*words;
#line 370
      *tmp___7 = tmp___8;
#line 370
      A += ((D ^ (B & (C ^ D))) + tmp___8) + 4118548399U;
#line 370
      words ++;
#line 370
      A = (A << 7) | (A >> 25);
#line 370
      A += B;
#line 370
      break;
    }
#line 371
    while (1) {
#line 371
      tmp___9 = cwp;
#line 371
      cwp ++;
#line 371
      tmp___10 = (uint32_t )*words;
#line 371
      *tmp___9 = tmp___10;
#line 371
      D += ((C ^ (A & (B ^ C))) + tmp___10) + 1200080426U;
#line 371
      words ++;
#line 371
      D = (D << 12) | (D >> 20);
#line 371
      D += A;
#line 371
      break;
    }
#line 372
    while (1) {
#line 372
      tmp___11 = cwp;
#line 372
      cwp ++;
#line 372
      tmp___12 = (uint32_t )*words;
#line 372
      *tmp___11 = tmp___12;
#line 372
      C += ((B ^ (D & (A ^ B))) + tmp___12) + 2821735955U;
#line 372
      words ++;
#line 372
      C = (C << 17) | (C >> 15);
#line 372
      C += D;
#line 372
      break;
    }
#line 373
    while (1) {
#line 373
      tmp___13 = cwp;
#line 373
      cwp ++;
#line 373
      tmp___14 = (uint32_t )*words;
#line 373
      *tmp___13 = tmp___14;
#line 373
      B += ((A ^ (C & (D ^ A))) + tmp___14) + 4249261313U;
#line 373
      words ++;
#line 373
      B = (B << 22) | (B >> 10);
#line 373
      B += C;
#line 373
      break;
    }
#line 374
    while (1) {
#line 374
      tmp___15 = cwp;
#line 374
      cwp ++;
#line 374
      tmp___16 = (uint32_t )*words;
#line 374
      *tmp___15 = tmp___16;
#line 374
      A += ((D ^ (B & (C ^ D))) + tmp___16) + 1770035416U;
#line 374
      words ++;
#line 374
      A = (A << 7) | (A >> 25);
#line 374
      A += B;
#line 374
      break;
    }
#line 375
    while (1) {
#line 375
      tmp___17 = cwp;
#line 375
      cwp ++;
#line 375
      tmp___18 = (uint32_t )*words;
#line 375
      *tmp___17 = tmp___18;
#line 375
      D += ((C ^ (A & (B ^ C))) + tmp___18) + 2336552879U;
#line 375
      words ++;
#line 375
      D = (D << 12) | (D >> 20);
#line 375
      D += A;
#line 375
      break;
    }
#line 376
    while (1) {
#line 376
      tmp___19 = cwp;
#line 376
      cwp ++;
#line 376
      tmp___20 = (uint32_t )*words;
#line 376
      *tmp___19 = tmp___20;
#line 376
      C += ((B ^ (D & (A ^ B))) + tmp___20) + 4294925233U;
#line 376
      words ++;
#line 376
      C = (C << 17) | (C >> 15);
#line 376
      C += D;
#line 376
      break;
    }
#line 377
    while (1) {
#line 377
      tmp___21 = cwp;
#line 377
      cwp ++;
#line 377
      tmp___22 = (uint32_t )*words;
#line 377
      *tmp___21 = tmp___22;
#line 377
      B += ((A ^ (C & (D ^ A))) + tmp___22) + 2304563134U;
#line 377
      words ++;
#line 377
      B = (B << 22) | (B >> 10);
#line 377
      B += C;
#line 377
      break;
    }
#line 378
    while (1) {
#line 378
      tmp___23 = cwp;
#line 378
      cwp ++;
#line 378
      tmp___24 = (uint32_t )*words;
#line 378
      *tmp___23 = tmp___24;
#line 378
      A += ((D ^ (B & (C ^ D))) + tmp___24) + 1804603682U;
#line 378
      words ++;
#line 378
      A = (A << 7) | (A >> 25);
#line 378
      A += B;
#line 378
      break;
    }
#line 379
    while (1) {
#line 379
      tmp___25 = cwp;
#line 379
      cwp ++;
#line 379
      tmp___26 = (uint32_t )*words;
#line 379
      *tmp___25 = tmp___26;
#line 379
      D += ((C ^ (A & (B ^ C))) + tmp___26) + 4254626195U;
#line 379
      words ++;
#line 379
      D = (D << 12) | (D >> 20);
#line 379
      D += A;
#line 379
      break;
    }
#line 380
    while (1) {
#line 380
      tmp___27 = cwp;
#line 380
      cwp ++;
#line 380
      tmp___28 = (uint32_t )*words;
#line 380
      *tmp___27 = tmp___28;
#line 380
      C += ((B ^ (D & (A ^ B))) + tmp___28) + 2792965006U;
#line 380
      words ++;
#line 380
      C = (C << 17) | (C >> 15);
#line 380
      C += D;
#line 380
      break;
    }
#line 381
    while (1) {
#line 381
      tmp___29 = cwp;
#line 381
      cwp ++;
#line 381
      tmp___30 = (uint32_t )*words;
#line 381
      *tmp___29 = tmp___30;
#line 381
      B += ((A ^ (C & (D ^ A))) + tmp___30) + 1236535329U;
#line 381
      words ++;
#line 381
      B = (B << 22) | (B >> 10);
#line 381
      B += C;
#line 381
      break;
    }
#line 397
    while (1) {
#line 397
      A += ((C ^ (D & (B ^ C))) + correct_words[1]) + 4129170786U;
#line 397
      A = (A << 5) | (A >> 27);
#line 397
      A += B;
#line 397
      break;
    }
#line 398
    while (1) {
#line 398
      D += ((B ^ (C & (A ^ B))) + correct_words[6]) + 3225465664U;
#line 398
      D = (D << 9) | (D >> 23);
#line 398
      D += A;
#line 398
      break;
    }
#line 399
    while (1) {
#line 399
      C += ((A ^ (B & (D ^ A))) + correct_words[11]) + 643717713U;
#line 399
      C = (C << 14) | (C >> 18);
#line 399
      C += D;
#line 399
      break;
    }
#line 400
    while (1) {
#line 400
      B += ((D ^ (A & (C ^ D))) + correct_words[0]) + 3921069994U;
#line 400
      B = (B << 20) | (B >> 12);
#line 400
      B += C;
#line 400
      break;
    }
#line 401
    while (1) {
#line 401
      A += ((C ^ (D & (B ^ C))) + correct_words[5]) + 3593408605U;
#line 401
      A = (A << 5) | (A >> 27);
#line 401
      A += B;
#line 401
      break;
    }
#line 402
    while (1) {
#line 402
      D += ((B ^ (C & (A ^ B))) + correct_words[10]) + 38016083U;
#line 402
      D = (D << 9) | (D >> 23);
#line 402
      D += A;
#line 402
      break;
    }
#line 403
    while (1) {
#line 403
      C += ((A ^ (B & (D ^ A))) + correct_words[15]) + 3634488961U;
#line 403
      C = (C << 14) | (C >> 18);
#line 403
      C += D;
#line 403
      break;
    }
#line 404
    while (1) {
#line 404
      B += ((D ^ (A & (C ^ D))) + correct_words[4]) + 3889429448U;
#line 404
      B = (B << 20) | (B >> 12);
#line 404
      B += C;
#line 404
      break;
    }
#line 405
    while (1) {
#line 405
      A += ((C ^ (D & (B ^ C))) + correct_words[9]) + 568446438U;
#line 405
      A = (A << 5) | (A >> 27);
#line 405
      A += B;
#line 405
      break;
    }
#line 406
    while (1) {
#line 406
      D += ((B ^ (C & (A ^ B))) + correct_words[14]) + 3275163606U;
#line 406
      D = (D << 9) | (D >> 23);
#line 406
      D += A;
#line 406
      break;
    }
#line 407
    while (1) {
#line 407
      C += ((A ^ (B & (D ^ A))) + correct_words[3]) + 4107603335U;
#line 407
      C = (C << 14) | (C >> 18);
#line 407
      C += D;
#line 407
      break;
    }
#line 408
    while (1) {
#line 408
      B += ((D ^ (A & (C ^ D))) + correct_words[8]) + 1163531501U;
#line 408
      B = (B << 20) | (B >> 12);
#line 408
      B += C;
#line 408
      break;
    }
#line 409
    while (1) {
#line 409
      A += ((C ^ (D & (B ^ C))) + correct_words[13]) + 2850285829U;
#line 409
      A = (A << 5) | (A >> 27);
#line 409
      A += B;
#line 409
      break;
    }
#line 410
    while (1) {
#line 410
      D += ((B ^ (C & (A ^ B))) + correct_words[2]) + 4243563512U;
#line 410
      D = (D << 9) | (D >> 23);
#line 410
      D += A;
#line 410
      break;
    }
#line 411
    while (1) {
#line 411
      C += ((A ^ (B & (D ^ A))) + correct_words[7]) + 1735328473U;
#line 411
      C = (C << 14) | (C >> 18);
#line 411
      C += D;
#line 411
      break;
    }
#line 412
    while (1) {
#line 412
      B += ((D ^ (A & (C ^ D))) + correct_words[12]) + 2368359562U;
#line 412
      B = (B << 20) | (B >> 12);
#line 412
      B += C;
#line 412
      break;
    }
#line 415
    while (1) {
#line 415
      A += (((B ^ C) ^ D) + correct_words[5]) + 4294588738U;
#line 415
      A = (A << 4) | (A >> 28);
#line 415
      A += B;
#line 415
      break;
    }
#line 416
    while (1) {
#line 416
      D += (((A ^ B) ^ C) + correct_words[8]) + 2272392833U;
#line 416
      D = (D << 11) | (D >> 21);
#line 416
      D += A;
#line 416
      break;
    }
#line 417
    while (1) {
#line 417
      C += (((D ^ A) ^ B) + correct_words[11]) + 1839030562U;
#line 417
      C = (C << 16) | (C >> 16);
#line 417
      C += D;
#line 417
      break;
    }
#line 418
    while (1) {
#line 418
      B += (((C ^ D) ^ A) + correct_words[14]) + 4259657740U;
#line 418
      B = (B << 23) | (B >> 9);
#line 418
      B += C;
#line 418
      break;
    }
#line 419
    while (1) {
#line 419
      A += (((B ^ C) ^ D) + correct_words[1]) + 2763975236U;
#line 419
      A = (A << 4) | (A >> 28);
#line 419
      A += B;
#line 419
      break;
    }
#line 420
    while (1) {
#line 420
      D += (((A ^ B) ^ C) + correct_words[4]) + 1272893353U;
#line 420
      D = (D << 11) | (D >> 21);
#line 420
      D += A;
#line 420
      break;
    }
#line 421
    while (1) {
#line 421
      C += (((D ^ A) ^ B) + correct_words[7]) + 4139469664U;
#line 421
      C = (C << 16) | (C >> 16);
#line 421
      C += D;
#line 421
      break;
    }
#line 422
    while (1) {
#line 422
      B += (((C ^ D) ^ A) + correct_words[10]) + 3200236656U;
#line 422
      B = (B << 23) | (B >> 9);
#line 422
      B += C;
#line 422
      break;
    }
#line 423
    while (1) {
#line 423
      A += (((B ^ C) ^ D) + correct_words[13]) + 681279174U;
#line 423
      A = (A << 4) | (A >> 28);
#line 423
      A += B;
#line 423
      break;
    }
#line 424
    while (1) {
#line 424
      D += (((A ^ B) ^ C) + correct_words[0]) + 3936430074U;
#line 424
      D = (D << 11) | (D >> 21);
#line 424
      D += A;
#line 424
      break;
    }
#line 425
    while (1) {
#line 425
      C += (((D ^ A) ^ B) + correct_words[3]) + 3572445317U;
#line 425
      C = (C << 16) | (C >> 16);
#line 425
      C += D;
#line 425
      break;
    }
#line 426
    while (1) {
#line 426
      B += (((C ^ D) ^ A) + correct_words[6]) + 76029189U;
#line 426
      B = (B << 23) | (B >> 9);
#line 426
      B += C;
#line 426
      break;
    }
#line 427
    while (1) {
#line 427
      A += (((B ^ C) ^ D) + correct_words[9]) + 3654602809U;
#line 427
      A = (A << 4) | (A >> 28);
#line 427
      A += B;
#line 427
      break;
    }
#line 428
    while (1) {
#line 428
      D += (((A ^ B) ^ C) + correct_words[12]) + 3873151461U;
#line 428
      D = (D << 11) | (D >> 21);
#line 428
      D += A;
#line 428
      break;
    }
#line 429
    while (1) {
#line 429
      C += (((D ^ A) ^ B) + correct_words[15]) + 530742520U;
#line 429
      C = (C << 16) | (C >> 16);
#line 429
      C += D;
#line 429
      break;
    }
#line 430
    while (1) {
#line 430
      B += (((C ^ D) ^ A) + correct_words[2]) + 3299628645U;
#line 430
      B = (B << 23) | (B >> 9);
#line 430
      B += C;
#line 430
      break;
    }
#line 433
    while (1) {
#line 433
      A += ((C ^ (B | ~ D)) + correct_words[0]) + 4096336452U;
#line 433
      A = (A << 6) | (A >> 26);
#line 433
      A += B;
#line 433
      break;
    }
#line 434
    while (1) {
#line 434
      D += ((B ^ (A | ~ C)) + correct_words[7]) + 1126891415U;
#line 434
      D = (D << 10) | (D >> 22);
#line 434
      D += A;
#line 434
      break;
    }
#line 435
    while (1) {
#line 435
      C += ((A ^ (D | ~ B)) + correct_words[14]) + 2878612391U;
#line 435
      C = (C << 15) | (C >> 17);
#line 435
      C += D;
#line 435
      break;
    }
#line 436
    while (1) {
#line 436
      B += ((D ^ (C | ~ A)) + correct_words[5]) + 4237533241U;
#line 436
      B = (B << 21) | (B >> 11);
#line 436
      B += C;
#line 436
      break;
    }
#line 437
    while (1) {
#line 437
      A += ((C ^ (B | ~ D)) + correct_words[12]) + 1700485571U;
#line 437
      A = (A << 6) | (A >> 26);
#line 437
      A += B;
#line 437
      break;
    }
#line 438
    while (1) {
#line 438
      D += ((B ^ (A | ~ C)) + correct_words[3]) + 2399980690U;
#line 438
      D = (D << 10) | (D >> 22);
#line 438
      D += A;
#line 438
      break;
    }
#line 439
    while (1) {
#line 439
      C += ((A ^ (D | ~ B)) + correct_words[10]) + 4293915773U;
#line 439
      C = (C << 15) | (C >> 17);
#line 439
      C += D;
#line 439
      break;
    }
#line 440
    while (1) {
#line 440
      B += ((D ^ (C | ~ A)) + correct_words[1]) + 2240044497U;
#line 440
      B = (B << 21) | (B >> 11);
#line 440
      B += C;
#line 440
      break;
    }
#line 441
    while (1) {
#line 441
      A += ((C ^ (B | ~ D)) + correct_words[8]) + 1873313359U;
#line 441
      A = (A << 6) | (A >> 26);
#line 441
      A += B;
#line 441
      break;
    }
#line 442
    while (1) {
#line 442
      D += ((B ^ (A | ~ C)) + correct_words[15]) + 4264355552U;
#line 442
      D = (D << 10) | (D >> 22);
#line 442
      D += A;
#line 442
      break;
    }
#line 443
    while (1) {
#line 443
      C += ((A ^ (D | ~ B)) + correct_words[6]) + 2734768916U;
#line 443
      C = (C << 15) | (C >> 17);
#line 443
      C += D;
#line 443
      break;
    }
#line 444
    while (1) {
#line 444
      B += ((D ^ (C | ~ A)) + correct_words[13]) + 1309151649U;
#line 444
      B = (B << 21) | (B >> 11);
#line 444
      B += C;
#line 444
      break;
    }
#line 445
    while (1) {
#line 445
      A += ((C ^ (B | ~ D)) + correct_words[4]) + 4149444226U;
#line 445
      A = (A << 6) | (A >> 26);
#line 445
      A += B;
#line 445
      break;
    }
#line 446
    while (1) {
#line 446
      D += ((B ^ (A | ~ C)) + correct_words[11]) + 3174756917U;
#line 446
      D = (D << 10) | (D >> 22);
#line 446
      D += A;
#line 446
      break;
    }
#line 447
    while (1) {
#line 447
      C += ((A ^ (D | ~ B)) + correct_words[2]) + 718787259U;
#line 447
      C = (C << 15) | (C >> 17);
#line 447
      C += D;
#line 447
      break;
    }
#line 448
    while (1) {
#line 448
      B += ((D ^ (C | ~ A)) + correct_words[9]) + 3951481745U;
#line 448
      B = (B << 21) | (B >> 11);
#line 448
      B += C;
#line 448
      break;
    }
#line 451
    A += A_save;
#line 452
    B += B_save;
#line 453
    C += C_save;
#line 454
    D += D_save;
  }
#line 458
  ctx->A = A;
#line 459
  ctx->B = B;
#line 460
  ctx->C = C;
#line 461
  ctx->D = D;
#line 462
  return;
}
}
#line 1 "cil-ne2WOtLp.o"
#pragma merger("0","../lib/memcasecmp.o.i","")
#line 22 "/home/wslee/project/coreutils-8.1/lib/memcasecmp.h"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/memcasecmp.c"
int memcasecmp(void const   *vs1 , void const   *vs2 , size_t n ) 
{ 
  size_t i ;
  char const   *s1 ;
  char const   *s2 ;
  unsigned char u1 ;
  unsigned char u2 ;
  int U1 ;
  int tmp ;
  int U2 ;
  int tmp___0 ;
  int diff ;

  {
#line 34
  s1 = (char const   *)vs1;
#line 35
  s2 = (char const   *)vs2;
#line 36
  i = (size_t )0;
#line 36
  while (i < n) {
#line 38
    u1 = (unsigned char )*(s1 + i);
#line 39
    u2 = (unsigned char )*(s2 + i);
#line 40
    tmp = toupper((int )u1);
#line 40
    U1 = tmp;
#line 41
    tmp___0 = toupper((int )u2);
#line 41
    U2 = tmp___0;
#line 42
    diff = U1 - U2;
#line 44
    if (diff) {
#line 45
      return (diff);
    }
#line 36
    i ++;
  }
#line 47
  return (0);
}
}
#line 1 "cil-Lb34rXj9.o"
#pragma merger("0","../lib/memchr2.o.i","")
#line 35 "/home/wslee/project/coreutils-8.1/lib/memchr2.c"
void *memchr2(void const   *s , int c1_in , int c2_in , size_t n ) 
{ 
  unsigned char const   *char_ptr ;
  longword const   *longword_ptr ;
  longword repeated_one ;
  longword repeated_c1 ;
  longword repeated_c2 ;
  unsigned char c1 ;
  unsigned char c2 ;
  void *tmp ;
  size_t i ;
  longword longword1 ;
  longword longword2 ;

  {
#line 53
  c1 = (unsigned char )c1_in;
#line 54
  c2 = (unsigned char )c2_in;
#line 56
  if ((int )c1 == (int )c2) {
#line 57
    tmp = memchr(s, (int )c1, n);
#line 57
    return (tmp);
  }
#line 61
  char_ptr = (unsigned char const   *)s;
#line 61
  while (1) {
#line 61
    if (n > 0UL) {
#line 61
      if (! ((size_t )char_ptr % sizeof(longword ) != 0UL)) {
#line 61
        break;
      }
    } else {
#line 61
      break;
    }
#line 64
    if ((int const   )*char_ptr == (int const   )c1) {
#line 65
      return ((void *)char_ptr);
    } else
#line 64
    if ((int const   )*char_ptr == (int const   )c2) {
#line 65
      return ((void *)char_ptr);
    }
#line 61
    n --;
#line 61
    char_ptr ++;
  }
#line 67
  longword_ptr = (longword const   *)char_ptr;
#line 76
  repeated_one = (longword )16843009;
#line 77
  repeated_c1 = (longword )((int )c1 | ((int )c1 << 8));
#line 78
  repeated_c2 = (longword )((int )c2 | ((int )c2 << 8));
#line 79
  repeated_c1 |= repeated_c1 << 16;
#line 80
  repeated_c2 |= repeated_c2 << 16;
#line 83
  repeated_one |= (repeated_one << 31) << 1;
#line 84
  repeated_c1 |= (repeated_c1 << 31) << 1;
#line 85
  repeated_c2 |= (repeated_c2 << 31) << 1;
#line 86
  if (8UL < sizeof(longword )) {
#line 90
    i = (size_t )64;
#line 90
    while (i < sizeof(longword ) * 8UL) {
#line 92
      repeated_one |= repeated_one << i;
#line 93
      repeated_c1 |= repeated_c1 << i;
#line 94
      repeated_c2 |= repeated_c2 << i;
#line 90
      i *= 2UL;
    }
  }
#line 135
  while (n >= sizeof(longword )) {
#line 137
    longword1 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c1);
#line 138
    longword2 = (longword )(*longword_ptr ^ (unsigned long const   )repeated_c2);
#line 140
    if (((((longword1 - repeated_one) & ~ longword1) | ((longword2 - repeated_one) & ~ longword2)) & (repeated_one << 7)) != 0UL) {
#line 143
      break;
    }
#line 144
    longword_ptr ++;
#line 145
    n -= sizeof(longword );
  }
#line 148
  char_ptr = (unsigned char const   *)longword_ptr;
#line 157
  while (n > 0UL) {
#line 159
    if ((int const   )*char_ptr == (int const   )c1) {
#line 160
      return ((void *)char_ptr);
    } else
#line 159
    if ((int const   )*char_ptr == (int const   )c2) {
#line 160
      return ((void *)char_ptr);
    }
#line 157
    n --;
#line 157
    char_ptr ++;
  }
#line 163
  return ((void *)0);
}
}
#line 1 "cil-YqyGpPVV.o"
#pragma merger("0","../lib/memcmp2.o.i","")
#line 32 "/home/wslee/project/coreutils-8.1/lib/memcmp2.h"
int memcmp2(char const   *s1 , size_t n1 , char const   *s2 , size_t n2 ) ;
#line 24 "/home/wslee/project/coreutils-8.1/lib/memcmp2.c"
int memcmp2(char const   *s1 , size_t n1 , char const   *s2 , size_t n2 ) 
{ 
  int cmp ;
  size_t tmp ;
  int tmp___0 ;

  {
#line 27
  if (n1 <= n2) {
#line 27
    tmp = n1;
  } else {
#line 27
    tmp = n2;
  }
#line 27
  tmp___0 = memcmp((void const   *)s1, (void const   *)s2, tmp);
#line 27
  cmp = tmp___0;
#line 28
  if (cmp == 0) {
#line 30
    if (n1 < n2) {
#line 31
      cmp = -1;
    } else
#line 32
    if (n1 > n2) {
#line 33
      cmp = 1;
    }
  }
#line 35
  return (cmp);
}
}
#line 1 "cil-gxSoN0t9.o"
#pragma merger("0","../lib/memcoll.o.i","")
#line 25 "/home/wslee/project/coreutils-8.1/lib/memcoll.h"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 147 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcoll)(char const   *__s1 ,
                                                                                                char const   *__s2 )  __attribute__((__pure__)) ;
#line 32 "/home/wslee/project/coreutils-8.1/lib/memcoll.c"
int memcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ 
  int diff ;
  int *tmp ;
  char n1 ;
  char n2 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t size1 ;
  size_t tmp___2 ;
  size_t size2 ;
  size_t tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 43
  if (s1len == s2len) {
#line 43
    tmp___7 = memcmp((void const   *)s1, (void const   *)s2, s1len);
#line 43
    if (tmp___7 == 0) {
#line 45
      tmp = __errno_location();
#line 45
      *tmp = 0;
#line 46
      diff = 0;
    } else {
#line 43
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 50
    n1 = *(s1 + s1len);
#line 51
    n2 = *(s2 + s2len);
#line 53
    tmp___0 = s1len;
#line 53
    s1len ++;
#line 53
    *(s1 + tmp___0) = (char )'\000';
#line 54
    tmp___1 = s2len;
#line 54
    s2len ++;
#line 54
    *(s2 + tmp___1) = (char )'\000';
#line 56
    while (1) {
#line 56
      tmp___4 = __errno_location();
#line 56
      *tmp___4 = 0;
#line 56
      diff = strcoll((char const   *)s1, (char const   *)s2);
#line 56
      if (diff) {
#line 56
        tmp___6 = 1;
      } else {
#line 56
        tmp___5 = __errno_location();
#line 56
        if (*tmp___5) {
#line 56
          tmp___6 = 1;
        } else {
#line 56
          tmp___6 = 0;
        }
      }
#line 56
      if (tmp___6) {
#line 56
        break;
      }
#line 61
      tmp___2 = strlen((char const   *)s1);
#line 61
      size1 = tmp___2 + 1UL;
#line 62
      tmp___3 = strlen((char const   *)s2);
#line 62
      size2 = tmp___3 + 1UL;
#line 63
      s1 += size1;
#line 64
      s2 += size2;
#line 65
      s1len -= size1;
#line 66
      s2len -= size2;
#line 68
      if (s1len == 0UL) {
#line 70
        if (s2len != 0UL) {
#line 71
          diff = -1;
        }
#line 72
        break;
      } else
#line 74
      if (s2len == 0UL) {
#line 76
        diff = 1;
#line 77
        break;
      }
    }
#line 81
    *(s1 + (s1len - 1UL)) = n1;
#line 82
    *(s2 + (s2len - 1UL)) = n2;
  }
#line 94
  return (diff);
}
}
#line 1 "cil-lH1qz2SM.o"
#pragma merger("0","../lib/memxfrm.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/memxfrm.h"
size_t memxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
               size_t srcsize ) ;
#line 150 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(2), __leaf__)) strxfrm)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 41 "/home/wslee/project/coreutils-8.1/lib/memxfrm.c"
size_t memxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
               size_t srcsize ) 
{ 
  size_t di ;
  size_t si ;
  size_t result ;
  char ch ;
  size_t slen ;
  size_t tmp ;
  size_t result0 ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  size_t bufsize___0 ;
  char stackbuf[4000] ;
  char *buf___0 ;
  void *tmp___4 ;
  int *tmp___5 ;

  {
#line 47
  di = (size_t )0;
#line 48
  si = (size_t )0;
#line 49
  result = (size_t )0;
#line 51
  ch = *(src + srcsize);
#line 52
  *(src + srcsize) = (char )'\000';
#line 54
  while (si < srcsize) {
#line 56
    tmp = strlen((char const   *)(src + si));
#line 56
    slen = tmp;
#line 58
    result0 = result;
#line 59
    tmp___0 = __errno_location();
#line 59
    *tmp___0 = 0;
#line 60
    tmp___1 = strxfrm(dest + di, (char const   * __restrict  )(src + si), destsize - di);
#line 60
    result += tmp___1 + 1UL;
#line 61
    tmp___2 = __errno_location();
#line 61
    if (*tmp___2 != 0) {
#line 62
      break;
    }
#line 63
    if (result <= result0) {
#line 65
      tmp___3 = __errno_location();
#line 65
      *tmp___3 = 34;
#line 66
      break;
    }
#line 69
    if (result == destsize + 1UL) {
#line 69
      if (si + slen == srcsize) {
#line 74
        bufsize___0 = (destsize - di) + 1UL;
#line 76
        buf___0 = stackbuf;
#line 77
        if (sizeof(stackbuf) < bufsize___0) {
#line 79
          tmp___4 = malloc(bufsize___0);
#line 79
          buf___0 = (char *)tmp___4;
#line 80
          if (! buf___0) {
#line 81
            break;
          }
        }
#line 83
        strxfrm((char * __restrict  )buf___0, (char const   * __restrict  )(src + si),
                bufsize___0);
#line 84
        memcpy((void * __restrict  )(dest + di), (void const   * __restrict  )buf___0,
               destsize - di);
#line 85
        if (sizeof(stackbuf) < bufsize___0) {
#line 86
          free((void *)buf___0);
        }
#line 87
        tmp___5 = __errno_location();
#line 87
        *tmp___5 = 0;
      }
    }
#line 90
    if (result < destsize) {
#line 90
      di = result;
    } else {
#line 90
      di = destsize;
    }
#line 91
    si += slen + 1UL;
  }
#line 94
  *(src + srcsize) = ch;
#line 95
  return (result - (size_t )(si != srcsize));
}
}
#line 1 "cil-DUn6ySZv.o"
#pragma merger("0","../lib/mgetgroups.o.i","")
#line 19 "/home/wslee/project/coreutils-8.1/lib/mgetgroups.h"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) ;
#line 692 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getgroups)(int __size ,
                                                                                __gid_t *__list ) ;
#line 187 "/usr/include/grp.h"
extern int getgrouplist(char const   *__user , __gid_t __group , __gid_t *__groups ,
                        int *__ngroups ) ;
#line 36 "/home/wslee/project/coreutils-8.1/lib/mgetgroups.c"
static gid_t *realloc_groupbuf(gid_t *g , size_t num ) 
{ 
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 39
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 39
    tmp___0 = -1;
  } else {
#line 39
    tmp___0 = -2;
  }
#line 39
  if ((size_t )tmp___0 / sizeof(*g) < num) {
#line 41
    tmp = __errno_location();
#line 41
    *tmp = 12;
#line 42
    return ((gid_t *)((void *)0));
  }
#line 45
  tmp___1 = realloc((void *)g, num * sizeof(*g));
#line 45
  return ((gid_t *)tmp___1);
}
}
#line 58 "/home/wslee/project/coreutils-8.1/lib/mgetgroups.c"
int mgetgroups(char const   *username , gid_t gid , gid_t **groups ) 
{ 
  int max_n_groups ;
  int ng ;
  gid_t *g ;
  gid_t *h ;
  int last_n_groups ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int saved_errno___0 ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 74
  if (username) {
#line 77
    max_n_groups = 10;
#line 79
    g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
#line 80
    if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 81
      return (-1);
    }
#line 83
    while (1) {
#line 86
      last_n_groups = max_n_groups;
#line 89
      ng = getgrouplist(username, gid, g, & max_n_groups);
#line 93
      if (ng < 0) {
#line 93
        if (last_n_groups == max_n_groups) {
#line 94
          max_n_groups *= 2;
        }
      }
#line 96
      h = realloc_groupbuf(g, (size_t )max_n_groups);
#line 96
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 98
        tmp = __errno_location();
#line 98
        saved_errno = *tmp;
#line 99
        free((void *)g);
#line 100
        tmp___0 = __errno_location();
#line 100
        *tmp___0 = saved_errno;
#line 101
        return (-1);
      }
#line 103
      g = h;
#line 105
      if (0 <= ng) {
#line 107
        *groups = g;
#line 110
        return (max_n_groups);
      }
    }
  }
#line 117
  if (username) {
#line 117
    tmp___1 = getugroups(0, (gid_t *)((void *)0), username, gid);
#line 117
    max_n_groups = tmp___1;
  } else {
#line 117
    tmp___2 = getgroups(0, (__gid_t *)((void *)0));
#line 117
    max_n_groups = tmp___2 + (gid != 4294967295U);
  }
#line 123
  if (max_n_groups < 0) {
#line 124
    max_n_groups = 5;
  }
#line 126
  g = realloc_groupbuf((gid_t *)((void *)0), (size_t )max_n_groups);
#line 127
  if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 128
    return (-1);
  }
#line 130
  if (username) {
#line 130
    tmp___3 = getugroups(max_n_groups, g, username, gid);
#line 130
    ng = tmp___3;
  } else {
#line 130
    tmp___4 = getgroups(max_n_groups, g + (gid != 4294967295U));
#line 130
    ng = tmp___4;
  }
#line 134
  if (ng < 0) {
#line 136
    tmp___5 = __errno_location();
#line 136
    saved_errno___0 = *tmp___5;
#line 137
    free((void *)g);
#line 138
    tmp___6 = __errno_location();
#line 138
    *tmp___6 = saved_errno___0;
#line 139
    return (-1);
  }
#line 142
  if (! username) {
#line 142
    if (gid != 4294967295U) {
#line 144
      *g = gid;
#line 145
      ng ++;
    }
  }
#line 147
  *groups = g;
#line 148
  return (ng);
}
}
#line 1 "cil-70c0vT7c.o"
#pragma merger("0","../lib/mkancesdirs.o.i","")
#line 3 "/home/wslee/project/coreutils-8.1/lib/mkancesdirs.h"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) ;
#line 108 "/home/wslee/project/coreutils-8.1/lib/savewd.h"
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) ;
#line 66 "/home/wslee/project/coreutils-8.1/lib/mkancesdirs.c"
ptrdiff_t mkancesdirs(char *file , struct savewd *wd , int (*make_dir)(char const   * ,
                                                                       char const   * ,
                                                                       void * ) ,
                      void *make_dir_arg ) 
{ 
  char *sep ;
  char *component ;
  char *p ;
  char c ;
  _Bool made_dir ;
  int make_dir_errno ;
  int savewd_chdir_options ;
  int chdir_result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 74
  sep = (char *)((void *)0);
#line 78
  component = file;
#line 80
  p = file + 0;
#line 82
  made_dir = (_Bool)0;
#line 90
  while (1) {
#line 90
    tmp___3 = p;
#line 90
    p ++;
#line 90
    c = *tmp___3;
#line 90
    if (! c) {
#line 90
      break;
    }
#line 91
    if ((int )*p == 47) {
#line 93
      if (! ((int )c == 47)) {
#line 94
        sep = p;
      }
    } else
#line 96
    if ((int )c == 47) {
#line 96
      if (*p) {
#line 96
        if (sep) {
#line 100
          if (sep - component == 1L) {
#line 100
            if (! ((int )*(component + 0) == 46)) {
#line 100
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 102
            make_dir_errno = 0;
#line 103
            savewd_chdir_options = 0;
#line 108
            *sep = (char )'\000';
#line 112
            if (sep - component == 2L) {
#line 112
              if ((int )*(component + 0) == 46) {
#line 112
                if ((int )*(component + 1) == 46) {
#line 114
                  made_dir = (_Bool)0;
                } else {
#line 112
                  goto _L___0;
                }
              } else {
#line 112
                goto _L___0;
              }
            } else {
              _L___0: /* CIL Label */ 
#line 116
              tmp = (*make_dir)((char const   *)file, (char const   *)component, make_dir_arg);
#line 116
              switch (tmp) {
              case -1: 
#line 119
              tmp___0 = __errno_location();
#line 119
              make_dir_errno = *tmp___0;
#line 120
              break;
              case 0: 
#line 123
              savewd_chdir_options |= 2;
              case 1: 
#line 126
              made_dir = (_Bool)1;
#line 127
              break;
              }
            }
#line 130
            if (made_dir) {
#line 131
              savewd_chdir_options |= 1;
            }
#line 133
            chdir_result = savewd_chdir(wd, (char const   *)component, savewd_chdir_options,
                                        (int *)((void *)0));
#line 138
            if (chdir_result != -1) {
#line 139
              *sep = (char )'/';
            }
#line 141
            if (chdir_result != 0) {
#line 143
              if (make_dir_errno != 0) {
#line 143
                tmp___2 = __errno_location();
#line 143
                if (*tmp___2 == 2) {
#line 144
                  tmp___1 = __errno_location();
#line 144
                  *tmp___1 = make_dir_errno;
                }
              }
#line 145
              return ((ptrdiff_t )chdir_result);
            }
          }
#line 149
          component = p;
        }
      }
    }
  }
#line 152
  return (component - file);
}
}
#line 1 "cil-8z8mcgBq.o"
#pragma merger("0","../lib/mkdir-p.o.i","")
#line 25 "/home/wslee/project/coreutils-8.1/lib/mkdir-p.h"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) ;
#line 320 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 120 "/home/wslee/project/coreutils-8.1/lib/savewd.h"
__inline static int savewd_errno(struct savewd  const  *wd ) 
{ 
  int tmp ;

  {
#line 123
  if ((unsigned int const   )wd->state == 4U) {
#line 123
    tmp = wd->val.errnum;
  } else {
#line 123
    tmp = (int const   )0;
  }
#line 123
  return ((int )tmp);
}
}
#line 85 "/home/wslee/project/coreutils-8.1/lib/mkdir-p.c"
_Bool make_dir_parents(char *dir , struct savewd *wd , int (*make_ancestor)(char const   * ,
                                                                            char const   * ,
                                                                            void * ) ,
                       void *options , mode_t mode , void (*announce)(char const   * ,
                                                                      void * ) , mode_t mode_bits ,
                       uid_t owner , gid_t group , _Bool preserve_existing ) 
{ 
  int mkdir_errno ;
  int tmp ;
  int tmp___0 ;
  ptrdiff_t prefix_len ;
  int savewd_chdir_options ;
  int *tmp___1 ;
  _Bool keep_owner ;
  int tmp___2 ;
  _Bool keep_special_mode_bits ;
  mode_t mkdir_mode ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  struct stat st ;
  int tmp___6 ;
  int open_result[2] ;
  int chdir_result ;
  int tmp___7 ;
  _Bool chdir_ok ;
  int chdir_errno ;
  int *tmp___8 ;
  int fd ;
  _Bool chdir_failed_unexpectedly ;
  int tmp___9 ;
  char const   *subdir ;
  char const   *tmp___10 ;
  int tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  char const   *tmp___19 ;
  char *tmp___20 ;

  {
#line 97
  if ((int )*(dir + 0) == 47) {
#line 97
    tmp___0 = 0;
  } else {
#line 97
    tmp = savewd_errno((struct savewd  const  *)wd);
#line 97
    tmp___0 = tmp;
  }
#line 97
  mkdir_errno = tmp___0;
#line 99
  if (mkdir_errno == 0) {
#line 101
    prefix_len = (ptrdiff_t )0;
#line 102
    savewd_chdir_options = 4;
#line 104
    if (make_ancestor) {
#line 106
      prefix_len = mkancesdirs(dir, wd, make_ancestor, options);
#line 107
      if (prefix_len < 0L) {
#line 109
        if (prefix_len < -1L) {
#line 110
          return ((_Bool)1);
        }
#line 111
        tmp___1 = __errno_location();
#line 111
        mkdir_errno = *tmp___1;
      }
    }
#line 115
    if (0L <= prefix_len) {
#line 122
      if (owner == 4294967295U) {
#line 122
        if (group == 4294967295U) {
#line 122
          tmp___2 = 1;
        } else {
#line 122
          tmp___2 = 0;
        }
      } else {
#line 122
        tmp___2 = 0;
      }
#line 122
      keep_owner = (_Bool )tmp___2;
#line 123
      keep_special_mode_bits = (_Bool )(((mode_bits & 3072U) | (mode & 512U)) == 0U);
#line 125
      mkdir_mode = mode;
#line 126
      if (! keep_owner) {
#line 127
        mkdir_mode &= (unsigned int )(~ ((448 >> 3) | ((448 >> 3) >> 3)));
      } else
#line 128
      if (! keep_special_mode_bits) {
#line 129
        mkdir_mode &= (unsigned int )(~ ((128 >> 3) | ((128 >> 3) >> 3)));
      }
#line 131
      tmp___5 = mkdir((char const   *)(dir + prefix_len), mkdir_mode);
#line 131
      if (tmp___5 == 0) {
#line 133
        (*announce)((char const   *)dir, options);
#line 134
        preserve_existing = (_Bool )((int )keep_owner & (int )keep_special_mode_bits);
#line 135
        if (mode & 256U) {
#line 135
          tmp___3 = 2;
        } else {
#line 135
          tmp___3 = 0;
        }
#line 135
        savewd_chdir_options |= 1 | tmp___3;
      } else {
#line 141
        tmp___4 = __errno_location();
#line 141
        mkdir_errno = *tmp___4;
#line 142
        mkdir_mode = (mode_t )-1;
      }
#line 145
      if (preserve_existing) {
#line 148
        if (mkdir_errno == 0) {
#line 152
          return ((_Bool)1);
        } else
#line 148
        if (mkdir_errno != 2) {
#line 148
          if (make_ancestor) {
#line 148
            tmp___6 = stat((char const   * __restrict  )(dir + prefix_len), (struct stat * __restrict  )(& st));
#line 148
            if (tmp___6 == 0) {
#line 148
              if ((st.st_mode & 61440U) == 16384U) {
#line 152
                return ((_Bool)1);
              }
            }
          }
        }
      } else {
#line 157
        tmp___7 = savewd_chdir(wd, (char const   *)(dir + prefix_len), savewd_chdir_options,
                               (int *)(open_result));
#line 157
        chdir_result = tmp___7;
#line 160
        if (chdir_result < -1) {
#line 161
          return ((_Bool)1);
        } else {
#line 164
          chdir_ok = (_Bool )(chdir_result == 0);
#line 165
          tmp___8 = __errno_location();
#line 165
          chdir_errno = *tmp___8;
#line 166
          fd = open_result[0];
#line 167
          if (mkdir_errno == 0) {
#line 167
            if (! chdir_ok) {
#line 167
              if (mode & 64U) {
#line 167
                tmp___9 = 1;
              } else {
#line 167
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 167
            if (fd < 0) {
#line 167
              if (mode & 256U) {
#line 167
                tmp___9 = 1;
              } else {
#line 167
                tmp___9 = 0;
              }
            } else {
#line 167
              tmp___9 = 0;
            }
          } else {
#line 167
            tmp___9 = 0;
          }
#line 167
          chdir_failed_unexpectedly = (_Bool )tmp___9;
#line 172
          if (chdir_failed_unexpectedly) {
#line 175
            if (0 <= fd) {
#line 176
              close(fd);
            }
          } else {
#line 180
            if (chdir_ok) {
#line 180
              tmp___10 = ".";
            } else {
#line 180
              tmp___10 = (char const   *)(dir + prefix_len);
            }
#line 180
            subdir = tmp___10;
#line 181
            tmp___11 = dirchownmod(fd, subdir, mkdir_mode, owner, group, mode, mode_bits);
#line 181
            if (tmp___11 == 0) {
#line 184
              return ((_Bool)1);
            }
          }
#line 187
          if (mkdir_errno == 0) {
#line 187
            goto _L___0;
          } else
#line 187
          if (mkdir_errno != 2) {
#line 187
            if (make_ancestor) {
#line 187
              tmp___18 = __errno_location();
#line 187
              if (*tmp___18 != 20) {
                _L___0: /* CIL Label */ 
#line 191
                tmp___12 = quote((char const   *)dir);
#line 191
                if (keep_owner) {
#line 191
                  tmp___13 = "cannot change permissions of %s";
                } else {
#line 191
                  tmp___13 = "cannot change owner and permissions of %s";
                }
#line 191
                tmp___14 = gettext(tmp___13);
#line 191
                if (! chdir_failed_unexpectedly) {
#line 191
                  tmp___15 = __errno_location();
#line 191
                  tmp___17 = *tmp___15;
                } else {
#line 191
                  if (! chdir_ok) {
#line 191
                    if (mode & 64U) {
#line 191
                      tmp___16 = chdir_errno;
                    } else {
#line 191
                      tmp___16 = open_result[1];
                    }
                  } else {
#line 191
                    tmp___16 = open_result[1];
                  }
#line 191
                  tmp___17 = tmp___16;
                }
#line 191
                error(0, tmp___17, (char const   *)tmp___14, tmp___12);
#line 199
                return ((_Bool)0);
              }
            }
          }
        }
      }
    }
  }
#line 206
  tmp___19 = quote((char const   *)dir);
#line 206
  tmp___20 = gettext("cannot create directory %s");
#line 206
  error(0, mkdir_errno, (char const   *)tmp___20, tmp___19);
#line 207
  return ((_Bool)0);
}
}
#line 1 "cil-iWKNhNie.o"
#pragma merger("0","../lib/mkstemp-safer.o.i","")
#line 20 "/home/wslee/project/coreutils-8.1/lib/stdlib-safer.h"
int mkstemp_safer(char *templ ) ;
#line 619 "/usr/include/stdlib.h"
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/mkstemp-safer.c"
int mkstemp_safer(char *templ ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 33
  tmp = mkstemp(templ);
#line 33
  tmp___0 = fd_safer(tmp);
#line 33
  return (tmp___0);
}
}
#line 1 "cil-8bnkDzRu.o"
#pragma merger("0","../lib/modechange.o.i","")
#line 25 "/home/wslee/project/coreutils-8.1/lib/modechange.h"
struct mode_change *mode_compile(char const   *mode_string ) ;
#line 26
struct mode_change *mode_create_from_ref(char const   *ref_file ) ;
#line 27
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) ;
#line 119 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 120
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 120 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s ) 
{ 
  int tmp ;
  void *tmp___0 ;

  {
#line 123
  if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 123
    tmp = -1;
  } else {
#line 123
    tmp = -2;
  }
#line 123
  if ((size_t )tmp / s < n) {
#line 124
    xalloc_die();
  }
#line 125
  tmp___0 = xmalloc(n * s);
#line 125
  return (tmp___0);
}
}
#line 53 "/home/wslee/project/coreutils-8.1/lib/modechange.c"
static mode_t octal_to_mode(unsigned int octal ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  unsigned int tmp___11 ;

  {
#line 58
  if (256 >> 3 == 32) {
#line 58
    if (128 >> 3 == 16) {
#line 58
      if (64 >> 3 == 8) {
#line 58
        if ((256 >> 3) >> 3 == 4) {
#line 58
          if ((128 >> 3) >> 3 == 2) {
#line 58
            if ((64 >> 3) >> 3 == 1) {
#line 58
              tmp___11 = octal;
            } else {
#line 58
              goto _L___3;
            }
          } else {
#line 58
            goto _L___3;
          }
        } else {
#line 58
          goto _L___3;
        }
      } else {
#line 58
        goto _L___3;
      }
    } else {
#line 58
      goto _L___3;
    }
  } else {
    _L___3: /* CIL Label */ 
#line 58
    if (octal & 2048U) {
#line 58
      tmp = 2048;
    } else {
#line 58
      tmp = 0;
    }
#line 58
    if (octal & 1024U) {
#line 58
      tmp___0 = 1024;
    } else {
#line 58
      tmp___0 = 0;
    }
#line 58
    if (octal & 512U) {
#line 58
      tmp___1 = 512;
    } else {
#line 58
      tmp___1 = 0;
    }
#line 58
    if (octal & 256U) {
#line 58
      tmp___2 = 256;
    } else {
#line 58
      tmp___2 = 0;
    }
#line 58
    if (octal & 128U) {
#line 58
      tmp___3 = 128;
    } else {
#line 58
      tmp___3 = 0;
    }
#line 58
    if (octal & 64U) {
#line 58
      tmp___4 = 64;
    } else {
#line 58
      tmp___4 = 0;
    }
#line 58
    if (octal & 32U) {
#line 58
      tmp___5 = 256 >> 3;
    } else {
#line 58
      tmp___5 = 0;
    }
#line 58
    if (octal & 16U) {
#line 58
      tmp___6 = 128 >> 3;
    } else {
#line 58
      tmp___6 = 0;
    }
#line 58
    if (octal & 8U) {
#line 58
      tmp___7 = 64 >> 3;
    } else {
#line 58
      tmp___7 = 0;
    }
#line 58
    if (octal & 4U) {
#line 58
      tmp___8 = (256 >> 3) >> 3;
    } else {
#line 58
      tmp___8 = 0;
    }
#line 58
    if (octal & 2U) {
#line 58
      tmp___9 = (128 >> 3) >> 3;
    } else {
#line 58
      tmp___9 = 0;
    }
#line 58
    if (octal & 1U) {
#line 58
      tmp___10 = (64 >> 3) >> 3;
    } else {
#line 58
      tmp___10 = 0;
    }
#line 58
    tmp___11 = (mode_t )(((((((((((tmp | tmp___0) | tmp___1) | tmp___2) | tmp___3) | tmp___4) | tmp___5) | tmp___6) | tmp___7) | tmp___8) | tmp___9) | tmp___10);
  }
#line 58
  return (tmp___11);
}
}
#line 111 "/home/wslee/project/coreutils-8.1/lib/modechange.c"
static struct mode_change *make_node_op_equals(mode_t new_mode , mode_t mentioned ) 
{ 
  struct mode_change *p ;
  void *tmp ;

  {
#line 114
  tmp = xmalloc(2UL * sizeof(*p));
#line 114
  p = (struct mode_change *)tmp;
#line 115
  p->op = (char )'=';
#line 116
  p->flag = (char)1;
#line 117
  p->affected = (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 118
  p->value = new_mode;
#line 119
  p->mentioned = mentioned;
#line 120
  (p + 1)->flag = (char)0;
#line 121
  return (p);
}
}
#line 133 "/home/wslee/project/coreutils-8.1/lib/modechange.c"
struct mode_change *mode_compile(char const   *mode_string ) 
{ 
  struct mode_change *mc ;
  size_t used ;
  unsigned int octal_mode ;
  mode_t mode ;
  mode_t mentioned ;
  char const   *tmp ;
  struct mode_change *tmp___0 ;
  size_t needed ;
  char const   *p ;
  int tmp___1 ;
  void *tmp___2 ;
  mode_t affected ;
  char op ;
  char const   *tmp___3 ;
  mode_t value ;
  char flag ;
  struct mode_change *change ;
  char const   *tmp___4 ;
  size_t tmp___5 ;

  {
#line 138
  used = (size_t )0;
#line 140
  if (48 <= (int )*mode_string) {
#line 140
    if ((int const   )*mode_string < 56) {
#line 142
      octal_mode = 0U;
#line 146
      while (1) {
#line 148
        tmp = mode_string;
#line 148
        mode_string ++;
#line 148
        octal_mode = (8U * octal_mode + (unsigned int )*tmp) - 48U;
#line 149
        if (4095U < octal_mode) {
#line 150
          return ((struct mode_change *)((void *)0));
        }
#line 146
        if (48 <= (int )*mode_string) {
#line 146
          if (! ((int const   )*mode_string < 56)) {
#line 146
            break;
          }
        } else {
#line 146
          break;
        }
      }
#line 154
      if (*mode_string) {
#line 155
        return ((struct mode_change *)((void *)0));
      }
#line 157
      mode = octal_to_mode(octal_mode);
#line 158
      mentioned = ((mode & 3072U) | 512U) | (unsigned int )((448 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 159
      tmp___0 = make_node_op_equals(mode, mentioned);
#line 159
      return (tmp___0);
    }
  }
#line 164
  needed = (size_t )1;
#line 166
  p = mode_string;
#line 166
  while (*p) {
#line 167
    if ((int const   )*p == 61) {
#line 167
      tmp___1 = 1;
    } else
#line 167
    if ((int const   )*p == 43) {
#line 167
      tmp___1 = 1;
    } else
#line 167
    if ((int const   )*p == 45) {
#line 167
      tmp___1 = 1;
    } else {
#line 167
      tmp___1 = 0;
    }
#line 167
    needed += (size_t )tmp___1;
#line 166
    p ++;
  }
#line 168
  tmp___2 = xnmalloc(needed, sizeof(*mc));
#line 168
  mc = (struct mode_change *)tmp___2;
#line 172
  while (1) {
#line 175
    affected = (mode_t )0;
#line 178
    while (1) {
#line 179
      switch ((int const   )*mode_string) {
      default: 
#line 182
      goto invalid;
      case 117: 
#line 184
      affected |= 2496U;
#line 185
      break;
      case 103: 
#line 187
      affected |= (unsigned int )(1024 | (448 >> 3));
#line 188
      break;
      case 111: 
#line 190
      affected |= (unsigned int )(512 | ((448 >> 3) >> 3));
#line 191
      break;
      case 97: 
#line 193
      affected |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 194
      break;
      case 45: 
      case 43: 
      case 61: 
#line 196
      goto no_more_affected;
      }
#line 178
      mode_string ++;
    }
    no_more_affected: ;
#line 200
    while (1) {
#line 202
      tmp___3 = mode_string;
#line 202
      mode_string ++;
#line 202
      op = (char )*tmp___3;
#line 204
      flag = (char)3;
#line 207
      tmp___4 = mode_string;
#line 207
      mode_string ++;
#line 207
      switch ((int const   )*tmp___4) {
      case 117: 
#line 212
      value = (mode_t )448;
#line 213
      break;
      case 103: 
#line 217
      value = (mode_t )(448 >> 3);
#line 218
      break;
      case 111: 
#line 222
      value = (mode_t )((448 >> 3) >> 3);
#line 223
      break;
      default: 
#line 226
      value = (mode_t )0;
#line 227
      flag = (char)1;
#line 229
      mode_string --;
#line 229
      while (1) {
#line 230
        switch ((int const   )*mode_string) {
        case 114: 
#line 233
        value |= (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3));
#line 234
        break;
        case 119: 
#line 236
        value |= (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3));
#line 237
        break;
        case 120: 
#line 239
        value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
#line 240
        break;
        case 88: 
#line 242
        flag = (char)2;
#line 243
        break;
        case 115: 
#line 246
        value |= 3072U;
#line 247
        break;
        case 116: 
#line 250
        value |= 512U;
#line 251
        break;
        default: 
#line 253
        goto no_more_values;
        }
#line 229
        mode_string ++;
      }
      no_more_values: ;
      }
#line 258
      tmp___5 = used;
#line 258
      used ++;
#line 258
      change = mc + tmp___5;
#line 259
      change->op = op;
#line 260
      change->flag = flag;
#line 261
      change->affected = affected;
#line 262
      change->value = value;
#line 263
      if (affected) {
#line 263
        change->mentioned = affected & value;
      } else {
#line 263
        change->mentioned = value;
      }
#line 200
      if (! ((int const   )*mode_string == 61)) {
#line 200
        if (! ((int const   )*mode_string == 43)) {
#line 200
          if (! ((int const   )*mode_string == 45)) {
#line 200
            break;
          }
        }
      }
    }
#line 268
    if ((int const   )*mode_string != 44) {
#line 269
      break;
    }
#line 172
    mode_string ++;
  }
#line 272
  if ((int const   )*mode_string == 0) {
#line 274
    (mc + used)->flag = (char)0;
#line 275
    return (mc);
  }
  invalid: 
#line 279
  free((void *)mc);
#line 280
  return ((struct mode_change *)((void *)0));
}
}
#line 286 "/home/wslee/project/coreutils-8.1/lib/modechange.c"
struct mode_change *mode_create_from_ref(char const   *ref_file ) 
{ 
  struct stat ref_stats ;
  int tmp ;
  struct mode_change *tmp___0 ;

  {
#line 291
  tmp = stat((char const   * __restrict  )ref_file, (struct stat * __restrict  )(& ref_stats));
#line 291
  if (tmp != 0) {
#line 292
    return ((struct mode_change *)((void *)0));
  }
#line 293
  tmp___0 = make_node_op_equals(ref_stats.st_mode, (mode_t )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)));
#line 293
  return (tmp___0);
}
}
#line 309 "/home/wslee/project/coreutils-8.1/lib/modechange.c"
mode_t mode_adjust(mode_t oldmode , _Bool dir , mode_t umask_value , struct mode_change  const  *changes ,
                   mode_t *pmode_bits ) 
{ 
  mode_t newmode ;
  mode_t mode_bits ;
  mode_t affected ;
  mode_t omit_change ;
  int tmp ;
  mode_t value ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  mode_t tmp___3 ;
  mode_t preserved ;
  mode_t tmp___4 ;

  {
#line 314
  newmode = oldmode & (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3));
#line 317
  mode_bits = (mode_t )0;
#line 319
  while ((int const   )changes->flag != 0) {
#line 321
    affected = (mode_t )changes->affected;
#line 322
    if (dir) {
#line 322
      tmp = 3072;
    } else {
#line 322
      tmp = 0;
    }
#line 322
    omit_change = (mode_t )((unsigned int const   )tmp & ~ changes->mentioned);
#line 324
    value = (mode_t )changes->value;
#line 326
    switch ((int const   )changes->flag) {
    case 1: 
#line 329
    break;
    case 3: 
#line 333
    value &= newmode;
#line 336
    if (value & (unsigned int )((256 | (256 >> 3)) | ((256 >> 3) >> 3))) {
#line 336
      tmp___0 = (256 | (256 >> 3)) | ((256 >> 3) >> 3);
    } else {
#line 336
      tmp___0 = 0;
    }
#line 336
    if (value & (unsigned int )((128 | (128 >> 3)) | ((128 >> 3) >> 3))) {
#line 336
      tmp___1 = (128 | (128 >> 3)) | ((128 >> 3) >> 3);
    } else {
#line 336
      tmp___1 = 0;
    }
#line 336
    if (value & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) {
#line 336
      tmp___2 = (64 | (64 >> 3)) | ((64 >> 3) >> 3);
    } else {
#line 336
      tmp___2 = 0;
    }
#line 336
    value |= (unsigned int )((tmp___0 | tmp___1) | tmp___2);
#line 342
    break;
    case 2: 
#line 347
    if ((newmode & (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3))) | (unsigned int )dir) {
#line 348
      value |= (unsigned int )((64 | (64 >> 3)) | ((64 >> 3) >> 3));
    }
#line 349
    break;
    }
#line 355
    if (affected) {
#line 355
      tmp___3 = affected;
    } else {
#line 355
      tmp___3 = ~ umask_value;
    }
#line 355
    value &= tmp___3 & ~ omit_change;
#line 357
    switch ((int const   )changes->op) {
    case 61: 
#line 364
    if (affected) {
#line 364
      tmp___4 = ~ affected;
    } else {
#line 364
      tmp___4 = (mode_t )0;
    }
#line 364
    preserved = tmp___4 | omit_change;
#line 365
    mode_bits |= (unsigned int )((4032 | (448 >> 3)) | ((448 >> 3) >> 3)) & ~ preserved;
#line 366
    newmode = (newmode & preserved) | value;
#line 367
    break;
    case 43: 
#line 371
    mode_bits |= value;
#line 372
    newmode |= value;
#line 373
    break;
    case 45: 
#line 376
    mode_bits |= value;
#line 377
    newmode &= ~ value;
#line 378
    break;
    }
#line 319
    changes ++;
  }
#line 382
  if (pmode_bits) {
#line 383
    *pmode_bits = mode_bits;
  }
#line 384
  return (newmode);
}
}
#line 1 "cil-yrN83pp8.o"
#pragma merger("0","../lib/mountlist.o.i","")
#line 38 "/home/wslee/project/coreutils-8.1/lib/mountlist.h"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) ;
#line 66 "/usr/include/mntent.h"
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) setmntent)(char const   *__file ,
                                                                                  char const   *__mode ) ;
#line 71
extern  __attribute__((__nothrow__)) struct mntent *( __attribute__((__leaf__)) getmntent)(FILE *__stream ) ;
#line 87
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) endmntent)(FILE *__stream ) ;
#line 299 "/home/wslee/project/coreutils-8.1/lib/mountlist.c"
static dev_t dev_from_mount_options(char const   *mount_options ) 
{ 


  {
#line 326
  return ((dev_t )-1);
}
}
#line 336 "/home/wslee/project/coreutils-8.1/lib/mountlist.c"
struct mount_entry *read_file_system_list(_Bool need_fs_type ) 
{ 
  struct mount_entry *mount_list ;
  struct mount_entry *me ;
  struct mount_entry **mtail ;
  struct mntent *mnt ;
  char const   *table ;
  FILE *fp ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int saved_errno ;
  int *tmp___12 ;
  int *tmp___13 ;

  {
#line 341
  mtail = & mount_list;
#line 377
  table = "/etc/mtab";
#line 380
  fp = setmntent(table, "r");
#line 381
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
#line 382
    return ((struct mount_entry *)((void *)0));
  }
#line 384
  while (1) {
#line 384
    mnt = getmntent(fp);
#line 384
    if (! mnt) {
#line 384
      break;
    }
#line 386
    tmp = xmalloc(sizeof(*me));
#line 386
    me = (struct mount_entry *)tmp;
#line 387
    me->me_devname = xstrdup((char const   *)mnt->mnt_fsname);
#line 388
    me->me_mountdir = xstrdup((char const   *)mnt->mnt_dir);
#line 389
    me->me_type = xstrdup((char const   *)mnt->mnt_type);
#line 390
    me->me_type_malloced = 1U;
#line 391
    tmp___0 = strcmp((char const   *)me->me_type, "autofs");
#line 391
    if (tmp___0 == 0) {
#line 391
      tmp___6 = 1;
    } else {
#line 391
      tmp___1 = strcmp((char const   *)me->me_type, "none");
#line 391
      if (tmp___1 == 0) {
#line 391
        tmp___6 = 1;
      } else {
#line 391
        tmp___2 = strcmp((char const   *)me->me_type, "proc");
#line 391
        if (tmp___2 == 0) {
#line 391
          tmp___6 = 1;
        } else {
#line 391
          tmp___3 = strcmp((char const   *)me->me_type, "subfs");
#line 391
          if (tmp___3 == 0) {
#line 391
            tmp___6 = 1;
          } else {
#line 391
            tmp___4 = strcmp((char const   *)me->me_type, "kernfs");
#line 391
            if (tmp___4 == 0) {
#line 391
              tmp___6 = 1;
            } else {
#line 391
              tmp___5 = strcmp((char const   *)me->me_type, "ignore");
#line 391
              if (tmp___5 == 0) {
#line 391
                tmp___6 = 1;
              } else {
#line 391
                tmp___6 = 0;
              }
            }
          }
        }
      }
    }
#line 391
    me->me_dummy = (unsigned int )tmp___6;
#line 392
    tmp___7 = strchr((char const   *)me->me_devname, ':');
#line 392
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 392
      tmp___10 = 1;
    } else
#line 392
    if ((int )*(me->me_devname + 0) == 47) {
#line 392
      if ((int )*(me->me_devname + 1) == 47) {
#line 392
        tmp___8 = strcmp((char const   *)me->me_type, "smbfs");
#line 392
        if (tmp___8 == 0) {
#line 392
          tmp___10 = 1;
        } else {
#line 392
          tmp___9 = strcmp((char const   *)me->me_type, "cifs");
#line 392
          if (tmp___9 == 0) {
#line 392
            tmp___10 = 1;
          } else {
#line 392
            tmp___10 = 0;
          }
        }
      } else {
#line 392
        tmp___10 = 0;
      }
    } else {
#line 392
      tmp___10 = 0;
    }
#line 392
    me->me_remote = (unsigned int )tmp___10;
#line 393
    me->me_dev = dev_from_mount_options((char const   *)mnt->mnt_opts);
#line 396
    *mtail = me;
#line 397
    mtail = & me->me_next;
  }
#line 400
  tmp___11 = endmntent(fp);
#line 400
  if (tmp___11 == 0) {
#line 401
    goto free_then_fail;
  }
#line 857
  *mtail = (struct mount_entry *)((void *)0);
#line 858
  return (mount_list);
  free_then_fail: 
#line 863
  tmp___12 = __errno_location();
#line 863
  saved_errno = *tmp___12;
#line 864
  *mtail = (struct mount_entry *)((void *)0);
#line 866
  while (mount_list) {
#line 868
    me = mount_list->me_next;
#line 869
    free((void *)mount_list->me_devname);
#line 870
    free((void *)mount_list->me_mountdir);
#line 871
    if (mount_list->me_type_malloced) {
#line 872
      free((void *)mount_list->me_type);
    }
#line 873
    free((void *)mount_list);
#line 874
    mount_list = me;
  }
#line 877
  tmp___13 = __errno_location();
#line 877
  *tmp___13 = saved_errno;
#line 878
  return ((struct mount_entry *)((void *)0));
}
}
#line 1 "cil-D85U9ZoG.o"
#pragma merger("0","../lib/mpsort.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/mpsort.h"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) ;
#line 36 "/home/wslee/project/coreutils-8.1/lib/mpsort.c"
static void mpsort_into_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ 
  size_t n1 ;
  size_t n2 ;
  size_t a ;
  size_t alim ;
  size_t b ;
  size_t blim ;
  void const   *ba ;
  void const   *bb ;
  void const   ** __restrict  tmp___0 ;
  void const   ** __restrict  tmp___1 ;
  int tmp___2 ;

  {
#line 41
  n1 = n / 2UL;
#line 42
  n2 = n - n1;
#line 43
  a = (size_t )0;
#line 44
  alim = n1;
#line 45
  b = n1;
#line 46
  blim = n;
#line 50
  mpsort_with_tmp(base + n1, n2, tmp, cmp);
#line 51
  mpsort_with_tmp(base, n1, tmp, cmp);
#line 53
  ba = *(base + a);
#line 54
  bb = *(base + b);
#line 56
  while (1) {
#line 57
    tmp___2 = (*cmp)(ba, bb);
#line 57
    if (tmp___2 <= 0) {
#line 59
      tmp___0 = tmp;
#line 59
      tmp ++;
#line 59
      *tmp___0 = ba;
#line 60
      a ++;
#line 61
      if (a == alim) {
#line 63
        a = b;
#line 64
        alim = blim;
#line 65
        break;
      }
#line 67
      ba = *(base + a);
    } else {
#line 71
      tmp___1 = tmp;
#line 71
      tmp ++;
#line 71
      *tmp___1 = bb;
#line 72
      b ++;
#line 73
      if (b == blim) {
#line 74
        break;
      }
#line 75
      bb = *(base + b);
    }
  }
#line 78
  memcpy((void * __restrict  )tmp, (void const   * __restrict  )(base + a), (alim - a) * sizeof(*base));
#line 79
  return;
}
}
#line 85 "/home/wslee/project/coreutils-8.1/lib/mpsort.c"
static void mpsort_with_tmp(void const   ** __restrict  base , size_t n , void const   ** __restrict  tmp ,
                            int (*cmp)(void const   * , void const   * ) ) 
{ 
  void const   *p0 ;
  void const   *p1 ;
  int tmp___0 ;
  size_t n1 ;
  size_t n2 ;
  size_t i ;
  size_t t ;
  size_t tlim ;
  size_t b ;
  size_t blim ;
  void const   *bb ;
  void const   *tt ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;

  {
#line 90
  if (n <= 2UL) {
#line 92
    if (n == 2UL) {
#line 94
      p0 = *(base + 0);
#line 95
      p1 = *(base + 1);
#line 96
      tmp___0 = (*cmp)(p0, p1);
#line 96
      if (! (tmp___0 <= 0)) {
#line 98
        *(base + 0) = p1;
#line 99
        *(base + 1) = p0;
      }
    }
  } else {
#line 105
    n1 = n / 2UL;
#line 106
    n2 = n - n1;
#line 108
    t = (size_t )0;
#line 109
    tlim = n1;
#line 110
    b = n1;
#line 111
    blim = n;
#line 115
    mpsort_with_tmp(base + n1, n2, tmp, cmp);
#line 117
    if (n1 < 2UL) {
#line 118
      *(tmp + 0) = *(base + 0);
    } else {
#line 120
      mpsort_into_tmp(base, n1, tmp, cmp);
    }
#line 122
    tt = *(tmp + t);
#line 123
    bb = *(base + b);
#line 125
    i = (size_t )0;
#line 125
    while (1) {
#line 126
      tmp___3 = (*cmp)(tt, bb);
#line 126
      if (tmp___3 <= 0) {
#line 128
        tmp___1 = i;
#line 128
        i ++;
#line 128
        *(base + tmp___1) = tt;
#line 129
        t ++;
#line 130
        if (t == tlim) {
#line 131
          break;
        }
#line 132
        tt = *(tmp + t);
      } else {
#line 136
        tmp___2 = i;
#line 136
        i ++;
#line 136
        *(base + tmp___2) = bb;
#line 137
        b ++;
#line 138
        if (b == blim) {
#line 140
          memcpy((void * __restrict  )(base + i), (void const   * __restrict  )(tmp + t),
                 (tlim - t) * sizeof(*base));
#line 141
          break;
        }
#line 143
        bb = *(base + b);
      }
    }
  }
#line 146
  return;
}
}
#line 152 "/home/wslee/project/coreutils-8.1/lib/mpsort.c"
void mpsort(void const   **base , size_t n , int (*cmp)(void const   * , void const   * ) ) 
{ 


  {
#line 155
  mpsort_with_tmp((void const   ** __restrict  )base, n, (void const   ** __restrict  )(base + n),
                  cmp);
#line 156
  return;
}
}
#line 1 "cil-ln8Wc9qZ.o"
#pragma merger("0","../lib/nanosleep.o.i","")
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 69 "./time.h"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) ;
#line 45 "/home/wslee/project/coreutils-8.1/lib/nanosleep.c"
static void getnow(struct timespec *t ) 
{ 
  int tmp ;

  {
#line 49
  tmp = clock_gettime(1, t);
#line 49
  if (tmp == 0) {
#line 50
    return;
  }
#line 52
  gettime(t);
#line 53
  return;
}
}
#line 55 "/home/wslee/project/coreutils-8.1/lib/nanosleep.c"
int rpl_nanosleep(struct timespec  const  *requested_delay , struct timespec *remaining_delay ) 
{ 
  struct timespec delay ;
  struct timespec t0 ;
  int r ;
  int tmp ;
  time_t secs_sofar ;
  struct timespec now ;

  {
#line 63
  delay = *requested_delay;
#line 65
  getnow(& t0);
#line 67
  while (1) {
#line 69
    tmp = nanosleep((struct timespec  const  *)(& delay), remaining_delay);
#line 69
    r = tmp;
#line 70
    if (r == 0) {
#line 74
      getnow(& now);
#line 76
      secs_sofar = now.tv_sec - t0.tv_sec;
#line 77
      if (requested_delay->tv_sec < (__time_t const   )secs_sofar) {
#line 78
        return (0);
      }
#line 79
      delay.tv_sec = (__time_t )(requested_delay->tv_sec - (__time_t const   )secs_sofar);
#line 80
      delay.tv_nsec = (__syscall_slong_t )(requested_delay->tv_nsec - (__syscall_slong_t const   )(now.tv_nsec - t0.tv_nsec));
#line 81
      if (delay.tv_nsec < 0L) {
#line 83
        if (delay.tv_sec == 0L) {
#line 84
          return (0);
        }
#line 85
        delay.tv_nsec += 1000000000L;
#line 86
        (delay.tv_sec) --;
      } else
#line 88
      if (1000000000L <= delay.tv_nsec) {
#line 90
        delay.tv_nsec -= 1000000000L;
#line 91
        (delay.tv_sec) ++;
      }
    }
  }
}
}
#line 1 "cil-af_9jJN8.o"
#pragma merger("0","../lib/nproc.o.i","")
#line 43 "/home/wslee/project/coreutils-8.1/lib/nproc.h"
unsigned long num_processors(enum nproc_query query ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 622 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 203 "/usr/include/x86_64-linux-gnu/bits/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __sched_cpucount)(size_t __setsize ,
                                                                                       cpu_set_t const   *__setp ) ;
#line 122 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_getaffinity)(__pid_t __pid ,
                                                                                        size_t __cpusetsize ,
                                                                                        cpu_set_t *__cpuset ) ;
#line 62 "/home/wslee/project/coreutils-8.1/lib/nproc.c"
unsigned long num_processors(enum nproc_query query ) 
{ 
  char const   *envvalue ;
  char *tmp ;
  _Bool tmp___0 ;
  char *endptr ;
  unsigned long value ;
  unsigned long tmp___1 ;
  _Bool tmp___2 ;
  unsigned long tmp___3 ;
  _Bool tmp___4 ;
  cpu_set_t set ;
  unsigned long count ;
  int tmp___5 ;
  int tmp___6 ;
  long nprocs ;
  long tmp___7 ;
  long nprocs___0 ;
  long tmp___8 ;

  {
#line 65
  if ((unsigned int )query == 2U) {
#line 71
    tmp = getenv("OMP_NUM_THREADS");
#line 71
    envvalue = (char const   *)tmp;
#line 73
    if ((unsigned long )envvalue != (unsigned long )((void *)0)) {
#line 75
      while (1) {
#line 75
        if ((int const   )*envvalue != 0) {
#line 75
          tmp___0 = c_isspace((int )*envvalue);
#line 75
          if (! tmp___0) {
#line 75
            break;
          }
        } else {
#line 75
          break;
        }
#line 76
        envvalue ++;
      }
#line 78
      tmp___4 = c_isdigit((int )*envvalue);
#line 78
      if (tmp___4) {
#line 80
        endptr = (char *)((void *)0);
#line 81
        tmp___1 = strtoul((char const   * __restrict  )envvalue, (char ** __restrict  )(& endptr),
                          10);
#line 81
        value = tmp___1;
#line 83
        if ((unsigned long )endptr != (unsigned long )((void *)0)) {
#line 85
          while (1) {
#line 85
            if ((int )*endptr != 0) {
#line 85
              tmp___2 = c_isspace((int )*endptr);
#line 85
              if (! tmp___2) {
#line 85
                break;
              }
            } else {
#line 85
              break;
            }
#line 86
            endptr ++;
          }
#line 87
          if ((int )*endptr == 0) {
#line 88
            if (value > 0UL) {
#line 88
              tmp___3 = value;
            } else {
#line 88
              tmp___3 = 1UL;
            }
#line 88
            return (tmp___3);
          }
        }
      }
    }
#line 93
    query = (enum nproc_query )1;
  }
#line 97
  if ((unsigned int )query == 1U) {
#line 159
    tmp___6 = sched_getaffinity(0, sizeof(set), & set);
#line 159
    if (tmp___6 == 0) {
#line 165
      tmp___5 = __sched_cpucount(sizeof(cpu_set_t ), (cpu_set_t const   *)(& set));
#line 165
      count = (unsigned long )tmp___5;
#line 174
      if (count > 0UL) {
#line 175
        return (count);
      }
    }
#line 230
    tmp___7 = sysconf(84);
#line 230
    nprocs = tmp___7;
#line 231
    if (nprocs > 0L) {
#line 232
      return ((unsigned long )nprocs);
    }
  } else {
#line 241
    tmp___8 = sysconf(83);
#line 241
    nprocs___0 = tmp___8;
#line 242
    if (nprocs___0 > 0L) {
#line 243
      return ((unsigned long )nprocs___0);
    }
  }
#line 309
  return (1UL);
}
}
#line 1 "cil-dNIsAo4R.o"
#pragma merger("0","../lib/offtostr.o.i","")
#line 43 "/home/wslee/project/coreutils-8.1/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___0 ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) offtostr)(off_t i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 32
  p = buf___0 + ((((sizeof(off_t ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL);
#line 33
  *p = (char)0;
#line 37
  if (i < 0L) {
#line 39
    while (1) {
#line 40
      p --;
#line 40
      *p = (char )(48L - i % 10L);
#line 39
      i /= 10L;
#line 39
      if (! (i != 0L)) {
#line 39
        break;
      }
    }
#line 43
    p --;
#line 43
    *p = (char )'-';
  } else {
#line 48
    while (1) {
#line 49
      p --;
#line 49
      *p = (char )(48L + i % 10L);
#line 48
      i /= 10L;
#line 48
      if (! (i != 0L)) {
#line 48
        break;
      }
    }
  }
#line 53
  return (p);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 1 "cil-8x11wHJs.o"
#pragma merger("0","../lib/open-safer.o.i","")
#line 28 "/home/wslee/project/coreutils-8.1/lib/open-safer.c"
int open_safer(char const   *file , int flags  , ...) 
{ 
  mode_t mode ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode = tmp;
#line 42
    __builtin_va_end(ap);
  }
#line 45
  tmp___0 = open(file, flags, mode);
#line 45
  tmp___1 = fd_safer(tmp___0);
#line 45
  return (tmp___1);
}
}
#line 1 "cil-9yfs0lnF.o"
#pragma merger("0","../lib/openat-die.o.i","")
#line 54 "/home/wslee/project/coreutils-8.1/lib/openat.h"
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 55
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/openat-die.c"
 __attribute__((__noreturn__)) void openat_save_fail(int errnum ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/openat-die.c"
void openat_save_fail(int errnum ) 
{ 
  char *tmp ;

  {
#line 33
  tmp = gettext("unable to record current working directory");
#line 33
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 40
  abort();
}
}
#line 48
 __attribute__((__noreturn__)) void openat_restore_fail(int errnum ) ;
#line 48 "/home/wslee/project/coreutils-8.1/lib/openat-die.c"
void openat_restore_fail(int errnum ) 
{ 
  char *tmp ;

  {
#line 51
  tmp = gettext("failed to return to initial working directory");
#line 51
  error((int )exit_failure, errnum, (char const   *)tmp);
#line 55
  abort();
}
}
#line 1 "cil-hUJBoSDT.o"
#pragma merger("0","../lib/openat-proc.o.i","")
#line 27 "/home/wslee/project/coreutils-8.1/lib/openat-priv.h"
char *openat_proc_name(char *buf___0 , int fd , char const   *file ) ;
#line 58 "/home/wslee/project/coreutils-8.1/lib/openat-proc.c"
static int proc_status  =    0;
#line 55 "/home/wslee/project/coreutils-8.1/lib/openat-proc.c"
char *openat_proc_name(char *buf___0 , int fd , char const   *file ) 
{ 
  int proc_self_fd ;
  int tmp ;
  struct stat proc_self_fd_dotdot_st ;
  struct stat proc_self_st ;
  char dotdot_buf[(((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL)) + (sizeof("..") - 1UL)) + 1UL] ;
  int tmp___2 ;
  int tmp___3 ;
  size_t bufsize___0 ;
  size_t tmp___4 ;
  char *result ;
  void *tmp___5 ;
  char *tmp___6 ;

  {
#line 61
  if (! *file) {
#line 63
    *(buf___0 + 0) = (char )'\000';
#line 64
    return ((char *)buf___0);
  }
#line 67
  if (! proc_status) {
#line 77
    tmp = open("/proc/self/fd", 0);
#line 77
    proc_self_fd = tmp;
#line 78
    if (proc_self_fd < 0) {
#line 79
      proc_status = -1;
    } else {
#line 85
      sprintf((char * __restrict  )(dotdot_buf), (char const   * __restrict  )"/proc/self/fd/%d/%s",
              proc_self_fd, "..");
#line 86
      tmp___2 = stat((char const   * __restrict  )(dotdot_buf), (struct stat * __restrict  )(& proc_self_fd_dotdot_st));
#line 86
      if (tmp___2 == 0) {
#line 86
        tmp___3 = stat((char const   * __restrict  )"/proc/self", (struct stat * __restrict  )(& proc_self_st));
#line 86
        if (tmp___3 == 0) {
#line 86
          if (proc_self_fd_dotdot_st.st_ino == proc_self_st.st_ino) {
#line 86
            if (proc_self_fd_dotdot_st.st_dev == proc_self_st.st_dev) {
#line 86
              proc_status = 1;
            } else {
#line 86
              proc_status = -1;
            }
          } else {
#line 86
            proc_status = -1;
          }
        } else {
#line 86
          proc_status = -1;
        }
      } else {
#line 86
        proc_status = -1;
      }
#line 91
      close(proc_self_fd);
    }
  }
#line 95
  if (proc_status < 0) {
#line 96
    return ((char *)((void *)0));
  } else {
#line 99
    tmp___4 = strlen(file);
#line 99
    bufsize___0 = (((sizeof("/proc/self/fd/%d/%s") - sizeof("%d%s")) + ((((sizeof(int ) * 8UL - 1UL) * 146UL) / 485UL + 1UL) + 1UL)) + tmp___4) + 1UL;
#line 100
    if (bufsize___0 < 512UL) {
#line 100
      tmp___6 = buf___0;
    } else {
#line 100
      tmp___5 = xmalloc(bufsize___0);
#line 100
      tmp___6 = (char *)tmp___5;
    }
#line 100
    result = (char *)tmp___6;
#line 101
    sprintf((char * __restrict  )result, (char const   * __restrict  )"/proc/self/fd/%d/%s",
            fd, file);
#line 102
    return (result);
  }
}
}
#line 1 "cil-pwh4QWa_.o"
#pragma merger("0","../lib/openat-safer.o.i","")
#line 28 "/home/wslee/project/coreutils-8.1/lib/openat-safer.c"
int openat_safer(int fd , char const   *file , int flags  , ...) 
{ 
  mode_t mode ;
  va_list ap ;
  mode_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 31
  mode = (mode_t )0;
#line 33
  if (flags & 64) {
#line 36
    __builtin_va_start(ap, flags);
#line 40
    tmp = __builtin_va_arg(ap, mode_t );
#line 40
    mode = tmp;
#line 42
    __builtin_va_end(ap);
  }
#line 45
  tmp___0 = openat(fd, file, flags, mode);
#line 45
  tmp___1 = fd_safer(tmp___0);
#line 45
  return (tmp___1);
}
}
#line 1 "cil-f0vlYzHJ.o"
#pragma merger("0","../lib/opendir-safer.o.i","")
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/opendir-safer.c"
DIR *opendir_safer(char const   *name ) 
{ 
  DIR *dp ;
  DIR *tmp ;
  int fd ;
  int tmp___0 ;
  DIR *newdp ;
  int e ;
  int f ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 33
  tmp = opendir(name);
#line 33
  dp = tmp;
#line 35
  if (dp) {
#line 37
    tmp___0 = dirfd(dp);
#line 37
    fd = tmp___0;
#line 39
    if (0 <= fd) {
#line 39
      if (fd <= 2) {
#line 52
        tmp___1 = dup_safer(fd);
#line 52
        f = tmp___1;
#line 53
        newdp = rpl_fdopendir(f);
#line 54
        tmp___2 = __errno_location();
#line 54
        e = *tmp___2;
#line 55
        if (! newdp) {
#line 56
          close(f);
        }
#line 61
        closedir(dp);
#line 62
        tmp___3 = __errno_location();
#line 62
        *tmp___3 = e;
#line 63
        dp = newdp;
      }
    }
  }
#line 67
  return (dp);
}
}
#line 1 "cil-d7U7Tssz.o"
#pragma merger("0","../lib/physmem.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/physmem.h"
double physmem_total(void) ;
#line 24
double physmem_available(void) ;
#line 81 "/home/wslee/project/coreutils-8.1/lib/physmem.c"
double physmem_total(void) 
{ 
  double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;

  {
#line 86
  tmp = sysconf(85);
#line 86
  pages = (double )tmp;
#line 87
  tmp___0 = sysconf(30);
#line 87
  pagesize = (double )tmp___0;
#line 88
  if ((double )0 <= pages) {
#line 88
    if ((double )0 <= pagesize) {
#line 89
      return (pages * pagesize);
    }
  }
#line 181
  return ((double )67108864);
}
}
#line 185 "/home/wslee/project/coreutils-8.1/lib/physmem.c"
double physmem_available(void) 
{ 
  double pages ;
  long tmp ;
  double pagesize ;
  long tmp___0 ;
  double tmp___1 ;

  {
#line 190
  tmp = sysconf(86);
#line 190
  pages = (double )tmp;
#line 191
  tmp___0 = sysconf(30);
#line 191
  pagesize = (double )tmp___0;
#line 192
  if ((double )0 <= pages) {
#line 192
    if ((double )0 <= pagesize) {
#line 193
      return (pages * pagesize);
    }
  }
#line 282
  tmp___1 = physmem_total();
#line 282
  return (tmp___1 / (double )4);
}
}
#line 1 "cil-hA4oP3ey.o"
#pragma merger("0","../lib/pipe-safer.o.i","")
#line 22 "/home/wslee/project/coreutils-8.1/lib/unistd-safer.h"
int pipe_safer(int *fd ) ;
#line 420 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/pipe-safer.c"
int pipe_safer(int *fd ) 
{ 
  int i ;
  int e ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 34
  tmp___1 = pipe(fd);
#line 34
  if (tmp___1 == 0) {
#line 37
    i = 0;
#line 37
    while (i < 2) {
#line 39
      *(fd + i) = fd_safer(*(fd + i));
#line 40
      if (*(fd + i) < 0) {
#line 42
        tmp = __errno_location();
#line 42
        e = *tmp;
#line 43
        close(*(fd + (1 - i)));
#line 44
        tmp___0 = __errno_location();
#line 44
        *tmp___0 = e;
#line 45
        return (-1);
      }
#line 37
      i ++;
    }
#line 49
    return (0);
  }
#line 55
  return (-1);
}
}
#line 1 "cil-QGaAdBdt.o"
#pragma merger("0","../lib/posixtm.o.i","")
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 34 "/home/wslee/project/coreutils-8.1/lib/posixtm.h"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) ;
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) stpcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 61 "/home/wslee/project/coreutils-8.1/lib/posixtm.c"
static int year(struct tm *tm , int const   *digit_pair , size_t n , unsigned int syntax_bits ) 
{ 
  time_t now ;
  struct tm *tmp ;

  {
#line 64
  switch (n) {
  case 1UL: 
#line 67
  tm->tm_year = (int )*digit_pair;
#line 71
  if (*(digit_pair + 0) <= 68) {
#line 73
    if (syntax_bits & 16U) {
#line 74
      return (1);
    }
#line 75
    tm->tm_year += 100;
  }
#line 77
  break;
  case 2UL: 
#line 80
  if (! (syntax_bits & 4U)) {
#line 81
    return (1);
  }
#line 82
  tm->tm_year = (int )((*(digit_pair + 0) * 100 + *(digit_pair + 1)) - 1900);
#line 83
  break;
  case 0UL: 
#line 91
  time(& now);
#line 92
  tmp = localtime((time_t const   *)(& now));
#line 93
  if (! tmp) {
#line 94
    return (1);
  }
#line 95
  tm->tm_year = tmp->tm_year;
#line 97
  break;
  default: 
#line 100
  abort();
  }
#line 103
  return (0);
}
}
#line 106 "/home/wslee/project/coreutils-8.1/lib/posixtm.c"
static int posix_time_parse(struct tm *tm , char const   *s , unsigned int syntax_bits ) 
{ 
  char const   *dot ;
  int pair[6] ;
  int *p ;
  size_t i ;
  size_t s_len ;
  size_t tmp ;
  size_t len ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int seconds ;

  {
#line 109
  dot = (char const   *)((void *)0);
#line 114
  tmp = strlen(s);
#line 114
  s_len = tmp;
#line 115
  if (syntax_bits & 8U) {
#line 115
    tmp___2 = strchr(s, '.');
#line 115
    dot = (char const   *)tmp___2;
#line 115
    if (dot) {
#line 115
      tmp___1 = (size_t )(dot - s);
    } else {
#line 115
      tmp___1 = s_len;
    }
  } else {
#line 115
    tmp___1 = s_len;
  }
#line 115
  len = tmp___1;
#line 119
  if (len != 8UL) {
#line 119
    if (len != 10UL) {
#line 119
      if (len != 12UL) {
#line 120
        return (1);
      }
    }
  }
#line 122
  if (dot) {
#line 124
    if (! (syntax_bits & 8U)) {
#line 125
      return (1);
    }
#line 127
    if (s_len - len != 3UL) {
#line 128
      return (1);
    }
  }
#line 131
  i = (size_t )0;
#line 131
  while (i < len) {
#line 132
    if (! ((unsigned int )*(s + i) - 48U <= 9U)) {
#line 133
      return (1);
    }
#line 131
    i ++;
  }
#line 135
  len /= 2UL;
#line 136
  i = (size_t )0;
#line 136
  while (i < len) {
#line 137
    pair[i] = (10 * (int )((int const   )*(s + 2UL * i) - 48) + (int )*(s + (2UL * i + 1UL))) - 48;
#line 136
    i ++;
  }
#line 139
  p = pair;
#line 140
  if (syntax_bits & 1U) {
#line 142
    tmp___3 = year(tm, (int const   *)p, len - 4UL, syntax_bits);
#line 142
    if (tmp___3) {
#line 143
      return (1);
    }
#line 144
    p += len - 4UL;
#line 145
    len = (size_t )4;
  }
#line 149
  tmp___4 = p;
#line 149
  p ++;
#line 149
  tm->tm_mon = *tmp___4 - 1;
#line 150
  tmp___5 = p;
#line 150
  p ++;
#line 150
  tm->tm_mday = *tmp___5;
#line 151
  tmp___6 = p;
#line 151
  p ++;
#line 151
  tm->tm_hour = *tmp___6;
#line 152
  tmp___7 = p;
#line 152
  p ++;
#line 152
  tm->tm_min = *tmp___7;
#line 153
  len -= 4UL;
#line 156
  if (syntax_bits & 2U) {
#line 158
    tmp___8 = year(tm, (int const   *)p, len, syntax_bits);
#line 158
    if (tmp___8) {
#line 159
      return (1);
    }
  }
#line 163
  if (! dot) {
#line 165
    tm->tm_sec = 0;
  } else {
#line 171
    dot ++;
#line 172
    if (! ((unsigned int )*(dot + 0) - 48U <= 9U)) {
#line 173
      return (1);
    } else
#line 172
    if (! ((unsigned int )*(dot + 1) - 48U <= 9U)) {
#line 173
      return (1);
    }
#line 174
    seconds = (10 * (int )((int const   )*(dot + 0) - 48) + (int )*(dot + 1)) - 48;
#line 176
    tm->tm_sec = seconds;
  }
#line 179
  return (0);
}
}
#line 184 "/home/wslee/project/coreutils-8.1/lib/posixtm.c"
_Bool posixtime(time_t *p , char const   *s , unsigned int syntax_bits ) 
{ 
  struct tm tm0 ;
  struct tm tm1 ;
  struct tm  const  *tm ;
  time_t t ;
  int tmp ;
  struct tm *tmp___0 ;
  time_t dummy ;
  char buf___0[16] ;
  char *b ;
  char *tmp___1 ;
  _Bool tmp___2 ;

  {
#line 192
  tmp = posix_time_parse(& tm0, s, syntax_bits);
#line 192
  if (tmp) {
#line 193
    return ((_Bool)0);
  }
#line 195
  tm1 = tm0;
#line 196
  tm1.tm_isdst = -1;
#line 197
  t = mktime(& tm1);
#line 199
  if (t != -1L) {
#line 200
    tm = (struct tm  const  *)(& tm1);
  } else {
#line 205
    tmp___0 = localtime((time_t const   *)(& t));
#line 205
    tm = (struct tm  const  *)tmp___0;
#line 206
    if (! tm) {
#line 207
      return ((_Bool)0);
    }
  }
#line 212
  if ((((((tm0.tm_year ^ (int )tm->tm_year) | (tm0.tm_mon ^ (int )tm->tm_mon)) | (tm0.tm_mday ^ (int )tm->tm_mday)) | (tm0.tm_hour ^ (int )tm->tm_hour)) | (tm0.tm_min ^ (int )tm->tm_min)) | (tm0.tm_sec ^ (int )tm->tm_sec)) {
#line 220
    if (tm0.tm_sec != 60) {
#line 221
      return ((_Bool)0);
    }
#line 227
    tmp___1 = stpcpy((char * __restrict  )(buf___0), (char const   * __restrict  )s);
#line 227
    b = tmp___1;
#line 228
    strcpy((char * __restrict  )(b - 2), (char const   * __restrict  )"59");
#line 229
    tmp___2 = posixtime(& dummy, (char const   *)(buf___0), syntax_bits);
#line 229
    if (! tmp___2) {
#line 230
      return ((_Bool)0);
    }
  }
#line 234
  *p = t;
#line 235
  return ((_Bool)1);
}
}
#line 1 "cil-UUh1gJmp.o"
#pragma merger("0","../lib/posixver.o.i","")
#line 1 "/home/wslee/project/coreutils-8.1/lib/posixver.h"
int posix2_version(void) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 40 "/home/wslee/project/coreutils-8.1/lib/posixver.c"
int posix2_version(void) 
{ 
  long v ;
  char const   *s ;
  char *tmp ;
  char *e ;
  long i ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 43
  v = 200809L;
#line 44
  tmp = getenv("_POSIX2_VERSION");
#line 44
  s = (char const   *)tmp;
#line 46
  if (s) {
#line 46
    if (*s) {
#line 49
      tmp___0 = strtol((char const   * __restrict  )s, (char ** __restrict  )(& e),
                       10);
#line 49
      i = tmp___0;
#line 50
      if (! *e) {
#line 51
        v = i;
      }
    }
  }
#line 54
  if (v < (-0x7FFFFFFF-1)) {
#line 54
    tmp___2 = (-0x7FFFFFFF-1);
  } else {
#line 54
    if (v < 2147483647L) {
#line 54
      tmp___1 = v;
    } else {
#line 54
      tmp___1 = 2147483647L;
    }
#line 54
    tmp___2 = tmp___1;
  }
#line 54
  return ((int )tmp___2);
}
}
#line 1 "cil-2ZsNaNYy.o"
#pragma merger("0","../lib/printf-args.o.i","")
#line 150 "/home/wslee/project/coreutils-8.1/lib/printf-args.h"
int printf_fetchargs(va_list args , arguments *a ) ;
#line 113 "/home/wslee/project/coreutils-8.1/lib/printf-args.c"
static wchar_t const   wide_null_string[7]  = {      (wchar_t const   )'(',      (wchar_t const   )'N',      (wchar_t const   )'U',      (wchar_t const   )'L', 
        (wchar_t const   )'L',      (wchar_t const   )')',      (wchar_t const   )0};
#line 36 "/home/wslee/project/coreutils-8.1/lib/printf-args.c"
int printf_fetchargs(va_list args , arguments *a ) 
{ 
  size_t i ;
  argument *ap ;
  signed char tmp ;
  unsigned char tmp___0 ;
  short tmp___1 ;
  unsigned short tmp___2 ;
  int tmp___3 ;
  unsigned int tmp___4 ;
  long tmp___5 ;
  unsigned long tmp___6 ;
  long long tmp___7 ;
  unsigned long long tmp___8 ;
  double tmp___9 ;
  long double tmp___10 ;
  int tmp___11 ;
  int tmp___13 ;
  wint_t tmp___15 ;
  char const   *tmp___16 ;
  wchar_t const   *tmp___17 ;
  void *tmp___18 ;
  signed char *tmp___19 ;
  short *tmp___20 ;
  int *tmp___21 ;
  long *tmp___22 ;
  long long *tmp___23 ;

  {
#line 42
  i = (size_t )0;
#line 42
  ap = a->arg + 0;
#line 42
  while (i < a->count) {
#line 43
    switch ((unsigned int )ap->type) {
    case 1U: 
#line 46
    tmp = __builtin_va_arg(args, int );
#line 46
    ap->a.a_schar = tmp;
#line 47
    break;
    case 2U: 
#line 49
    tmp___0 = __builtin_va_arg(args, int );
#line 49
    ap->a.a_uchar = tmp___0;
#line 50
    break;
    case 3U: 
#line 52
    tmp___1 = __builtin_va_arg(args, int );
#line 52
    ap->a.a_short = tmp___1;
#line 53
    break;
    case 4U: 
#line 55
    tmp___2 = __builtin_va_arg(args, int );
#line 55
    ap->a.a_ushort = tmp___2;
#line 56
    break;
    case 5U: 
#line 58
    tmp___3 = __builtin_va_arg(args, int );
#line 58
    ap->a.a_int = tmp___3;
#line 59
    break;
    case 6U: 
#line 61
    tmp___4 = __builtin_va_arg(args, unsigned int );
#line 61
    ap->a.a_uint = tmp___4;
#line 62
    break;
    case 7U: 
#line 64
    tmp___5 = __builtin_va_arg(args, long );
#line 64
    ap->a.a_longint = tmp___5;
#line 65
    break;
    case 8U: 
#line 67
    tmp___6 = __builtin_va_arg(args, unsigned long );
#line 67
    ap->a.a_ulongint = tmp___6;
#line 68
    break;
    case 9U: 
#line 71
    tmp___7 = __builtin_va_arg(args, long long );
#line 71
    ap->a.a_longlongint = tmp___7;
#line 72
    break;
    case 10U: 
#line 74
    tmp___8 = __builtin_va_arg(args, unsigned long long );
#line 74
    ap->a.a_ulonglongint = tmp___8;
#line 75
    break;
    case 11U: 
#line 78
    tmp___9 = __builtin_va_arg(args, double );
#line 78
    ap->a.a_double = tmp___9;
#line 79
    break;
    case 12U: 
#line 81
    tmp___10 = __builtin_va_arg(args, long double );
#line 81
    ap->a.a_longdouble = tmp___10;
#line 82
    break;
    case 13U: 
#line 84
    tmp___11 = __builtin_va_arg(args, int );
#line 84
    ap->a.a_char = tmp___11;
#line 85
    break;
    case 14U: 
#line 91
    if (sizeof(wint_t ) < sizeof(int )) {
#line 91
      tmp___13 = __builtin_va_arg(args, int );
#line 91
      ap->a.a_wide_char = (wint_t )tmp___13;
    } else {
#line 91
      tmp___15 = __builtin_va_arg(args, wint_t );
#line 91
      ap->a.a_wide_char = tmp___15;
    }
#line 95
    break;
    case 15U: 
#line 98
    tmp___16 = __builtin_va_arg(args, char const   *);
#line 98
    ap->a.a_string = tmp___16;
#line 102
    if ((unsigned long )ap->a.a_string == (unsigned long )((void *)0)) {
#line 103
      ap->a.a_string = "(NULL)";
    }
#line 104
    break;
    case 16U: 
#line 107
    tmp___17 = __builtin_va_arg(args, wchar_t const   *);
#line 107
    ap->a.a_wide_string = tmp___17;
#line 111
    if ((unsigned long )ap->a.a_wide_string == (unsigned long )((void *)0)) {
#line 120
      ap->a.a_wide_string = wide_null_string;
    }
#line 122
    break;
    case 17U: 
#line 125
    tmp___18 = __builtin_va_arg(args, void *);
#line 125
    ap->a.a_pointer = tmp___18;
#line 126
    break;
    case 18U: 
#line 128
    tmp___19 = __builtin_va_arg(args, signed char *);
#line 128
    ap->a.a_count_schar_pointer = tmp___19;
#line 129
    break;
    case 19U: 
#line 131
    tmp___20 = __builtin_va_arg(args, short *);
#line 131
    ap->a.a_count_short_pointer = tmp___20;
#line 132
    break;
    case 20U: 
#line 134
    tmp___21 = __builtin_va_arg(args, int *);
#line 134
    ap->a.a_count_int_pointer = tmp___21;
#line 135
    break;
    case 21U: 
#line 137
    tmp___22 = __builtin_va_arg(args, long *);
#line 137
    ap->a.a_count_longint_pointer = tmp___22;
#line 138
    break;
    case 22U: 
#line 141
    tmp___23 = __builtin_va_arg(args, long long *);
#line 141
    ap->a.a_count_longlongint_pointer = tmp___23;
#line 142
    break;
    default: 
#line 185
    return (-1);
    }
#line 42
    i ++;
#line 42
    ap ++;
  }
#line 187
  return (0);
}
}
#line 1 "cil-FcLnQPbE.o"
#pragma merger("0","../lib/printf-frexp.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/printf-frexp.h"
double printf_frexp(double x , int *expptr ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) frexp)(double __x ,
                                                                               int *__exponent ) ;
#line 106
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ldexp)(double __x ,
                                                                               int __exponent ) ;
#line 64 "/home/wslee/project/coreutils-8.1/lib/printf-frexp.c"
double printf_frexp(double x , int *expptr ) 
{ 
  int exponent ;

  {
#line 74
  x = frexp(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
#line 79
  if (exponent < -1022) {
#line 81
    x = ldexp(x, exponent - -1022);
#line 82
    exponent = -1022;
  }
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 1 "cil-1eWFKABM.o"
#pragma merger("0","../lib/printf-frexpl.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/printf-frexpl.h"
long double printf_frexpl(long double x , int *expptr ) ;
#line 103 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) frexpl)(long double __x ,
                                                                                     int *__exponent ) ;
#line 106
extern  __attribute__((__nothrow__)) long double ( __attribute__((__leaf__)) ldexpl)(long double __x ,
                                                                                     int __exponent ) ;
#line 64 "/home/wslee/project/coreutils-8.1/lib/printf-frexp.c"
long double printf_frexpl(long double x , int *expptr ) 
{ 
  int exponent ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  fpucw_t _ncw___0 ;

  {
#line 70
  __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 70
  oldcw = _cw;
#line 70
  _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 70
  __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 74
  x = frexpl(x, & exponent);
#line 76
  x += x;
#line 77
  exponent --;
#line 79
  if (exponent < -16382) {
#line 81
    x = ldexpl(x, exponent - -16382);
#line 82
    exponent = -16382;
  }
#line 184
  _ncw___0 = oldcw;
#line 184
  __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
#line 186
  *expptr = exponent;
#line 187
  return (x);
}
}
#line 1 "cil-zidCssWz.o"
#pragma merger("0","../lib/printf-parse.o.i","")
#line 174 "/home/wslee/project/coreutils-8.1/lib/printf-parse.h"
int printf_parse(char const   *format , char_directives *d , arguments *a ) ;
#line 52 "/home/wslee/project/coreutils-8.1/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum(size_t size1 , size_t size2 ) 
{ 
  size_t sum ;
  size_t tmp ;

  {
#line 58
  sum = size1 + size2;
#line 59
  if (sum >= size1) {
#line 59
    tmp = sum;
  } else {
#line 59
    tmp = 0xffffffffffffffffUL;
  }
#line 59
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 80 "/home/wslee/project/coreutils-8.1/lib/printf-parse.c"
int printf_parse(char const   *format , char_directives *d , arguments *a ) 
{ 
  char const   *cp ;
  size_t arg_posn ;
  size_t d_allocated ;
  size_t a_allocated ;
  size_t max_width_length ;
  size_t max_precision_length ;
  void *tmp ;
  char c ;
  char const   *tmp___0 ;
  size_t arg_index ;
  char_directive *dp ;
  char const   *np ;
  size_t n ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  char const   *np___0 ;
  size_t n___0 ;
  size_t tmp___3 ;
  size_t __attribute__((__pure__))  tmp___4 ;
  size_t tmp___5 ;
  size_t n___1 ;
  size_t memory_size ;
  argument *memory ;
  size_t __attribute__((__pure__))  tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  size_t width_length ;
  char const   *np___1 ;
  size_t n___2 ;
  size_t tmp___11 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t tmp___13 ;
  size_t n___3 ;
  size_t memory_size___0 ;
  argument *memory___0 ;
  size_t __attribute__((__pure__))  tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  size_t tmp___18 ;
  size_t precision_length ;
  arg_type type ;
  int flags ;
  char const   *tmp___19 ;
  size_t tmp___20 ;
  size_t n___4 ;
  size_t memory_size___1 ;
  argument *memory___1 ;
  size_t __attribute__((__pure__))  tmp___21 ;
  void *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  size_t tmp___25 ;
  size_t memory_size___2 ;
  char_directive *memory___2 ;
  void *tmp___26 ;
  int *tmp___27 ;
  int *tmp___28 ;

  {
#line 83
  cp = format;
#line 84
  arg_posn = (size_t )0;
#line 87
  max_width_length = (size_t )0;
#line 88
  max_precision_length = (size_t )0;
#line 90
  d->count = (size_t )0;
#line 91
  d_allocated = (size_t )1;
#line 92
  tmp = malloc(d_allocated * sizeof(char_directive ));
#line 92
  d->dir = (char_directive *)tmp;
#line 93
  if ((unsigned long )d->dir == (unsigned long )((void *)0)) {
#line 95
    goto out_of_memory_1;
  }
#line 97
  a->count = (size_t )0;
#line 98
  a_allocated = (size_t )0;
#line 99
  a->arg = (argument *)((void *)0);
#line 133
  while ((int const   )*cp != 0) {
#line 135
    tmp___0 = cp;
#line 135
    cp ++;
#line 135
    c = (char )*tmp___0;
#line 136
    if ((int )c == 37) {
#line 138
      arg_index = ~ ((size_t )0);
#line 139
      dp = d->dir + d->count;
#line 142
      dp->dir_start = cp - 1;
#line 143
      dp->flags = 0;
#line 144
      dp->width_start = (char const   *)((void *)0);
#line 145
      dp->width_end = (char const   *)((void *)0);
#line 146
      dp->width_arg_index = ~ ((size_t )0);
#line 147
      dp->precision_start = (char const   *)((void *)0);
#line 148
      dp->precision_end = (char const   *)((void *)0);
#line 149
      dp->precision_arg_index = ~ ((size_t )0);
#line 150
      dp->arg_index = ~ ((size_t )0);
#line 153
      if ((int const   )*cp >= 48) {
#line 153
        if ((int const   )*cp <= 57) {
#line 157
          np = cp;
#line 157
          while (1) {
#line 157
            if ((int const   )*np >= 48) {
#line 157
              if (! ((int const   )*np <= 57)) {
#line 157
                break;
              }
            } else {
#line 157
              break;
            }
#line 157
            np ++;
          }
#line 159
          if ((int const   )*np == 36) {
#line 161
            n = (size_t )0;
#line 163
            np = cp;
#line 163
            while (1) {
#line 163
              if ((int const   )*np >= 48) {
#line 163
                if (! ((int const   )*np <= 57)) {
#line 163
                  break;
                }
              } else {
#line 163
                break;
              }
#line 164
              if (n <= 1844674407370955161UL) {
#line 164
                tmp___1 = n * 10UL;
              } else {
#line 164
                tmp___1 = 0xffffffffffffffffUL;
              }
#line 164
              tmp___2 = xsum(tmp___1, (size_t )((int const   )*np - 48));
#line 164
              n = (size_t )tmp___2;
#line 163
              np ++;
            }
#line 165
            if (n == 0UL) {
#line 167
              goto error;
            }
#line 168
            if (n == 0xffffffffffffffffUL) {
#line 170
              goto error;
            }
#line 171
            arg_index = n - 1UL;
#line 172
            cp = np + 1;
          }
        }
      }
#line 177
      while (1) {
#line 179
        if ((int const   )*cp == 39) {
#line 181
          dp->flags |= 1;
#line 182
          cp ++;
        } else
#line 184
        if ((int const   )*cp == 45) {
#line 186
          dp->flags |= 2;
#line 187
          cp ++;
        } else
#line 189
        if ((int const   )*cp == 43) {
#line 191
          dp->flags |= 4;
#line 192
          cp ++;
        } else
#line 194
        if ((int const   )*cp == 32) {
#line 196
          dp->flags |= 8;
#line 197
          cp ++;
        } else
#line 199
        if ((int const   )*cp == 35) {
#line 201
          dp->flags |= 16;
#line 202
          cp ++;
        } else
#line 204
        if ((int const   )*cp == 48) {
#line 206
          dp->flags |= 32;
#line 207
          cp ++;
        } else {
#line 210
          break;
        }
      }
#line 214
      if ((int const   )*cp == 42) {
#line 216
        dp->width_start = cp;
#line 217
        cp ++;
#line 218
        dp->width_end = cp;
#line 219
        if (max_width_length < 1UL) {
#line 220
          max_width_length = (size_t )1;
        }
#line 223
        if ((int const   )*cp >= 48) {
#line 223
          if ((int const   )*cp <= 57) {
#line 227
            np___0 = cp;
#line 227
            while (1) {
#line 227
              if ((int const   )*np___0 >= 48) {
#line 227
                if (! ((int const   )*np___0 <= 57)) {
#line 227
                  break;
                }
              } else {
#line 227
                break;
              }
#line 227
              np___0 ++;
            }
#line 229
            if ((int const   )*np___0 == 36) {
#line 231
              n___0 = (size_t )0;
#line 233
              np___0 = cp;
#line 233
              while (1) {
#line 233
                if ((int const   )*np___0 >= 48) {
#line 233
                  if (! ((int const   )*np___0 <= 57)) {
#line 233
                    break;
                  }
                } else {
#line 233
                  break;
                }
#line 234
                if (n___0 <= 1844674407370955161UL) {
#line 234
                  tmp___3 = n___0 * 10UL;
                } else {
#line 234
                  tmp___3 = 0xffffffffffffffffUL;
                }
#line 234
                tmp___4 = xsum(tmp___3, (size_t )((int const   )*np___0 - 48));
#line 234
                n___0 = (size_t )tmp___4;
#line 233
                np___0 ++;
              }
#line 235
              if (n___0 == 0UL) {
#line 237
                goto error;
              }
#line 238
              if (n___0 == 0xffffffffffffffffUL) {
#line 240
                goto error;
              }
#line 241
              dp->width_arg_index = n___0 - 1UL;
#line 242
              cp = np___0 + 1;
            }
          }
        }
#line 245
        if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 247
          tmp___5 = arg_posn;
#line 247
          arg_posn ++;
#line 247
          dp->width_arg_index = tmp___5;
#line 248
          if (dp->width_arg_index == 0xffffffffffffffffUL) {
#line 250
            goto error;
          }
        }
#line 252
        n___1 = dp->width_arg_index;
#line 252
        if (n___1 >= a_allocated) {
#line 252
          if (a_allocated <= 9223372036854775807UL) {
#line 252
            a_allocated *= 2UL;
          } else {
#line 252
            a_allocated = 0xffffffffffffffffUL;
          }
#line 252
          if (a_allocated <= n___1) {
#line 252
            tmp___6 = xsum(n___1, (size_t )1);
#line 252
            a_allocated = (size_t )tmp___6;
          }
#line 252
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 252
            memory_size = a_allocated * sizeof(argument );
          } else {
#line 252
            memory_size = 0xffffffffffffffffUL;
          }
#line 252
          if (memory_size == 0xffffffffffffffffUL) {
#line 252
            goto out_of_memory;
          }
#line 252
          if (a->arg) {
#line 252
            tmp___7 = realloc((void *)a->arg, memory_size);
#line 252
            tmp___9 = tmp___7;
          } else {
#line 252
            tmp___8 = malloc(memory_size);
#line 252
            tmp___9 = tmp___8;
          }
#line 252
          memory = (argument *)tmp___9;
#line 252
          if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 252
            goto out_of_memory;
          }
#line 252
          a->arg = memory;
        }
#line 252
        while (a->count <= n___1) {
#line 252
          tmp___10 = a->count;
#line 252
          (a->count) ++;
#line 252
          (a->arg + tmp___10)->type = (arg_type )0;
        }
#line 252
        if ((unsigned int )(a->arg + n___1)->type == 0U) {
#line 252
          (a->arg + n___1)->type = (arg_type )5;
        } else
#line 252
        if ((unsigned int )(a->arg + n___1)->type != 5U) {
#line 252
          goto error;
        }
      } else
#line 254
      if ((int const   )*cp >= 48) {
#line 254
        if ((int const   )*cp <= 57) {
#line 258
          dp->width_start = cp;
#line 259
          while (1) {
#line 259
            if ((int const   )*cp >= 48) {
#line 259
              if (! ((int const   )*cp <= 57)) {
#line 259
                break;
              }
            } else {
#line 259
              break;
            }
#line 259
            cp ++;
          }
#line 261
          dp->width_end = cp;
#line 262
          width_length = (size_t )(dp->width_end - dp->width_start);
#line 263
          if (max_width_length < width_length) {
#line 264
            max_width_length = width_length;
          }
        }
      }
#line 268
      if ((int const   )*cp == 46) {
#line 270
        cp ++;
#line 271
        if ((int const   )*cp == 42) {
#line 273
          dp->precision_start = cp - 1;
#line 274
          cp ++;
#line 275
          dp->precision_end = cp;
#line 276
          if (max_precision_length < 2UL) {
#line 277
            max_precision_length = (size_t )2;
          }
#line 280
          if ((int const   )*cp >= 48) {
#line 280
            if ((int const   )*cp <= 57) {
#line 284
              np___1 = cp;
#line 284
              while (1) {
#line 284
                if ((int const   )*np___1 >= 48) {
#line 284
                  if (! ((int const   )*np___1 <= 57)) {
#line 284
                    break;
                  }
                } else {
#line 284
                  break;
                }
#line 284
                np___1 ++;
              }
#line 286
              if ((int const   )*np___1 == 36) {
#line 288
                n___2 = (size_t )0;
#line 290
                np___1 = cp;
#line 290
                while (1) {
#line 290
                  if ((int const   )*np___1 >= 48) {
#line 290
                    if (! ((int const   )*np___1 <= 57)) {
#line 290
                      break;
                    }
                  } else {
#line 290
                    break;
                  }
#line 291
                  if (n___2 <= 1844674407370955161UL) {
#line 291
                    tmp___11 = n___2 * 10UL;
                  } else {
#line 291
                    tmp___11 = 0xffffffffffffffffUL;
                  }
#line 291
                  tmp___12 = xsum(tmp___11, (size_t )((int const   )*np___1 - 48));
#line 291
                  n___2 = (size_t )tmp___12;
#line 290
                  np___1 ++;
                }
#line 292
                if (n___2 == 0UL) {
#line 294
                  goto error;
                }
#line 295
                if (n___2 == 0xffffffffffffffffUL) {
#line 298
                  goto error;
                }
#line 299
                dp->precision_arg_index = n___2 - 1UL;
#line 300
                cp = np___1 + 1;
              }
            }
          }
#line 303
          if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 305
            tmp___13 = arg_posn;
#line 305
            arg_posn ++;
#line 305
            dp->precision_arg_index = tmp___13;
#line 306
            if (dp->precision_arg_index == 0xffffffffffffffffUL) {
#line 308
              goto error;
            }
          }
#line 310
          n___3 = dp->precision_arg_index;
#line 310
          if (n___3 >= a_allocated) {
#line 310
            if (a_allocated <= 9223372036854775807UL) {
#line 310
              a_allocated *= 2UL;
            } else {
#line 310
              a_allocated = 0xffffffffffffffffUL;
            }
#line 310
            if (a_allocated <= n___3) {
#line 310
              tmp___14 = xsum(n___3, (size_t )1);
#line 310
              a_allocated = (size_t )tmp___14;
            }
#line 310
            if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 310
              memory_size___0 = a_allocated * sizeof(argument );
            } else {
#line 310
              memory_size___0 = 0xffffffffffffffffUL;
            }
#line 310
            if (memory_size___0 == 0xffffffffffffffffUL) {
#line 310
              goto out_of_memory;
            }
#line 310
            if (a->arg) {
#line 310
              tmp___15 = realloc((void *)a->arg, memory_size___0);
#line 310
              tmp___17 = tmp___15;
            } else {
#line 310
              tmp___16 = malloc(memory_size___0);
#line 310
              tmp___17 = tmp___16;
            }
#line 310
            memory___0 = (argument *)tmp___17;
#line 310
            if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 310
              goto out_of_memory;
            }
#line 310
            a->arg = memory___0;
          }
#line 310
          while (a->count <= n___3) {
#line 310
            tmp___18 = a->count;
#line 310
            (a->count) ++;
#line 310
            (a->arg + tmp___18)->type = (arg_type )0;
          }
#line 310
          if ((unsigned int )(a->arg + n___3)->type == 0U) {
#line 310
            (a->arg + n___3)->type = (arg_type )5;
          } else
#line 310
          if ((unsigned int )(a->arg + n___3)->type != 5U) {
#line 310
            goto error;
          }
        } else {
#line 316
          dp->precision_start = cp - 1;
#line 317
          while (1) {
#line 317
            if ((int const   )*cp >= 48) {
#line 317
              if (! ((int const   )*cp <= 57)) {
#line 317
                break;
              }
            } else {
#line 317
              break;
            }
#line 317
            cp ++;
          }
#line 319
          dp->precision_end = cp;
#line 320
          precision_length = (size_t )(dp->precision_end - dp->precision_start);
#line 321
          if (max_precision_length < precision_length) {
#line 322
            max_precision_length = precision_length;
          }
        }
      }
#line 331
      flags = 0;
#line 333
      while (1) {
#line 335
        if ((int const   )*cp == 104) {
#line 337
          flags |= 1 << (flags & 1);
#line 338
          cp ++;
        } else
#line 340
        if ((int const   )*cp == 76) {
#line 342
          flags |= 4;
#line 343
          cp ++;
        } else
#line 345
        if ((int const   )*cp == 108) {
#line 347
          flags += 8;
#line 348
          cp ++;
        } else
#line 350
        if ((int const   )*cp == 106) {
#line 352
          if (sizeof(intmax_t ) > sizeof(long )) {
#line 355
            flags += 16;
          } else
#line 357
          if (sizeof(intmax_t ) > sizeof(int )) {
#line 360
            flags += 8;
          }
#line 362
          cp ++;
        } else
#line 364
        if ((int const   )*cp == 122) {
#line 364
          goto _L;
        } else
#line 364
        if ((int const   )*cp == 90) {
          _L: /* CIL Label */ 
#line 369
          if (sizeof(size_t ) > sizeof(long )) {
#line 372
            flags += 16;
          } else
#line 374
          if (sizeof(size_t ) > sizeof(int )) {
#line 377
            flags += 8;
          }
#line 379
          cp ++;
        } else
#line 381
        if ((int const   )*cp == 116) {
#line 383
          if (sizeof(ptrdiff_t ) > sizeof(long )) {
#line 386
            flags += 16;
          } else
#line 388
          if (sizeof(ptrdiff_t ) > sizeof(int )) {
#line 391
            flags += 8;
          }
#line 393
          cp ++;
        } else {
#line 434
          break;
        }
      }
#line 438
      tmp___19 = cp;
#line 438
      cp ++;
#line 438
      c = (char )*tmp___19;
#line 439
      switch ((int )c) {
      case 105: 
      case 100: 
#line 444
      if (flags >= 16) {
#line 445
        type = (arg_type )9;
      } else
#line 444
      if (flags & 4) {
#line 445
        type = (arg_type )9;
      } else
#line 450
      if (flags >= 8) {
#line 451
        type = (arg_type )7;
      } else
#line 452
      if (flags & 2) {
#line 453
        type = (arg_type )1;
      } else
#line 454
      if (flags & 1) {
#line 455
        type = (arg_type )3;
      } else {
#line 457
        type = (arg_type )5;
      }
#line 458
      break;
      case 88: 
      case 120: 
      case 117: 
      case 111: 
#line 462
      if (flags >= 16) {
#line 463
        type = (arg_type )10;
      } else
#line 462
      if (flags & 4) {
#line 463
        type = (arg_type )10;
      } else
#line 468
      if (flags >= 8) {
#line 469
        type = (arg_type )8;
      } else
#line 470
      if (flags & 2) {
#line 471
        type = (arg_type )2;
      } else
#line 472
      if (flags & 1) {
#line 473
        type = (arg_type )4;
      } else {
#line 475
        type = (arg_type )6;
      }
#line 476
      break;
      case 65: 
      case 97: 
      case 71: 
      case 103: 
      case 69: 
      case 101: 
      case 70: 
      case 102: 
#line 479
      if (flags >= 16) {
#line 480
        type = (arg_type )12;
      } else
#line 479
      if (flags & 4) {
#line 480
        type = (arg_type )12;
      } else {
#line 482
        type = (arg_type )11;
      }
#line 483
      break;
      case 99: 
#line 485
      if (flags >= 8) {
#line 487
        type = (arg_type )14;
      } else {
#line 492
        type = (arg_type )13;
      }
#line 493
      break;
      case 67: 
#line 496
      type = (arg_type )14;
#line 497
      c = (char )'c';
#line 498
      break;
      case 115: 
#line 501
      if (flags >= 8) {
#line 503
        type = (arg_type )16;
      } else {
#line 508
        type = (arg_type )15;
      }
#line 509
      break;
      case 83: 
#line 512
      type = (arg_type )16;
#line 513
      c = (char )'s';
#line 514
      break;
      case 112: 
#line 517
      type = (arg_type )17;
#line 518
      break;
      case 110: 
#line 522
      if (flags >= 16) {
#line 523
        type = (arg_type )22;
      } else
#line 522
      if (flags & 4) {
#line 523
        type = (arg_type )22;
      } else
#line 528
      if (flags >= 8) {
#line 529
        type = (arg_type )21;
      } else
#line 530
      if (flags & 2) {
#line 531
        type = (arg_type )18;
      } else
#line 532
      if (flags & 1) {
#line 533
        type = (arg_type )19;
      } else {
#line 535
        type = (arg_type )20;
      }
#line 536
      break;
      case 37: 
#line 549
      type = (arg_type )0;
#line 550
      break;
      default: 
#line 553
      goto error;
      }
#line 557
      if ((unsigned int )type != 0U) {
#line 559
        dp->arg_index = arg_index;
#line 560
        if (dp->arg_index == 0xffffffffffffffffUL) {
#line 562
          tmp___20 = arg_posn;
#line 562
          arg_posn ++;
#line 562
          dp->arg_index = tmp___20;
#line 563
          if (dp->arg_index == 0xffffffffffffffffUL) {
#line 565
            goto error;
          }
        }
#line 567
        n___4 = dp->arg_index;
#line 567
        if (n___4 >= a_allocated) {
#line 567
          if (a_allocated <= 9223372036854775807UL) {
#line 567
            a_allocated *= 2UL;
          } else {
#line 567
            a_allocated = 0xffffffffffffffffUL;
          }
#line 567
          if (a_allocated <= n___4) {
#line 567
            tmp___21 = xsum(n___4, (size_t )1);
#line 567
            a_allocated = (size_t )tmp___21;
          }
#line 567
          if (a_allocated <= 0xffffffffffffffffUL / sizeof(argument )) {
#line 567
            memory_size___1 = a_allocated * sizeof(argument );
          } else {
#line 567
            memory_size___1 = 0xffffffffffffffffUL;
          }
#line 567
          if (memory_size___1 == 0xffffffffffffffffUL) {
#line 567
            goto out_of_memory;
          }
#line 567
          if (a->arg) {
#line 567
            tmp___22 = realloc((void *)a->arg, memory_size___1);
#line 567
            tmp___24 = tmp___22;
          } else {
#line 567
            tmp___23 = malloc(memory_size___1);
#line 567
            tmp___24 = tmp___23;
          }
#line 567
          memory___1 = (argument *)tmp___24;
#line 567
          if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 567
            goto out_of_memory;
          }
#line 567
          a->arg = memory___1;
        }
#line 567
        while (a->count <= n___4) {
#line 567
          tmp___25 = a->count;
#line 567
          (a->count) ++;
#line 567
          (a->arg + tmp___25)->type = (arg_type )0;
        }
#line 567
        if ((unsigned int )(a->arg + n___4)->type == 0U) {
#line 567
          (a->arg + n___4)->type = type;
        } else
#line 567
        if ((unsigned int )(a->arg + n___4)->type != (unsigned int )type) {
#line 567
          goto error;
        }
      }
#line 569
      dp->conversion = c;
#line 570
      dp->dir_end = cp;
#line 573
      (d->count) ++;
#line 574
      if (d->count >= d_allocated) {
#line 579
        if (d_allocated <= 9223372036854775807UL) {
#line 579
          d_allocated *= 2UL;
        } else {
#line 579
          d_allocated = 0xffffffffffffffffUL;
        }
#line 580
        if (d_allocated <= 0xffffffffffffffffUL / sizeof(char_directive )) {
#line 580
          memory_size___2 = d_allocated * sizeof(char_directive );
        } else {
#line 580
          memory_size___2 = 0xffffffffffffffffUL;
        }
#line 581
        if (memory_size___2 == 0xffffffffffffffffUL) {
#line 583
          goto out_of_memory;
        }
#line 584
        tmp___26 = realloc((void *)d->dir, memory_size___2);
#line 584
        memory___2 = (char_directive *)tmp___26;
#line 585
        if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 587
          goto out_of_memory;
        }
#line 588
        d->dir = memory___2;
      }
    }
  }
#line 599
  (d->dir + d->count)->dir_start = cp;
#line 601
  d->max_width_length = max_width_length;
#line 602
  d->max_precision_length = max_precision_length;
#line 603
  return (0);
  error: 
#line 606
  if (a->arg) {
#line 607
    free((void *)a->arg);
  }
#line 608
  if (d->dir) {
#line 609
    free((void *)d->dir);
  }
#line 610
  tmp___27 = __errno_location();
#line 610
  *tmp___27 = 22;
#line 611
  return (-1);
  out_of_memory: 
#line 614
  if (a->arg) {
#line 615
    free((void *)a->arg);
  }
#line 616
  if (d->dir) {
#line 617
    free((void *)d->dir);
  }
  out_of_memory_1: 
#line 619
  tmp___28 = __errno_location();
#line 619
  *tmp___28 = 12;
#line 620
  return (-1);
}
}
#line 1 "cil-7XdkxLlw.o"
#pragma merger("0","../lib/priv-set.o.i","")
#line 1 "cil-lj_rSbsm.o"
#pragma merger("0","../lib/progname.o.i","")
#line 54 "/usr/include/errno.h"
extern char *program_invocation_name ;
#line 54
extern char *program_invocation_short_name ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/progname.c"
char const   *program_name  =    (char const   *)((void *)0);
#line 34 "/home/wslee/project/coreutils-8.1/lib/progname.c"
void set_program_name(char const   *argv0 ) 
{ 
  char const   *slash ;
  char const   *base ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 45
  tmp = strrchr(argv0, '/');
#line 45
  slash = (char const   *)tmp;
#line 46
  if ((unsigned long )slash != (unsigned long )((void *)0)) {
#line 46
    base = slash + 1;
  } else {
#line 46
    base = argv0;
  }
#line 47
  if (base - argv0 >= 7L) {
#line 47
    tmp___1 = strncmp(base - 7, "/.libs/", (size_t )7);
#line 47
    if (tmp___1 == 0) {
#line 49
      argv0 = base;
#line 50
      tmp___0 = strncmp(base, "lt-", (size_t )3);
#line 50
      if (tmp___0 == 0) {
#line 52
        argv0 = base + 3;
#line 56
        program_invocation_short_name = (char *)argv0;
      }
    }
  }
#line 70
  program_name = argv0;
#line 76
  program_invocation_name = (char *)argv0;
#line 78
  return;
}
}
#line 1 "cil-y1_1yoqP.o"
#pragma merger("0","../lib/propername.o.i","")
#line 92 "/home/wslee/project/coreutils-8.1/lib/propername.h"
char const   *proper_name(char const   *name ) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/trim.h"
char *trim2(char const   *s , int how ) ;
#line 111 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswalnum)(wint_t __wc ) ;
#line 69 "/home/wslee/project/coreutils-8.1/lib/xstriconv.h"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 119 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 48 "/home/wslee/project/coreutils-8.1/lib/propername.c"
static _Bool mbsstr_trimmed_wordbounded(char const   *string , char const   *sub ) 
{ 
  char *tsub ;
  char *tmp ;
  _Bool found ;
  char const   *tsub_in_string ;
  char *tmp___0 ;
  mbui_iterator_t string_iter ;
  _Bool word_boundary_before ;
  _Bool word_boundary_after ;
  mbchar_t last_char_before_tsub ;
  int tmp___1 ;
  int tmp___2 ;
  mbui_iterator_t tsub_iter ;
  int tmp___3 ;
  int tmp___4 ;
  mbchar_t first_char_after_tsub ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  _Bool word_boundary_before___0 ;
  char const   *p ;
  _Bool word_boundary_after___0 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  size_t tmp___11 ;

  {
#line 51
  tmp = trim2(sub, 2);
#line 51
  tsub = tmp;
#line 52
  found = (_Bool)0;
#line 54
  while ((int const   )*string != 0) {
#line 56
    tmp___0 = mbsstr(string, (char const   *)tsub);
#line 56
    tsub_in_string = (char const   *)tmp___0;
#line 57
    if ((unsigned long )tsub_in_string == (unsigned long )((void *)0)) {
#line 58
      break;
    } else {
#line 61
      tmp___11 = __ctype_get_mb_cur_max();
#line 61
      if (tmp___11 > 1UL) {
#line 67
        string_iter.cur.ptr = string;
#line 67
        string_iter.in_shift = (_Bool)0;
#line 67
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 67
        string_iter.next_done = (_Bool)0;
#line 68
        word_boundary_before = (_Bool)1;
#line 69
        if ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string) {
#line 72
          while (1) {
#line 74
            mbuiter_multi_next(& string_iter);
#line 74
            if (string_iter.cur.wc_valid) {
#line 74
              if (string_iter.cur.wc == 0) {
#line 74
                tmp___1 = 0;
              } else {
#line 74
                tmp___1 = 1;
              }
            } else {
#line 74
              tmp___1 = 1;
            }
#line 74
            if (! tmp___1) {
#line 75
              abort();
            }
#line 76
            last_char_before_tsub = string_iter.cur;
#line 77
            string_iter.cur.ptr += string_iter.cur.bytes;
#line 77
            string_iter.next_done = (_Bool)0;
#line 72
            if (! ((unsigned long )string_iter.cur.ptr < (unsigned long )tsub_in_string)) {
#line 72
              break;
            }
          }
#line 80
          if (last_char_before_tsub.wc_valid) {
#line 80
            tmp___2 = iswalnum((wint_t )last_char_before_tsub.wc);
#line 80
            if (tmp___2) {
#line 81
              word_boundary_before = (_Bool)0;
            }
          }
        }
#line 84
        string_iter.cur.ptr = tsub_in_string;
#line 84
        string_iter.in_shift = (_Bool)0;
#line 84
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 84
        string_iter.next_done = (_Bool)0;
#line 88
        tsub_iter.cur.ptr = (char const   *)tsub;
#line 88
        tsub_iter.in_shift = (_Bool)0;
#line 88
        memset((void *)(& tsub_iter.state), '\000', sizeof(mbstate_t ));
#line 88
        tsub_iter.next_done = (_Bool)0;
#line 88
        while (1) {
#line 88
          mbuiter_multi_next(& tsub_iter);
#line 88
          if (tsub_iter.cur.wc_valid) {
#line 88
            if (tsub_iter.cur.wc == 0) {
#line 88
              tmp___4 = 0;
            } else {
#line 88
              tmp___4 = 1;
            }
          } else {
#line 88
            tmp___4 = 1;
          }
#line 88
          if (! tmp___4) {
#line 88
            break;
          }
#line 92
          mbuiter_multi_next(& string_iter);
#line 92
          if (string_iter.cur.wc_valid) {
#line 92
            if (string_iter.cur.wc == 0) {
#line 92
              tmp___3 = 0;
            } else {
#line 92
              tmp___3 = 1;
            }
          } else {
#line 92
            tmp___3 = 1;
          }
#line 92
          if (! tmp___3) {
#line 93
            abort();
          }
#line 94
          string_iter.cur.ptr += string_iter.cur.bytes;
#line 94
          string_iter.next_done = (_Bool)0;
#line 88
          tsub_iter.cur.ptr += tsub_iter.cur.bytes;
#line 88
          tsub_iter.next_done = (_Bool)0;
        }
#line 97
        word_boundary_after = (_Bool)1;
#line 98
        mbuiter_multi_next(& string_iter);
#line 98
        if (string_iter.cur.wc_valid) {
#line 98
          if (string_iter.cur.wc == 0) {
#line 98
            tmp___6 = 0;
          } else {
#line 98
            tmp___6 = 1;
          }
        } else {
#line 98
          tmp___6 = 1;
        }
#line 98
        if (tmp___6) {
#line 100
          first_char_after_tsub = string_iter.cur;
#line 101
          if (first_char_after_tsub.wc_valid) {
#line 101
            tmp___5 = iswalnum((wint_t )first_char_after_tsub.wc);
#line 101
            if (tmp___5) {
#line 102
              word_boundary_after = (_Bool)0;
            }
          }
        }
#line 105
        if (word_boundary_before) {
#line 105
          if (word_boundary_after) {
#line 107
            found = (_Bool)1;
#line 108
            break;
          }
        }
#line 111
        string_iter.cur.ptr = tsub_in_string;
#line 111
        string_iter.in_shift = (_Bool)0;
#line 111
        memset((void *)(& string_iter.state), '\000', sizeof(mbstate_t ));
#line 111
        string_iter.next_done = (_Bool)0;
#line 112
        mbuiter_multi_next(& string_iter);
#line 112
        if (string_iter.cur.wc_valid) {
#line 112
          if (string_iter.cur.wc == 0) {
#line 112
            tmp___7 = 0;
          } else {
#line 112
            tmp___7 = 1;
          }
        } else {
#line 112
          tmp___7 = 1;
        }
#line 112
        if (! tmp___7) {
#line 113
          break;
        }
#line 114
        string = tsub_in_string + string_iter.cur.bytes;
      } else {
#line 122
        word_boundary_before___0 = (_Bool)1;
#line 123
        if ((unsigned long )string < (unsigned long )tsub_in_string) {
#line 124
          tmp___8 = __ctype_b_loc();
#line 124
          if ((int const   )*(*tmp___8 + (int )((unsigned char )*(tsub_in_string + -1))) & 8) {
#line 125
            word_boundary_before___0 = (_Bool)0;
          }
        }
#line 127
        tmp___9 = strlen((char const   *)tsub);
#line 127
        p = tsub_in_string + tmp___9;
#line 128
        word_boundary_after___0 = (_Bool)1;
#line 129
        if ((int const   )*p != 0) {
#line 130
          tmp___10 = __ctype_b_loc();
#line 130
          if ((int const   )*(*tmp___10 + (int )((unsigned char )*p)) & 8) {
#line 131
            word_boundary_after___0 = (_Bool)0;
          }
        }
#line 133
        if (word_boundary_before___0) {
#line 133
          if (word_boundary_after___0) {
#line 135
            found = (_Bool)1;
#line 136
            break;
          }
        }
#line 139
        if ((int const   )*tsub_in_string == 0) {
#line 140
          break;
        }
#line 141
        string = tsub_in_string + 1;
      }
    }
  }
#line 145
  free((void *)tsub);
#line 146
  return (found);
}
}
#line 151 "/home/wslee/project/coreutils-8.1/lib/propername.c"
char const   *proper_name(char const   *name ) 
{ 
  char const   *translation ;
  char *tmp ;
  char *result ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  _Bool tmp___7 ;

  {
#line 155
  tmp = gettext(name);
#line 155
  translation = (char const   *)tmp;
#line 157
  if ((unsigned long )translation != (unsigned long )name) {
#line 160
    tmp___7 = mbsstr_trimmed_wordbounded(translation, name);
#line 160
    if (tmp___7) {
#line 161
      return (translation);
    } else {
#line 165
      if (sizeof(char ) == 1UL) {
#line 165
        tmp___0 = strlen(translation);
#line 165
        tmp___1 = strlen(name);
#line 165
        tmp___2 = xmalloc((((tmp___0 + 2UL) + tmp___1) + 1UL) + 1UL);
#line 165
        tmp___6 = tmp___2;
      } else {
#line 165
        tmp___3 = strlen(translation);
#line 165
        tmp___4 = strlen(name);
#line 165
        tmp___5 = xnmalloc((((tmp___3 + 2UL) + tmp___4) + 1UL) + 1UL, sizeof(char ));
#line 165
        tmp___6 = tmp___5;
      }
#line 165
      result = (char *)tmp___6;
#line 168
      sprintf((char * __restrict  )result, (char const   * __restrict  )"%s (%s)",
              translation, name);
#line 169
      return ((char const   *)result);
    }
  } else {
#line 173
    return (name);
  }
}
}
#line 181 "/home/wslee/project/coreutils-8.1/lib/propername.c"
char const   *proper_name_utf8(char const   *name_ascii , char const   *name_utf8 ) 
{ 
  char const   *translation ;
  char *tmp ;
  char const   *locale_code ;
  char const   *tmp___0 ;
  char *alloc_name_converted ;
  char *alloc_name_converted_translit ;
  char const   *name_converted ;
  char const   *name_converted_translit ;
  char const   *name ;
  char *converted_translit ;
  size_t len ;
  size_t tmp___1 ;
  char *locale_code_translit ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char *result ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  _Bool tmp___15 ;
  _Bool tmp___16 ;
  _Bool tmp___17 ;
  int tmp___18 ;

  {
#line 185
  tmp = gettext(name_ascii);
#line 185
  translation = (char const   *)tmp;
#line 188
  tmp___0 = locale_charset();
#line 188
  locale_code = tmp___0;
#line 189
  alloc_name_converted = (char *)((void *)0);
#line 190
  alloc_name_converted_translit = (char *)((void *)0);
#line 191
  name_converted = (char const   *)((void *)0);
#line 192
  name_converted_translit = (char const   *)((void *)0);
#line 195
  tmp___6 = c_strcasecmp(locale_code, "UTF-8");
#line 195
  if (tmp___6 != 0) {
#line 198
    alloc_name_converted = xstr_iconv(name_utf8, "UTF-8", locale_code);
#line 198
    name_converted = (char const   *)alloc_name_converted;
#line 206
    tmp___1 = strlen(locale_code);
#line 206
    len = tmp___1;
#line 207
    if (sizeof(char ) == 1UL) {
#line 207
      tmp___2 = xmalloc((len + 10UL) + 1UL);
#line 207
      tmp___4 = tmp___2;
    } else {
#line 207
      tmp___3 = xnmalloc((len + 10UL) + 1UL, sizeof(char ));
#line 207
      tmp___4 = tmp___3;
    }
#line 207
    locale_code_translit = (char *)tmp___4;
#line 208
    memcpy((void * __restrict  )locale_code_translit, (void const   * __restrict  )locale_code,
           len);
#line 209
    memcpy((void * __restrict  )(locale_code_translit + len), (void const   * __restrict  )"//TRANSLIT",
           (size_t )11);
#line 211
    converted_translit = xstr_iconv(name_utf8, "UTF-8", (char const   *)locale_code_translit);
#line 214
    free((void *)locale_code_translit);
#line 216
    if ((unsigned long )converted_translit != (unsigned long )((void *)0)) {
#line 223
      tmp___5 = strchr((char const   *)converted_translit, '?');
#line 223
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 224
        free((void *)converted_translit);
      } else {
#line 227
        alloc_name_converted_translit = converted_translit;
#line 227
        name_converted_translit = (char const   *)alloc_name_converted_translit;
      }
    }
  } else {
#line 236
    name_converted = name_utf8;
#line 237
    name_converted_translit = name_utf8;
  }
#line 241
  if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 241
    name = name_converted;
  } else {
#line 241
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 241
      tmp___7 = name_converted_translit;
    } else {
#line 241
      tmp___7 = name_ascii;
    }
#line 241
    name = tmp___7;
  }
#line 248
  tmp___18 = strcmp(translation, name_ascii);
#line 248
  if (tmp___18 != 0) {
#line 251
    tmp___15 = mbsstr_trimmed_wordbounded(translation, name_ascii);
#line 251
    if (tmp___15) {
#line 251
      goto _L;
    } else
#line 251
    if ((unsigned long )name_converted != (unsigned long )((void *)0)) {
#line 251
      tmp___16 = mbsstr_trimmed_wordbounded(translation, name_converted);
#line 251
      if (tmp___16) {
#line 251
        goto _L;
      } else {
#line 251
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 251
    if ((unsigned long )name_converted_translit != (unsigned long )((void *)0)) {
#line 251
      tmp___17 = mbsstr_trimmed_wordbounded(translation, name_converted_translit);
#line 251
      if (tmp___17) {
        _L: /* CIL Label */ 
#line 257
        if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 258
          free((void *)alloc_name_converted);
        }
#line 259
        if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 260
          free((void *)alloc_name_converted_translit);
        }
#line 261
        return (translation);
      } else {
#line 251
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 266
      if (sizeof(char ) == 1UL) {
#line 266
        tmp___8 = strlen(translation);
#line 266
        tmp___9 = strlen(name);
#line 266
        tmp___10 = xmalloc((((tmp___8 + 2UL) + tmp___9) + 1UL) + 1UL);
#line 266
        tmp___14 = tmp___10;
      } else {
#line 266
        tmp___11 = strlen(translation);
#line 266
        tmp___12 = strlen(name);
#line 266
        tmp___13 = xnmalloc((((tmp___11 + 2UL) + tmp___12) + 1UL) + 1UL, sizeof(char ));
#line 266
        tmp___14 = tmp___13;
      }
#line 266
      result = (char *)tmp___14;
#line 269
      sprintf((char * __restrict  )result, (char const   * __restrict  )"%s (%s)",
              translation, name);
#line 271
      if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 272
        free((void *)alloc_name_converted);
      }
#line 273
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 274
        free((void *)alloc_name_converted_translit);
      }
#line 275
      return ((char const   *)result);
    }
  } else {
#line 280
    if ((unsigned long )alloc_name_converted != (unsigned long )((void *)0)) {
#line 280
      if ((unsigned long )alloc_name_converted != (unsigned long )name) {
#line 281
        free((void *)alloc_name_converted);
      }
    }
#line 282
    if ((unsigned long )alloc_name_converted_translit != (unsigned long )((void *)0)) {
#line 282
      if ((unsigned long )alloc_name_converted_translit != (unsigned long )name) {
#line 284
        free((void *)alloc_name_converted_translit);
      }
    }
#line 285
    return (name);
  }
}
}
#line 1 "cil-iFNr0nHV.o"
#pragma merger("0","../lib/quote.o.i","")
#line 28 "/home/wslee/project/coreutils-8.1/lib/quote.c"
char const   *quote_n(int n , char const   *name ) 
{ 
  char *tmp ;

  {
#line 31
  tmp = quotearg_n_style(n, (enum quoting_style )6, name);
#line 31
  return ((char const   *)tmp);
}
}
#line 36 "/home/wslee/project/coreutils-8.1/lib/quote.c"
char const   *quote(char const   *name ) 
{ 
  char const   *tmp ;

  {
#line 39
  tmp = quote_n(0, name);
#line 39
  return (tmp);
}
}
#line 1 "cil-dm6B30yc.o"
#pragma merger("0","../lib/quotearg.o.i","")
#line 234 "/home/wslee/project/coreutils-8.1/lib/quotearg.h"
char const   * const  quoting_style_args[9] ;
#line 235
enum quoting_style  const  quoting_style_vals[8] ;
#line 245
struct quoting_options *clone_quoting_options(struct quoting_options *o ) ;
#line 248
enum quoting_style get_quoting_style(struct quoting_options *o ) ;
#line 252
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) ;
#line 261
int set_char_quoting(struct quoting_options *o , char c , int i ) ;
#line 267
int set_quoting_flags(struct quoting_options *o , int i ) ;
#line 278
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) ;
#line 293
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) ;
#line 300
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) ;
#line 309
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) ;
#line 319
char *quotearg_n(int n , char const   *arg ) ;
#line 322
char *quotearg(char const   *arg ) ;
#line 327
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) ;
#line 330
char *quotearg_mem(char const   *arg , size_t argsize ) ;
#line 340
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 344
char *quotearg_style(enum quoting_style s , char const   *arg ) ;
#line 347
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) ;
#line 352
char *quotearg_char(char const   *arg , char ch ) ;
#line 355
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) ;
#line 361
char *quotearg_colon_mem(char const   *arg , size_t argsize ) ;
#line 367
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) ;
#line 372
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) ;
#line 377
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) ;
#line 382
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) ;
#line 387
void quotearg_free(void) ;
#line 119 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 231
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 232
__inline static char *xcharalloc(size_t n )  __attribute__((__malloc__)) ;
#line 232 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static char *xcharalloc(size_t n ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 235
  if (sizeof(char ) == 1UL) {
#line 235
    tmp = xmalloc(n);
#line 235
    tmp___1 = tmp;
  } else {
#line 235
    tmp___0 = xnmalloc(n, sizeof(char ));
#line 235
    tmp___1 = tmp___0;
  }
#line 235
  return ((char *)tmp___1);
}
}
#line 66 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char const   * const  quoting_style_args[9]  = 
#line 66 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
  {      (char const   * const  )"literal",      (char const   * const  )"shell",      (char const   * const  )"shell-always",      (char const   * const  )"c", 
        (char const   * const  )"c-maybe",      (char const   * const  )"escape",      (char const   * const  )"locale",      (char const   * const  )"clocale", 
        (char const   * const  )0};
#line 80 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
enum quoting_style  const  quoting_style_vals[8]  = 
#line 80
  {      (enum quoting_style  const  )0,      (enum quoting_style  const  )1,      (enum quoting_style  const  )2,      (enum quoting_style  const  )3, 
        (enum quoting_style  const  )4,      (enum quoting_style  const  )5,      (enum quoting_style  const  )6,      (enum quoting_style  const  )7};
#line 93 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static struct quoting_options default_quoting_options  ;
#line 98 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
struct quoting_options *clone_quoting_options(struct quoting_options *o ) 
{ 
  int e ;
  int *tmp ;
  struct quoting_options *p ;
  struct quoting_options *tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;

  {
#line 101
  tmp = __errno_location();
#line 101
  e = *tmp;
#line 102
  if (o) {
#line 102
    tmp___0 = o;
  } else {
#line 102
    tmp___0 = & default_quoting_options;
  }
#line 102
  tmp___1 = xmemdup((void const   *)tmp___0, sizeof(*o));
#line 102
  p = (struct quoting_options *)tmp___1;
#line 104
  tmp___2 = __errno_location();
#line 104
  *tmp___2 = e;
#line 105
  return (p);
}
}
#line 109 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
enum quoting_style get_quoting_style(struct quoting_options *o ) 
{ 
  struct quoting_options *tmp ;

  {
#line 112
  if (o) {
#line 112
    tmp = o;
  } else {
#line 112
    tmp = & default_quoting_options;
  }
#line 112
  return (tmp->style);
}
}
#line 117 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
void set_quoting_style(struct quoting_options *o , enum quoting_style s ) 
{ 
  struct quoting_options *tmp ;

  {
#line 120
  if (o) {
#line 120
    tmp = o;
  } else {
#line 120
    tmp = & default_quoting_options;
  }
#line 120
  tmp->style = s;
#line 121
  return;
}
}
#line 128 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
int set_char_quoting(struct quoting_options *o , char c , int i ) 
{ 
  unsigned char uc ;
  unsigned int *p ;
  struct quoting_options *tmp ;
  int shift ;
  int r ;

  {
#line 131
  uc = (unsigned char )c;
#line 132
  if (o) {
#line 132
    tmp = o;
  } else {
#line 132
    tmp = & default_quoting_options;
  }
#line 132
  p = tmp->quote_these_too + (unsigned long )uc / (sizeof(int ) * 8UL);
#line 134
  shift = (int )((unsigned long )uc % (sizeof(int ) * 8UL));
#line 135
  r = (int )((*p >> shift) & 1U);
#line 136
  *p ^= (unsigned int )(((i & 1) ^ r) << shift);
#line 137
  return (r);
}
}
#line 144 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
int set_quoting_flags(struct quoting_options *o , int i ) 
{ 
  int r ;

  {
#line 148
  if (! o) {
#line 149
    o = & default_quoting_options;
  }
#line 150
  r = o->flags;
#line 151
  o->flags = i;
#line 152
  return (r);
}
}
#line 155 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
void set_custom_quoting(struct quoting_options *o , char const   *left_quote , char const   *right_quote ) 
{ 


  {
#line 159
  if (! o) {
#line 160
    o = & default_quoting_options;
  }
#line 161
  o->style = (enum quoting_style )8;
#line 162
  if (! left_quote) {
#line 163
    abort();
  } else
#line 162
  if (! right_quote) {
#line 163
    abort();
  }
#line 164
  o->left_quote = left_quote;
#line 165
  o->right_quote = right_quote;
#line 166
  return;
}
}
#line 169 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static struct quoting_options quoting_options_from_style(enum quoting_style style ) 
{ 
  struct quoting_options o ;

  {
#line 173
  o.style = style;
#line 174
  o.flags = 0;
#line 175
  memset((void *)(o.quote_these_too), 0, sizeof(o.quote_these_too));
#line 176
  return (o);
}
}
#line 181 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static char const   *gettext_quote(char const   *msgid , enum quoting_style s ) 
{ 
  char const   *translation ;
  char *tmp ;

  {
#line 184
  tmp = gettext(msgid);
#line 184
  translation = (char const   *)tmp;
#line 185
  if ((unsigned long )translation == (unsigned long )msgid) {
#line 185
    if ((unsigned int )s == 7U) {
#line 186
      translation = "\"";
    }
  }
#line 187
  return (translation);
}
}
#line 203 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static size_t quotearg_buffer_restyled(char *buffer , size_t buffersize , char const   *arg ,
                                       size_t argsize , enum quoting_style quoting_style ,
                                       int flags , unsigned int const   *quote_these_too ,
                                       char const   *left_quote , char const   *right_quote ) 
{ 
  size_t i ;
  size_t len ;
  char const   *quote_string ;
  size_t quote_string_len ;
  _Bool backslash_escapes ;
  _Bool unibyte_locale ;
  size_t tmp ;
  _Bool elide_outer_quotes ;
  unsigned char c ;
  unsigned char esc ;
  _Bool is_right_quote ;
  int tmp___0 ;
  int tmp___1 ;
  size_t m ;
  _Bool printable ;
  unsigned short const   **tmp___2 ;
  mbstate_t mbstate ;
  wchar_t w ;
  size_t bytes ;
  size_t tmp___3 ;
  size_t j ;
  int tmp___4 ;
  int tmp___5 ;
  size_t ilim ;
  int tmp___6 ;
  size_t tmp___7 ;

  {
#line 212
  len = (size_t )0;
#line 213
  quote_string = (char const   *)0;
#line 214
  quote_string_len = (size_t )0;
#line 215
  backslash_escapes = (_Bool)0;
#line 216
  tmp = __ctype_get_mb_cur_max();
#line 216
  unibyte_locale = (_Bool )(tmp == 1UL);
#line 217
  elide_outer_quotes = (_Bool )((flags & 2) != 0);
#line 228
  switch ((unsigned int )quoting_style) {
  case 4U: 
#line 231
  quoting_style = (enum quoting_style )3;
#line 232
  elide_outer_quotes = (_Bool)1;
  case 3U: 
#line 235
  if (! elide_outer_quotes) {
#line 236
    while (1) {
#line 236
      if (len < buffersize) {
#line 236
        *(buffer + len) = (char )'\"';
      }
#line 236
      len ++;
#line 236
      break;
    }
  }
#line 237
  backslash_escapes = (_Bool)1;
#line 238
  quote_string = "\"";
#line 239
  quote_string_len = (size_t )1;
#line 240
  break;
  case 5U: 
#line 243
  backslash_escapes = (_Bool)1;
#line 244
  elide_outer_quotes = (_Bool)0;
#line 245
  break;
  case 8U: 
  case 7U: 
  case 6U: 
#line 251
  if ((unsigned int )quoting_style != 8U) {
#line 272
    left_quote = gettext_quote("`", quoting_style);
#line 273
    right_quote = gettext_quote("\'", quoting_style);
  }
#line 275
  if (! elide_outer_quotes) {
#line 276
    quote_string = left_quote;
#line 276
    while (*quote_string) {
#line 277
      while (1) {
#line 277
        if (len < buffersize) {
#line 277
          *(buffer + len) = (char )*quote_string;
        }
#line 277
        len ++;
#line 277
        break;
      }
#line 276
      quote_string ++;
    }
  }
#line 278
  backslash_escapes = (_Bool)1;
#line 279
  quote_string = right_quote;
#line 280
  quote_string_len = strlen(quote_string);
#line 282
  break;
  case 1U: 
#line 285
  quoting_style = (enum quoting_style )2;
#line 286
  elide_outer_quotes = (_Bool)1;
  case 2U: 
#line 289
  if (! elide_outer_quotes) {
#line 290
    while (1) {
#line 290
      if (len < buffersize) {
#line 290
        *(buffer + len) = (char )'\'';
      }
#line 290
      len ++;
#line 290
      break;
    }
  }
#line 291
  quote_string = "\'";
#line 292
  quote_string_len = (size_t )1;
#line 293
  break;
  case 0U: 
#line 296
  elide_outer_quotes = (_Bool)0;
#line 297
  break;
  default: 
#line 300
  abort();
  }
#line 303
  i = (size_t )0;
#line 303
  while (1) {
#line 303
    if (argsize == 0xffffffffffffffffUL) {
#line 303
      tmp___6 = (int const   )*(arg + i) == 0;
    } else {
#line 303
      tmp___6 = i == argsize;
    }
#line 303
    if (tmp___6) {
#line 303
      break;
    }
#line 307
    is_right_quote = (_Bool)0;
#line 309
    if (backslash_escapes) {
#line 309
      if (quote_string_len) {
#line 309
        if (i + quote_string_len <= argsize) {
#line 309
          tmp___0 = memcmp((void const   *)(arg + i), (void const   *)quote_string,
                           quote_string_len);
#line 309
          if (tmp___0 == 0) {
#line 314
            if (elide_outer_quotes) {
#line 315
              goto force_outer_quoting_style;
            }
#line 316
            is_right_quote = (_Bool)1;
          }
        }
      }
    }
#line 319
    c = (unsigned char )*(arg + i);
#line 320
    switch ((int )c) {
    case 0: 
#line 323
    if (backslash_escapes) {
#line 325
      if (elide_outer_quotes) {
#line 326
        goto force_outer_quoting_style;
      }
#line 327
      while (1) {
#line 327
        if (len < buffersize) {
#line 327
          *(buffer + len) = (char )'\\';
        }
#line 327
        len ++;
#line 327
        break;
      }
#line 333
      if (i + 1UL < argsize) {
#line 333
        if (48 <= (int )*(arg + (i + 1UL))) {
#line 333
          if ((int const   )*(arg + (i + 1UL)) <= 57) {
#line 335
            while (1) {
#line 335
              if (len < buffersize) {
#line 335
                *(buffer + len) = (char )'0';
              }
#line 335
              len ++;
#line 335
              break;
            }
#line 336
            while (1) {
#line 336
              if (len < buffersize) {
#line 336
                *(buffer + len) = (char )'0';
              }
#line 336
              len ++;
#line 336
              break;
            }
          }
        }
      }
#line 338
      c = (unsigned char )'0';
    } else
#line 344
    if (flags & 1) {
#line 345
      goto __Cont;
    }
#line 346
    break;
    case 63: 
#line 349
    switch ((unsigned int )quoting_style) {
    case 2U: 
#line 352
    if (elide_outer_quotes) {
#line 353
      goto force_outer_quoting_style;
    }
#line 354
    break;
    case 3U: 
#line 357
    if (flags & 4) {
#line 357
      if (i + 2UL < argsize) {
#line 357
        if ((int const   )*(arg + (i + 1UL)) == 63) {
#line 359
          switch ((int const   )*(arg + (i + 2UL))) {
          case 62: 
          case 61: 
          case 60: 
          case 47: 
          case 45: 
          case 41: 
          case 40: 
          case 39: 
          case 33: 
#line 366
          if (elide_outer_quotes) {
#line 367
            goto force_outer_quoting_style;
          }
#line 368
          c = (unsigned char )*(arg + (i + 2UL));
#line 369
          i += 2UL;
#line 370
          while (1) {
#line 370
            if (len < buffersize) {
#line 370
              *(buffer + len) = (char )'?';
            }
#line 370
            len ++;
#line 370
            break;
          }
#line 371
          while (1) {
#line 371
            if (len < buffersize) {
#line 371
              *(buffer + len) = (char )'\"';
            }
#line 371
            len ++;
#line 371
            break;
          }
#line 372
          while (1) {
#line 372
            if (len < buffersize) {
#line 372
              *(buffer + len) = (char )'\"';
            }
#line 372
            len ++;
#line 372
            break;
          }
#line 373
          while (1) {
#line 373
            if (len < buffersize) {
#line 373
              *(buffer + len) = (char )'?';
            }
#line 373
            len ++;
#line 373
            break;
          }
#line 374
          break;
          default: 
#line 377
          break;
          }
        }
      }
    }
#line 379
    break;
    default: 
#line 382
    break;
    }
#line 384
    break;
    case 7: 
#line 386
    esc = (unsigned char )'a';
#line 386
    goto c_escape;
    case 8: 
#line 387
    esc = (unsigned char )'b';
#line 387
    goto c_escape;
    case 12: 
#line 388
    esc = (unsigned char )'f';
#line 388
    goto c_escape;
    case 10: 
#line 389
    esc = (unsigned char )'n';
#line 389
    goto c_and_shell_escape;
    case 13: 
#line 390
    esc = (unsigned char )'r';
#line 390
    goto c_and_shell_escape;
    case 9: 
#line 391
    esc = (unsigned char )'t';
#line 391
    goto c_and_shell_escape;
    case 11: 
#line 392
    esc = (unsigned char )'v';
#line 392
    goto c_escape;
    case 92: 
#line 393
    esc = c;
#line 396
    if (backslash_escapes) {
#line 396
      if (elide_outer_quotes) {
#line 396
        if (quote_string_len) {
#line 397
          goto store_c;
        }
      }
    }
    c_and_shell_escape: 
#line 400
    if ((unsigned int )quoting_style == 2U) {
#line 400
      if (elide_outer_quotes) {
#line 402
        goto force_outer_quoting_style;
      }
    }
    c_escape: 
#line 405
    if (backslash_escapes) {
#line 407
      c = esc;
#line 408
      goto store_escape;
    }
#line 410
    break;
    case 125: 
    case 123: 
#line 413
    if (argsize == 0xffffffffffffffffUL) {
#line 413
      tmp___1 = (int const   )*(arg + 1) == 0;
    } else {
#line 413
      tmp___1 = argsize == 1UL;
    }
#line 413
    if (! tmp___1) {
#line 414
      break;
    }
    case 126: 
    case 35: 
#line 417
    if (i != 0UL) {
#line 418
      break;
    }
    case 124: 
    case 96: 
    case 94: 
    case 91: 
    case 62: 
    case 61: 
    case 60: 
    case 59: 
    case 42: 
    case 41: 
    case 40: 
    case 38: 
    case 36: 
    case 34: 
    case 33: 
    case 32: 
#line 433
    if ((unsigned int )quoting_style == 2U) {
#line 433
      if (elide_outer_quotes) {
#line 435
        goto force_outer_quoting_style;
      }
    }
#line 436
    break;
    case 39: 
#line 439
    if ((unsigned int )quoting_style == 2U) {
#line 441
      if (elide_outer_quotes) {
#line 442
        goto force_outer_quoting_style;
      }
#line 443
      while (1) {
#line 443
        if (len < buffersize) {
#line 443
          *(buffer + len) = (char )'\'';
        }
#line 443
        len ++;
#line 443
        break;
      }
#line 444
      while (1) {
#line 444
        if (len < buffersize) {
#line 444
          *(buffer + len) = (char )'\\';
        }
#line 444
        len ++;
#line 444
        break;
      }
#line 445
      while (1) {
#line 445
        if (len < buffersize) {
#line 445
          *(buffer + len) = (char )'\'';
        }
#line 445
        len ++;
#line 445
        break;
      }
    }
#line 447
    break;
    case 122: 
    case 121: 
    case 120: 
    case 119: 
    case 118: 
    case 117: 
    case 116: 
    case 115: 
    case 114: 
    case 113: 
    case 112: 
    case 111: 
    case 110: 
    case 109: 
    case 108: 
    case 107: 
    case 106: 
    case 105: 
    case 104: 
    case 103: 
    case 102: 
    case 101: 
    case 100: 
    case 99: 
    case 98: 
    case 97: 
    case 95: 
    case 93: 
    case 90: 
    case 89: 
    case 88: 
    case 87: 
    case 86: 
    case 85: 
    case 84: 
    case 83: 
    case 82: 
    case 81: 
    case 80: 
    case 79: 
    case 78: 
    case 77: 
    case 76: 
    case 75: 
    case 74: 
    case 73: 
    case 72: 
    case 71: 
    case 70: 
    case 69: 
    case 68: 
    case 67: 
    case 66: 
    case 65: 
    case 58: 
    case 57: 
    case 56: 
    case 55: 
    case 54: 
    case 53: 
    case 52: 
    case 51: 
    case 50: 
    case 49: 
    case 48: 
    case 47: 
    case 46: 
    case 45: 
    case 44: 
    case 43: 
    case 37: 
#line 471
    break;
    default: 
#line 485
    if (unibyte_locale) {
#line 487
      m = (size_t )1;
#line 488
      tmp___2 = __ctype_b_loc();
#line 488
      printable = (_Bool )(((int const   )*(*tmp___2 + (int )c) & 16384) != 0);
    } else {
#line 493
      memset((void *)(& mbstate), 0, sizeof(mbstate));
#line 495
      m = (size_t )0;
#line 496
      printable = (_Bool)1;
#line 497
      if (argsize == 0xffffffffffffffffUL) {
#line 498
        argsize = strlen(arg);
      }
#line 500
      while (1) {
#line 503
        tmp___3 = mbrtowc((wchar_t * __restrict  )(& w), (char const   * __restrict  )(arg + (i + m)),
                          argsize - (i + m), (mbstate_t * __restrict  )(& mbstate));
#line 503
        bytes = tmp___3;
#line 505
        if (bytes == 0UL) {
#line 506
          break;
        } else
#line 507
        if (bytes == 0xffffffffffffffffUL) {
#line 509
          printable = (_Bool)0;
#line 510
          break;
        } else
#line 512
        if (bytes == 0xfffffffffffffffeUL) {
#line 514
          printable = (_Bool)0;
#line 515
          while (1) {
#line 515
            if (i + m < argsize) {
#line 515
              if (! *(arg + (i + m))) {
#line 515
                break;
              }
            } else {
#line 515
              break;
            }
#line 516
            m ++;
          }
#line 517
          break;
        } else {
#line 525
          if (elide_outer_quotes) {
#line 525
            if ((unsigned int )quoting_style == 2U) {
#line 529
              j = (size_t )1;
#line 529
              while (j < bytes) {
#line 530
                switch ((int const   )*(arg + ((i + m) + j))) {
                case 124: 
                case 96: 
                case 94: 
                case 92: 
                case 91: 
#line 534
                goto force_outer_quoting_style;
                default: 
#line 537
                break;
                }
#line 529
                j ++;
              }
            }
          }
#line 541
          tmp___4 = iswprint((wint_t )w);
#line 541
          if (! tmp___4) {
#line 542
            printable = (_Bool)0;
          }
#line 543
          m += bytes;
        }
#line 500
        tmp___5 = mbsinit((mbstate_t const   *)(& mbstate));
#line 500
        if (tmp___5) {
#line 500
          break;
        }
      }
    }
#line 549
    if (1UL < m) {
#line 549
      goto _L___0;
    } else
#line 549
    if (backslash_escapes) {
#line 549
      if (! printable) {
        _L___0: /* CIL Label */ 
#line 553
        ilim = i + m;
#line 555
        while (1) {
#line 557
          if (backslash_escapes) {
#line 557
            if (! printable) {
#line 559
              if (elide_outer_quotes) {
#line 560
                goto force_outer_quoting_style;
              }
#line 561
              while (1) {
#line 561
                if (len < buffersize) {
#line 561
                  *(buffer + len) = (char )'\\';
                }
#line 561
                len ++;
#line 561
                break;
              }
#line 562
              while (1) {
#line 562
                if (len < buffersize) {
#line 562
                  *(buffer + len) = (char )(48 + ((int )c >> 6));
                }
#line 562
                len ++;
#line 562
                break;
              }
#line 563
              while (1) {
#line 563
                if (len < buffersize) {
#line 563
                  *(buffer + len) = (char )(48 + (((int )c >> 3) & 7));
                }
#line 563
                len ++;
#line 563
                break;
              }
#line 564
              c = (unsigned char )(48 + ((int )c & 7));
            } else {
#line 557
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 566
          if (is_right_quote) {
#line 568
            while (1) {
#line 568
              if (len < buffersize) {
#line 568
                *(buffer + len) = (char )'\\';
              }
#line 568
              len ++;
#line 568
              break;
            }
#line 569
            is_right_quote = (_Bool)0;
          }
#line 571
          if (ilim <= i + 1UL) {
#line 572
            break;
          }
#line 573
          while (1) {
#line 573
            if (len < buffersize) {
#line 573
              *(buffer + len) = (char )c;
            }
#line 573
            len ++;
#line 573
            break;
          }
#line 574
          i ++;
#line 574
          c = (unsigned char )*(arg + i);
        }
#line 577
        goto store_c;
      }
    }
    }
#line 582
    if (backslash_escapes) {
#line 582
      goto _L___3;
    } else
#line 582
    if (elide_outer_quotes) {
      _L___3: /* CIL Label */ 
#line 582
      if (quote_these_too) {
#line 582
        if (! (*(quote_these_too + (unsigned long )c / (sizeof(int ) * 8UL)) & (unsigned int const   )(1 << (unsigned long )c % (sizeof(int ) * 8UL)))) {
#line 582
          goto _L___2;
        }
      } else {
#line 582
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 582
    if (! is_right_quote) {
#line 586
      goto store_c;
    }
    store_escape: 
#line 589
    if (elide_outer_quotes) {
#line 590
      goto force_outer_quoting_style;
    }
#line 591
    while (1) {
#line 591
      if (len < buffersize) {
#line 591
        *(buffer + len) = (char )'\\';
      }
#line 591
      len ++;
#line 591
      break;
    }
    store_c: 
#line 594
    while (1) {
#line 594
      if (len < buffersize) {
#line 594
        *(buffer + len) = (char )c;
      }
#line 594
      len ++;
#line 594
      break;
    }
    __Cont: /* CIL Label */ 
#line 303
    i ++;
  }
#line 597
  if (len == 0UL) {
#line 597
    if ((unsigned int )quoting_style == 2U) {
#line 597
      if (elide_outer_quotes) {
#line 599
        goto force_outer_quoting_style;
      }
    }
  }
#line 601
  if (quote_string) {
#line 601
    if (! elide_outer_quotes) {
#line 602
      while (*quote_string) {
#line 603
        while (1) {
#line 603
          if (len < buffersize) {
#line 603
            *(buffer + len) = (char )*quote_string;
          }
#line 603
          len ++;
#line 603
          break;
        }
#line 602
        quote_string ++;
      }
    }
  }
#line 605
  if (len < buffersize) {
#line 606
    *(buffer + len) = (char )'\000';
  }
#line 607
  return (len);
  force_outer_quoting_style: 
#line 612
  tmp___7 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, quoting_style,
                                     flags & -3, (unsigned int const   *)((void *)0),
                                     left_quote, right_quote);
#line 612
  return (tmp___7);
}
}
#line 627 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
size_t quotearg_buffer(char *buffer , size_t buffersize , char const   *arg , size_t argsize ,
                       struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  size_t r ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 632
  if (o) {
#line 632
    tmp = o;
  } else {
#line 632
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 632
  p = tmp;
#line 633
  tmp___0 = __errno_location();
#line 633
  e = *tmp___0;
#line 634
  tmp___1 = quotearg_buffer_restyled(buffer, buffersize, arg, argsize, (enum quoting_style )p->style,
                                     (int )p->flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 634
  r = tmp___1;
#line 637
  tmp___2 = __errno_location();
#line 637
  *tmp___2 = e;
#line 638
  return (r);
}
}
#line 642 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_alloc(char const   *arg , size_t argsize , struct quoting_options  const  *o ) 
{ 
  char *tmp ;

  {
#line 646
  tmp = quotearg_alloc_mem(arg, argsize, (size_t *)((void *)0), o);
#line 646
  return (tmp);
}
}
#line 655 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_alloc_mem(char const   *arg , size_t argsize , size_t *size , struct quoting_options  const  *o ) 
{ 
  struct quoting_options  const  *p ;
  struct quoting_options  const  *tmp ;
  int e ;
  int *tmp___0 ;
  int flags ;
  int tmp___1 ;
  size_t bufsize___0 ;
  size_t tmp___2 ;
  char *buf___0 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 659
  if (o) {
#line 659
    tmp = o;
  } else {
#line 659
    tmp = (struct quoting_options  const  *)(& default_quoting_options);
  }
#line 659
  p = tmp;
#line 660
  tmp___0 = __errno_location();
#line 660
  e = *tmp___0;
#line 662
  if (size) {
#line 662
    tmp___1 = 0;
  } else {
#line 662
    tmp___1 = 1;
  }
#line 662
  flags = (int )(p->flags | (int const   )tmp___1);
#line 663
  tmp___2 = quotearg_buffer_restyled((char *)0, (size_t )0, arg, argsize, (enum quoting_style )p->style,
                                     flags, (unsigned int const   *)(p->quote_these_too),
                                     (char const   *)p->left_quote, (char const   *)p->right_quote);
#line 663
  bufsize___0 = tmp___2 + 1UL;
#line 667
  tmp___3 = xcharalloc(bufsize___0);
#line 667
  buf___0 = tmp___3;
#line 668
  quotearg_buffer_restyled(buf___0, bufsize___0, arg, argsize, (enum quoting_style )p->style,
                           flags, (unsigned int const   *)(p->quote_these_too), (char const   *)p->left_quote,
                           (char const   *)p->right_quote);
#line 671
  tmp___4 = __errno_location();
#line 671
  *tmp___4 = e;
#line 672
  if (size) {
#line 673
    *size = bufsize___0 - 1UL;
  }
#line 674
  return (buf___0);
}
}
#line 686 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static char slot0[256]  ;
#line 687 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static unsigned int nslots  =    1U;
#line 688 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static struct slotvec slotvec0  =    {sizeof(slot0), slot0};
#line 689 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static struct slotvec *slotvec  =    & slotvec0;
#line 691 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
void quotearg_free(void) 
{ 
  struct slotvec *sv ;
  unsigned int i ;

  {
#line 694
  sv = slotvec;
#line 696
  i = 1U;
#line 696
  while (i < nslots) {
#line 697
    free((void *)(sv + i)->val);
#line 696
    i ++;
  }
#line 698
  if ((unsigned long )(sv + 0)->val != (unsigned long )(slot0)) {
#line 700
    free((void *)(sv + 0)->val);
#line 701
    slotvec0.size = sizeof(slot0);
#line 702
    slotvec0.val = slot0;
  }
#line 704
  if ((unsigned long )sv != (unsigned long )(& slotvec0)) {
#line 706
    free((void *)sv);
#line 707
    slotvec = & slotvec0;
  }
#line 709
  nslots = 1U;
#line 710
  return;
}
}
#line 720 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
static char *quotearg_n_options(int n , char const   *arg , size_t argsize , struct quoting_options  const  *options ) 
{ 
  int e ;
  int *tmp ;
  unsigned int n0 ;
  struct slotvec *sv ;
  size_t n1 ;
  _Bool preallocated ;
  int tmp___0 ;
  struct slotvec *tmp___1 ;
  void *tmp___2 ;
  size_t size ;
  char *val ;
  int flags ;
  size_t qsize ;
  size_t tmp___3 ;
  int *tmp___4 ;

  {
#line 724
  tmp = __errno_location();
#line 724
  e = *tmp;
#line 726
  n0 = (unsigned int )n;
#line 727
  sv = slotvec;
#line 729
  if (n < 0) {
#line 730
    abort();
  }
#line 732
  if (nslots <= n0) {
#line 739
    n1 = (size_t )(n0 + 1U);
#line 740
    preallocated = (_Bool )((unsigned long )sv == (unsigned long )(& slotvec0));
#line 742
    if (sizeof(ptrdiff_t ) <= sizeof(size_t )) {
#line 742
      tmp___0 = -1;
    } else {
#line 742
      tmp___0 = -2;
    }
#line 742
    if ((size_t )tmp___0 / sizeof(*sv) < n1) {
#line 743
      xalloc_die();
    }
#line 745
    if (preallocated) {
#line 745
      tmp___1 = (struct slotvec *)((void *)0);
    } else {
#line 745
      tmp___1 = sv;
    }
#line 745
    tmp___2 = xrealloc((void *)tmp___1, n1 * sizeof(*sv));
#line 745
    sv = (struct slotvec *)tmp___2;
#line 745
    slotvec = sv;
#line 746
    if (preallocated) {
#line 747
      *sv = slotvec0;
    }
#line 748
    memset((void *)(sv + nslots), 0, (n1 - (size_t )nslots) * sizeof(*sv));
#line 749
    nslots = (unsigned int )n1;
  }
#line 753
  size = (sv + n)->size;
#line 754
  val = (sv + n)->val;
#line 756
  flags = (int )(options->flags | 1);
#line 757
  tmp___3 = quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                                     flags, (unsigned int const   *)(options->quote_these_too),
                                     (char const   *)options->left_quote, (char const   *)options->right_quote);
#line 757
  qsize = tmp___3;
#line 763
  if (size <= qsize) {
#line 765
    size = qsize + 1UL;
#line 765
    (sv + n)->size = size;
#line 766
    if ((unsigned long )val != (unsigned long )(slot0)) {
#line 767
      free((void *)val);
    }
#line 768
    val = xcharalloc(size);
#line 768
    (sv + n)->val = val;
#line 769
    quotearg_buffer_restyled(val, size, arg, argsize, (enum quoting_style )options->style,
                             flags, (unsigned int const   *)(options->quote_these_too),
                             (char const   *)options->left_quote, (char const   *)options->right_quote);
  }
#line 775
  tmp___4 = __errno_location();
#line 775
  *tmp___4 = e;
#line 776
  return (val);
}
}
#line 780 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_n(int n , char const   *arg ) 
{ 
  char *tmp ;

  {
#line 783
  tmp = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& default_quoting_options));
#line 783
  return (tmp);
}
}
#line 786 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_n_mem(int n , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
#line 789
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& default_quoting_options));
#line 789
  return (tmp);
}
}
#line 792 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg(char const   *arg ) 
{ 
  char *tmp ;

  {
#line 795
  tmp = quotearg_n(0, arg);
#line 795
  return (tmp);
}
}
#line 798 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
#line 801
  tmp = quotearg_n_mem(0, arg, argsize);
#line 801
  return (tmp);
}
}
#line 804 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_n_style(int n , enum quoting_style s , char const   *arg ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
#line 807
  tmp = quoting_options_from_style(s);
#line 807
  o = tmp;
#line 808
  tmp___0 = quotearg_n_options(n, arg, (size_t )-1, (struct quoting_options  const  *)(& o));
#line 808
  return (tmp___0);
}
}
#line 811 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_n_style_mem(int n , enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  struct quoting_options tmp ;
  char *tmp___0 ;

  {
#line 815
  tmp = quoting_options_from_style(s);
#line 815
  o = tmp;
#line 816
  tmp___0 = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
#line 816
  return (tmp___0);
}
}
#line 819 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_style(enum quoting_style s , char const   *arg ) 
{ 
  char *tmp ;

  {
#line 822
  tmp = quotearg_n_style(0, s, arg);
#line 822
  return (tmp);
}
}
#line 825 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_style_mem(enum quoting_style s , char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
#line 828
  tmp = quotearg_n_style_mem(0, s, arg, argsize);
#line 828
  return (tmp);
}
}
#line 831 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_char_mem(char const   *arg , size_t argsize , char ch ) 
{ 
  struct quoting_options options ;
  char *tmp ;

  {
#line 835
  options = default_quoting_options;
#line 836
  set_char_quoting(& options, ch, 1);
#line 837
  tmp = quotearg_n_options(0, arg, argsize, (struct quoting_options  const  *)(& options));
#line 837
  return (tmp);
}
}
#line 840 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_char(char const   *arg , char ch ) 
{ 
  char *tmp ;

  {
#line 843
  tmp = quotearg_char_mem(arg, (size_t )-1, ch);
#line 843
  return (tmp);
}
}
#line 846 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_colon(char const   *arg ) 
{ 
  char *tmp ;

  {
#line 849
  tmp = quotearg_char(arg, (char )':');
#line 849
  return (tmp);
}
}
#line 852 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_colon_mem(char const   *arg , size_t argsize ) 
{ 
  char *tmp ;

  {
#line 855
  tmp = quotearg_char_mem(arg, argsize, (char )':');
#line 855
  return (tmp);
}
}
#line 858 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_n_custom(int n , char const   *left_quote , char const   *right_quote ,
                        char const   *arg ) 
{ 
  char *tmp ;

  {
#line 862
  tmp = quotearg_n_custom_mem(n, left_quote, right_quote, arg, (size_t )-1);
#line 862
  return (tmp);
}
}
#line 866 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_n_custom_mem(int n , char const   *left_quote , char const   *right_quote ,
                            char const   *arg , size_t argsize ) 
{ 
  struct quoting_options o ;
  char *tmp ;

  {
#line 871
  o = default_quoting_options;
#line 872
  set_custom_quoting(& o, left_quote, right_quote);
#line 873
  tmp = quotearg_n_options(n, arg, argsize, (struct quoting_options  const  *)(& o));
#line 873
  return (tmp);
}
}
#line 876 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_custom(char const   *left_quote , char const   *right_quote , char const   *arg ) 
{ 
  char *tmp ;

  {
#line 880
  tmp = quotearg_n_custom(0, left_quote, right_quote, arg);
#line 880
  return (tmp);
}
}
#line 883 "/home/wslee/project/coreutils-8.1/lib/quotearg.c"
char *quotearg_custom_mem(char const   *left_quote , char const   *right_quote , char const   *arg ,
                          size_t argsize ) 
{ 
  char *tmp ;

  {
#line 887
  tmp = quotearg_n_custom_mem(0, left_quote, right_quote, arg, argsize);
#line 887
  return (tmp);
}
}
#line 1 "cil-Nt4IZe0I.o"
#pragma merger("0","../lib/rand-isaac.o.i","")
#line 40 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.h"
void isaac_seed(struct isaac_state *s ) ;
#line 41
void isaac_refill(struct isaac_state *s , uint32_t *r ) ;
#line 631 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 634
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 684
extern  __attribute__((__nothrow__)) __gid_t ( __attribute__((__leaf__)) getgid)(void) ;
#line 63 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.c"
void isaac_refill(struct isaac_state *s , uint32_t *r ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t x ;
  uint32_t y ;
  uint32_t *m ;

  {
#line 68
  m = s->mm;
#line 70
  a = s->a;
#line 71
  (s->c) ++;
#line 71
  b = s->b + s->c;
#line 73
  while (1) {
#line 75
    a = (a ^ (a << 13)) + *(m + (1 << 8) / 2);
#line 75
    x = *m;
#line 75
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 75
    *m = y;
#line 75
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 75
    *r = b;
#line 76
    a = (a ^ (a >> 6)) + *((m + 1) + (1 << 8) / 2);
#line 76
    x = *(m + 1);
#line 76
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 76
    *(m + 1) = y;
#line 76
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 76
    *(r + 1) = b;
#line 77
    a = (a ^ (a << 2)) + *((m + 2) + (1 << 8) / 2);
#line 77
    x = *(m + 2);
#line 77
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 77
    *(m + 2) = y;
#line 77
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 77
    *(r + 2) = b;
#line 78
    a = (a ^ (a >> 16)) + *((m + 3) + (1 << 8) / 2);
#line 78
    x = *(m + 3);
#line 78
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 78
    *(m + 3) = y;
#line 78
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 78
    *(r + 3) = b;
#line 79
    r += 4;
#line 73
    m += 4;
#line 73
    if (! ((unsigned long )m < (unsigned long )(s->mm + (1 << 8) / 2))) {
#line 73
      break;
    }
  }
#line 82
  while (1) {
#line 84
    a = (a ^ (a << 13)) + *(m + - (1 << 8) / 2);
#line 84
    x = *m;
#line 84
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 84
    *m = y;
#line 84
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 84
    *r = b;
#line 85
    a = (a ^ (a >> 6)) + *((m + 1) + - (1 << 8) / 2);
#line 85
    x = *(m + 1);
#line 85
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 85
    *(m + 1) = y;
#line 85
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 85
    *(r + 1) = b;
#line 86
    a = (a ^ (a << 2)) + *((m + 2) + - (1 << 8) / 2);
#line 86
    x = *(m + 2);
#line 86
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 86
    *(m + 2) = y;
#line 86
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 86
    *(r + 2) = b;
#line 87
    a = (a ^ (a >> 16)) + *((m + 3) + - (1 << 8) / 2);
#line 87
    x = *(m + 3);
#line 87
    y = (*((uint32_t *)((char *)(s->mm) + ((unsigned long )x & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + a) + b;
#line 87
    *(m + 3) = y;
#line 87
    b = *((uint32_t *)((char *)(s->mm) + ((unsigned long )(y >> 8) & (unsigned long )((1 << 8) - 1) * sizeof(uint32_t )))) + x;
#line 87
    *(r + 3) = b;
#line 88
    r += 4;
#line 82
    m += 4;
#line 82
    if (! ((unsigned long )m < (unsigned long )(s->mm + (1 << 8)))) {
#line 82
      break;
    }
  }
#line 91
  s->a = a;
#line 92
  s->b = b;
#line 93
  return;
}
}
#line 111 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.c"
static void isaac_mix(struct isaac_state *s , uint32_t const   *seed ) 
{ 
  int i ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;

  {
#line 115
  a = s->iv[0];
#line 116
  b = s->iv[1];
#line 117
  c = s->iv[2];
#line 118
  d = s->iv[3];
#line 119
  e = s->iv[4];
#line 120
  f = s->iv[5];
#line 121
  g = s->iv[6];
#line 122
  h = s->iv[7];
#line 124
  i = 0;
#line 124
  while (i < 1 << 8) {
#line 126
    a += (uint32_t )*(seed + i);
#line 127
    b += (uint32_t )*(seed + (i + 1));
#line 128
    c += (uint32_t )*(seed + (i + 2));
#line 129
    d += (uint32_t )*(seed + (i + 3));
#line 130
    e += (uint32_t )*(seed + (i + 4));
#line 131
    f += (uint32_t )*(seed + (i + 5));
#line 132
    g += (uint32_t )*(seed + (i + 6));
#line 133
    h += (uint32_t )*(seed + (i + 7));
#line 135
    a ^= b << 11;
#line 135
    d += a;
#line 135
    b += c;
#line 135
    b ^= c >> 2;
#line 135
    e += b;
#line 135
    c += d;
#line 135
    c ^= d << 8;
#line 135
    f += c;
#line 135
    d += e;
#line 135
    d ^= e >> 16;
#line 135
    g += d;
#line 135
    e += f;
#line 135
    e ^= f << 10;
#line 135
    h += e;
#line 135
    f += g;
#line 135
    f ^= g >> 4;
#line 135
    a += f;
#line 135
    g += h;
#line 135
    g ^= h << 8;
#line 135
    b += g;
#line 135
    h += a;
#line 135
    h ^= a >> 9;
#line 135
    c += h;
#line 135
    a += b;
#line 137
    s->mm[i] = a;
#line 138
    s->mm[i + 1] = b;
#line 139
    s->mm[i + 2] = c;
#line 140
    s->mm[i + 3] = d;
#line 141
    s->mm[i + 4] = e;
#line 142
    s->mm[i + 5] = f;
#line 143
    s->mm[i + 6] = g;
#line 144
    s->mm[i + 7] = h;
#line 124
    i += 8;
  }
#line 147
  s->iv[0] = a;
#line 148
  s->iv[1] = b;
#line 149
  s->iv[2] = c;
#line 150
  s->iv[3] = d;
#line 151
  s->iv[4] = e;
#line 152
  s->iv[5] = f;
#line 153
  s->iv[6] = g;
#line 154
  s->iv[7] = h;
#line 155
  return;
}
}
#line 217
static void isaac_seed_start(struct isaac_state *s ) ;
#line 217 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.c"
static uint32_t const   iv[8]  = 
#line 217
  {      (uint32_t const   )325574490,      (uint32_t const   )2514026585U,      (uint32_t const   )3273014859U,      (uint32_t const   )255990488, 
        (uint32_t const   )3643427448U,      (uint32_t const   )2769960009U,      (uint32_t const   )3304057371U,      (uint32_t const   )811634969};
#line 214 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.c"
static void isaac_seed_start(struct isaac_state *s ) 
{ 
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
#line 232
  memset((void *)(s->mm), 0, sizeof(s->mm));
#line 233
  memcpy((void * __restrict  )(s->iv), (void const   * __restrict  )(iv), sizeof(s->iv));
#line 236
  tmp___0 = (uint32_t )0;
#line 236
  s->c = tmp___0;
#line 236
  tmp = tmp___0;
#line 236
  s->b = tmp;
#line 236
  s->a = tmp;
#line 237
  return;
}
}
#line 240 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.c"
static void isaac_seed_data(struct isaac_state *s , void const   *buffer , size_t size ) 
{ 
  unsigned char const   *buf___0 ;
  unsigned char *p ;
  size_t avail ;
  size_t i ;

  {
#line 243
  buf___0 = (unsigned char const   *)buffer;
#line 248
  avail = sizeof(s->mm) - (unsigned long )s->c;
#line 251
  while (size > avail) {
#line 253
    p = (unsigned char *)(s->mm) + s->c;
#line 254
    i = (size_t )0;
#line 254
    while (i < avail) {
#line 255
      *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___0 + i));
#line 254
      i ++;
    }
#line 256
    buf___0 += avail;
#line 257
    size -= avail;
#line 258
    isaac_mix(s, (uint32_t const   *)(s->mm));
#line 259
    s->c = (uint32_t )0;
#line 260
    avail = sizeof(s->mm);
  }
#line 264
  p = (unsigned char *)(s->mm) + s->c;
#line 265
  i = (size_t )0;
#line 265
  while (i < size) {
#line 266
    *(p + i) = (unsigned char )((int )*(p + i) ^ (int )*(buf___0 + i));
#line 265
    i ++;
  }
#line 267
  s->c = (uint32_t )size;
#line 268
  return;
}
}
#line 272 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.c"
static void isaac_seed_finish(struct isaac_state *s ) 
{ 


  {
#line 275
  isaac_mix(s, (uint32_t const   *)(s->mm));
#line 276
  isaac_mix(s, (uint32_t const   *)(s->mm));
#line 278
  s->c = (uint32_t )0;
#line 279
  return;
}
}
#line 284 "/home/wslee/project/coreutils-8.1/lib/rand-isaac.c"
void isaac_seed(struct isaac_state *s ) 
{ 
  pid_t t ;
  __pid_t tmp ;
  pid_t t___0 ;
  __pid_t tmp___0 ;
  uid_t t___1 ;
  __uid_t tmp___1 ;
  gid_t t___2 ;
  __gid_t tmp___2 ;
  xtime_t t___3 ;
  xtime_t tmp___3 ;

  {
#line 287
  isaac_seed_start(s);
#line 289
  tmp = getpid();
#line 289
  t = tmp;
#line 289
  isaac_seed_data(s, (void const   *)(& t), sizeof(t));
#line 290
  tmp___0 = getppid();
#line 290
  t___0 = tmp___0;
#line 290
  isaac_seed_data(s, (void const   *)(& t___0), sizeof(t___0));
#line 291
  tmp___1 = getuid();
#line 291
  t___1 = tmp___1;
#line 291
  isaac_seed_data(s, (void const   *)(& t___1), sizeof(t___1));
#line 292
  tmp___2 = getgid();
#line 292
  t___2 = tmp___2;
#line 292
  isaac_seed_data(s, (void const   *)(& t___2), sizeof(t___2));
#line 295
  tmp___3 = gethrxtime();
#line 295
  t___3 = tmp___3;
#line 296
  isaac_seed_data(s, (void const   *)(& t___3), sizeof(t___3));
#line 299
  isaac_seed_finish(s);
#line 300
  return;
}
}
#line 1 "cil-wVBndhpC.o"
#pragma merger("0","../lib/randint.o.i","")
#line 27 "/home/wslee/project/coreutils-8.1/lib/randread.h"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) ;
#line 28
void randread(struct randread_source *s , void *buf___0 , size_t size ) ;
#line 31
int randread_free(struct randread_source *s ) ;
#line 35 "/home/wslee/project/coreutils-8.1/lib/randint.h"
struct randint_source *randint_new(struct randread_source *source ) ;
#line 36
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) ;
#line 37
struct randread_source *randint_get_source(struct randint_source  const  *s ) ;
#line 38
randint randint_genmax(struct randint_source *s , randint genmax ) ;
#line 48
void randint_free(struct randint_source *s ) ;
#line 49
int randint_all_free(struct randint_source *s ) ;
#line 70 "/home/wslee/project/coreutils-8.1/lib/randint.c"
struct randint_source *randint_new(struct randread_source *source ) 
{ 
  struct randint_source *s ;
  void *tmp ;
  randint tmp___0 ;

  {
#line 73
  tmp = xmalloc(sizeof(*s));
#line 73
  s = (struct randint_source *)tmp;
#line 74
  s->source = source;
#line 75
  tmp___0 = (randint )0;
#line 75
  s->randmax = tmp___0;
#line 75
  s->randnum = tmp___0;
#line 76
  return (s);
}
}
#line 83 "/home/wslee/project/coreutils-8.1/lib/randint.c"
struct randint_source *randint_all_new(char const   *name , size_t bytes_bound ) 
{ 
  struct randread_source *source ;
  struct randread_source *tmp ;
  struct randint_source *tmp___0 ;
  struct randint_source *tmp___1 ;

  {
#line 86
  tmp = randread_new(name, bytes_bound);
#line 86
  source = tmp;
#line 87
  if (source) {
#line 87
    tmp___0 = randint_new(source);
#line 87
    tmp___1 = tmp___0;
  } else {
#line 87
    tmp___1 = (struct randint_source *)((void *)0);
  }
#line 87
  return (tmp___1);
}
}
#line 92 "/home/wslee/project/coreutils-8.1/lib/randint.c"
struct randread_source *randint_get_source(struct randint_source  const  *s ) 
{ 


  {
#line 95
  return ((struct randread_source *)s->source);
}
}
#line 104 "/home/wslee/project/coreutils-8.1/lib/randint.c"
__inline static randint shift_left(randint x ) 
{ 


  {
#line 106
  return (x << 8);
}
}
#line 120 "/home/wslee/project/coreutils-8.1/lib/randint.c"
randint randint_genmax(struct randint_source *s , randint genmax ) 
{ 
  struct randread_source *source ;
  randint randnum ;
  randint randmax ;
  randint choices ;
  size_t i ;
  randint rmax ;
  unsigned char buf___0[sizeof(randnum)] ;
  randint tmp ;
  randint tmp___0 ;
  randint tmp___1 ;
  randint tmp___2 ;
  randint excess_choices ;
  randint unusable_choices ;
  randint last_usable_choice ;
  randint reduced_randnum ;

  {
#line 123
  source = s->source;
#line 124
  randnum = s->randnum;
#line 125
  randmax = s->randmax;
#line 126
  choices = genmax + 1UL;
#line 128
  while (1) {
#line 130
    if (randmax < genmax) {
#line 135
      i = (size_t )0;
#line 136
      rmax = randmax;
#line 139
      while (1) {
#line 141
        tmp = shift_left(rmax);
#line 141
        rmax = tmp + 255UL;
#line 142
        i ++;
#line 139
        if (! (rmax < genmax)) {
#line 139
          break;
        }
      }
#line 146
      randread(source, (void *)(buf___0), i);
#line 155
      i = (size_t )0;
#line 157
      while (1) {
#line 159
        tmp___0 = shift_left(randnum);
#line 159
        randnum = tmp___0 + (randint )buf___0[i];
#line 160
        tmp___1 = shift_left(randmax);
#line 160
        randmax = tmp___1 + 255UL;
#line 161
        i ++;
#line 157
        if (! (randmax < genmax)) {
#line 157
          break;
        }
      }
    }
#line 166
    if (randmax == genmax) {
#line 168
      tmp___2 = (randint )0;
#line 168
      s->randmax = tmp___2;
#line 168
      s->randnum = tmp___2;
#line 169
      return (randnum);
    } else {
#line 183
      excess_choices = randmax - genmax;
#line 184
      unusable_choices = excess_choices % choices;
#line 185
      last_usable_choice = randmax - unusable_choices;
#line 186
      reduced_randnum = randnum % choices;
#line 188
      if (randnum <= last_usable_choice) {
#line 190
        s->randnum = randnum / choices;
#line 191
        s->randmax = excess_choices / choices;
#line 192
        return (reduced_randnum);
      }
#line 197
      randnum = reduced_randnum;
#line 198
      randmax = unusable_choices - 1UL;
    }
  }
}
}
#line 205 "/home/wslee/project/coreutils-8.1/lib/randint.c"
void randint_free(struct randint_source *s ) 
{ 


  {
#line 208
  memset((void *)s, 0, sizeof(*s));
#line 209
  free((void *)s);
#line 210
  return;
}
}
#line 215 "/home/wslee/project/coreutils-8.1/lib/randint.c"
int randint_all_free(struct randint_source *s ) 
{ 
  int r ;
  int tmp ;
  int e ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 218
  tmp = randread_free(s->source);
#line 218
  r = tmp;
#line 219
  tmp___0 = __errno_location();
#line 219
  e = *tmp___0;
#line 220
  randint_free(s);
#line 221
  tmp___1 = __errno_location();
#line 221
  *tmp___1 = e;
#line 222
  return (r);
}
}
#line 1 "cil-dnn8sn5P.o"
#pragma merger("0","../lib/randperm.o.i","")
#line 42 "/home/wslee/project/coreutils-8.1/lib/randint.h"
__inline static randint randint_choose(struct randint_source *s , randint choices ) 
{ 
  randint tmp ;

  {
#line 45
  tmp = randint_genmax(s, choices - 1UL);
#line 45
  return (tmp);
}
}
#line 3 "/home/wslee/project/coreutils-8.1/lib/randperm.h"
size_t randperm_bound(size_t h , size_t n ) ;
#line 4
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) ;
#line 119 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/randperm.c"
static size_t ceil_lg(size_t n ) 
{ 
  size_t b ;

  {
#line 34
  b = (size_t )0;
#line 35
  n --;
#line 35
  while (n != 0UL) {
#line 36
    b ++;
#line 35
    n /= 2UL;
  }
#line 37
  return (b);
}
}
#line 44 "/home/wslee/project/coreutils-8.1/lib/randperm.c"
size_t randperm_bound(size_t h , size_t n ) 
{ 
  size_t lg_n ;
  size_t tmp ;
  size_t ar ;
  size_t bound ;

  {
#line 49
  tmp = ceil_lg(n);
#line 49
  lg_n = tmp;
#line 52
  ar = lg_n * h;
#line 55
  bound = ((ar + 8UL) - 1UL) / 8UL;
#line 57
  return (bound);
}
}
#line 64 "/home/wslee/project/coreutils-8.1/lib/randperm.c"
size_t *randperm_new(struct randint_source *r , size_t h , size_t n ) 
{ 
  size_t *v ;
  void *tmp ;
  size_t i ;
  void *tmp___0 ;
  size_t j ;
  randint tmp___1 ;
  size_t t ;
  void *tmp___2 ;

  {
#line 69
  switch (h) {
  case 0UL: 
#line 72
  v = (size_t *)((void *)0);
#line 73
  break;
  case 1UL: 
#line 76
  tmp = xmalloc(sizeof(*v));
#line 76
  v = (size_t *)tmp;
#line 77
  *(v + 0) = randint_choose(r, n);
#line 78
  break;
  default: 
#line 84
  tmp___0 = xnmalloc(n, sizeof(*v));
#line 84
  v = (size_t *)tmp___0;
#line 85
  i = (size_t )0;
#line 85
  while (i < n) {
#line 86
    *(v + i) = i;
#line 85
    i ++;
  }
#line 88
  i = (size_t )0;
#line 88
  while (i < h) {
#line 90
    tmp___1 = randint_choose(r, n - i);
#line 90
    j = i + tmp___1;
#line 91
    t = *(v + i);
#line 92
    *(v + i) = *(v + j);
#line 93
    *(v + j) = t;
#line 88
    i ++;
  }
#line 96
  tmp___2 = xnrealloc((void *)v, h, sizeof(*v));
#line 96
  v = (size_t *)tmp___2;
#line 98
  break;
  }
#line 101
  return (v);
}
}
#line 1 "cil-p3ZZZOix.o"
#pragma merger("0","../lib/randread.o.i","")
#line 29 "/home/wslee/project/coreutils-8.1/lib/randread.h"
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) ;
#line 30
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) ;
#line 336 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 113 "/home/wslee/project/coreutils-8.1/lib/randread.c"
static  __attribute__((__noreturn__)) void randread_error(void const   *file_name___1 ) ;
#line 113 "/home/wslee/project/coreutils-8.1/lib/randread.c"
static void randread_error(void const   *file_name___1 ) 
{ 
  char *tmp ;
  char const   *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;

  {
#line 116
  if (file_name___1) {
#line 117
    tmp = quotearg_colon((char const   *)file_name___1);
#line 117
    tmp___2 = __errno_location();
#line 117
    if (*tmp___2 == 0) {
#line 117
      tmp___1 = "%s: end of file";
    } else {
#line 117
      tmp___1 = "%s: read error";
    }
#line 117
    tmp___3 = gettext(tmp___1);
#line 117
    tmp___4 = __errno_location();
#line 117
    error((int )exit_failure, *tmp___4, (char const   *)tmp___3, tmp);
  }
#line 120
  abort();
}
}
#line 126 "/home/wslee/project/coreutils-8.1/lib/randread.c"
static struct randread_source *simple_new(FILE *source , void const   *handler_arg ) 
{ 
  struct randread_source *s ;
  void *tmp ;

  {
#line 129
  tmp = xmalloc(sizeof(*s));
#line 129
  s = (struct randread_source *)tmp;
#line 130
  s->source = source;
#line 131
  s->handler = & randread_error;
#line 132
  s->handler_arg = handler_arg;
#line 133
  return (s);
}
}
#line 147 "/home/wslee/project/coreutils-8.1/lib/randread.c"
struct randread_source *randread_new(char const   *name , size_t bytes_bound ) 
{ 
  struct randread_source *tmp ;
  FILE *source ;
  struct randread_source *s ;
  unsigned long tmp___0 ;

  {
#line 150
  if (bytes_bound == 0UL) {
#line 151
    tmp = simple_new((FILE *)((void *)0), (void const   *)((void *)0));
#line 151
    return (tmp);
  } else {
#line 154
    source = (FILE *)((void *)0);
#line 157
    if (name) {
#line 158
      source = fopen_safer(name, "rb");
#line 158
      if (! source) {
#line 159
        return ((struct randread_source *)((void *)0));
      }
    }
#line 161
    s = simple_new(source, (void const   *)name);
#line 163
    if (source) {
#line 164
      if (sizeof(s->buf.c) < bytes_bound) {
#line 164
        tmp___0 = sizeof(s->buf.c);
      } else {
#line 164
        tmp___0 = bytes_bound;
      }
#line 164
      setvbuf((FILE * __restrict  )source, (char * __restrict  )(s->buf.c), 0, tmp___0);
    } else {
#line 167
      s->buf.isaac.buffered = (size_t )0;
#line 168
      isaac_seed(& s->buf.isaac.state);
    }
#line 171
    return (s);
  }
}
}
#line 183 "/home/wslee/project/coreutils-8.1/lib/randread.c"
void randread_set_handler(struct randread_source *s , void (*handler)(void const   * ) ) 
{ 


  {
#line 186
  s->handler = handler;
#line 187
  return;
}
}
#line 189 "/home/wslee/project/coreutils-8.1/lib/randread.c"
void randread_set_handler_arg(struct randread_source *s , void const   *handler_arg ) 
{ 


  {
#line 192
  s->handler_arg = handler_arg;
#line 193
  return;
}
}
#line 199 "/home/wslee/project/coreutils-8.1/lib/randread.c"
static void readsource(struct randread_source *s , unsigned char *p , size_t size ) 
{ 
  size_t inbytes ;
  size_t tmp ;
  int fread_errno ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___3 ;

  {
#line 202
  while (1) {
#line 204
    tmp = fread_unlocked((void * __restrict  )p, sizeof(*p), size, (FILE * __restrict  )s->source);
#line 204
    inbytes = tmp;
#line 205
    tmp___0 = __errno_location();
#line 205
    fread_errno = *tmp___0;
#line 206
    p += inbytes;
#line 207
    size -= inbytes;
#line 208
    if (size == 0UL) {
#line 209
      break;
    }
#line 210
    tmp___1 = __errno_location();
#line 210
    tmp___3 = ferror_unlocked(s->source);
#line 210
    if (tmp___3) {
#line 210
      *tmp___1 = fread_errno;
    } else {
#line 210
      *tmp___1 = 0;
    }
#line 211
    (*(s->handler))(s->handler_arg);
  }
#line 213
  return;
}
}
#line 219 "/home/wslee/project/coreutils-8.1/lib/randread.c"
static void readisaac(struct isaac *isaac , unsigned char *p , size_t size ) 
{ 
  size_t inbytes ;
  uint32_t *wp ;

  {
#line 222
  inbytes = isaac->buffered;
#line 224
  while (1) {
#line 226
    if (size <= inbytes) {
#line 228
      memcpy((void * __restrict  )p, (void const   * __restrict  )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(uint32_t )) - inbytes),
             size);
#line 229
      isaac->buffered = inbytes - size;
#line 230
      return;
    }
#line 233
    memcpy((void * __restrict  )p, (void const   * __restrict  )((isaac->data.b + (unsigned long )(1 << 8) * sizeof(uint32_t )) - inbytes),
           inbytes);
#line 234
    p += inbytes;
#line 235
    size -= inbytes;
#line 239
    if ((size_t )p % (unsigned long )(& ((struct __anonstruct_833865290___0 *)0)->x) == 0UL) {
#line 241
      wp = (uint32_t *)p;
#line 242
      while ((unsigned long )(1 << 8) * sizeof(uint32_t ) <= size) {
#line 244
        isaac_refill(& isaac->state, (uint32_t *)wp);
#line 245
        wp += 1 << 8;
#line 246
        size -= (unsigned long )(1 << 8) * sizeof(uint32_t );
#line 247
        if (size == 0UL) {
#line 249
          isaac->buffered = (size_t )0;
#line 250
          return;
        }
      }
#line 253
      p = (unsigned char *)wp;
    }
#line 256
    isaac_refill(& isaac->state, (uint32_t *)(isaac->data.w));
#line 257
    inbytes = (unsigned long )(1 << 8) * sizeof(uint32_t );
  }
}
}
#line 265 "/home/wslee/project/coreutils-8.1/lib/randread.c"
void randread(struct randread_source *s , void *buf___0 , size_t size ) 
{ 


  {
#line 268
  if (s->source) {
#line 269
    readsource(s, (unsigned char *)buf___0, size);
  } else {
#line 271
    readisaac(& s->buf.isaac, (unsigned char *)buf___0, size);
  }
#line 272
  return;
}
}
#line 280 "/home/wslee/project/coreutils-8.1/lib/randread.c"
int randread_free(struct randread_source *s ) 
{ 
  FILE *source ;
  int tmp ;
  int tmp___0 ;

  {
#line 283
  source = s->source;
#line 284
  memset((void *)s, 0, sizeof(*s));
#line 285
  free((void *)s);
#line 286
  if (source) {
#line 286
    tmp = fclose(source);
#line 286
    tmp___0 = tmp;
  } else {
#line 286
    tmp___0 = 0;
  }
#line 286
  return (tmp___0);
}
}
#line 1 "cil-DC6sRcDv.o"
#pragma merger("0","../lib/readtokens.o.i","")
#line 32 "/home/wslee/project/coreutils-8.1/lib/readtokens.h"
void init_tokenbuffer(token_buffer *tokenbuffer ) ;
#line 34
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) ;
#line 37
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) ;
#line 119 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 41 "/home/wslee/project/coreutils-8.1/lib/readtokens.c"
void init_tokenbuffer(token_buffer *tokenbuffer ) 
{ 


  {
#line 44
  tokenbuffer->size = (size_t )0;
#line 45
  tokenbuffer->buffer = (char *)((void *)0);
#line 46
  return;
}
}
#line 70 "/home/wslee/project/coreutils-8.1/lib/readtokens.c"
static char const   *saved_delim  =    (char const   *)((void *)0);
#line 71 "/home/wslee/project/coreutils-8.1/lib/readtokens.c"
static char isdelim[256]  ;
#line 61 "/home/wslee/project/coreutils-8.1/lib/readtokens.c"
size_t readtoken(FILE *stream , char const   *delim , size_t n_delim , token_buffer *tokenbuffer ) 
{ 
  char *p ;
  int c ;
  size_t i ;
  size_t n ;
  _Bool same_delimiters ;
  size_t j ;
  unsigned char ch ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 74
  if ((unsigned long )delim == (unsigned long )((void *)0)) {
#line 74
    if ((unsigned long )saved_delim == (unsigned long )((void *)0)) {
#line 75
      abort();
    }
  }
#line 77
  same_delimiters = (_Bool)0;
#line 78
  if ((unsigned long )delim != (unsigned long )saved_delim) {
#line 78
    if ((unsigned long )saved_delim != (unsigned long )((void *)0)) {
#line 80
      same_delimiters = (_Bool)1;
#line 81
      i = (size_t )0;
#line 81
      while (i < n_delim) {
#line 83
        if ((int const   )*(delim + i) != (int const   )*(saved_delim + i)) {
#line 85
          same_delimiters = (_Bool)0;
#line 86
          break;
        }
#line 81
        i ++;
      }
    }
  }
#line 91
  if (! same_delimiters) {
#line 94
    saved_delim = delim;
#line 95
    memset((void *)(isdelim), 0, sizeof(isdelim));
#line 96
    j = (size_t )0;
#line 96
    while (j < n_delim) {
#line 98
      ch = (unsigned char )*(delim + j);
#line 99
      isdelim[ch] = (char)1;
#line 96
      j ++;
    }
  }
#line 105
  c = getc_unlocked(stream);
#line 105
  while (1) {
#line 105
    if (c >= 0) {
#line 105
      if (! isdelim[c]) {
#line 105
        break;
      }
    } else {
#line 105
      break;
    }
#line 105
    c = getc_unlocked(stream);
  }
#line 110
  p = tokenbuffer->buffer;
#line 111
  n = tokenbuffer->size;
#line 112
  i = (size_t )0;
#line 113
  while (1) {
#line 115
    if (c < 0) {
#line 115
      if (i == 0UL) {
#line 116
        return ((size_t )-1);
      }
    }
#line 118
    if (i == n) {
#line 119
      tmp = x2nrealloc((void *)p, & n, sizeof(*p));
#line 119
      p = (char *)tmp;
    }
#line 121
    if (c < 0) {
#line 123
      *(p + i) = (char)0;
#line 124
      break;
    }
#line 126
    if (isdelim[c]) {
#line 128
      *(p + i) = (char)0;
#line 129
      break;
    }
#line 131
    tmp___0 = i;
#line 131
    i ++;
#line 131
    *(p + tmp___0) = (char )c;
#line 132
    c = getc_unlocked(stream);
  }
#line 135
  tokenbuffer->buffer = p;
#line 136
  tokenbuffer->size = n;
#line 137
  return (i);
}
}
#line 147 "/home/wslee/project/coreutils-8.1/lib/readtokens.c"
size_t readtokens(FILE *stream , size_t projected_n_tokens , char const   *delim ,
                  size_t n_delim , char ***tokens_out , size_t **token_lengths ) 
{ 
  token_buffer tb ;
  token_buffer *token ;
  char **tokens ;
  size_t *lengths ;
  size_t sz ;
  size_t n_tokens ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  size_t token_length ;
  size_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 155
  token = & tb;
#line 161
  if (projected_n_tokens == 0UL) {
#line 162
    projected_n_tokens = (size_t )64;
  } else {
#line 164
    projected_n_tokens ++;
  }
#line 166
  sz = projected_n_tokens;
#line 167
  tmp = xnmalloc(sz, sizeof(*tokens));
#line 167
  tokens = (char **)tmp;
#line 168
  tmp___0 = xnmalloc(sz, sizeof(*lengths));
#line 168
  lengths = (size_t *)tmp___0;
#line 170
  n_tokens = (size_t )0;
#line 171
  init_tokenbuffer(token);
#line 172
  while (1) {
#line 175
    tmp___2 = readtoken(stream, delim, n_delim, token);
#line 175
    token_length = tmp___2;
#line 176
    if (n_tokens >= sz) {
#line 178
      tmp___3 = x2nrealloc((void *)tokens, & sz, sizeof(*tokens));
#line 178
      tokens = (char **)tmp___3;
#line 179
      tmp___4 = xnrealloc((void *)lengths, sz, sizeof(*lengths));
#line 179
      lengths = (size_t *)tmp___4;
    }
#line 182
    if (token_length == 0xffffffffffffffffUL) {
#line 185
      *(tokens + n_tokens) = (char *)((void *)0);
#line 186
      *(lengths + n_tokens) = (size_t )0;
#line 187
      break;
    }
#line 189
    tmp___5 = xnmalloc(token_length + 1UL, sizeof(*tmp___1));
#line 189
    tmp___1 = (char *)tmp___5;
#line 190
    *(lengths + n_tokens) = token_length;
#line 191
    tmp___6 = memcpy((void * __restrict  )tmp___1, (void const   * __restrict  )token->buffer,
                     token_length + 1UL);
#line 191
    *(tokens + n_tokens) = (char *)tmp___6;
#line 192
    n_tokens ++;
  }
#line 195
  free((void *)token->buffer);
#line 196
  *tokens_out = tokens;
#line 197
  if ((unsigned long )token_lengths != (unsigned long )((void *)0)) {
#line 198
    *token_lengths = lengths;
  }
#line 199
  return (n_tokens);
}
}
#line 1 "cil-2q1ltuVW.o"
#pragma merger("0","../lib/readtokens0.o.i","")
#line 180 "/home/wslee/project/coreutils-8.1/lib/obstack.h"
extern void _obstack_newchunk(struct obstack * , int  ) ;
#line 181
extern int _obstack_begin(struct obstack * , int  , int  , void *(*)(long  ) , void (*)(void * ) ) ;
#line 193
extern void obstack_free(struct obstack *obstack , void *block ) ;
#line 38 "/home/wslee/project/coreutils-8.1/lib/readtokens0.h"
void readtokens0_init(struct Tokens *t ) ;
#line 39
void readtokens0_free(struct Tokens *t ) ;
#line 40
_Bool readtokens0(FILE *in , struct Tokens *t ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/readtokens0.c"
void readtokens0_init(struct Tokens *t ) 
{ 


  {
#line 32
  t->n_tok = (size_t )0;
#line 33
  t->tok = (char **)((void *)0);
#line 34
  t->tok_len = (size_t *)((void *)0);
#line 35
  _obstack_begin(& t->o_data, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
#line 36
  _obstack_begin(& t->o_tok, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
#line 37
  _obstack_begin(& t->o_tok_len, 0, 0, (void *(*)(long  ))(& malloc), (void (*)(void * ))(& free));
#line 38
  return;
}
}
#line 40 "/home/wslee/project/coreutils-8.1/lib/readtokens0.c"
void readtokens0_free(struct Tokens *t ) 
{ 
  struct obstack *__o ;
  void *__obj ;
  char *tmp ;
  struct obstack *__o___0 ;
  void *__obj___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  void *__obj___1 ;
  char *tmp___1 ;

  {
#line 43
  __o = & t->o_data;
#line 43
  __obj = (void *)0;
#line 43
  if ((unsigned long )__obj > (unsigned long )((void *)__o->chunk)) {
#line 43
    if ((unsigned long )__obj < (unsigned long )((void *)__o->chunk_limit)) {
#line 43
      tmp = (char *)__obj;
#line 43
      __o->object_base = tmp;
#line 43
      __o->next_free = tmp;
    } else {
#line 43
      obstack_free(__o, __obj);
    }
  } else {
#line 43
    obstack_free(__o, __obj);
  }
#line 44
  __o___0 = & t->o_tok;
#line 44
  __obj___0 = (void *)0;
#line 44
  if ((unsigned long )__obj___0 > (unsigned long )((void *)__o___0->chunk)) {
#line 44
    if ((unsigned long )__obj___0 < (unsigned long )((void *)__o___0->chunk_limit)) {
#line 44
      tmp___0 = (char *)__obj___0;
#line 44
      __o___0->object_base = tmp___0;
#line 44
      __o___0->next_free = tmp___0;
    } else {
#line 44
      obstack_free(__o___0, __obj___0);
    }
  } else {
#line 44
    obstack_free(__o___0, __obj___0);
  }
#line 45
  __o___1 = & t->o_tok_len;
#line 45
  __obj___1 = (void *)0;
#line 45
  if ((unsigned long )__obj___1 > (unsigned long )((void *)__o___1->chunk)) {
#line 45
    if ((unsigned long )__obj___1 < (unsigned long )((void *)__o___1->chunk_limit)) {
#line 45
      tmp___1 = (char *)__obj___1;
#line 45
      __o___1->object_base = tmp___1;
#line 45
      __o___1->next_free = tmp___1;
    } else {
#line 45
      obstack_free(__o___1, __obj___1);
    }
  } else {
#line 45
    obstack_free(__o___1, __obj___1);
  }
#line 46
  return;
}
}
#line 50 "/home/wslee/project/coreutils-8.1/lib/readtokens0.c"
static void save_token(struct Tokens *t ) 
{ 
  size_t len ;
  struct obstack  const  *__o ;
  char const   *s ;
  struct obstack *__o1 ;
  void *__value ;
  char *tmp ;
  char *tmp___0 ;
  struct obstack *__o___0 ;
  struct obstack *__o1___0 ;
  struct obstack *__o___1 ;
  int __len ;

  {
#line 54
  __o = (struct obstack  const  *)(& t->o_data);
#line 54
  len = (size_t )((unsigned int )(__o->next_free - __o->object_base) - 1U);
#line 55
  __o1 = & t->o_data;
#line 55
  __value = (void *)__o1->object_base;
#line 55
  if ((unsigned long )__o1->next_free == (unsigned long )__value) {
#line 55
    __o1->maybe_empty_object = 1U;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp = __o1->object_base;
  } else {
#line 55
    tmp = (char *)0;
  }
#line 55
  if (sizeof(long ) < sizeof(void *)) {
#line 55
    tmp___0 = __o1->object_base;
  } else {
#line 55
    tmp___0 = (char *)0;
  }
#line 55
  __o1->next_free = tmp + (((__o1->next_free - tmp___0) + (long )__o1->alignment_mask) & (long )(~ __o1->alignment_mask));
#line 55
  if (__o1->next_free - (char *)__o1->chunk > __o1->chunk_limit - (char *)__o1->chunk) {
#line 55
    __o1->next_free = __o1->chunk_limit;
  }
#line 55
  __o1->object_base = __o1->next_free;
#line 55
  s = (char const   *)__value;
#line 56
  __o___0 = & t->o_tok;
#line 56
  if ((unsigned long )(__o___0->next_free + sizeof(void *)) > (unsigned long )__o___0->chunk_limit) {
#line 56
    _obstack_newchunk(__o___0, (int )sizeof(void *));
  }
#line 56
  __o1___0 = __o___0;
#line 56
  *((void const   **)__o1___0->next_free) = (void const   *)s;
#line 56
  __o1___0->next_free += sizeof(void const   *);
#line 57
  __o___1 = & t->o_tok_len;
#line 57
  __len = (int )sizeof(len);
#line 57
  if ((unsigned long )(__o___1->next_free + __len) > (unsigned long )__o___1->chunk_limit) {
#line 57
    _obstack_newchunk(__o___1, __len);
  }
#line 57
  memcpy((void * __restrict  )__o___1->next_free, (void const   * __restrict  )(& len),
         (size_t )__len);
#line 57
  __o___1->next_free += __len;
#line 58
  (t->n_tok) ++;
#line 59
  return;
}
}
#line 65 "/home/wslee/project/coreutils-8.1/lib/readtokens0.c"
_Bool readtokens0(FILE *in , struct Tokens *t ) 
{ 
  int c ;
  int tmp ;
  size_t len ;
  struct obstack  const  *__o ;
  struct obstack *__o___0 ;
  char *tmp___0 ;
  struct obstack *__o___1 ;
  char *tmp___1 ;
  struct obstack *__o___2 ;
  struct obstack *__o1 ;
  struct obstack *__o1___0 ;
  void *__value ;
  char *tmp___2 ;
  char *tmp___3 ;
  struct obstack *__o1___1 ;
  void *__value___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 69
  while (1) {
#line 71
    tmp = fgetc(in);
#line 71
    c = tmp;
#line 72
    if (c == -1) {
#line 74
      __o = (struct obstack  const  *)(& t->o_data);
#line 74
      len = (size_t )((unsigned int )(__o->next_free - __o->object_base));
#line 78
      if (len) {
#line 80
        __o___0 = & t->o_data;
#line 80
        if ((unsigned long )(__o___0->next_free + 1) > (unsigned long )__o___0->chunk_limit) {
#line 80
          _obstack_newchunk(__o___0, 1);
        }
#line 80
        tmp___0 = __o___0->next_free;
#line 80
        (__o___0->next_free) ++;
#line 80
        *tmp___0 = (char )'\000';
#line 81
        save_token(t);
      }
#line 84
      break;
    }
#line 87
    __o___1 = & t->o_data;
#line 87
    if ((unsigned long )(__o___1->next_free + 1) > (unsigned long )__o___1->chunk_limit) {
#line 87
      _obstack_newchunk(__o___1, 1);
    }
#line 87
    tmp___1 = __o___1->next_free;
#line 87
    (__o___1->next_free) ++;
#line 87
    *tmp___1 = (char )c;
#line 88
    if (c == 0) {
#line 89
      save_token(t);
    }
  }
#line 94
  __o___2 = & t->o_tok;
#line 94
  if ((unsigned long )(__o___2->next_free + sizeof(void *)) > (unsigned long )__o___2->chunk_limit) {
#line 94
    _obstack_newchunk(__o___2, (int )sizeof(void *));
  }
#line 94
  __o1 = __o___2;
#line 94
  *((void const   **)__o1->next_free) = (void const   *)((void *)0);
#line 94
  __o1->next_free += sizeof(void const   *);
#line 96
  __o1___0 = & t->o_tok;
#line 96
  __value = (void *)__o1___0->object_base;
#line 96
  if ((unsigned long )__o1___0->next_free == (unsigned long )__value) {
#line 96
    __o1___0->maybe_empty_object = 1U;
  }
#line 96
  if (sizeof(long ) < sizeof(void *)) {
#line 96
    tmp___2 = __o1___0->object_base;
  } else {
#line 96
    tmp___2 = (char *)0;
  }
#line 96
  if (sizeof(long ) < sizeof(void *)) {
#line 96
    tmp___3 = __o1___0->object_base;
  } else {
#line 96
    tmp___3 = (char *)0;
  }
#line 96
  __o1___0->next_free = tmp___2 + (((__o1___0->next_free - tmp___3) + (long )__o1___0->alignment_mask) & (long )(~ __o1___0->alignment_mask));
#line 96
  if (__o1___0->next_free - (char *)__o1___0->chunk > __o1___0->chunk_limit - (char *)__o1___0->chunk) {
#line 96
    __o1___0->next_free = __o1___0->chunk_limit;
  }
#line 96
  __o1___0->object_base = __o1___0->next_free;
#line 96
  t->tok = (char **)__value;
#line 97
  __o1___1 = & t->o_tok_len;
#line 97
  __value___0 = (void *)__o1___1->object_base;
#line 97
  if ((unsigned long )__o1___1->next_free == (unsigned long )__value___0) {
#line 97
    __o1___1->maybe_empty_object = 1U;
  }
#line 97
  if (sizeof(long ) < sizeof(void *)) {
#line 97
    tmp___4 = __o1___1->object_base;
  } else {
#line 97
    tmp___4 = (char *)0;
  }
#line 97
  if (sizeof(long ) < sizeof(void *)) {
#line 97
    tmp___5 = __o1___1->object_base;
  } else {
#line 97
    tmp___5 = (char *)0;
  }
#line 97
  __o1___1->next_free = tmp___4 + (((__o1___1->next_free - tmp___5) + (long )__o1___1->alignment_mask) & (long )(~ __o1___1->alignment_mask));
#line 97
  if (__o1___1->next_free - (char *)__o1___1->chunk > __o1___1->chunk_limit - (char *)__o1___1->chunk) {
#line 97
    __o1___1->next_free = __o1___1->chunk_limit;
  }
#line 97
  __o1___1->object_base = __o1___1->next_free;
#line 97
  t->tok_len = (size_t *)__value___0;
#line 98
  tmp___6 = ferror(in);
#line 98
  if (tmp___6) {
#line 98
    tmp___7 = 0;
  } else {
#line 98
    tmp___7 = 1;
  }
#line 98
  return ((_Bool )tmp___7);
}
}
#line 1 "cil-pxB5eQUI.o"
#pragma merger("0","../lib/readutmp.o.i","")
#line 53 "/usr/include/utmpx.h"
extern void setutxent(void) ;
#line 59
extern void endutxent(void) ;
#line 65
extern struct utmpx *getutxent(void) ;
#line 93
extern int utmpxname(char const   *__file ) ;
#line 212 "/home/wslee/project/coreutils-8.1/lib/readutmp.h"
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) ;
#line 213
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 128 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 45 "/home/wslee/project/coreutils-8.1/lib/readutmp.c"
char *extract_trimmed_name(STRUCT_UTMP const   *ut ) 
{ 
  char *p ;
  char *trimmed_name ;
  void *tmp ;
  size_t tmp___0 ;

  {
#line 50
  tmp = xmalloc(sizeof(ut->ut_user) + 1UL);
#line 50
  trimmed_name = (char *)tmp;
#line 51
  strncpy((char * __restrict  )trimmed_name, (char const   * __restrict  )(ut->ut_user),
          sizeof(ut->ut_user));
#line 55
  *(trimmed_name + sizeof(ut->ut_user)) = (char )'\000';
#line 56
  tmp___0 = strlen((char const   *)trimmed_name);
#line 56
  p = trimmed_name + tmp___0;
#line 56
  while (1) {
#line 56
    if ((unsigned long )trimmed_name < (unsigned long )p) {
#line 56
      if (! ((int )*(p + -1) == 32)) {
#line 56
        break;
      }
    } else {
#line 56
      break;
    }
#line 59
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 56
    p --;
#line 56
    *p = (char )'\000';
  }
#line 60
  return (trimmed_name);
}
}
#line 65 "/home/wslee/project/coreutils-8.1/lib/readutmp.c"
__inline static _Bool desirable_utmp_entry(STRUCT_UTMP const   *u , int options ) 
{ 
  _Bool user_proc ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;

  {
#line 68
  if (u->ut_user[0]) {
#line 68
    if ((int const   )u->ut_type == 7) {
#line 68
      tmp = 1;
    } else {
#line 68
      tmp = 0;
    }
  } else {
#line 68
    tmp = 0;
  }
#line 68
  user_proc = (_Bool )tmp;
#line 69
  if (options & 2) {
#line 69
    if (! user_proc) {
#line 70
      return ((_Bool)0);
    }
  }
#line 71
  if (options & 1) {
#line 71
    if (user_proc) {
#line 71
      if (u->ut_pid <= 0) {
#line 75
        return ((_Bool)0);
      } else {
#line 71
        tmp___0 = kill((__pid_t )u->ut_pid, 0);
#line 71
        if (tmp___0 < 0) {
#line 71
          tmp___1 = __errno_location();
#line 71
          if (*tmp___1 == 3) {
#line 75
            return ((_Bool)0);
          }
        }
      }
    }
  }
#line 76
  return ((_Bool)1);
}
}
#line 88 "/home/wslee/project/coreutils-8.1/lib/readutmp.c"
int read_utmp(char const   *file , size_t *n_entries , STRUCT_UTMP **utmp_buf , int options ) 
{ 
  size_t n_read ;
  size_t n_alloc___0 ;
  STRUCT_UTMP *utmp ;
  STRUCT_UTMP *u ;
  void *tmp ;
  size_t tmp___0 ;
  _Bool tmp___1 ;

  {
#line 92
  n_read = (size_t )0;
#line 93
  n_alloc___0 = (size_t )0;
#line 94
  utmp = (STRUCT_UTMP *)((void *)0);
#line 101
  utmpxname(file);
#line 103
  setutxent();
#line 105
  while (1) {
#line 105
    u = getutxent();
#line 105
    if (! ((unsigned long )u != (unsigned long )((void *)0))) {
#line 105
      break;
    }
#line 106
    tmp___1 = desirable_utmp_entry((STRUCT_UTMP const   *)u, options);
#line 106
    if (tmp___1) {
#line 108
      if (n_read == n_alloc___0) {
#line 109
        tmp = x2nrealloc((void *)utmp, & n_alloc___0, sizeof(*utmp));
#line 109
        utmp = (STRUCT_UTMP *)tmp;
      }
#line 111
      tmp___0 = n_read;
#line 111
      n_read ++;
#line 111
      *(utmp + tmp___0) = *u;
    }
  }
#line 114
  endutxent();
#line 116
  *n_entries = n_read;
#line 117
  *utmp_buf = utmp;
#line 119
  return (0);
}
}
/* compiler builtin: 
   long __builtin_expect(long  , long  ) ;  */
#line 1 "cil-vcsDIPvN.o"
#pragma merger("0","../lib/regex.o.i","")
#line 235 "./regex.h"
reg_syntax_t rpl_re_syntax_options  ;
#line 551
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) ;
#line 556
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) ;
#line 563
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) ;
#line 571
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                       __re_idx_t start , regoff_t range , struct re_registers *regs ) ;
#line 579
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         __re_idx_t length1 , char const   *string2 , __re_idx_t length2 ,
                         __re_idx_t start , regoff_t range , struct re_registers *regs ,
                         __re_idx_t stop ) ;
#line 589
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                      __re_idx_t start , struct re_registers *regs ) ;
#line 595
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , __re_idx_t length1 ,
                        char const   *string2 , __re_idx_t length2 , __re_idx_t start ,
                        struct re_registers *regs , __re_idx_t stop ) ;
#line 614
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) ;
#line 656
int rpl_regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern ,
                int cflags ) ;
#line 660
int rpl_regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
                size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) ;
#line 665
size_t rpl_regerror(int errcode , regex_t const   * __restrict  preg  __attribute__((__unused__)) ,
                    char * __restrict  errbuf , size_t errbuf_size ) ;
#line 668
void rpl_regfree(regex_t *preg ) ;
#line 195 "/usr/include/wchar.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) wcscoll)(wchar_t const   *__s1 ,
                                                                              wchar_t const   *__s2 ) ;
#line 356
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) btowc)(int __c ) ;
#line 373
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) wcrtomb)(char * __restrict  __s ,
                                                                                 wchar_t __wc ,
                                                                                 mbstate_t * __restrict  __ps ) ;
#line 133 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswlower)(wint_t __wc ) ;
#line 171
extern  __attribute__((__nothrow__)) wctype_t ( __attribute__((__leaf__)) wctype)(char const   *__property ) ;
#line 175
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswctype)(wint_t __wc ,
                                                                               wctype_t __desc ) ;
#line 197
extern  __attribute__((__nothrow__)) wint_t ( __attribute__((__leaf__)) towupper)(wint_t __wc ) ;
#line 429 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , Idx new_buf_len ) ;
#line 433
static void build_wcs_buffer(re_string_t *pstr ) ;
#line 434
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr ) ;
#line 437
static void build_upper_buffer(re_string_t *pstr ) ;
#line 438
static void re_string_translate_buffer(re_string_t *pstr ) ;
#line 439
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags )  __attribute__((__pure__)) ;
#line 736 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_set(bitset_word_t *set , Idx i ) 
{ 


  {
#line 739
  *(set + i / 64UL) |= 1UL << i % 64UL;
#line 740
  return;
}
}
#line 742 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_clear(bitset_word_t *set , Idx i ) 
{ 


  {
#line 745
  *(set + i / 64UL) &= ~ (1UL << i % 64UL);
#line 746
  return;
}
}
#line 748 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static _Bool bitset_contain(bitset_word_t * const  set , Idx i ) 
{ 


  {
#line 751
  return ((_Bool )((*(set + i / 64UL) >> i % 64UL) & 1UL));
}
}
#line 754 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_empty(bitset_word_t *set ) 
{ 


  {
#line 757
  memset((void *)set, '\000', sizeof(bitset_t ));
#line 758
  return;
}
}
#line 760 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_set_all(bitset_word_t *set ) 
{ 


  {
#line 763
  memset((void *)set, -1, sizeof(bitset_word_t ) * 4UL);
#line 767
  return;
}
}
#line 769 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_copy(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 


  {
#line 772
  memcpy((void * __restrict  )dest, (void const   * __restrict  )src, sizeof(bitset_t ));
#line 773
  return;
}
}
#line 775 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_not(bitset_word_t *set ) 
{ 
  int bitset_i ;

  {
#line 779
  bitset_i = 0;
#line 779
  while (bitset_i < 4) {
#line 780
    *(set + bitset_i) = ~ *(set + bitset_i);
#line 779
    bitset_i ++;
  }
#line 785
  return;
}
}
#line 787 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_merge(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 791
  bitset_i = 0;
#line 791
  while (bitset_i < 4) {
#line 792
    *(dest + bitset_i) |= *(src + bitset_i);
#line 791
    bitset_i ++;
  }
#line 793
  return;
}
}
#line 795 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static void bitset_mask(bitset_word_t *dest , bitset_word_t * const  src ) 
{ 
  int bitset_i ;

  {
#line 799
  bitset_i = 0;
#line 799
  while (bitset_i < 4) {
#line 800
    *(dest + bitset_i) &= *(src + bitset_i);
#line 799
    bitset_i ++;
  }
#line 801
  return;
}
}
#line 805 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static int __attribute__((__pure__))  re_string_char_size_at(re_string_t const   *pstr ,
                                                                      Idx idx ) 
{ 
  int byte_idx ;

  {
#line 810
  if (pstr->mb_cur_max == 1) {
#line 811
    return ((int __attribute__((__pure__))  )1);
  }
#line 812
  byte_idx = 1;
#line 812
  while (idx + (Idx )byte_idx < (Idx )pstr->valid_len) {
#line 813
    if (*(pstr->wcs + (idx + (Idx )byte_idx)) != 4294967295U) {
#line 814
      break;
    }
#line 812
    byte_idx ++;
  }
#line 815
  return ((int __attribute__((__pure__))  )byte_idx);
}
}
#line 818 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
__inline static wint_t __attribute__((__pure__))  re_string_wchar_at(re_string_t const   *pstr ,
                                                                     Idx idx ) 
{ 


  {
#line 822
  if (pstr->mb_cur_max == 1) {
#line 823
    return ((wint_t __attribute__((__pure__))  )((wint_t )*(pstr->mbs + idx)));
  }
#line 824
  return ((wint_t __attribute__((__pure__))  )*(pstr->wcs + idx));
}
}
#line 827 "/home/wslee/project/coreutils-8.1/lib/regex_internal.h"
static int __attribute__((__pure__))  re_string_elem_size_at(re_string_t const   *pstr  __attribute__((__unused__)) ,
                                                             Idx idx  __attribute__((__unused__)) ) 
{ 


  {
#line 852
  return ((int __attribute__((__pure__))  )1);
}
}
#line 23 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) ;
#line 27
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         re_hashval_t hash ) ;
#line 30
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , re_hashval_t hash ) ;
#line 40 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_string_allocate(re_string_t *pstr , char const   *str , Idx len ,
                                        Idx init_len , unsigned char *trans , _Bool icase ,
                                        re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  Idx init_buf_len ;
  long tmp ;

  {
#line 49
  if (init_len < (Idx )dfa->mb_cur_max) {
#line 50
    init_len = (Idx )dfa->mb_cur_max;
  }
#line 51
  if (len + 1UL < init_len) {
#line 51
    init_buf_len = len + 1UL;
  } else {
#line 51
    init_buf_len = init_len;
  }
#line 52
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
#line 54
  ret = re_string_realloc_buffers(pstr, init_buf_len);
#line 55
  tmp = __builtin_expect((long )((int )ret != 0), 0L);
#line 55
  if (tmp) {
#line 56
    return (ret);
  }
#line 58
  pstr->word_char = (re_const_bitset_ptr_t )(dfa->word_char);
#line 59
  pstr->word_ops_used = (unsigned char )dfa->word_ops_used;
#line 60
  if (pstr->mbs_allocated) {
#line 60
    pstr->mbs = pstr->mbs;
  } else {
#line 60
    pstr->mbs = (unsigned char *)str;
  }
#line 61
  if (pstr->mbs_allocated) {
#line 61
    pstr->valid_len = (Idx )0;
  } else
#line 61
  if (dfa->mb_cur_max > 1) {
#line 61
    pstr->valid_len = (Idx )0;
  } else {
#line 61
    pstr->valid_len = len;
  }
#line 62
  pstr->valid_raw_len = pstr->valid_len;
#line 63
  return ((reg_errcode_t )0);
}
}
#line 68 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_string_construct(re_string_t *pstr , char const   *str , Idx len ,
                                         unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ 
  reg_errcode_t ret ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 74
  memset((void *)pstr, '\000', sizeof(re_string_t ));
#line 75
  re_string_construct_common(str, len, pstr, trans, icase, dfa);
#line 77
  if (len > 0UL) {
#line 79
    ret = re_string_realloc_buffers(pstr, len + 1UL);
#line 80
    tmp = __builtin_expect((long )((int )ret != 0), 0L);
#line 80
    if (tmp) {
#line 81
      return (ret);
    }
  }
#line 83
  if (pstr->mbs_allocated) {
#line 83
    pstr->mbs = pstr->mbs;
  } else {
#line 83
    pstr->mbs = (unsigned char *)str;
  }
#line 85
  if (icase) {
#line 88
    if (dfa->mb_cur_max > 1) {
#line 90
      while (1) {
#line 92
        ret = build_wcs_upper_buffer(pstr);
#line 93
        tmp___0 = __builtin_expect((long )((int )ret != 0), 0L);
#line 93
        if (tmp___0) {
#line 94
          return (ret);
        }
#line 95
        if (pstr->valid_raw_len >= len) {
#line 96
          break;
        }
#line 97
        if (pstr->bufs_len > pstr->valid_len + (Idx )dfa->mb_cur_max) {
#line 98
          break;
        }
#line 99
        ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2UL);
#line 100
        tmp___1 = __builtin_expect((long )((int )ret != 0), 0L);
#line 100
        if (tmp___1) {
#line 101
          return (ret);
        }
      }
    } else {
#line 106
      build_upper_buffer(pstr);
    }
  } else
#line 111
  if (dfa->mb_cur_max > 1) {
#line 112
    build_wcs_buffer(pstr);
  } else
#line 116
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 117
    re_string_translate_buffer(pstr);
  } else {
#line 120
    pstr->valid_len = pstr->bufs_len;
#line 121
    pstr->valid_raw_len = pstr->bufs_len;
  }
#line 126
  return ((reg_errcode_t )0);
}
}
#line 131 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_string_realloc_buffers(re_string_t *pstr , Idx new_buf_len ) 
{ 
  wint_t *new_wcs ;
  size_t max_object_size ;
  unsigned long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  Idx *new_offsets ;
  void *tmp___3 ;
  long tmp___4 ;
  unsigned char *new_mbs ;
  void *tmp___5 ;
  long tmp___6 ;

  {
#line 136
  if (pstr->mb_cur_max > 1) {
#line 141
    if (sizeof(wint_t ) < sizeof(Idx )) {
#line 141
      tmp = sizeof(Idx );
    } else {
#line 141
      tmp = sizeof(wint_t );
    }
#line 141
    max_object_size = tmp;
#line 142
    tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < new_buf_len),
                               0L);
#line 142
    if (tmp___0) {
#line 143
      return ((reg_errcode_t )12);
    }
#line 145
    tmp___1 = realloc((void *)pstr->wcs, new_buf_len * sizeof(wint_t ));
#line 145
    new_wcs = (wint_t *)tmp___1;
#line 146
    tmp___2 = __builtin_expect((long )((unsigned long )new_wcs == (unsigned long )((void *)0)),
                               0L);
#line 146
    if (tmp___2) {
#line 147
      return ((reg_errcode_t )12);
    }
#line 148
    pstr->wcs = new_wcs;
#line 149
    if ((unsigned long )pstr->offsets != (unsigned long )((void *)0)) {
#line 151
      tmp___3 = realloc((void *)pstr->offsets, new_buf_len * sizeof(Idx ));
#line 151
      new_offsets = (Idx *)tmp___3;
#line 152
      tmp___4 = __builtin_expect((long )((unsigned long )new_offsets == (unsigned long )((void *)0)),
                                 0L);
#line 152
      if (tmp___4) {
#line 153
        return ((reg_errcode_t )12);
      }
#line 154
      pstr->offsets = new_offsets;
    }
  }
#line 158
  if (pstr->mbs_allocated) {
#line 160
    tmp___5 = realloc((void *)pstr->mbs, new_buf_len * sizeof(unsigned char ));
#line 160
    new_mbs = (unsigned char *)tmp___5;
#line 162
    tmp___6 = __builtin_expect((long )((unsigned long )new_mbs == (unsigned long )((void *)0)),
                               0L);
#line 162
    if (tmp___6) {
#line 163
      return ((reg_errcode_t )12);
    }
#line 164
    pstr->mbs = new_mbs;
  }
#line 166
  pstr->bufs_len = new_buf_len;
#line 167
  return ((reg_errcode_t )0);
}
}
#line 171 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void re_string_construct_common(char const   *str , Idx len , re_string_t *pstr ,
                                       unsigned char *trans , _Bool icase , re_dfa_t const   *dfa ) 
{ 
  int tmp ;

  {
#line 177
  pstr->raw_mbs = (unsigned char const   *)str;
#line 178
  pstr->len = len;
#line 179
  pstr->raw_len = len;
#line 180
  pstr->trans = trans;
#line 181
  pstr->icase = (unsigned char )icase;
#line 182
  if ((unsigned long )trans != (unsigned long )((void *)0)) {
#line 182
    tmp = 1;
  } else
#line 182
  if (icase) {
#line 182
    tmp = 1;
  } else {
#line 182
    tmp = 0;
  }
#line 182
  pstr->mbs_allocated = (unsigned char )tmp;
#line 183
  pstr->mb_cur_max = (int )dfa->mb_cur_max;
#line 184
  pstr->is_utf8 = (unsigned char )dfa->is_utf8;
#line 185
  pstr->map_notascii = (unsigned char )dfa->map_notascii;
#line 186
  pstr->stop = pstr->len;
#line 187
  pstr->raw_stop = pstr->stop;
#line 188
  return;
}
}
#line 203 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void build_wcs_buffer(re_string_t *pstr ) 
{ 
  unsigned char buf___0[64] ;
  mbstate_t prev_st ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  wchar_t wc ;
  char const   *p ;
  int i ;
  int ch ;
  unsigned char tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 219
  if (pstr->bufs_len > pstr->len) {
#line 219
    end_idx = pstr->len;
  } else {
#line 219
    end_idx = pstr->bufs_len;
  }
#line 220
  byte_idx = pstr->valid_len;
#line 220
  while (byte_idx < end_idx) {
#line 225
    remain_len = end_idx - byte_idx;
#line 226
    prev_st = pstr->cur_state;
#line 228
    tmp___0 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                               0L);
#line 228
    if (tmp___0) {
#line 232
      i = 0;
#line 232
      while (1) {
#line 232
        if (i < pstr->mb_cur_max) {
#line 232
          if (! ((Idx )i < remain_len)) {
#line 232
            break;
          }
        } else {
#line 232
          break;
        }
#line 234
        ch = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + byte_idx) + (Idx )i));
#line 235
        tmp = *(pstr->trans + ch);
#line 235
        *(pstr->mbs + (byte_idx + (Idx )i)) = tmp;
#line 235
        buf___0[i] = tmp;
#line 232
        i ++;
      }
#line 237
      p = (char const   *)(buf___0);
    } else {
#line 240
      p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx;
    }
#line 241
    mbclen = mbrtowc((wchar_t * __restrict  )(& wc), (char const   * __restrict  )p,
                     remain_len, (mbstate_t * __restrict  )(& pstr->cur_state));
#line 242
    tmp___4 = __builtin_expect((long )(mbclen == 0xfffffffffffffffeUL), 0L);
#line 242
    if (tmp___4) {
#line 245
      pstr->cur_state = prev_st;
#line 246
      break;
    } else {
#line 248
      if (mbclen == 0xffffffffffffffffUL) {
#line 248
        tmp___2 = 1;
      } else
#line 248
      if (mbclen == 0UL) {
#line 248
        tmp___2 = 1;
      } else {
#line 248
        tmp___2 = 0;
      }
#line 248
      tmp___3 = __builtin_expect((long )tmp___2, 0L);
#line 248
      if (tmp___3) {
#line 251
        mbclen = (size_t )1;
#line 252
        wc = (wchar_t )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 253
        tmp___1 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                   0L);
#line 253
        if (tmp___1) {
#line 254
          wc = (wchar_t )*(pstr->trans + wc);
        }
#line 255
        pstr->cur_state = prev_st;
      }
    }
#line 259
    tmp___5 = byte_idx;
#line 259
    byte_idx ++;
#line 259
    *(pstr->wcs + tmp___5) = (wint_t )wc;
#line 261
    remain_len = (byte_idx + mbclen) - 1UL;
#line 261
    while (byte_idx < remain_len) {
#line 262
      tmp___6 = byte_idx;
#line 262
      byte_idx ++;
#line 262
      *(pstr->wcs + tmp___6) = 4294967295U;
    }
  }
#line 264
  pstr->valid_len = byte_idx;
#line 265
  pstr->valid_raw_len = byte_idx;
#line 266
  return;
}
}
#line 271 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t build_wcs_upper_buffer(re_string_t *pstr ) 
{ 
  mbstate_t prev_st ;
  Idx src_idx ;
  Idx byte_idx ;
  Idx end_idx ;
  Idx remain_len ;
  size_t mbclen ;
  char buf___0[64] ;
  wchar_t wc ;
  int tmp ;
  int tmp___0 ;
  wchar_t wcu ;
  size_t mbcdlen ;
  wint_t tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  int ch ;
  Idx tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  wchar_t wc___0 ;
  char const   *p ;
  int i ;
  int ch___0 ;
  long tmp___9 ;
  wchar_t wcu___0 ;
  size_t mbcdlen___0 ;
  wint_t tmp___10 ;
  size_t i___0 ;
  void *tmp___11 ;
  size_t tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  size_t i___1 ;
  long tmp___15 ;
  Idx tmp___16 ;
  Idx tmp___17 ;
  int ch___1 ;
  long tmp___18 ;
  long tmp___19 ;
  Idx tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
#line 285
  byte_idx = pstr->valid_len;
#line 286
  if (pstr->bufs_len > pstr->len) {
#line 286
    end_idx = pstr->len;
  } else {
#line 286
    end_idx = pstr->bufs_len;
  }
#line 290
  if (! pstr->map_notascii) {
#line 290
    if ((unsigned long )pstr->trans == (unsigned long )((void *)0)) {
#line 290
      if (! pstr->offsets_needed) {
#line 292
        while (byte_idx < end_idx) {
#line 296
          if (((int const   )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)) & -128) == 0) {
#line 296
            tmp___0 = mbsinit((mbstate_t const   *)(& pstr->cur_state));
#line 296
            if (tmp___0) {
#line 300
              tmp = toupper((int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx)));
#line 300
              *(pstr->mbs + byte_idx) = (unsigned char )tmp;
#line 304
              *(pstr->wcs + byte_idx) = (wint_t )((wchar_t )*(pstr->mbs + byte_idx));
#line 305
              byte_idx ++;
#line 306
              continue;
            }
          }
#line 309
          remain_len = end_idx - byte_idx;
#line 310
          prev_st = pstr->cur_state;
#line 311
          mbclen = mbrtowc((wchar_t * __restrict  )(& wc), (char const   * __restrict  )(((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                           remain_len, (mbstate_t * __restrict  )(& pstr->cur_state));
#line 314
          tmp___8 = __builtin_expect((long )(mbclen < 0xfffffffffffffffeUL), 1L);
#line 314
          if (tmp___8) {
#line 316
            wcu = wc;
#line 317
            tmp___3 = iswlower((wint_t )wc);
#line 317
            if (tmp___3) {
#line 321
              tmp___1 = towupper((wint_t )wc);
#line 321
              wcu = (wchar_t )tmp___1;
#line 322
              mbcdlen = wcrtomb((char * __restrict  )(buf___0), wcu, (mbstate_t * __restrict  )(& prev_st));
#line 323
              tmp___2 = __builtin_expect((long )(mbclen == mbcdlen), 1L);
#line 323
              if (tmp___2) {
#line 324
                memcpy((void * __restrict  )(pstr->mbs + byte_idx), (void const   * __restrict  )(buf___0),
                       mbclen);
              } else {
#line 327
                src_idx = byte_idx;
#line 328
                goto offsets_needed;
              }
            } else {
#line 332
              memcpy((void * __restrict  )(pstr->mbs + byte_idx), (void const   * __restrict  )((pstr->raw_mbs + pstr->raw_mbs_idx) + byte_idx),
                     mbclen);
            }
#line 334
            tmp___4 = byte_idx;
#line 334
            byte_idx ++;
#line 334
            *(pstr->wcs + tmp___4) = (wint_t )wcu;
#line 336
            remain_len = (byte_idx + mbclen) - 1UL;
#line 336
            while (byte_idx < remain_len) {
#line 337
              tmp___5 = byte_idx;
#line 337
              byte_idx ++;
#line 337
              *(pstr->wcs + tmp___5) = 4294967295U;
            }
          } else
#line 339
          if (mbclen == 0xffffffffffffffffUL) {
#line 339
            goto _L;
          } else
#line 339
          if (mbclen == 0UL) {
            _L: /* CIL Label */ 
#line 342
            ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + byte_idx));
#line 343
            *(pstr->mbs + byte_idx) = (unsigned char )ch;
#line 345
            tmp___6 = byte_idx;
#line 345
            byte_idx ++;
#line 345
            *(pstr->wcs + tmp___6) = (wint_t )ch;
#line 346
            tmp___7 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
#line 346
            if (tmp___7) {
#line 347
              pstr->cur_state = prev_st;
            }
          } else {
#line 352
            pstr->cur_state = prev_st;
#line 353
            break;
          }
        }
#line 356
        pstr->valid_len = byte_idx;
#line 357
        pstr->valid_raw_len = byte_idx;
#line 358
        return ((reg_errcode_t )0);
      } else {
#line 290
        goto _L___2;
      }
    } else {
#line 290
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 361
    src_idx = pstr->valid_raw_len;
#line 361
    while (byte_idx < end_idx) {
      offsets_needed: 
#line 366
      remain_len = end_idx - byte_idx;
#line 367
      prev_st = pstr->cur_state;
#line 368
      tmp___9 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                 0L);
#line 368
      if (tmp___9) {
#line 372
        i = 0;
#line 372
        while (1) {
#line 372
          if (i < pstr->mb_cur_max) {
#line 372
            if (! ((Idx )i < remain_len)) {
#line 372
              break;
            }
          } else {
#line 372
            break;
          }
#line 374
          ch___0 = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + src_idx) + (Idx )i));
#line 375
          buf___0[i] = (char )*(pstr->trans + ch___0);
#line 372
          i ++;
        }
#line 377
        p = (char const   *)(buf___0);
      } else {
#line 380
        p = ((char const   *)pstr->raw_mbs + pstr->raw_mbs_idx) + src_idx;
      }
#line 381
      mbclen = mbrtowc((wchar_t * __restrict  )(& wc___0), (char const   * __restrict  )p,
                       remain_len, (mbstate_t * __restrict  )(& pstr->cur_state));
#line 382
      tmp___22 = __builtin_expect((long )(mbclen < 0xfffffffffffffffeUL), 1L);
#line 382
      if (tmp___22) {
#line 384
        wcu___0 = wc___0;
#line 385
        tmp___14 = iswlower((wint_t )wc___0);
#line 385
        if (tmp___14) {
#line 389
          tmp___10 = towupper((wint_t )wc___0);
#line 389
          wcu___0 = (wchar_t )tmp___10;
#line 390
          mbcdlen___0 = wcrtomb((char * __restrict  )(buf___0), wcu___0, (mbstate_t * __restrict  )(& prev_st));
#line 391
          tmp___13 = __builtin_expect((long )(mbclen == mbcdlen___0), 1L);
#line 391
          if (tmp___13) {
#line 392
            memcpy((void * __restrict  )(pstr->mbs + byte_idx), (void const   * __restrict  )(buf___0),
                   mbclen);
          } else
#line 393
          if (mbcdlen___0 != 0xffffffffffffffffUL) {
#line 397
            if (byte_idx + mbcdlen___0 > pstr->bufs_len) {
#line 399
              pstr->cur_state = prev_st;
#line 400
              break;
            }
#line 403
            if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
#line 405
              tmp___11 = malloc(pstr->bufs_len * sizeof(Idx ));
#line 405
              pstr->offsets = (Idx *)tmp___11;
#line 407
              if ((unsigned long )pstr->offsets == (unsigned long )((void *)0)) {
#line 408
                return ((reg_errcode_t )12);
              }
            }
#line 410
            if (! pstr->offsets_needed) {
#line 412
              i___0 = (size_t )0;
#line 412
              while (i___0 < byte_idx) {
#line 413
                *(pstr->offsets + i___0) = i___0;
#line 412
                i___0 ++;
              }
#line 414
              pstr->offsets_needed = (unsigned char)1;
            }
#line 417
            memcpy((void * __restrict  )(pstr->mbs + byte_idx), (void const   * __restrict  )(buf___0),
                   mbcdlen___0);
#line 418
            *(pstr->wcs + byte_idx) = (wint_t )wcu___0;
#line 419
            *(pstr->offsets + byte_idx) = src_idx;
#line 420
            i___0 = (size_t )1;
#line 420
            while (i___0 < mbcdlen___0) {
#line 422
              if (i___0 < mbclen) {
#line 422
                tmp___12 = i___0;
              } else {
#line 422
                tmp___12 = mbclen - 1UL;
              }
#line 422
              *(pstr->offsets + (byte_idx + i___0)) = src_idx + tmp___12;
#line 424
              *(pstr->wcs + (byte_idx + i___0)) = 4294967295U;
#line 420
              i___0 ++;
            }
#line 426
            pstr->len += mbcdlen___0 - mbclen;
#line 427
            if (pstr->raw_stop > src_idx) {
#line 428
              pstr->stop += mbcdlen___0 - mbclen;
            }
#line 429
            if (pstr->bufs_len > pstr->len) {
#line 429
              end_idx = pstr->len;
            } else {
#line 429
              end_idx = pstr->bufs_len;
            }
#line 431
            byte_idx += mbcdlen___0;
#line 432
            src_idx += mbclen;
#line 433
            goto __Cont;
          } else {
#line 436
            memcpy((void * __restrict  )(pstr->mbs + byte_idx), (void const   * __restrict  )p,
                   mbclen);
          }
        } else {
#line 439
          memcpy((void * __restrict  )(pstr->mbs + byte_idx), (void const   * __restrict  )p,
                 mbclen);
        }
#line 441
        tmp___15 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
#line 441
        if (tmp___15) {
#line 444
          i___1 = (size_t )0;
#line 444
          while (i___1 < mbclen) {
#line 445
            *(pstr->offsets + (byte_idx + i___1)) = src_idx + i___1;
#line 444
            i___1 ++;
          }
        }
#line 447
        src_idx += mbclen;
#line 449
        tmp___16 = byte_idx;
#line 449
        byte_idx ++;
#line 449
        *(pstr->wcs + tmp___16) = (wint_t )wcu___0;
#line 451
        remain_len = (byte_idx + mbclen) - 1UL;
#line 451
        while (byte_idx < remain_len) {
#line 452
          tmp___17 = byte_idx;
#line 452
          byte_idx ++;
#line 452
          *(pstr->wcs + tmp___17) = 4294967295U;
        }
      } else
#line 454
      if (mbclen == 0xffffffffffffffffUL) {
#line 454
        goto _L___0;
      } else
#line 454
      if (mbclen == 0UL) {
        _L___0: /* CIL Label */ 
#line 457
        ch___1 = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + src_idx));
#line 459
        tmp___18 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                    0L);
#line 459
        if (tmp___18) {
#line 460
          ch___1 = (int )*(pstr->trans + ch___1);
        }
#line 461
        *(pstr->mbs + byte_idx) = (unsigned char )ch___1;
#line 463
        tmp___19 = __builtin_expect((long )((int )pstr->offsets_needed != 0), 0L);
#line 463
        if (tmp___19) {
#line 464
          *(pstr->offsets + byte_idx) = src_idx;
        }
#line 465
        src_idx ++;
#line 468
        tmp___20 = byte_idx;
#line 468
        byte_idx ++;
#line 468
        *(pstr->wcs + tmp___20) = (wint_t )ch___1;
#line 469
        tmp___21 = __builtin_expect((long )(mbclen == 0xffffffffffffffffUL), 0L);
#line 469
        if (tmp___21) {
#line 470
          pstr->cur_state = prev_st;
        }
      } else {
#line 475
        pstr->cur_state = prev_st;
#line 476
        break;
      }
      __Cont: /* CIL Label */ ;
    }
  }
#line 479
  pstr->valid_len = byte_idx;
#line 480
  pstr->valid_raw_len = src_idx;
#line 481
  return ((reg_errcode_t )0);
}
}
#line 487 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static Idx re_string_skip_chars(re_string_t *pstr , Idx new_raw_idx , wint_t *last_wc ) 
{ 
  mbstate_t prev_st ;
  Idx rawbuf_idx ;
  size_t mbclen ;
  wint_t wc ;
  wchar_t wc2 ;
  Idx remain_len ;
  int tmp ;
  long tmp___0 ;

  {
#line 494
  wc = 4294967295U;
#line 497
  rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;
#line 497
  while (rawbuf_idx < new_raw_idx) {
#line 502
    remain_len = pstr->len - rawbuf_idx;
#line 503
    prev_st = pstr->cur_state;
#line 504
    mbclen = mbrtowc((wchar_t * __restrict  )(& wc2), (char const   * __restrict  )((char const   *)pstr->raw_mbs + rawbuf_idx),
                     remain_len, (mbstate_t * __restrict  )(& pstr->cur_state));
#line 506
    if (mbclen == 0xfffffffffffffffeUL) {
#line 506
      tmp = 1;
    } else
#line 506
    if (mbclen == 0xffffffffffffffffUL) {
#line 506
      tmp = 1;
    } else
#line 506
    if (mbclen == 0UL) {
#line 506
      tmp = 1;
    } else {
#line 506
      tmp = 0;
    }
#line 506
    tmp___0 = __builtin_expect((long )tmp, 0L);
#line 506
    if (tmp___0) {
#line 509
      if (mbclen == 0UL) {
#line 510
        wc = (wint_t )0;
      } else
#line 509
      if (remain_len == 0UL) {
#line 510
        wc = (wint_t )0;
      } else {
#line 512
        wc = (wint_t )*((unsigned char *)(pstr->raw_mbs + rawbuf_idx));
      }
#line 513
      mbclen = (size_t )1;
#line 514
      pstr->cur_state = prev_st;
    } else {
#line 517
      wc = (wint_t )wc2;
    }
#line 519
    rawbuf_idx += mbclen;
  }
#line 521
  *last_wc = wc;
#line 522
  return (rawbuf_idx);
}
}
#line 529 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void build_upper_buffer(re_string_t *pstr ) 
{ 
  Idx char_idx ;
  Idx end_idx ;
  int ch ;
  long tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 534
  if (pstr->bufs_len > pstr->len) {
#line 534
    end_idx = pstr->len;
  } else {
#line 534
    end_idx = pstr->bufs_len;
  }
#line 536
  char_idx = pstr->valid_len;
#line 536
  while (char_idx < end_idx) {
#line 538
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + char_idx));
#line 539
    tmp = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                           0L);
#line 539
    if (tmp) {
#line 540
      ch = (int )*(pstr->trans + ch);
    }
#line 541
    tmp___1 = __ctype_b_loc();
#line 541
    if ((int const   )*(*tmp___1 + ch) & 512) {
#line 542
      tmp___0 = toupper(ch);
#line 542
      *(pstr->mbs + char_idx) = (unsigned char )tmp___0;
    } else {
#line 544
      *(pstr->mbs + char_idx) = (unsigned char )ch;
    }
#line 536
    char_idx ++;
  }
#line 546
  pstr->valid_len = char_idx;
#line 547
  pstr->valid_raw_len = char_idx;
#line 548
  return;
}
}
#line 552 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void re_string_translate_buffer(re_string_t *pstr ) 
{ 
  Idx buf_idx ;
  Idx end_idx ;
  int ch ;

  {
#line 557
  if (pstr->bufs_len > pstr->len) {
#line 557
    end_idx = pstr->len;
  } else {
#line 557
    end_idx = pstr->bufs_len;
  }
#line 559
  buf_idx = pstr->valid_len;
#line 559
  while (buf_idx < end_idx) {
#line 561
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + buf_idx));
#line 562
    *(pstr->mbs + buf_idx) = *(pstr->trans + ch);
#line 559
    buf_idx ++;
  }
#line 565
  pstr->valid_len = buf_idx;
#line 566
  pstr->valid_raw_len = buf_idx;
#line 567
  return;
}
}
#line 573 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_string_reconstruct(re_string_t *pstr , Idx idx , int eflags ) 
{ 
  Idx offset ;
  long tmp ;
  Idx low ;
  Idx high ;
  Idx mid ;
  long tmp___0 ;
  long tmp___1 ;
  Idx prev_valid_len ;
  long tmp___2 ;
  Idx wcs_idx ;
  wint_t wc ;
  unsigned char const   *raw ;
  unsigned char const   *p ;
  unsigned char const   *end ;
  mbstate_t cur_state ;
  wchar_t wc2 ;
  Idx mlen ;
  unsigned char buf___0[6] ;
  size_t mbclen ;
  int i ;
  Idx tmp___3 ;
  long tmp___4 ;
  Idx tmp___5 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int c ;
  int tmp___13 ;
  _Bool tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  reg_errcode_t ret ;
  reg_errcode_t tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;

  {
#line 579
  tmp = __builtin_expect((long )(pstr->raw_mbs_idx <= idx), 0L);
#line 579
  if (tmp) {
#line 580
    offset = idx - pstr->raw_mbs_idx;
  } else {
#line 585
    if (pstr->mb_cur_max > 1) {
#line 586
      memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
    }
#line 588
    pstr->len = pstr->raw_len;
#line 589
    pstr->stop = pstr->raw_stop;
#line 590
    pstr->valid_len = (Idx )0;
#line 591
    pstr->raw_mbs_idx = (Idx )0;
#line 592
    pstr->valid_raw_len = (Idx )0;
#line 593
    pstr->offsets_needed = (unsigned char)0;
#line 594
    if (eflags & 1) {
#line 594
      pstr->tip_context = (unsigned int )((1 << 1) << 1);
    } else {
#line 594
      pstr->tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
    }
#line 596
    if (! pstr->mbs_allocated) {
#line 597
      pstr->mbs = (unsigned char *)pstr->raw_mbs;
    }
#line 598
    offset = idx;
  }
#line 601
  tmp___17 = __builtin_expect((long )(offset != 0UL), 1L);
#line 601
  if (tmp___17) {
#line 604
    tmp___15 = __builtin_expect((long )(offset < pstr->valid_raw_len), 1L);
#line 604
    if (tmp___15) {
#line 608
      tmp___1 = __builtin_expect((long )pstr->offsets_needed, 0L);
#line 608
      if (tmp___1) {
#line 610
        low = (Idx )0;
#line 610
        high = pstr->valid_len;
#line 611
        while (1) {
#line 613
          mid = (high + low) / 2UL;
#line 614
          if (*(pstr->offsets + mid) > offset) {
#line 615
            high = mid;
          } else
#line 616
          if (*(pstr->offsets + mid) < offset) {
#line 617
            low = mid + 1UL;
          } else {
#line 619
            break;
          }
#line 611
          if (! (low < high)) {
#line 611
            break;
          }
        }
#line 622
        if (*(pstr->offsets + mid) < offset) {
#line 623
          mid ++;
        }
#line 624
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, mid - 1UL,
                                                 eflags);
#line 630
        if (pstr->valid_len > offset) {
#line 630
          if (mid == offset) {
#line 630
            if (*(pstr->offsets + mid) == offset) {
#line 633
              memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
#line 635
              memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
#line 636
              pstr->valid_len -= offset;
#line 637
              pstr->valid_raw_len -= offset;
#line 638
              low = (Idx )0;
#line 638
              while (low < pstr->valid_len) {
#line 639
                *(pstr->offsets + low) = *(pstr->offsets + (low + offset)) - offset;
#line 638
                low ++;
              }
            } else {
#line 630
              goto _L___0;
            }
          } else {
#line 630
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 645
          pstr->len = (pstr->raw_len - idx) + offset;
#line 646
          pstr->stop = (pstr->raw_stop - idx) + offset;
#line 647
          pstr->offsets_needed = (unsigned char)0;
#line 648
          while (1) {
#line 648
            if (mid > 0UL) {
#line 648
              if (! (*(pstr->offsets + (mid - 1UL)) == offset)) {
#line 648
                break;
              }
            } else {
#line 648
              break;
            }
#line 649
            mid --;
          }
#line 650
          while (mid < pstr->valid_len) {
#line 651
            if (*(pstr->wcs + mid) != 4294967295U) {
#line 652
              break;
            } else {
#line 654
              mid ++;
            }
          }
#line 655
          if (mid == pstr->valid_len) {
#line 656
            pstr->valid_len = (Idx )0;
          } else {
#line 659
            pstr->valid_len = *(pstr->offsets + mid) - offset;
#line 660
            if (pstr->valid_len) {
#line 662
              low = (Idx )0;
#line 662
              while (low < pstr->valid_len) {
#line 663
                *(pstr->wcs + low) = 4294967295U;
#line 662
                low ++;
              }
#line 664
              memset((void *)pstr->mbs, 255, pstr->valid_len);
            }
          }
#line 667
          pstr->valid_raw_len = pstr->valid_len;
        }
      } else {
#line 673
        pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, offset - 1UL,
                                                 eflags);
#line 676
        if (pstr->mb_cur_max > 1) {
#line 677
          memmove((void *)pstr->wcs, (void const   *)(pstr->wcs + offset), (pstr->valid_len - offset) * sizeof(wint_t ));
        }
#line 680
        tmp___0 = __builtin_expect((long )pstr->mbs_allocated, 0L);
#line 680
        if (tmp___0) {
#line 681
          memmove((void *)pstr->mbs, (void const   *)(pstr->mbs + offset), pstr->valid_len - offset);
        }
#line 683
        pstr->valid_len -= offset;
#line 684
        pstr->valid_raw_len -= offset;
      }
    } else {
#line 694
      prev_valid_len = pstr->valid_len;
#line 696
      tmp___2 = __builtin_expect((long )pstr->offsets_needed, 0L);
#line 696
      if (tmp___2) {
#line 698
        pstr->len = (pstr->raw_len - idx) + offset;
#line 699
        pstr->stop = (pstr->raw_stop - idx) + offset;
#line 700
        pstr->offsets_needed = (unsigned char)0;
      }
#line 703
      pstr->valid_len = (Idx )0;
#line 705
      if (pstr->mb_cur_max > 1) {
#line 708
        wc = 4294967295U;
#line 710
        if (pstr->is_utf8) {
#line 716
          raw = pstr->raw_mbs + pstr->raw_mbs_idx;
#line 717
          end = raw + (offset - (Idx )pstr->mb_cur_max);
#line 718
          if ((unsigned long )end < (unsigned long )pstr->raw_mbs) {
#line 719
            end = pstr->raw_mbs;
          }
#line 720
          p = (raw + offset) - 1;
#line 732
          while ((unsigned long )p >= (unsigned long )end) {
#line 733
            if (((int const   )*p & 192) != 128) {
#line 737
              mlen = (Idx )((raw + pstr->len) - p);
#line 741
              tmp___4 = __builtin_expect((long )((unsigned long )pstr->trans != (unsigned long )((void *)0)),
                                         0L);
#line 741
              if (tmp___4) {
#line 743
                if (mlen < 6UL) {
#line 743
                  tmp___3 = mlen;
                } else {
#line 743
                  tmp___3 = (Idx )6;
                }
#line 743
                i = (int )tmp___3;
#line 744
                while (1) {
#line 744
                  i --;
#line 744
                  if (! (i >= 0)) {
#line 744
                    break;
                  }
#line 745
                  buf___0[i] = *(pstr->trans + *(p + i));
                }
              }
#line 749
              memset((void *)(& cur_state), 0, sizeof(cur_state));
#line 750
              mbclen = mbrtowc((wchar_t * __restrict  )(& wc2), (char const   * __restrict  )((char const   *)p),
                               mlen, (mbstate_t * __restrict  )(& cur_state));
#line 752
              if ((size_t )((raw + offset) - p) <= mbclen) {
#line 752
                if (mbclen < 0xfffffffffffffffeUL) {
#line 755
                  memset((void *)(& pstr->cur_state), '\000', sizeof(mbstate_t ));
#line 757
                  pstr->valid_len = mbclen - (size_t )((raw + offset) - p);
#line 758
                  wc = (wint_t )wc2;
                }
              }
#line 760
              break;
            }
#line 732
            p --;
          }
        }
#line 764
        if (wc == 4294967295U) {
#line 765
          tmp___5 = re_string_skip_chars(pstr, idx, & wc);
#line 765
          pstr->valid_len = tmp___5 - idx;
        }
#line 766
        if (wc == 4294967295U) {
#line 767
          pstr->tip_context = re_string_context_at((re_string_t const   *)pstr, prev_valid_len - 1UL,
                                                   eflags);
        } else {
#line 770
          tmp___9 = __builtin_expect((long )((int )pstr->word_ops_used != 0), 0L);
#line 770
          if (tmp___9) {
#line 770
            tmp___10 = iswalnum(wc);
#line 770
            if (tmp___10) {
#line 770
              pstr->tip_context = 1U;
            } else
#line 770
            if (wc == 95U) {
#line 770
              pstr->tip_context = 1U;
            } else {
#line 770
              goto _L___1;
            }
          } else {
            _L___1: /* CIL Label */ 
#line 770
            if (wc == 10U) {
#line 770
              if (pstr->newline_anchor) {
#line 770
                tmp___8 = 1 << 1;
              } else {
#line 770
                tmp___8 = 0;
              }
            } else {
#line 770
              tmp___8 = 0;
            }
#line 770
            pstr->tip_context = (unsigned int )tmp___8;
          }
        }
#line 776
        tmp___11 = __builtin_expect((long )pstr->valid_len, 0L);
#line 776
        if (tmp___11) {
#line 778
          wcs_idx = (Idx )0;
#line 778
          while (wcs_idx < pstr->valid_len) {
#line 779
            *(pstr->wcs + wcs_idx) = 4294967295U;
#line 778
            wcs_idx ++;
          }
#line 780
          if (pstr->mbs_allocated) {
#line 781
            memset((void *)pstr->mbs, 255, pstr->valid_len);
          }
        }
#line 783
        pstr->valid_raw_len = pstr->valid_len;
      } else {
#line 788
        c = (int )*(pstr->raw_mbs + ((pstr->raw_mbs_idx + offset) - 1UL));
#line 789
        pstr->valid_raw_len = (Idx )0;
#line 790
        if (pstr->trans) {
#line 791
          c = (int )*(pstr->trans + c);
        }
#line 792
        tmp___14 = bitset_contain((bitset_word_t * const  )pstr->word_char, (Idx )c);
#line 792
        if (tmp___14) {
#line 792
          pstr->tip_context = 1U;
        } else {
#line 792
          if (c == 10) {
#line 792
            if (pstr->newline_anchor) {
#line 792
              tmp___13 = 1 << 1;
            } else {
#line 792
              tmp___13 = 0;
            }
          } else {
#line 792
            tmp___13 = 0;
          }
#line 792
          pstr->tip_context = (unsigned int )tmp___13;
        }
      }
    }
#line 798
    tmp___16 = __builtin_expect((long )pstr->mbs_allocated, 0L);
#line 798
    if (! tmp___16) {
#line 799
      pstr->mbs += offset;
    }
  }
#line 801
  pstr->raw_mbs_idx = idx;
#line 802
  pstr->len -= offset;
#line 803
  pstr->stop -= offset;
#line 807
  if (pstr->mb_cur_max > 1) {
#line 809
    if (pstr->icase) {
#line 811
      tmp___18 = build_wcs_upper_buffer(pstr);
#line 811
      ret = tmp___18;
#line 812
      tmp___19 = __builtin_expect((long )((int )ret != 0), 0L);
#line 812
      if (tmp___19) {
#line 813
        return (ret);
      }
    } else {
#line 816
      build_wcs_buffer(pstr);
    }
  } else {
#line 820
    tmp___20 = __builtin_expect((long )pstr->mbs_allocated, 0L);
#line 820
    if (tmp___20) {
#line 822
      if (pstr->icase) {
#line 823
        build_upper_buffer(pstr);
      } else
#line 824
      if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 825
        re_string_translate_buffer(pstr);
      }
    } else {
#line 828
      pstr->valid_len = pstr->len;
    }
  }
#line 830
  pstr->cur_idx = (Idx )0;
#line 831
  return ((reg_errcode_t )0);
}
}
#line 834 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_peek_byte_case(re_string_t const   *pstr ,
                                                                         Idx idx ) 
{ 
  int ch ;
  Idx off ;
  long tmp ;

  {
#line 842
  tmp = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
#line 842
  if (tmp) {
#line 843
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
  }
#line 846
  if (pstr->mb_cur_max > 1) {
#line 846
    if (*(pstr->wcs + (pstr->cur_idx + (Idx const   )idx)) != 4294967295U) {
#line 846
      if (! (pstr->valid_len == (pstr->cur_idx + (Idx const   )idx) + 1UL)) {
#line 846
        if (! (*(pstr->wcs + ((pstr->cur_idx + (Idx const   )idx) + 1UL)) != 4294967295U)) {
#line 848
          return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
        }
      }
    } else {
#line 848
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 851
  off = (Idx )(pstr->cur_idx + (Idx const   )idx);
#line 853
  if (pstr->offsets_needed) {
#line 854
    off = *(pstr->offsets + off);
  }
#line 857
  ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + (Idx const   )off));
#line 864
  if (pstr->offsets_needed) {
#line 864
    if (! ((ch & -128) == 0)) {
#line 865
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + (pstr->cur_idx + (Idx const   )idx)));
    }
  }
#line 868
  return ((unsigned char __attribute__((__pure__))  )ch);
}
}
#line 871 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static unsigned char __attribute__((__pure__))  re_string_fetch_byte_case(re_string_t *pstr ) 
{ 
  Idx tmp ;
  long tmp___0 ;
  Idx off ;
  int ch ;
  Idx tmp___1 ;
  Idx tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  Idx tmp___4 ;

  {
#line 875
  tmp___0 = __builtin_expect((long )(! pstr->mbs_allocated), 1L);
#line 875
  if (tmp___0) {
#line 876
    tmp = pstr->cur_idx;
#line 876
    (pstr->cur_idx) ++;
#line 876
    return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp));
  }
#line 879
  if (pstr->offsets_needed) {
#line 891
    if (! (pstr->cur_idx == pstr->valid_len)) {
#line 891
      if (! (*(pstr->wcs + pstr->cur_idx) != 4294967295U)) {
#line 892
        tmp___1 = pstr->cur_idx;
#line 892
        (pstr->cur_idx) ++;
#line 892
        return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp___1));
      }
    }
#line 894
    off = *(pstr->offsets + pstr->cur_idx);
#line 895
    ch = (int )*(pstr->raw_mbs + (pstr->raw_mbs_idx + off));
#line 897
    if (! ((ch & -128) == 0)) {
#line 898
      tmp___2 = pstr->cur_idx;
#line 898
      (pstr->cur_idx) ++;
#line 898
      return ((unsigned char __attribute__((__pure__))  )*(pstr->mbs + tmp___2));
    }
#line 900
    tmp___3 = re_string_char_size_at((re_string_t const   *)pstr, pstr->cur_idx);
#line 900
    pstr->cur_idx += (Idx )tmp___3;
#line 902
    return ((unsigned char __attribute__((__pure__))  )ch);
  }
#line 906
  tmp___4 = pstr->cur_idx;
#line 906
  (pstr->cur_idx) ++;
#line 906
  return ((unsigned char __attribute__((__pure__))  )*(pstr->raw_mbs + (pstr->raw_mbs_idx + tmp___4)));
}
}
#line 909 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void re_string_destruct(re_string_t *pstr ) 
{ 


  {
#line 914
  free((void *)pstr->wcs);
#line 915
  free((void *)pstr->offsets);
#line 917
  if (pstr->mbs_allocated) {
#line 918
    free((void *)pstr->mbs);
  }
#line 919
  return;
}
}
#line 923
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags )  __attribute__((__pure__)) ;
#line 923 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static unsigned int re_string_context_at(re_string_t const   *input , Idx idx , int eflags ) 
{ 
  int c ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  wint_t wc ;
  Idx wc_idx ;
  long tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool tmp___5 ;
  int tmp___6 ;

  {
#line 928
  tmp = __builtin_expect((long )(! (idx < 0xfffffffffffffffeUL)), 0L);
#line 928
  if (tmp) {
#line 931
    return ((unsigned int )input->tip_context);
  }
#line 932
  tmp___1 = __builtin_expect((long )(idx == (Idx )input->len), 0L);
#line 932
  if (tmp___1) {
#line 933
    if (eflags & (1 << 1)) {
#line 933
      tmp___0 = ((1 << 1) << 1) << 1;
    } else {
#line 933
      tmp___0 = (1 << 1) | (((1 << 1) << 1) << 1);
    }
#line 933
    return ((unsigned int )tmp___0);
  }
#line 936
  if (input->mb_cur_max > 1) {
#line 939
    wc_idx = idx;
#line 940
    while (*(input->wcs + wc_idx) == 4294967295U) {
#line 946
      wc_idx --;
#line 947
      if (! (wc_idx < 0xfffffffffffffffeUL)) {
#line 948
        return ((unsigned int )input->tip_context);
      }
    }
#line 950
    wc = *(input->wcs + wc_idx);
#line 951
    tmp___2 = __builtin_expect((long )((int const   )input->word_ops_used != 0), 0L);
#line 951
    if (tmp___2) {
#line 951
      tmp___3 = iswalnum(wc);
#line 951
      if (tmp___3) {
#line 952
        return (1U);
      } else
#line 951
      if (wc == 95U) {
#line 952
        return (1U);
      }
    }
#line 953
    if (wc == 10U) {
#line 953
      if (input->newline_anchor) {
#line 953
        tmp___4 = 1 << 1;
      } else {
#line 953
        tmp___4 = 0;
      }
    } else {
#line 953
      tmp___4 = 0;
    }
#line 953
    return ((unsigned int )tmp___4);
  } else {
#line 959
    c = (int )*(input->mbs + idx);
#line 960
    tmp___5 = bitset_contain((bitset_word_t * const  )input->word_char, (Idx )c);
#line 960
    if (tmp___5) {
#line 961
      return (1U);
    }
#line 962
    if (c == 10) {
#line 962
      if (input->newline_anchor) {
#line 962
        tmp___6 = 1 << 1;
      } else {
#line 962
        tmp___6 = 0;
      }
    } else {
#line 962
      tmp___6 = 0;
    }
#line 962
    return ((unsigned int )tmp___6);
  }
}
}
#line 968 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_alloc(re_node_set *set , Idx size ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
#line 972
  set->alloc = size;
#line 973
  set->nelem = (Idx )0;
#line 974
  tmp = malloc(size * sizeof(Idx ));
#line 974
  set->elems = (Idx *)tmp;
#line 975
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
#line 975
  if (tmp___0) {
#line 976
    return ((reg_errcode_t )12);
  }
#line 977
  return ((reg_errcode_t )0);
}
}
#line 980 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_1(re_node_set *set , Idx elem ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
#line 984
  set->alloc = (Idx )1;
#line 985
  set->nelem = (Idx )1;
#line 986
  tmp = malloc(sizeof(Idx ));
#line 986
  set->elems = (Idx *)tmp;
#line 987
  tmp___1 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
#line 987
  if (tmp___1) {
#line 989
    tmp___0 = (Idx )0;
#line 989
    set->nelem = tmp___0;
#line 989
    set->alloc = tmp___0;
#line 990
    return ((reg_errcode_t )12);
  }
#line 992
  *(set->elems + 0) = elem;
#line 993
  return ((reg_errcode_t )0);
}
}
#line 996 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_2(re_node_set *set , Idx elem1 , Idx elem2 ) 
{ 
  void *tmp ;
  long tmp___0 ;

  {
#line 1000
  set->alloc = (Idx )2;
#line 1001
  tmp = malloc(2UL * sizeof(Idx ));
#line 1001
  set->elems = (Idx *)tmp;
#line 1002
  tmp___0 = __builtin_expect((long )((unsigned long )set->elems == (unsigned long )((void *)0)),
                             0L);
#line 1002
  if (tmp___0) {
#line 1003
    return ((reg_errcode_t )12);
  }
#line 1004
  if (elem1 == elem2) {
#line 1006
    set->nelem = (Idx )1;
#line 1007
    *(set->elems + 0) = elem1;
  } else {
#line 1011
    set->nelem = (Idx )2;
#line 1012
    if (elem1 < elem2) {
#line 1014
      *(set->elems + 0) = elem1;
#line 1015
      *(set->elems + 1) = elem2;
    } else {
#line 1019
      *(set->elems + 0) = elem2;
#line 1020
      *(set->elems + 1) = elem1;
    }
  }
#line 1023
  return ((reg_errcode_t )0);
}
}
#line 1026 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_copy(re_node_set *dest , re_node_set const   *src ) 
{ 
  void *tmp ;
  Idx tmp___0 ;
  long tmp___1 ;

  {
#line 1030
  dest->nelem = (Idx )src->nelem;
#line 1031
  if (src->nelem > 0UL) {
#line 1033
    dest->alloc = dest->nelem;
#line 1034
    tmp = malloc(dest->alloc * sizeof(Idx ));
#line 1034
    dest->elems = (Idx *)tmp;
#line 1035
    tmp___1 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                               0L);
#line 1035
    if (tmp___1) {
#line 1037
      tmp___0 = (Idx )0;
#line 1037
      dest->nelem = tmp___0;
#line 1037
      dest->alloc = tmp___0;
#line 1038
      return ((reg_errcode_t )12);
    }
#line 1040
    memcpy((void * __restrict  )dest->elems, (void const   * __restrict  )src->elems,
           (size_t )(src->nelem * (Idx const   )sizeof(Idx )));
  } else {
#line 1043
    memset((void *)dest, '\000', sizeof(re_node_set ));
  }
#line 1044
  return ((reg_errcode_t )0);
}
}
#line 1051 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_add_intersect(re_node_set *dest , re_node_set const   *src1 ,
                                               re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx is ;
  Idx id ;
  Idx delta ;
  Idx sbase ;
  Idx new_alloc ;
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  Idx tmp___2 ;

  {
#line 1057
  if (src1->nelem == 0UL) {
#line 1058
    return ((reg_errcode_t )0);
  } else
#line 1057
  if (src2->nelem == 0UL) {
#line 1058
    return ((reg_errcode_t )0);
  }
#line 1062
  if ((src1->nelem + src2->nelem) + (Idx const   )dest->nelem > (Idx const   )dest->alloc) {
#line 1064
    new_alloc = (Idx )((src1->nelem + src2->nelem) + (Idx const   )dest->alloc);
#line 1065
    tmp = realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1065
    new_elems = (Idx *)tmp;
#line 1066
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
#line 1066
    if (tmp___0) {
#line 1067
      return ((reg_errcode_t )12);
    }
#line 1068
    dest->elems = new_elems;
#line 1069
    dest->alloc = new_alloc;
  }
#line 1074
  sbase = (dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem;
#line 1075
  i1 = (Idx )(src1->nelem - 1UL);
#line 1076
  i2 = (Idx )(src2->nelem - 1UL);
#line 1077
  id = dest->nelem - 1UL;
#line 1078
  while (1) {
#line 1080
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1083
      while (1) {
#line 1083
        if (id < 0xfffffffffffffffeUL) {
#line 1083
          if (! (*(dest->elems + id) > *(src1->elems + i1))) {
#line 1083
            break;
          }
        } else {
#line 1083
          break;
        }
#line 1084
        id --;
      }
#line 1086
      if (! (id < 0xfffffffffffffffeUL)) {
#line 1087
        sbase --;
#line 1087
        *(dest->elems + sbase) = *(src1->elems + i1);
      } else
#line 1086
      if (*(dest->elems + id) != *(src1->elems + i1)) {
#line 1087
        sbase --;
#line 1087
        *(dest->elems + sbase) = *(src1->elems + i1);
      }
#line 1089
      i1 --;
#line 1089
      if (i1 < 0xfffffffffffffffeUL) {
#line 1089
        i2 --;
#line 1089
        if (! (i2 < 0xfffffffffffffffeUL)) {
#line 1090
          break;
        }
      } else {
#line 1090
        break;
      }
    } else
#line 1094
    if (*(src1->elems + i1) < *(src2->elems + i2)) {
#line 1096
      i2 --;
#line 1096
      if (! (i2 < 0xfffffffffffffffeUL)) {
#line 1097
        break;
      }
    } else {
#line 1101
      i1 --;
#line 1101
      if (! (i1 < 0xfffffffffffffffeUL)) {
#line 1102
        break;
      }
    }
  }
#line 1106
  id = dest->nelem - 1UL;
#line 1107
  is = ((dest->nelem + (Idx )src1->nelem) + (Idx )src2->nelem) - 1UL;
#line 1108
  delta = (is - sbase) + 1UL;
#line 1113
  dest->nelem += delta;
#line 1114
  if (delta > 0UL) {
#line 1114
    if (id < 0xfffffffffffffffeUL) {
#line 1115
      while (1) {
#line 1117
        if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1120
          tmp___1 = delta;
#line 1120
          delta --;
#line 1120
          tmp___2 = is;
#line 1120
          is --;
#line 1120
          *(dest->elems + (id + tmp___1)) = *(dest->elems + tmp___2);
#line 1121
          if (delta == 0UL) {
#line 1122
            break;
          }
        } else {
#line 1127
          *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1128
          id --;
#line 1128
          if (! (id < 0xfffffffffffffffeUL)) {
#line 1129
            break;
          }
        }
      }
    }
  }
#line 1134
  memcpy((void * __restrict  )dest->elems, (void const   * __restrict  )(dest->elems + sbase),
         delta * sizeof(Idx ));
#line 1136
  return ((reg_errcode_t )0);
}
}
#line 1142 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_init_union(re_node_set *dest , re_node_set const   *src1 ,
                                            re_node_set const   *src2 ) 
{ 
  Idx i1 ;
  Idx i2 ;
  Idx id ;
  void *tmp ;
  long tmp___0 ;
  reg_errcode_t tmp___1 ;
  reg_errcode_t tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;
  Idx tmp___5 ;
  Idx tmp___6 ;

  {
#line 1148
  if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1148
    if (src1->nelem > 0UL) {
#line 1148
      if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1148
        if (src2->nelem > 0UL) {
#line 1150
          dest->alloc = (Idx )(src1->nelem + src2->nelem);
#line 1151
          tmp = malloc(dest->alloc * sizeof(Idx ));
#line 1151
          dest->elems = (Idx *)tmp;
#line 1152
          tmp___0 = __builtin_expect((long )((unsigned long )dest->elems == (unsigned long )((void *)0)),
                                     0L);
#line 1152
          if (tmp___0) {
#line 1153
            return ((reg_errcode_t )12);
          }
        } else {
#line 1148
          goto _L___2;
        }
      } else {
#line 1148
        goto _L___2;
      }
    } else {
#line 1148
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 1157
    if ((unsigned long )src1 != (unsigned long )((void *)0)) {
#line 1157
      if (src1->nelem > 0UL) {
#line 1158
        tmp___1 = re_node_set_init_copy(dest, src1);
#line 1158
        return (tmp___1);
      } else {
#line 1157
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1159
    if ((unsigned long )src2 != (unsigned long )((void *)0)) {
#line 1159
      if (src2->nelem > 0UL) {
#line 1160
        tmp___2 = re_node_set_init_copy(dest, src2);
#line 1160
        return (tmp___2);
      } else {
#line 1162
        memset((void *)dest, '\000', sizeof(re_node_set ));
      }
    } else {
#line 1162
      memset((void *)dest, '\000', sizeof(re_node_set ));
    }
#line 1163
    return ((reg_errcode_t )0);
  }
#line 1165
  id = (Idx )0;
#line 1165
  i2 = id;
#line 1165
  i1 = i2;
#line 1165
  while (1) {
#line 1165
    if (i1 < (Idx )src1->nelem) {
#line 1165
      if (! (i2 < (Idx )src2->nelem)) {
#line 1165
        break;
      }
    } else {
#line 1165
      break;
    }
#line 1167
    if (*(src1->elems + i1) > *(src2->elems + i2)) {
#line 1169
      tmp___3 = id;
#line 1169
      id ++;
#line 1169
      tmp___4 = i2;
#line 1169
      i2 ++;
#line 1169
      *(dest->elems + tmp___3) = *(src2->elems + tmp___4);
#line 1170
      goto __Cont;
    }
#line 1172
    if (*(src1->elems + i1) == *(src2->elems + i2)) {
#line 1173
      i2 ++;
    }
#line 1174
    tmp___5 = id;
#line 1174
    id ++;
#line 1174
    tmp___6 = i1;
#line 1174
    i1 ++;
#line 1174
    *(dest->elems + tmp___5) = *(src1->elems + tmp___6);
    __Cont: /* CIL Label */ ;
  }
#line 1176
  if (i1 < (Idx )src1->nelem) {
#line 1178
    memcpy((void * __restrict  )(dest->elems + id), (void const   * __restrict  )(src1->elems + i1),
           (size_t )((src1->nelem - (Idx const   )i1) * (Idx const   )sizeof(Idx )));
#line 1180
    id += (Idx )(src1->nelem - (Idx const   )i1);
  } else
#line 1182
  if (i2 < (Idx )src2->nelem) {
#line 1184
    memcpy((void * __restrict  )(dest->elems + id), (void const   * __restrict  )(src2->elems + i2),
           (size_t )((src2->nelem - (Idx const   )i2) * (Idx const   )sizeof(Idx )));
#line 1186
    id += (Idx )(src2->nelem - (Idx const   )i2);
  }
#line 1188
  dest->nelem = id;
#line 1189
  return ((reg_errcode_t )0);
}
}
#line 1195 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t re_node_set_merge(re_node_set *dest , re_node_set const   *src ) 
{ 
  Idx is ;
  Idx id ;
  Idx sbase ;
  Idx delta ;
  Idx new_alloc ;
  Idx *new_buffer ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  Idx tmp___3 ;
  Idx tmp___4 ;

  {
#line 1200
  if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1201
    return ((reg_errcode_t )0);
  } else
#line 1200
  if (src->nelem == 0UL) {
#line 1201
    return ((reg_errcode_t )0);
  }
#line 1202
  if (dest->alloc < (Idx )(2UL * src->nelem + (Idx const   )dest->nelem)) {
#line 1204
    new_alloc = (Idx )(2UL * (src->nelem + (Idx const   )dest->alloc));
#line 1205
    tmp = realloc((void *)dest->elems, new_alloc * sizeof(Idx ));
#line 1205
    new_buffer = (Idx *)tmp;
#line 1206
    tmp___0 = __builtin_expect((long )((unsigned long )new_buffer == (unsigned long )((void *)0)),
                               0L);
#line 1206
    if (tmp___0) {
#line 1207
      return ((reg_errcode_t )12);
    }
#line 1208
    dest->elems = new_buffer;
#line 1209
    dest->alloc = new_alloc;
  }
#line 1212
  tmp___1 = __builtin_expect((long )(dest->nelem == 0UL), 0L);
#line 1212
  if (tmp___1) {
#line 1214
    dest->nelem = (Idx )src->nelem;
#line 1215
    memcpy((void * __restrict  )dest->elems, (void const   * __restrict  )src->elems,
           (size_t )(src->nelem * (Idx const   )sizeof(Idx )));
#line 1216
    return ((reg_errcode_t )0);
  }
#line 1221
  sbase = dest->nelem + (Idx )(2UL * src->nelem);
#line 1221
  is = (Idx )(src->nelem - 1UL);
#line 1221
  id = dest->nelem - 1UL;
#line 1221
  while (1) {
#line 1221
    if (is < 0xfffffffffffffffeUL) {
#line 1221
      if (! (id < 0xfffffffffffffffeUL)) {
#line 1221
        break;
      }
    } else {
#line 1221
      break;
    }
#line 1225
    if (*(dest->elems + id) == *(src->elems + is)) {
#line 1226
      is --;
#line 1226
      id --;
    } else
#line 1227
    if (*(dest->elems + id) < *(src->elems + is)) {
#line 1228
      sbase --;
#line 1228
      tmp___2 = is;
#line 1228
      is --;
#line 1228
      *(dest->elems + sbase) = *(src->elems + tmp___2);
    } else {
#line 1230
      id --;
    }
  }
#line 1233
  if (is < 0xfffffffffffffffeUL) {
#line 1236
    sbase -= is + 1UL;
#line 1237
    memcpy((void * __restrict  )(dest->elems + sbase), (void const   * __restrict  )src->elems,
           (is + 1UL) * sizeof(Idx ));
  }
#line 1240
  id = dest->nelem - 1UL;
#line 1241
  is = (dest->nelem + (Idx )(2UL * src->nelem)) - 1UL;
#line 1242
  delta = (is - sbase) + 1UL;
#line 1243
  if (delta == 0UL) {
#line 1244
    return ((reg_errcode_t )0);
  }
#line 1248
  dest->nelem += delta;
#line 1249
  while (1) {
#line 1251
    if (*(dest->elems + is) > *(dest->elems + id)) {
#line 1254
      tmp___3 = delta;
#line 1254
      delta --;
#line 1254
      tmp___4 = is;
#line 1254
      is --;
#line 1254
      *(dest->elems + (id + tmp___3)) = *(dest->elems + tmp___4);
#line 1255
      if (delta == 0UL) {
#line 1256
        break;
      }
    } else {
#line 1261
      *(dest->elems + (id + delta)) = *(dest->elems + id);
#line 1262
      id --;
#line 1262
      if (! (id < 0xfffffffffffffffeUL)) {
#line 1265
        memcpy((void * __restrict  )dest->elems, (void const   * __restrict  )(dest->elems + sbase),
               delta * sizeof(Idx ));
#line 1267
        break;
      }
    }
  }
#line 1272
  return ((reg_errcode_t )0);
}
}
#line 1279 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static _Bool re_node_set_insert(re_node_set *set , Idx elem ) 
{ 
  Idx idx ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  long tmp___1 ;
  Idx *new_elems ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 1285
  if (set->alloc == 0UL) {
#line 1286
    tmp = re_node_set_init_1(set, elem);
#line 1286
    tmp___0 = __builtin_expect((long )((int )tmp == 0), 1L);
#line 1286
    return ((_Bool )tmp___0);
  }
#line 1288
  tmp___1 = __builtin_expect((long )set->nelem, 0L);
#line 1288
  if (tmp___1 == 0L) {
#line 1291
    *(set->elems + 0) = elem;
#line 1292
    (set->nelem) ++;
#line 1293
    return ((_Bool)1);
  }
#line 1297
  if (set->alloc == set->nelem) {
#line 1300
    set->alloc *= 2UL;
#line 1301
    tmp___2 = realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1301
    new_elems = (Idx *)tmp___2;
#line 1302
    tmp___3 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
#line 1302
    if (tmp___3) {
#line 1303
      return ((_Bool)0);
    }
#line 1304
    set->elems = new_elems;
  }
#line 1309
  if (elem < *(set->elems + 0)) {
#line 1311
    idx = (Idx )0;
#line 1312
    idx = set->nelem;
#line 1312
    while (idx > 0UL) {
#line 1313
      *(set->elems + idx) = *(set->elems + (idx - 1UL));
#line 1312
      idx --;
    }
  } else {
#line 1317
    idx = set->nelem;
#line 1317
    while (*(set->elems + (idx - 1UL)) > elem) {
#line 1318
      *(set->elems + idx) = *(set->elems + (idx - 1UL));
#line 1317
      idx --;
    }
  }
#line 1322
  *(set->elems + idx) = elem;
#line 1323
  (set->nelem) ++;
#line 1324
  return ((_Bool)1);
}
}
#line 1331 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static _Bool re_node_set_insert_last(re_node_set *set , Idx elem ) 
{ 
  Idx *new_elems ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 1336
  if (set->alloc == set->nelem) {
#line 1339
    set->alloc = (set->alloc + 1UL) * 2UL;
#line 1340
    tmp = realloc((void *)set->elems, set->alloc * sizeof(Idx ));
#line 1340
    new_elems = (Idx *)tmp;
#line 1341
    tmp___0 = __builtin_expect((long )((unsigned long )new_elems == (unsigned long )((void *)0)),
                               0L);
#line 1341
    if (tmp___0) {
#line 1342
      return ((_Bool)0);
    }
#line 1343
    set->elems = new_elems;
  }
#line 1347
  tmp___1 = set->nelem;
#line 1347
  (set->nelem) ++;
#line 1347
  *(set->elems + tmp___1) = elem;
#line 1348
  return ((_Bool)1);
}
}
#line 1354 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static _Bool __attribute__((__pure__))  re_node_set_compare(re_node_set const   *set1 ,
                                                            re_node_set const   *set2 ) 
{ 
  Idx i ;

  {
#line 1359
  if ((unsigned long )set1 == (unsigned long )((void *)0)) {
#line 1360
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1359
  if ((unsigned long )set2 == (unsigned long )((void *)0)) {
#line 1360
    return ((_Bool __attribute__((__pure__))  )0);
  } else
#line 1359
  if (set1->nelem != set2->nelem) {
#line 1360
    return ((_Bool __attribute__((__pure__))  )0);
  }
#line 1361
  i = (Idx )set1->nelem;
#line 1361
  while (1) {
#line 1361
    i --;
#line 1361
    if (! (i < 0xfffffffffffffffeUL)) {
#line 1361
      break;
    }
#line 1362
    if (*(set1->elems + i) != *(set2->elems + i)) {
#line 1363
      return ((_Bool __attribute__((__pure__))  )0);
    }
  }
#line 1364
  return ((_Bool __attribute__((__pure__))  )1);
}
}
#line 1369 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static Idx __attribute__((__pure__))  re_node_set_contains(re_node_set const   *set ,
                                                           Idx elem ) 
{ 
  __re_size_t idx ;
  __re_size_t right ;
  __re_size_t mid ;
  __re_size_t tmp ;

  {
#line 1374
  if (! ((Idx )(set->nelem - 1UL) < 0xfffffffffffffffdUL)) {
#line 1375
    return ((Idx __attribute__((__pure__))  )0);
  }
#line 1378
  idx = (__re_size_t )0;
#line 1379
  right = (__re_size_t )(set->nelem - 1UL);
#line 1380
  while (idx < right) {
#line 1382
    mid = (idx + right) / 2UL;
#line 1383
    if (*(set->elems + mid) < elem) {
#line 1384
      idx = mid + 1UL;
    } else {
#line 1386
      right = mid;
    }
  }
#line 1388
  if (*(set->elems + idx) == elem) {
#line 1388
    tmp = idx + 1UL;
  } else {
#line 1388
    tmp = (__re_size_t )0;
  }
#line 1388
  return ((Idx __attribute__((__pure__))  )tmp);
}
}
#line 1391 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void re_node_set_remove_at(re_node_set *set , Idx idx ) 
{ 


  {
#line 1398
  if (idx >= set->nelem) {
#line 1399
    return;
  }
#line 1400
  (set->nelem) --;
#line 1401
  while (idx < set->nelem) {
#line 1402
    *(set->elems + idx) = *(set->elems + (idx + 1UL));
#line 1401
    idx ++;
  }
#line 1403
  return;
}
}
#line 1409 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static Idx re_dfa_add_node(re_dfa_t *dfa , re_token_t token ) 
{ 
  size_t new_nodes_alloc ;
  Idx *new_nexts ;
  Idx *new_indices ;
  re_node_set *new_edests ;
  re_node_set *new_eclosures ;
  re_token_t *new_nodes ;
  size_t max_object_size ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  unsigned long tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int type ;
  int tmp___13 ;
  size_t tmp___14 ;

  {
#line 1413
  tmp___12 = __builtin_expect((long )(dfa->nodes_len >= dfa->nodes_alloc), 0L);
#line 1413
  if (tmp___12) {
#line 1415
    new_nodes_alloc = dfa->nodes_alloc * 2UL;
#line 1419
    if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1419
      tmp___2 = sizeof(Idx );
    } else {
#line 1419
      tmp___2 = sizeof(re_node_set );
    }
#line 1419
    if (sizeof(re_token_t ) < tmp___2) {
#line 1419
      if (sizeof(re_node_set ) < sizeof(Idx )) {
#line 1419
        tmp___0 = sizeof(Idx );
      } else {
#line 1419
        tmp___0 = sizeof(re_node_set );
      }
#line 1419
      tmp___1 = tmp___0;
    } else {
#line 1419
      tmp___1 = sizeof(re_token_t );
    }
#line 1419
    max_object_size = tmp___1;
#line 1425
    tmp___3 = __builtin_expect((long )(9223372036854775807UL / max_object_size < dfa->nodes_alloc),
                               0L);
#line 1425
    if (tmp___3) {
#line 1426
      return ((Idx )-1);
    }
#line 1428
    tmp___4 = realloc((void *)dfa->nodes, new_nodes_alloc * sizeof(re_token_t ));
#line 1428
    new_nodes = (re_token_t *)tmp___4;
#line 1429
    tmp___5 = __builtin_expect((long )((unsigned long )new_nodes == (unsigned long )((void *)0)),
                               0L);
#line 1429
    if (tmp___5) {
#line 1430
      return ((Idx )-1);
    }
#line 1431
    dfa->nodes = new_nodes;
#line 1432
    tmp___6 = realloc((void *)dfa->nexts, new_nodes_alloc * sizeof(Idx ));
#line 1432
    new_nexts = (Idx *)tmp___6;
#line 1433
    tmp___7 = realloc((void *)dfa->org_indices, new_nodes_alloc * sizeof(Idx ));
#line 1433
    new_indices = (Idx *)tmp___7;
#line 1434
    tmp___8 = realloc((void *)dfa->edests, new_nodes_alloc * sizeof(re_node_set ));
#line 1434
    new_edests = (re_node_set *)tmp___8;
#line 1435
    tmp___9 = realloc((void *)dfa->eclosures, new_nodes_alloc * sizeof(re_node_set ));
#line 1435
    new_eclosures = (re_node_set *)tmp___9;
#line 1436
    if ((unsigned long )new_nexts == (unsigned long )((void *)0)) {
#line 1436
      tmp___10 = 1;
    } else
#line 1436
    if ((unsigned long )new_indices == (unsigned long )((void *)0)) {
#line 1436
      tmp___10 = 1;
    } else
#line 1436
    if ((unsigned long )new_edests == (unsigned long )((void *)0)) {
#line 1436
      tmp___10 = 1;
    } else
#line 1436
    if ((unsigned long )new_eclosures == (unsigned long )((void *)0)) {
#line 1436
      tmp___10 = 1;
    } else {
#line 1436
      tmp___10 = 0;
    }
#line 1436
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
#line 1436
    if (tmp___11) {
#line 1438
      return ((Idx )-1);
    }
#line 1439
    dfa->nexts = new_nexts;
#line 1440
    dfa->org_indices = new_indices;
#line 1441
    dfa->edests = new_edests;
#line 1442
    dfa->eclosures = new_eclosures;
#line 1443
    dfa->nodes_alloc = new_nodes_alloc;
  }
#line 1445
  *(dfa->nodes + dfa->nodes_len) = token;
#line 1446
  (dfa->nodes + dfa->nodes_len)->constraint = 0U;
#line 1449
  type = (int )token.type;
#line 1450
  if (type == 5) {
#line 1450
    if (dfa->mb_cur_max > 1) {
#line 1450
      tmp___13 = 1;
    } else {
#line 1450
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1450
  if (type == 6) {
#line 1450
    tmp___13 = 1;
  } else {
#line 1450
    tmp___13 = 0;
  }
#line 1450
  (dfa->nodes + dfa->nodes_len)->accept_mb = (unsigned int )tmp___13;
#line 1454
  *(dfa->nexts + dfa->nodes_len) = (Idx )-1;
#line 1455
  memset((void *)(dfa->edests + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1456
  memset((void *)(dfa->eclosures + dfa->nodes_len), '\000', sizeof(re_node_set ));
#line 1457
  tmp___14 = dfa->nodes_len;
#line 1457
  (dfa->nodes_len) ++;
#line 1457
  return (tmp___14);
}
}
#line 1460 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
__inline static re_hashval_t calc_state_hash(re_node_set const   *nodes , unsigned int context ) 
{ 
  re_hashval_t hash ;
  Idx i ;

  {
#line 1464
  hash = (re_hashval_t )(nodes->nelem + (Idx const   )context);
#line 1466
  i = (Idx )0;
#line 1466
  while (i < (Idx )nodes->nelem) {
#line 1467
    hash += *(nodes->elems + i);
#line 1466
    i ++;
  }
#line 1468
  return (hash);
}
}
#line 1480 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static re_dfastate_t *re_acquire_state(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                       re_node_set const   *nodes ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  long tmp ;
  re_dfastate_t *state ;
  _Bool __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;

  {
#line 1493
  tmp = __builtin_expect((long )(nodes->nelem == 0UL), 0L);
#line 1493
  if (tmp) {
#line 1495
    *err = (reg_errcode_t )0;
#line 1496
    return ((re_dfastate_t *)((void *)0));
  }
#line 1498
  hash = calc_state_hash(nodes, 0U);
#line 1499
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1501
  i = (Idx )0;
#line 1501
  while (i < spot->num) {
#line 1503
    state = *(spot->array + i);
#line 1504
    if (hash != state->hash) {
#line 1505
      goto __Cont;
    }
#line 1506
    tmp___0 = re_node_set_compare((re_node_set const   *)(& state->nodes), nodes);
#line 1506
    if (tmp___0) {
#line 1507
      return (state);
    }
    __Cont: /* CIL Label */ 
#line 1501
    i ++;
  }
#line 1511
  new_state = create_ci_newstate(dfa, nodes, hash);
#line 1512
  tmp___1 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
#line 1512
  if (tmp___1) {
#line 1513
    *err = (reg_errcode_t )12;
  }
#line 1515
  return (new_state);
}
}
#line 1528 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static re_dfastate_t *re_acquire_state_context(reg_errcode_t *err , re_dfa_t const   *dfa ,
                                               re_node_set const   *nodes , unsigned int context ) 
{ 
  re_hashval_t hash ;
  re_dfastate_t *new_state ;
  struct re_state_table_entry *spot ;
  Idx i ;
  re_dfastate_t *state ;
  _Bool __attribute__((__pure__))  tmp ;
  long tmp___0 ;

  {
#line 1541
  if (nodes->nelem == 0UL) {
#line 1543
    *err = (reg_errcode_t )0;
#line 1544
    return ((re_dfastate_t *)((void *)0));
  }
#line 1546
  hash = calc_state_hash(nodes, context);
#line 1547
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1549
  i = (Idx )0;
#line 1549
  while (i < spot->num) {
#line 1551
    state = *(spot->array + i);
#line 1552
    if (state->hash == hash) {
#line 1552
      if (state->context == context) {
#line 1552
        tmp = re_node_set_compare((re_node_set const   *)state->entrance_nodes, nodes);
#line 1552
        if (tmp) {
#line 1555
          return (state);
        }
      }
    }
#line 1549
    i ++;
  }
#line 1558
  new_state = create_cd_newstate(dfa, nodes, context, hash);
#line 1559
  tmp___0 = __builtin_expect((long )((unsigned long )new_state == (unsigned long )((void *)0)),
                             0L);
#line 1559
  if (tmp___0) {
#line 1560
    *err = (reg_errcode_t )12;
  }
#line 1562
  return (new_state);
}
}
#line 1569 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static reg_errcode_t register_state(re_dfa_t const   *dfa , re_dfastate_t *newstate ,
                                    re_hashval_t hash ) 
{ 
  struct re_state_table_entry *spot ;
  reg_errcode_t err ;
  Idx i ;
  long tmp ;
  Idx elem ;
  _Bool tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  Idx new_alloc ;
  re_dfastate_t **new_array ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Idx tmp___6 ;

  {
#line 1577
  newstate->hash = hash;
#line 1578
  err = re_node_set_alloc(& newstate->non_eps_nodes, newstate->nodes.nelem);
#line 1579
  tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 1579
  if (tmp) {
#line 1580
    return ((reg_errcode_t )12);
  }
#line 1581
  i = (Idx )0;
#line 1581
  while (i < newstate->nodes.nelem) {
#line 1583
    elem = *(newstate->nodes.elems + i);
#line 1584
    if (! ((unsigned int )(dfa->nodes + elem)->type & 8U)) {
#line 1585
      tmp___0 = re_node_set_insert_last(& newstate->non_eps_nodes, elem);
#line 1585
      if (tmp___0) {
#line 1585
        tmp___1 = 0;
      } else {
#line 1585
        tmp___1 = 1;
      }
#line 1585
      tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 1585
      if (tmp___2) {
#line 1586
        return ((reg_errcode_t )12);
      }
    }
#line 1581
    i ++;
  }
#line 1589
  spot = (struct re_state_table_entry *)(dfa->state_table + (hash & (unsigned long )dfa->state_hash_mask));
#line 1590
  tmp___5 = __builtin_expect((long )(spot->alloc <= spot->num), 0L);
#line 1590
  if (tmp___5) {
#line 1592
    new_alloc = 2UL * spot->num + 2UL;
#line 1593
    tmp___3 = realloc((void *)spot->array, new_alloc * sizeof(re_dfastate_t *));
#line 1593
    new_array = (re_dfastate_t **)tmp___3;
#line 1595
    tmp___4 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
#line 1595
    if (tmp___4) {
#line 1596
      return ((reg_errcode_t )12);
    }
#line 1597
    spot->array = new_array;
#line 1598
    spot->alloc = new_alloc;
  }
#line 1600
  tmp___6 = spot->num;
#line 1600
  (spot->num) ++;
#line 1600
  *(spot->array + tmp___6) = newstate;
#line 1601
  return ((reg_errcode_t )0);
}
}
#line 1604 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static void free_state(re_dfastate_t *state ) 
{ 


  {
#line 1607
  free((void *)state->non_eps_nodes.elems);
#line 1608
  free((void *)state->inveclosure.elems);
#line 1609
  if ((unsigned long )state->entrance_nodes != (unsigned long )(& state->nodes)) {
#line 1611
    free((void *)(state->entrance_nodes)->elems);
#line 1612
    free((void *)state->entrance_nodes);
  }
#line 1614
  free((void *)state->nodes.elems);
#line 1615
  free((void *)state->word_trtable);
#line 1616
  free((void *)state->trtable);
#line 1617
  free((void *)state);
#line 1618
  return;
}
}
#line 1623 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static re_dfastate_t *create_ci_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         re_hashval_t hash ) 
{ 
  Idx i ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  long tmp___2 ;

  {
#line 1632
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1632
  newstate = (re_dfastate_t *)tmp;
#line 1633
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
#line 1633
  if (tmp___0) {
#line 1634
    return ((re_dfastate_t *)((void *)0));
  }
#line 1635
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1636
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 1636
  if (tmp___1) {
#line 1638
    free((void *)newstate);
#line 1639
    return ((re_dfastate_t *)((void *)0));
  }
#line 1642
  newstate->entrance_nodes = & newstate->nodes;
#line 1643
  i = (Idx )0;
#line 1643
  while (i < (Idx )nodes->nelem) {
#line 1645
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1646
    type = node->type;
#line 1647
    if ((unsigned int )type == 1U) {
#line 1647
      if (! node->constraint) {
#line 1648
        goto __Cont;
      }
    }
#line 1650
    newstate->accept_mb |= node->accept_mb;
#line 1654
    if ((unsigned int )type == 2U) {
#line 1655
      newstate->halt = 1U;
    } else
#line 1656
    if ((unsigned int )type == 4U) {
#line 1657
      newstate->has_backref = 1U;
    } else
#line 1658
    if ((unsigned int )type == 12U) {
#line 1659
      newstate->has_constraint = 1U;
    } else
#line 1658
    if (node->constraint) {
#line 1659
      newstate->has_constraint = 1U;
    }
    __Cont: /* CIL Label */ 
#line 1643
    i ++;
  }
#line 1661
  err = register_state(dfa, newstate, hash);
#line 1662
  tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
#line 1662
  if (tmp___2) {
#line 1664
    free_state(newstate);
#line 1665
    newstate = (re_dfastate_t *)((void *)0);
  }
#line 1667
  return (newstate);
}
}
#line 1673 "/home/wslee/project/coreutils-8.1/lib/regex_internal.c"
static re_dfastate_t *create_cd_newstate(re_dfa_t const   *dfa , re_node_set const   *nodes ,
                                         unsigned int context , re_hashval_t hash ) 
{ 
  Idx i ;
  Idx nctx_nodes ;
  reg_errcode_t err ;
  re_dfastate_t *newstate ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 1678
  nctx_nodes = (Idx )0;
#line 1682
  tmp = calloc(sizeof(re_dfastate_t ), (size_t )1);
#line 1682
  newstate = (re_dfastate_t *)tmp;
#line 1683
  tmp___0 = __builtin_expect((long )((unsigned long )newstate == (unsigned long )((void *)0)),
                             0L);
#line 1683
  if (tmp___0) {
#line 1684
    return ((re_dfastate_t *)((void *)0));
  }
#line 1685
  err = re_node_set_init_copy(& newstate->nodes, nodes);
#line 1686
  tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 1686
  if (tmp___1) {
#line 1688
    free((void *)newstate);
#line 1689
    return ((re_dfastate_t *)((void *)0));
  }
#line 1692
  newstate->context = context;
#line 1693
  newstate->entrance_nodes = & newstate->nodes;
#line 1695
  i = (Idx )0;
#line 1695
  while (i < (Idx )nodes->nelem) {
#line 1697
    node = (re_token_t *)(dfa->nodes + *(nodes->elems + i));
#line 1698
    type = node->type;
#line 1699
    constraint = node->constraint;
#line 1701
    if ((unsigned int )type == 1U) {
#line 1701
      if (! constraint) {
#line 1702
        goto __Cont;
      }
    }
#line 1704
    newstate->accept_mb |= node->accept_mb;
#line 1708
    if ((unsigned int )type == 2U) {
#line 1709
      newstate->halt = 1U;
    } else
#line 1710
    if ((unsigned int )type == 4U) {
#line 1711
      newstate->has_backref = 1U;
    }
#line 1713
    if (constraint) {
#line 1715
      if ((unsigned long )newstate->entrance_nodes == (unsigned long )(& newstate->nodes)) {
#line 1717
        tmp___2 = malloc(sizeof(re_node_set ));
#line 1717
        newstate->entrance_nodes = (re_node_set *)tmp___2;
#line 1718
        tmp___3 = __builtin_expect((long )((unsigned long )newstate->entrance_nodes == (unsigned long )((void *)0)),
                                   0L);
#line 1718
        if (tmp___3) {
#line 1720
          free_state(newstate);
#line 1721
          return ((re_dfastate_t *)((void *)0));
        }
#line 1723
        re_node_set_init_copy(newstate->entrance_nodes, nodes);
#line 1724
        nctx_nodes = (Idx )0;
#line 1725
        newstate->has_constraint = 1U;
      }
#line 1728
      if (constraint & 1U) {
#line 1728
        if (! (context & 1U)) {
#line 1730
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1731
          nctx_nodes ++;
        } else {
#line 1728
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 1728
      if (constraint & 2U) {
#line 1728
        if (context & 1U) {
#line 1730
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1731
          nctx_nodes ++;
        } else {
#line 1728
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1728
      if (constraint & 16U) {
#line 1728
        if (! (context & (unsigned int )(1 << 1))) {
#line 1730
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1731
          nctx_nodes ++;
        } else {
#line 1728
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1728
      if (constraint & 64U) {
#line 1728
        if (! (context & (unsigned int )((1 << 1) << 1))) {
#line 1730
          re_node_set_remove_at(& newstate->nodes, i - nctx_nodes);
#line 1731
          nctx_nodes ++;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1695
    i ++;
  }
#line 1735
  err = register_state(dfa, newstate, hash);
#line 1736
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
#line 1736
  if (tmp___4) {
#line 1738
    free_state(newstate);
#line 1739
    newstate = (re_dfastate_t *)((void *)0);
  }
#line 1741
  return (newstate);
}
}
#line 23 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) ;
#line 25
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) ;
#line 28
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) ;
#line 30
static void free_charset(re_charset_t *cset ) ;
#line 32
static void free_workarea_compile(regex_t *preg ) ;
#line 33
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) ;
#line 35
static void optimize_utf8(re_dfa_t *dfa ) ;
#line 37
static reg_errcode_t analyze(regex_t *preg ) ;
#line 38
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) ;
#line 41
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) ;
#line 44
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) ;
#line 45
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) ;
#line 46
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) ;
#line 48
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) ;
#line 49
static reg_errcode_t calc_next(void *extra  __attribute__((__unused__)) , bin_tree_t *node ) ;
#line 50
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) ;
#line 51
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) ;
#line 52
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) ;
#line 54
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) ;
#line 55
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) ;
#line 57
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) ;
#line 58
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) ;
#line 60
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) ;
#line 62
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) ;
#line 64
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 67
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 70
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 73
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) ;
#line 76
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 79
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) ;
#line 82
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa  __attribute__((__unused__)) ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) ;
#line 88
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) ;
#line 92
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset  __attribute__((__unused__)) ,
                                       Idx *equiv_class_alloc  __attribute__((__unused__)) ,
                                       unsigned char const   *name ) ;
#line 96
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) ;
#line 110
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , _Bool non_match ,
                                      reg_errcode_t *err ) ;
#line 115
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) ;
#line 118
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) ;
#line 121
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) ;
#line 122
static void free_token(re_token_t *node ) ;
#line 123
static reg_errcode_t free_tree(void *extra  __attribute__((__unused__)) , bin_tree_t *node ) ;
#line 124
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) ;
#line 131 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static char const   __re_error_msgid[369]  = 
#line 131
  {      (char const   )'S',      (char const   )'u',      (char const   )'c',      (char const   )'c', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'\000', 
        (char const   )'N',      (char const   )'o',      (char const   )' ',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'\000',      (char const   )'I',      (char const   )'n',      (char const   )'v', 
        (char const   )'a',      (char const   )'l',      (char const   )'i',      (char const   )'d', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'l',      (char const   )'l', 
        (char const   )'a',      (char const   )'t',      (char const   )'i',      (char const   )'o', 
        (char const   )'n',      (char const   )' ',      (char const   )'c',      (char const   )'h', 
        (char const   )'a',      (char const   )'r',      (char const   )'a',      (char const   )'c', 
        (char const   )'t',      (char const   )'e',      (char const   )'r',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'h',      (char const   )'a',      (char const   )'r', 
        (char const   )'a',      (char const   )'c',      (char const   )'t',      (char const   )'e', 
        (char const   )'r',      (char const   )' ',      (char const   )'c',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'s',      (char const   )' ', 
        (char const   )'n',      (char const   )'a',      (char const   )'m',      (char const   )'e', 
        (char const   )'\000',      (char const   )'T',      (char const   )'r',      (char const   )'a', 
        (char const   )'i',      (char const   )'l',      (char const   )'i',      (char const   )'n', 
        (char const   )'g',      (char const   )' ',      (char const   )'b',      (char const   )'a', 
        (char const   )'c',      (char const   )'k',      (char const   )'s',      (char const   )'l', 
        (char const   )'a',      (char const   )'s',      (char const   )'h',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'b',      (char const   )'a',      (char const   )'c',      (char const   )'k', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'f', 
        (char const   )'e',      (char const   )'r',      (char const   )'e',      (char const   )'n', 
        (char const   )'c',      (char const   )'e',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'[',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'[',      (char const   )'^', 
        (char const   )'\000',      (char const   )'U',      (char const   )'n',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'c',      (char const   )'h', 
        (char const   )'e',      (char const   )'d',      (char const   )' ',      (char const   )'(', 
        (char const   )' ',      (char const   )'o',      (char const   )'r',      (char const   )' ', 
        (char const   )'\\',      (char const   )'(',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )'\\',      (char const   )'{',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'c',      (char const   )'o',      (char const   )'n',      (char const   )'t', 
        (char const   )'e',      (char const   )'n',      (char const   )'t',      (char const   )' ', 
        (char const   )'o',      (char const   )'f',      (char const   )' ',      (char const   )'\\', 
        (char const   )'{',      (char const   )'\\',      (char const   )'}',      (char const   )'\000', 
        (char const   )'I',      (char const   )'n',      (char const   )'v',      (char const   )'a', 
        (char const   )'l',      (char const   )'i',      (char const   )'d',      (char const   )' ', 
        (char const   )'r',      (char const   )'a',      (char const   )'n',      (char const   )'g', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )'\000',      (char const   )'M',      (char const   )'e', 
        (char const   )'m',      (char const   )'o',      (char const   )'r',      (char const   )'y', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'h', 
        (char const   )'a',      (char const   )'u',      (char const   )'s',      (char const   )'t', 
        (char const   )'e',      (char const   )'d',      (char const   )'\000',      (char const   )'I', 
        (char const   )'n',      (char const   )'v',      (char const   )'a',      (char const   )'l', 
        (char const   )'i',      (char const   )'d',      (char const   )' ',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'c',      (char const   )'e', 
        (char const   )'d',      (char const   )'i',      (char const   )'n',      (char const   )'g', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'P',      (char const   )'r',      (char const   )'e',      (char const   )'m', 
        (char const   )'a',      (char const   )'t',      (char const   )'u',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'e',      (char const   )'n', 
        (char const   )'d',      (char const   )' ',      (char const   )'o',      (char const   )'f', 
        (char const   )' ',      (char const   )'r',      (char const   )'e',      (char const   )'g', 
        (char const   )'u',      (char const   )'l',      (char const   )'a',      (char const   )'r', 
        (char const   )' ',      (char const   )'e',      (char const   )'x',      (char const   )'p', 
        (char const   )'r',      (char const   )'e',      (char const   )'s',      (char const   )'s', 
        (char const   )'i',      (char const   )'o',      (char const   )'n',      (char const   )'\000', 
        (char const   )'R',      (char const   )'e',      (char const   )'g',      (char const   )'u', 
        (char const   )'l',      (char const   )'a',      (char const   )'r',      (char const   )' ', 
        (char const   )'e',      (char const   )'x',      (char const   )'p',      (char const   )'r', 
        (char const   )'e',      (char const   )'s',      (char const   )'s',      (char const   )'i', 
        (char const   )'o',      (char const   )'n',      (char const   )' ',      (char const   )'t', 
        (char const   )'o',      (char const   )'o',      (char const   )' ',      (char const   )'b', 
        (char const   )'i',      (char const   )'g',      (char const   )'\000',      (char const   )'U', 
        (char const   )'n',      (char const   )'m',      (char const   )'a',      (char const   )'t', 
        (char const   )'c',      (char const   )'h',      (char const   )'e',      (char const   )'d', 
        (char const   )' ',      (char const   )')',      (char const   )' ',      (char const   )'o', 
        (char const   )'r',      (char const   )' ',      (char const   )'\\',      (char const   )')', 
        (char const   )'\000'};
#line 185 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static size_t const   __re_error_msgid_idx[17]  = 
#line 185
  {      (size_t const   )0,      (size_t const   )sizeof("Success"),      (size_t const   )(sizeof("Success") + sizeof("No match")),      (size_t const   )((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")), 
        (size_t const   )(((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")),      (size_t const   )((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")),      (size_t const   )(((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")),      (size_t const   )((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")), 
        (size_t const   )(((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")),      (size_t const   )((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")),      (size_t const   )(((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")),      (size_t const   )((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")), 
        (size_t const   )(((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")),      (size_t const   )((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")),      (size_t const   )(((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")),      (size_t const   )((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")), 
        (size_t const   )(((((((((((((((sizeof("Success") + sizeof("No match")) + sizeof("Invalid regular expression")) + sizeof("Invalid collation character")) + sizeof("Invalid character class name")) + sizeof("Trailing backslash")) + sizeof("Invalid back reference")) + sizeof("Unmatched [ or [^")) + sizeof("Unmatched ( or \\(")) + sizeof("Unmatched \\{")) + sizeof("Invalid content of \\{\\}")) + sizeof("Invalid range end")) + sizeof("Memory exhausted")) + sizeof("Invalid preceding regular expression")) + sizeof("Premature end of regular expression")) + sizeof("Regular expression too big"))};
#line 222 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
char const   *rpl_re_compile_pattern(char const   *pattern , size_t length , struct re_pattern_buffer *bufp ) 
{ 
  reg_errcode_t ret ;
  char *tmp ;

  {
#line 232
  bufp->no_sub = (unsigned int )(! (! (rpl_re_syntax_options & (((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))));
#line 235
  bufp->newline_anchor = 1U;
#line 237
  ret = re_compile_internal(bufp, pattern, length, rpl_re_syntax_options);
#line 239
  if (! ret) {
#line 240
    return ((char const   *)((void *)0));
  }
#line 241
  tmp = gettext(__re_error_msgid + __re_error_msgid_idx[(int )ret]);
#line 241
  return ((char const   *)tmp);
}
}
#line 262 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
reg_syntax_t rpl_re_set_syntax(reg_syntax_t syntax ) 
{ 
  reg_syntax_t ret ;

  {
#line 266
  ret = rpl_re_syntax_options;
#line 268
  rpl_re_syntax_options = syntax;
#line 269
  return (ret);
}
}
#line 275 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
int rpl_re_compile_fastmap(struct re_pattern_buffer *bufp ) 
{ 
  re_dfa_t *dfa ;
  char *fastmap ;

  {
#line 279
  dfa = (re_dfa_t *)bufp->buffer;
#line 280
  fastmap = bufp->fastmap;
#line 282
  memset((void *)fastmap, '\000', sizeof(char ) * 256UL);
#line 283
  re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state, fastmap);
#line 284
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_word) {
#line 285
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_word, fastmap);
  }
#line 286
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_nl) {
#line 287
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_nl, fastmap);
  }
#line 288
  if ((unsigned long )dfa->init_state != (unsigned long )dfa->init_state_begbuf) {
#line 289
    re_compile_fastmap_iter(bufp, (re_dfastate_t const   *)dfa->init_state_begbuf,
                            fastmap);
  }
#line 290
  bufp->fastmap_accurate = 1U;
#line 291
  return (0);
}
}
#line 297 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
__inline static void ( __attribute__((__always_inline__)) re_set_fastmap)(char *fastmap ,
                                                                          _Bool icase ,
                                                                          int ch ) 
{ 
  int tmp ;

  {
#line 301
  *(fastmap + ch) = (char)1;
#line 302
  if (icase) {
#line 303
    tmp = tolower(ch);
#line 303
    *(fastmap + tmp) = (char)1;
  }
#line 304
  return;
}
}
#line 309 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void re_compile_fastmap_iter(regex_t *bufp , re_dfastate_t const   *init_state ,
                                    char *fastmap ) 
{ 
  re_dfa_t *dfa ;
  Idx node_cnt ;
  _Bool icase ;
  int tmp ;
  Idx node ;
  re_token_type_t type ;
  unsigned char buf___0[16] ;
  unsigned char *p ;
  wchar_t wc ;
  mbstate_t state ;
  unsigned char *tmp___0 ;
  unsigned char *tmp___1 ;
  size_t tmp___2 ;
  wint_t tmp___3 ;
  size_t tmp___4 ;
  int i ;
  int ch ;
  int j ;
  bitset_word_t w ;
  re_charset_t *cset ;
  Idx i___0 ;
  unsigned char c ;
  mbstate_t mbs ;
  size_t tmp___5 ;
  char buf___1[256] ;
  mbstate_t state___0 ;
  size_t tmp___6 ;
  wint_t tmp___7 ;
  size_t tmp___8 ;

  {
#line 313
  dfa = (re_dfa_t *)bufp->buffer;
#line 315
  if (dfa->mb_cur_max == 1) {
#line 315
    if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 315
      tmp = 1;
    } else {
#line 315
      tmp = 0;
    }
  } else {
#line 315
    tmp = 0;
  }
#line 315
  icase = (_Bool )tmp;
#line 316
  node_cnt = (Idx )0;
#line 316
  while (node_cnt < (Idx )init_state->nodes.nelem) {
#line 318
    node = *(init_state->nodes.elems + node_cnt);
#line 319
    type = (dfa->nodes + node)->type;
#line 321
    if ((unsigned int )type == 1U) {
#line 323
      re_set_fastmap(fastmap, icase, (int )(dfa->nodes + node)->opr.c);
#line 325
      if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 325
        if (dfa->mb_cur_max > 1) {
#line 332
          p = buf___0;
#line 333
          tmp___0 = p;
#line 333
          p ++;
#line 333
          *tmp___0 = (dfa->nodes + node)->opr.c;
#line 334
          while (1) {
#line 334
            node ++;
#line 334
            if (node < dfa->nodes_len) {
#line 334
              if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 334
                if (! (dfa->nodes + node)->mb_partial) {
#line 334
                  break;
                }
              } else {
#line 334
                break;
              }
            } else {
#line 334
              break;
            }
#line 337
            tmp___1 = p;
#line 337
            p ++;
#line 337
            *tmp___1 = (dfa->nodes + node)->opr.c;
          }
#line 338
          memset((void *)(& state), '\000', sizeof(state));
#line 339
          tmp___2 = mbrtowc((wchar_t * __restrict  )(& wc), (char const   * __restrict  )((char const   *)(buf___0)),
                            (size_t )(p - buf___0), (mbstate_t * __restrict  )(& state));
#line 339
          if (tmp___2 == (size_t )(p - buf___0)) {
#line 339
            tmp___3 = towlower((wint_t )wc);
#line 339
            tmp___4 = wcrtomb((char * __restrict  )((char *)(buf___0)), (wchar_t )tmp___3,
                              (mbstate_t * __restrict  )(& state));
#line 339
            if (tmp___4 != 0xffffffffffffffffUL) {
#line 343
              re_set_fastmap(fastmap, (_Bool)0, (int )buf___0[0]);
            }
          }
        }
      }
    } else
#line 347
    if ((unsigned int )type == 3U) {
#line 350
      i = 0;
#line 350
      ch = 0;
#line 350
      while (i < 4) {
#line 353
        w = *((dfa->nodes + node)->opr.sbcset + i);
#line 354
        j = 0;
#line 354
        while (j < 64) {
#line 355
          if (w & (1UL << j)) {
#line 356
            re_set_fastmap(fastmap, icase, ch);
          }
#line 354
          j ++;
#line 354
          ch ++;
        }
#line 350
        i ++;
      }
    } else
#line 360
    if ((unsigned int )type == 6U) {
#line 362
      cset = (dfa->nodes + node)->opr.mbcset;
#line 387
      if (dfa->mb_cur_max > 1) {
#line 387
        if (cset->nchar_classes) {
#line 387
          goto _L___0;
        } else
#line 387
        if (cset->non_match) {
          _L___0: /* CIL Label */ 
#line 394
          c = (unsigned char)0;
#line 395
          while (1) {
#line 398
            memset((void *)(& mbs), 0, sizeof(mbs));
#line 399
            tmp___5 = mbrtowc((wchar_t * __restrict  )((void *)0), (char const   * __restrict  )((char *)(& c)),
                              (size_t )1, (mbstate_t * __restrict  )(& mbs));
#line 399
            if (tmp___5 == 0xfffffffffffffffeUL) {
#line 400
              re_set_fastmap(fastmap, (_Bool)0, (int )c);
            }
#line 395
            c = (unsigned char )((int )c + 1);
#line 395
            if (! ((int )c != 0)) {
#line 395
              break;
            }
          }
        } else {
#line 387
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 408
        i___0 = (Idx )0;
#line 408
        while (i___0 < cset->nmbchars) {
#line 412
          memset((void *)(& state___0), '\000', sizeof(state___0));
#line 413
          tmp___6 = wcrtomb((char * __restrict  )(buf___1), *(cset->mbchars + i___0),
                            (mbstate_t * __restrict  )(& state___0));
#line 413
          if (tmp___6 != 0xffffffffffffffffUL) {
#line 414
            re_set_fastmap(fastmap, icase, (int )*((unsigned char *)(buf___1)));
          }
#line 415
          if (bufp->syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 415
            if (dfa->mb_cur_max > 1) {
#line 417
              tmp___7 = towlower((wint_t )*(cset->mbchars + i___0));
#line 417
              tmp___8 = wcrtomb((char * __restrict  )(buf___1), (wchar_t )tmp___7,
                                (mbstate_t * __restrict  )(& state___0));
#line 417
              if (tmp___8 != 0xffffffffffffffffUL) {
#line 419
                re_set_fastmap(fastmap, (_Bool)0, (int )*((unsigned char *)(buf___1)));
              }
            }
          }
#line 408
          i___0 ++;
        }
      }
    } else
#line 425
    if ((unsigned int )type == 5U) {
#line 425
      goto _L___1;
    } else
#line 425
    if ((unsigned int )type == 7U) {
#line 425
      goto _L___1;
    } else
#line 425
    if ((unsigned int )type == 2U) {
      _L___1: /* CIL Label */ 
#line 431
      memset((void *)fastmap, '\001', sizeof(char ) * 256UL);
#line 432
      if ((unsigned int )type == 2U) {
#line 433
        bufp->can_be_null = 1U;
      }
#line 434
      return;
    }
#line 316
    node_cnt ++;
  }
#line 437
  return;
}
}
#line 475 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
int rpl_regcomp(regex_t * __restrict  preg , char const   * __restrict  pattern ,
                int cflags ) 
{ 
  reg_errcode_t ret ;
  reg_syntax_t syntax ;
  unsigned long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  unsigned long tmp___2 ;
  size_t tmp___3 ;
  long tmp___4 ;

  {
#line 482
  if (cflags & 1) {
#line 482
    tmp = ((((((((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((1UL << 1) << 1) << 1)) | ((((1UL << 1) << 1) << 1) << 1)) | ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((1UL << 1) << 1) << 1) << 1) << 1)) | (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  } else {
#line 482
    tmp = (((((((1UL << 1) << 1) | ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | ((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) | (1UL << 1)) | ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1);
  }
#line 482
  syntax = tmp;
#line 485
  preg->buffer = (unsigned char *)((void *)0);
#line 486
  preg->allocated = (__re_long_size_t )0;
#line 487
  preg->used = (__re_long_size_t )0;
#line 490
  tmp___0 = malloc(256UL * sizeof(char ));
#line 490
  preg->fastmap = (char *)tmp___0;
#line 491
  tmp___1 = __builtin_expect((long )((unsigned long )preg->fastmap == (unsigned long )((void *)0)),
                             0L);
#line 491
  if (tmp___1) {
#line 492
    return (12);
  }
#line 494
  if (cflags & (1 << 1)) {
#line 494
    tmp___2 = (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
  } else {
#line 494
    tmp___2 = 0UL;
  }
#line 494
  syntax |= tmp___2;
#line 497
  if (cflags & (1 << 2)) {
#line 499
    syntax &= ~ ((((((1UL << 1) << 1) << 1) << 1) << 1) << 1);
#line 500
    syntax |= (((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1;
#line 502
    preg->newline_anchor = 1U;
  } else {
#line 505
    preg->newline_anchor = 0U;
  }
#line 506
  preg->no_sub = (unsigned int )(! (! (cflags & (1 << 3))));
#line 507
  preg->translate = (unsigned char *)((void *)0);
#line 509
  tmp___3 = strlen((char const   *)pattern);
#line 509
  ret = re_compile_internal((regex_t *)preg, (char const   *)pattern, tmp___3, syntax);
#line 513
  if ((int )ret == 16) {
#line 514
    ret = (reg_errcode_t )8;
  }
#line 517
  tmp___4 = __builtin_expect((long )((int )ret == 0), 1L);
#line 517
  if (tmp___4) {
#line 520
    rpl_re_compile_fastmap((struct re_pattern_buffer *)preg);
  } else {
#line 524
    free((void *)preg->fastmap);
#line 525
    preg->fastmap = (char *)((void *)0);
  }
#line 528
  return ((int )ret);
}
}
#line 545 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
size_t rpl_regerror(int errcode , regex_t const   * __restrict  preg  __attribute__((__unused__)) ,
                    char * __restrict  errbuf , size_t errbuf_size ) 
{ 
  char const   *msg ;
  size_t msg_size ;
  int tmp ;
  long tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  size_t cpy_size ;
  long tmp___3 ;
  long tmp___4 ;

  {
#line 553
  if (errcode < 0) {
#line 553
    tmp = 1;
  } else
#line 553
  if (errcode >= (int )(sizeof(__re_error_msgid_idx) / sizeof(__re_error_msgid_idx[0]))) {
#line 553
    tmp = 1;
  } else {
#line 553
    tmp = 0;
  }
#line 553
  tmp___0 = __builtin_expect((long )tmp, 0L);
#line 553
  if (tmp___0) {
#line 560
    abort();
  }
#line 562
  tmp___1 = gettext(__re_error_msgid + __re_error_msgid_idx[errcode]);
#line 562
  msg = (char const   *)tmp___1;
#line 564
  tmp___2 = strlen(msg);
#line 564
  msg_size = tmp___2 + 1UL;
#line 566
  tmp___4 = __builtin_expect((long )(errbuf_size != 0UL), 1L);
#line 566
  if (tmp___4) {
#line 568
    cpy_size = msg_size;
#line 569
    tmp___3 = __builtin_expect((long )(msg_size > errbuf_size), 0L);
#line 569
    if (tmp___3) {
#line 571
      cpy_size = errbuf_size - 1UL;
#line 572
      *(errbuf + cpy_size) = (char )'\000';
    }
#line 574
    memcpy((void * __restrict  )errbuf, (void const   * __restrict  )msg, cpy_size);
  }
#line 577
  return (msg_size);
}
}
#line 589 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bitset_word_t utf8_sb_map[4]  = {      0xffffffffffffffffUL,      0xffffffffffffffffUL};
#line 609 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void free_dfa_content(re_dfa_t *dfa ) 
{ 
  Idx i ;
  Idx j ;
  struct re_state_table_entry *entry ;
  re_dfastate_t *state ;

  {
#line 614
  if (dfa->nodes) {
#line 615
    i = (Idx )0;
#line 615
    while (i < dfa->nodes_len) {
#line 616
      free_token(dfa->nodes + i);
#line 615
      i ++;
    }
  }
#line 617
  free((void *)dfa->nexts);
#line 618
  i = (Idx )0;
#line 618
  while (i < dfa->nodes_len) {
#line 620
    if ((unsigned long )dfa->eclosures != (unsigned long )((void *)0)) {
#line 621
      free((void *)(dfa->eclosures + i)->elems);
    }
#line 622
    if ((unsigned long )dfa->inveclosures != (unsigned long )((void *)0)) {
#line 623
      free((void *)(dfa->inveclosures + i)->elems);
    }
#line 624
    if ((unsigned long )dfa->edests != (unsigned long )((void *)0)) {
#line 625
      free((void *)(dfa->edests + i)->elems);
    }
#line 618
    i ++;
  }
#line 627
  free((void *)dfa->edests);
#line 628
  free((void *)dfa->eclosures);
#line 629
  free((void *)dfa->inveclosures);
#line 630
  free((void *)dfa->nodes);
#line 632
  if (dfa->state_table) {
#line 633
    i = (Idx )0;
#line 633
    while (i <= dfa->state_hash_mask) {
#line 635
      entry = dfa->state_table + i;
#line 636
      j = (Idx )0;
#line 636
      while (j < entry->num) {
#line 638
        state = *(entry->array + j);
#line 639
        free_state(state);
#line 636
        j ++;
      }
#line 641
      free((void *)entry->array);
#line 633
      i ++;
    }
  }
#line 643
  free((void *)dfa->state_table);
#line 645
  if ((unsigned long )dfa->sb_char != (unsigned long )(utf8_sb_map)) {
#line 646
    free((void *)dfa->sb_char);
  }
#line 648
  free((void *)dfa->subexp_map);
#line 653
  free((void *)dfa);
#line 654
  return;
}
}
#line 659 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
void rpl_regfree(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
#line 663
  dfa = (re_dfa_t *)preg->buffer;
#line 664
  tmp = __builtin_expect((long )((unsigned long )dfa != (unsigned long )((void *)0)),
                         1L);
#line 664
  if (tmp) {
#line 665
    free_dfa_content(dfa);
  }
#line 666
  preg->buffer = (unsigned char *)((void *)0);
#line 667
  preg->allocated = (__re_long_size_t )0;
#line 669
  free((void *)preg->fastmap);
#line 670
  preg->fastmap = (char *)((void *)0);
#line 672
  free((void *)preg->translate);
#line 673
  preg->translate = (unsigned char *)((void *)0);
#line 674
  return;
}
}
#line 752 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t re_compile_internal(regex_t *preg , char const   *pattern , size_t length ,
                                         reg_syntax_t syntax ) 
{ 
  reg_errcode_t err ;
  re_dfa_t *dfa ;
  re_string_t regexp ;
  unsigned int tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 756
  err = (reg_errcode_t )0;
#line 761
  preg->fastmap_accurate = 0U;
#line 762
  preg->syntax = syntax;
#line 763
  tmp = 0U;
#line 763
  preg->not_eol = tmp;
#line 763
  preg->not_bol = tmp;
#line 764
  preg->used = (__re_long_size_t )0;
#line 765
  preg->re_nsub = (size_t )0;
#line 766
  preg->can_be_null = 0U;
#line 767
  preg->regs_allocated = 0U;
#line 770
  dfa = (re_dfa_t *)preg->buffer;
#line 771
  tmp___1 = __builtin_expect((long )(preg->allocated < sizeof(re_dfa_t )), 0L);
#line 771
  if (tmp___1) {
#line 777
    tmp___0 = realloc((void *)preg->buffer, sizeof(re_dfa_t ));
#line 777
    dfa = (re_dfa_t *)tmp___0;
#line 778
    if ((unsigned long )dfa == (unsigned long )((void *)0)) {
#line 779
      return ((reg_errcode_t )12);
    }
#line 780
    preg->allocated = sizeof(re_dfa_t );
#line 781
    preg->buffer = (unsigned char *)dfa;
  }
#line 783
  preg->used = sizeof(re_dfa_t );
#line 785
  err = init_dfa(dfa, length);
#line 786
  tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
#line 786
  if (tmp___2) {
#line 788
    free_dfa_content(dfa);
#line 789
    preg->buffer = (unsigned char *)((void *)0);
#line 790
    preg->allocated = (__re_long_size_t )0;
#line 791
    return (err);
  }
#line 799
  while (1) {
#line 799
    break;
  }
#line 801
  err = re_string_construct(& regexp, pattern, length, preg->translate, (_Bool )((syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                            (re_dfa_t const   *)dfa);
#line 803
  tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
#line 803
  if (tmp___3) {
    re_compile_internal_free_return: 
#line 806
    free_workarea_compile(preg);
#line 807
    re_string_destruct(& regexp);
#line 808
    free_dfa_content(dfa);
#line 809
    preg->buffer = (unsigned char *)((void *)0);
#line 810
    preg->allocated = (__re_long_size_t )0;
#line 811
    return (err);
  }
#line 815
  preg->re_nsub = (size_t )0;
#line 816
  dfa->str_tree = parse(& regexp, preg, syntax, & err);
#line 817
  tmp___4 = __builtin_expect((long )((unsigned long )dfa->str_tree == (unsigned long )((void *)0)),
                             0L);
#line 817
  if (tmp___4) {
#line 818
    goto re_compile_internal_free_return;
  }
#line 821
  err = analyze(preg);
#line 822
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
#line 822
  if (tmp___5) {
#line 823
    goto re_compile_internal_free_return;
  }
#line 827
  if (dfa->is_utf8) {
#line 827
    if (! (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 827
      if ((unsigned long )preg->translate == (unsigned long )((void *)0)) {
#line 828
        optimize_utf8(dfa);
      }
    }
  }
#line 832
  err = create_initial_state(dfa);
#line 835
  free_workarea_compile(preg);
#line 836
  re_string_destruct(& regexp);
#line 838
  tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
#line 838
  if (tmp___6) {
#line 840
    free_dfa_content(dfa);
#line 841
    preg->buffer = (unsigned char *)((void *)0);
#line 842
    preg->allocated = (__re_long_size_t )0;
  }
#line 845
  return (err);
}
}
#line 851 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t init_dfa(re_dfa_t *dfa , size_t pat_len ) 
{ 
  __re_size_t table_size ;
  size_t max_i18n_object_size ;
  unsigned long tmp ;
  size_t max_object_size ;
  size_t tmp___18 ;
  size_t tmp___19 ;
  size_t tmp___20 ;
  size_t tmp___21 ;
  size_t tmp___23 ;
  size_t tmp___24 ;
  size_t tmp___25 ;
  size_t tmp___26 ;
  size_t tmp___32 ;
  size_t tmp___33 ;
  size_t tmp___34 ;
  size_t tmp___35 ;
  size_t tmp___37 ;
  size_t tmp___38 ;
  size_t tmp___39 ;
  long tmp___40 ;
  void *tmp___41 ;
  void *tmp___42 ;
  size_t tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  int i ;
  int j ;
  int ch ;
  void *tmp___46 ;
  long tmp___47 ;
  wint_t wch ;
  wint_t tmp___48 ;
  int tmp___49 ;
  long tmp___50 ;

  {
#line 856
  if (sizeof(wchar_t ) < sizeof(wctype_t )) {
#line 856
    tmp = sizeof(wctype_t );
  } else {
#line 856
    tmp = sizeof(wchar_t );
  }
#line 856
  max_i18n_object_size = tmp;
#line 860
  if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
    tmp___39 = max_i18n_object_size;
  } else {
#line 860
    tmp___39 = sizeof(regmatch_t );
  }
#line 860
  if (sizeof(re_node_set ) < tmp___39) {
#line 860
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
      tmp___37 = max_i18n_object_size;
    } else {
#line 860
      tmp___37 = sizeof(regmatch_t );
    }
#line 860
    tmp___38 = tmp___37;
  } else {
#line 860
    tmp___38 = sizeof(re_node_set );
  }
#line 860
  if (sizeof(re_token_t ) < tmp___38) {
#line 860
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
      tmp___34 = max_i18n_object_size;
    } else {
#line 860
      tmp___34 = sizeof(regmatch_t );
    }
#line 860
    if (sizeof(re_node_set ) < tmp___34) {
#line 860
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
        tmp___32 = max_i18n_object_size;
      } else {
#line 860
        tmp___32 = sizeof(regmatch_t );
      }
#line 860
      tmp___33 = tmp___32;
    } else {
#line 860
      tmp___33 = sizeof(re_node_set );
    }
#line 860
    tmp___35 = tmp___33;
  } else {
#line 860
    tmp___35 = sizeof(re_token_t );
  }
#line 860
  if (sizeof(struct re_state_table_entry ) < tmp___35) {
#line 860
    if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
      tmp___25 = max_i18n_object_size;
    } else {
#line 860
      tmp___25 = sizeof(regmatch_t );
    }
#line 860
    if (sizeof(re_node_set ) < tmp___25) {
#line 860
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
        tmp___23 = max_i18n_object_size;
      } else {
#line 860
        tmp___23 = sizeof(regmatch_t );
      }
#line 860
      tmp___24 = tmp___23;
    } else {
#line 860
      tmp___24 = sizeof(re_node_set );
    }
#line 860
    if (sizeof(re_token_t ) < tmp___24) {
#line 860
      if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
        tmp___20 = max_i18n_object_size;
      } else {
#line 860
        tmp___20 = sizeof(regmatch_t );
      }
#line 860
      if (sizeof(re_node_set ) < tmp___20) {
#line 860
        if (sizeof(regmatch_t ) < max_i18n_object_size) {
#line 860
          tmp___18 = max_i18n_object_size;
        } else {
#line 860
          tmp___18 = sizeof(regmatch_t );
        }
#line 860
        tmp___19 = tmp___18;
      } else {
#line 860
        tmp___19 = sizeof(re_node_set );
      }
#line 860
      tmp___21 = tmp___19;
    } else {
#line 860
      tmp___21 = sizeof(re_token_t );
    }
#line 860
    tmp___26 = tmp___21;
  } else {
#line 860
    tmp___26 = sizeof(struct re_state_table_entry );
  }
#line 860
  max_object_size = tmp___26;
#line 867
  memset((void *)dfa, '\000', sizeof(re_dfa_t ));
#line 870
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 876
  tmp___40 = __builtin_expect((long )((0xffffffffffffffffUL / max_object_size) / 2UL <= pat_len),
                              0L);
#line 876
  if (tmp___40) {
#line 877
    return ((reg_errcode_t )12);
  }
#line 879
  dfa->nodes_alloc = pat_len + 1UL;
#line 880
  tmp___41 = malloc(dfa->nodes_alloc * sizeof(re_token_t ));
#line 880
  dfa->nodes = (re_token_t *)tmp___41;
#line 883
  table_size = (__re_size_t )1;
#line 883
  while (! (table_size > pat_len)) {
#line 883
    table_size <<= 1;
  }
#line 887
  tmp___42 = calloc(sizeof(struct re_state_table_entry ), table_size);
#line 887
  dfa->state_table = (struct re_state_table_entry *)tmp___42;
#line 888
  dfa->state_hash_mask = table_size - 1UL;
#line 890
  tmp___43 = __ctype_get_mb_cur_max();
#line 890
  dfa->mb_cur_max = (int )tmp___43;
#line 898
  tmp___44 = locale_charset();
#line 898
  tmp___45 = strcmp(tmp___44, "UTF-8");
#line 898
  if (tmp___45 == 0) {
#line 899
    dfa->is_utf8 = 1U;
  }
#line 903
  dfa->map_notascii = 0U;
#line 907
  if (dfa->mb_cur_max > 1) {
#line 909
    if (dfa->is_utf8) {
#line 910
      dfa->sb_char = (re_bitset_ptr_t )(utf8_sb_map);
    } else {
#line 915
      tmp___46 = calloc(sizeof(bitset_t ), (size_t )1);
#line 915
      dfa->sb_char = (re_bitset_ptr_t )tmp___46;
#line 916
      tmp___47 = __builtin_expect((long )((unsigned long )dfa->sb_char == (unsigned long )((void *)0)),
                                  0L);
#line 916
      if (tmp___47) {
#line 917
        return ((reg_errcode_t )12);
      }
#line 920
      i = 0;
#line 920
      ch = 0;
#line 920
      while (i < 4) {
#line 921
        j = 0;
#line 921
        while (j < 64) {
#line 923
          tmp___48 = btowc(ch);
#line 923
          wch = tmp___48;
#line 924
          if (wch != 4294967295U) {
#line 925
            *(dfa->sb_char + i) |= 1UL << j;
          }
#line 927
          if ((ch & -128) == 0) {
#line 927
            if (wch != (wint_t )ch) {
#line 928
              dfa->map_notascii = 1U;
            }
          }
#line 921
          j ++;
#line 921
          ch ++;
        }
#line 920
        i ++;
      }
    }
  }
#line 935
  if ((unsigned long )dfa->nodes == (unsigned long )((void *)0)) {
#line 935
    tmp___49 = 1;
  } else
#line 935
  if ((unsigned long )dfa->state_table == (unsigned long )((void *)0)) {
#line 935
    tmp___49 = 1;
  } else {
#line 935
    tmp___49 = 0;
  }
#line 935
  tmp___50 = __builtin_expect((long )tmp___49, 0L);
#line 935
  if (tmp___50) {
#line 936
    return ((reg_errcode_t )12);
  }
#line 937
  return ((reg_errcode_t )0);
}
}
#line 944 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void init_word_char(re_dfa_t *dfa ) 
{ 
  int i ;
  int j ;
  int ch ;
  unsigned short const   **tmp ;

  {
#line 949
  dfa->word_ops_used = 1U;
#line 950
  i = 0;
#line 950
  ch = 0;
#line 950
  while (i < 4) {
#line 951
    j = 0;
#line 951
    while (j < 64) {
#line 952
      tmp = __ctype_b_loc();
#line 952
      if ((int const   )*(*tmp + ch) & 8) {
#line 953
        dfa->word_char[i] |= 1UL << j;
      } else
#line 952
      if (ch == 95) {
#line 953
        dfa->word_char[i] |= 1UL << j;
      }
#line 951
      j ++;
#line 951
      ch ++;
    }
#line 950
    i ++;
  }
#line 954
  return;
}
}
#line 958 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void free_workarea_compile(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_storage_t *storage ;
  bin_tree_storage_t *next ;

  {
#line 961
  dfa = (re_dfa_t *)preg->buffer;
#line 963
  storage = dfa->str_tree_storage;
#line 963
  while (storage) {
#line 965
    next = storage->next;
#line 966
    free((void *)storage);
#line 963
    storage = next;
  }
#line 968
  dfa->str_tree_storage = (bin_tree_storage_t *)((void *)0);
#line 969
  dfa->str_tree_storage_idx = (int )((1024UL - sizeof(void *)) / sizeof(bin_tree_t ));
#line 970
  dfa->str_tree = (bin_tree_t *)((void *)0);
#line 971
  free((void *)dfa->org_indices);
#line 972
  dfa->org_indices = (Idx *)((void *)0);
#line 973
  return;
}
}
#line 977 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t create_initial_state(re_dfa_t *dfa ) 
{ 
  Idx first ;
  Idx i ;
  reg_errcode_t err ;
  re_node_set init_nodes ;
  long tmp ;
  Idx node_idx ;
  re_token_type_t type ;
  Idx clexp_idx ;
  re_token_t *clexp_node ;
  Idx dest_idx ;
  Idx __attribute__((__pure__))  tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  re_dfastate_t *tmp___4 ;
  re_dfastate_t *tmp___5 ;

  {
#line 986
  first = ((dfa->str_tree)->first)->node_idx;
#line 987
  dfa->init_node = first;
#line 988
  err = re_node_set_init_copy(& init_nodes, (re_node_set const   *)(dfa->eclosures + first));
#line 989
  tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 989
  if (tmp) {
#line 990
    return (err);
  }
#line 996
  if (dfa->nbackref > 0UL) {
#line 997
    i = (Idx )0;
#line 997
    while (i < init_nodes.nelem) {
#line 999
      node_idx = *(init_nodes.elems + i);
#line 1000
      type = (dfa->nodes + node_idx)->type;
#line 1003
      if ((unsigned int )type != 4U) {
#line 1004
        goto __Cont;
      }
#line 1005
      clexp_idx = (Idx )0;
#line 1005
      while (clexp_idx < init_nodes.nelem) {
#line 1008
        clexp_node = dfa->nodes + *(init_nodes.elems + clexp_idx);
#line 1009
        if ((unsigned int )clexp_node->type == 9U) {
#line 1009
          if (clexp_node->opr.idx == (dfa->nodes + node_idx)->opr.idx) {
#line 1011
            break;
          }
        }
#line 1005
        clexp_idx ++;
      }
#line 1013
      if (clexp_idx == init_nodes.nelem) {
#line 1014
        goto __Cont;
      }
#line 1016
      if ((unsigned int )type == 4U) {
#line 1018
        dest_idx = *((dfa->edests + node_idx)->elems + 0);
#line 1019
        tmp___0 = re_node_set_contains((re_node_set const   *)(& init_nodes), dest_idx);
#line 1019
        if (! tmp___0) {
#line 1021
          re_node_set_merge(& init_nodes, (re_node_set const   *)(dfa->eclosures + dest_idx));
#line 1022
          i = (Idx )0;
        }
      }
      __Cont: /* CIL Label */ 
#line 997
      i ++;
    }
  }
#line 1028
  dfa->init_state = re_acquire_state_context(& err, (re_dfa_t const   *)dfa, (re_node_set const   *)(& init_nodes),
                                             0U);
#line 1030
  tmp___1 = __builtin_expect((long )((unsigned long )dfa->init_state == (unsigned long )((void *)0)),
                             0L);
#line 1030
  if (tmp___1) {
#line 1031
    return (err);
  }
#line 1032
  if ((dfa->init_state)->has_constraint) {
#line 1034
    dfa->init_state_word = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                    (re_node_set const   *)(& init_nodes),
                                                    1U);
#line 1036
    dfa->init_state_nl = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                  (re_node_set const   *)(& init_nodes),
                                                  (unsigned int )(1 << 1));
#line 1038
    dfa->init_state_begbuf = re_acquire_state_context(& err, (re_dfa_t const   *)dfa,
                                                      (re_node_set const   *)(& init_nodes),
                                                      (unsigned int )((1 << 1) | ((1 << 1) << 1)));
#line 1042
    if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 1042
      tmp___2 = 1;
    } else
#line 1042
    if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 1042
      tmp___2 = 1;
    } else
#line 1042
    if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 1042
      tmp___2 = 1;
    } else {
#line 1042
      tmp___2 = 0;
    }
#line 1042
    tmp___3 = __builtin_expect((long )tmp___2, 0L);
#line 1042
    if (tmp___3) {
#line 1044
      return (err);
    }
  } else {
#line 1047
    tmp___5 = dfa->init_state;
#line 1047
    dfa->init_state_begbuf = tmp___5;
#line 1047
    tmp___4 = tmp___5;
#line 1047
    dfa->init_state_nl = tmp___4;
#line 1047
    dfa->init_state_word = tmp___4;
  }
#line 1050
  free((void *)init_nodes.elems);
#line 1051
  return ((reg_errcode_t )0);
}
}
#line 1059 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void optimize_utf8(re_dfa_t *dfa ) 
{ 
  Idx node ;
  int i ;
  _Bool mb_chars ;
  _Bool has_period ;
  int rshift ;
  int tmp ;

  {
#line 1064
  mb_chars = (_Bool)0;
#line 1065
  has_period = (_Bool)0;
#line 1067
  node = (Idx )0;
#line 1067
  while (node < dfa->nodes_len) {
#line 1068
    switch ((unsigned int )(dfa->nodes + node)->type) {
    case 1U: 
#line 1071
    if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1072
      mb_chars = (_Bool)1;
    }
#line 1073
    break;
    case 12U: 
#line 1075
    switch ((unsigned int )(dfa->nodes + node)->opr.ctx_type) {
    case 128U: 
    case 64U: 
    case 32U: 
    case 16U: 
#line 1081
    break;
    default: 
#line 1086
    return;
    }
#line 1088
    break;
    case 5U: 
#line 1090
    has_period = (_Bool)1;
#line 1091
    break;
    case 9U: 
    case 8U: 
    case 11U: 
    case 2U: 
    case 10U: 
    case 4U: 
#line 1098
    break;
    case 6U: 
#line 1100
    return;
    case 3U: 
#line 1104
    rshift = 0;
#line 1107
    i = 2;
#line 1107
    while (i < 4) {
#line 1109
      if (*((dfa->nodes + node)->opr.sbcset + i) >> rshift != 0UL) {
#line 1110
        return;
      }
#line 1111
      rshift = 0;
#line 1107
      i ++;
    }
#line 1114
    break;
    default: 
#line 1116
    abort();
    }
#line 1067
    node ++;
  }
#line 1119
  if (mb_chars) {
#line 1119
    goto _L___0;
  } else
#line 1119
  if (has_period) {
    _L___0: /* CIL Label */ 
#line 1120
    node = (Idx )0;
#line 1120
    while (node < dfa->nodes_len) {
#line 1122
      if ((unsigned int )(dfa->nodes + node)->type == 1U) {
#line 1122
        if ((int )(dfa->nodes + node)->opr.c >= 128) {
#line 1124
          (dfa->nodes + node)->mb_partial = 0U;
        } else {
#line 1122
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1125
      if ((unsigned int )(dfa->nodes + node)->type == 5U) {
#line 1126
        (dfa->nodes + node)->type = (re_token_type_t )7;
      }
#line 1120
      node ++;
    }
  }
#line 1130
  dfa->mb_cur_max = 1;
#line 1131
  dfa->is_utf8 = 0U;
#line 1132
  if (dfa->nbackref > 0UL) {
#line 1132
    tmp = 1;
  } else
#line 1132
  if (has_period) {
#line 1132
    tmp = 1;
  } else {
#line 1132
    tmp = 0;
  }
#line 1132
  dfa->has_mb_node = (unsigned int )tmp;
#line 1133
  return;
}
}
#line 1139 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t analyze(regex_t *preg ) 
{ 
  re_dfa_t *dfa ;
  reg_errcode_t ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  void *tmp___5 ;
  Idx i ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;

  {
#line 1142
  dfa = (re_dfa_t *)preg->buffer;
#line 1146
  tmp = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1146
  dfa->nexts = (Idx *)tmp;
#line 1147
  tmp___0 = malloc(dfa->nodes_alloc * sizeof(Idx ));
#line 1147
  dfa->org_indices = (Idx *)tmp___0;
#line 1148
  tmp___1 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1148
  dfa->edests = (re_node_set *)tmp___1;
#line 1149
  tmp___2 = malloc(dfa->nodes_alloc * sizeof(re_node_set ));
#line 1149
  dfa->eclosures = (re_node_set *)tmp___2;
#line 1150
  if ((unsigned long )dfa->nexts == (unsigned long )((void *)0)) {
#line 1150
    tmp___3 = 1;
  } else
#line 1150
  if ((unsigned long )dfa->org_indices == (unsigned long )((void *)0)) {
#line 1150
    tmp___3 = 1;
  } else
#line 1150
  if ((unsigned long )dfa->edests == (unsigned long )((void *)0)) {
#line 1150
    tmp___3 = 1;
  } else
#line 1150
  if ((unsigned long )dfa->eclosures == (unsigned long )((void *)0)) {
#line 1150
    tmp___3 = 1;
  } else {
#line 1150
    tmp___3 = 0;
  }
#line 1150
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
#line 1150
  if (tmp___4) {
#line 1152
    return ((reg_errcode_t )12);
  }
#line 1154
  tmp___5 = malloc(preg->re_nsub * sizeof(Idx ));
#line 1154
  dfa->subexp_map = (Idx *)tmp___5;
#line 1155
  if ((unsigned long )dfa->subexp_map != (unsigned long )((void *)0)) {
#line 1158
    i = (Idx )0;
#line 1158
    while (i < preg->re_nsub) {
#line 1159
      *(dfa->subexp_map + i) = i;
#line 1158
      i ++;
    }
#line 1160
    preorder(dfa->str_tree, & optimize_subexps, (void *)dfa);
#line 1161
    i = (Idx )0;
#line 1161
    while (i < preg->re_nsub) {
#line 1162
      if (*(dfa->subexp_map + i) != i) {
#line 1163
        break;
      }
#line 1161
      i ++;
    }
#line 1164
    if (i == preg->re_nsub) {
#line 1166
      free((void *)dfa->subexp_map);
#line 1167
      dfa->subexp_map = (Idx *)((void *)0);
    }
  }
#line 1171
  ret = postorder(dfa->str_tree, & lower_subexps, (void *)preg);
#line 1172
  tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
#line 1172
  if (tmp___6) {
#line 1173
    return (ret);
  }
#line 1174
  ret = postorder(dfa->str_tree, & calc_first, (void *)dfa);
#line 1175
  tmp___7 = __builtin_expect((long )((int )ret != 0), 0L);
#line 1175
  if (tmp___7) {
#line 1176
    return (ret);
  }
#line 1177
  preorder(dfa->str_tree, & calc_next, (void *)dfa);
#line 1178
  ret = preorder(dfa->str_tree, & link_nfa_nodes, (void *)dfa);
#line 1179
  tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
#line 1179
  if (tmp___8) {
#line 1180
    return (ret);
  }
#line 1181
  ret = calc_eclosure(dfa);
#line 1182
  tmp___9 = __builtin_expect((long )((int )ret != 0), 0L);
#line 1182
  if (tmp___9) {
#line 1183
    return (ret);
  }
#line 1187
  if (! preg->no_sub) {
#line 1187
    if (preg->re_nsub > 0UL) {
#line 1187
      if (dfa->has_plural_match) {
#line 1187
        goto _L;
      } else {
#line 1187
        goto _L___1;
      }
    } else {
#line 1187
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1187
  if (dfa->nbackref) {
    _L: /* CIL Label */ 
#line 1190
    tmp___10 = malloc(dfa->nodes_len * sizeof(re_node_set ));
#line 1190
    dfa->inveclosures = (re_node_set *)tmp___10;
#line 1191
    tmp___11 = __builtin_expect((long )((unsigned long )dfa->inveclosures == (unsigned long )((void *)0)),
                                0L);
#line 1191
    if (tmp___11) {
#line 1192
      return ((reg_errcode_t )12);
    }
#line 1193
    ret = calc_inveclosure(dfa);
  }
#line 1196
  return (ret);
}
}
#line 1202 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t postorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                               void *extra ) 
{ 
  bin_tree_t *node ;
  bin_tree_t *prev ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;

  {
#line 1208
  node = root;
#line 1208
  while (1) {
#line 1212
    while (1) {
#line 1212
      if (! node->left) {
#line 1212
        if (! node->right) {
#line 1212
          break;
        }
      }
#line 1213
      if (node->left) {
#line 1214
        node = node->left;
      } else {
#line 1216
        node = node->right;
      }
    }
#line 1218
    while (1) {
#line 1220
      tmp = (*fn)(extra, node);
#line 1220
      err = tmp;
#line 1221
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1221
      if (tmp___0) {
#line 1222
        return (err);
      }
#line 1223
      if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 1224
        return ((reg_errcode_t )0);
      }
#line 1225
      prev = node;
#line 1226
      node = node->parent;
#line 1218
      if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1218
        if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1218
          break;
        }
      }
    }
#line 1230
    node = node->right;
  }
}
}
#line 1234 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t preorder(bin_tree_t *root , reg_errcode_t (*fn)(void * , bin_tree_t * ) ,
                              void *extra ) 
{ 
  bin_tree_t *node ;
  reg_errcode_t err ;
  reg_errcode_t tmp ;
  long tmp___0 ;
  bin_tree_t *prev ;

  {
#line 1240
  node = root;
#line 1240
  while (1) {
#line 1242
    tmp = (*fn)(extra, node);
#line 1242
    err = tmp;
#line 1243
    tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1243
    if (tmp___0) {
#line 1244
      return (err);
    }
#line 1247
    if (node->left) {
#line 1248
      node = node->left;
    } else {
#line 1251
      prev = (bin_tree_t *)((void *)0);
#line 1252
      while (1) {
#line 1252
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 1252
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 1252
            break;
          }
        }
#line 1254
        prev = node;
#line 1255
        node = node->parent;
#line 1256
        if (! node) {
#line 1257
          return ((reg_errcode_t )0);
        }
      }
#line 1259
      node = node->right;
    }
  }
}
}
#line 1267 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t optimize_subexps(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  int idx ;
  Idx other_idx ;

  {
#line 1270
  dfa = (re_dfa_t *)extra;
#line 1272
  if ((unsigned int )node->token.type == 4U) {
#line 1272
    if (dfa->subexp_map) {
#line 1274
      idx = (int )node->token.opr.idx;
#line 1275
      node->token.opr.idx = *(dfa->subexp_map + idx);
#line 1276
      dfa->used_bkref_map |= (unsigned long )(1 << node->token.opr.idx);
    } else {
#line 1272
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1279
  if ((unsigned int )node->token.type == 17U) {
#line 1279
    if (node->left) {
#line 1279
      if ((unsigned int )(node->left)->token.type == 17U) {
#line 1282
        other_idx = (node->left)->token.opr.idx;
#line 1284
        node->left = (node->left)->left;
#line 1285
        if (node->left) {
#line 1286
          (node->left)->parent = node;
        }
#line 1288
        *(dfa->subexp_map + other_idx) = *(dfa->subexp_map + node->token.opr.idx);
#line 1289
        if (other_idx < 64UL) {
#line 1290
          dfa->used_bkref_map &= ~ (1UL << other_idx);
        }
      }
    }
  }
#line 1293
  return ((reg_errcode_t )0);
}
}
#line 1298 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t lower_subexps(void *extra , bin_tree_t *node ) 
{ 
  regex_t *preg ;
  reg_errcode_t err ;

  {
#line 1301
  preg = (regex_t *)extra;
#line 1302
  err = (reg_errcode_t )0;
#line 1304
  if (node->left) {
#line 1304
    if ((unsigned int )(node->left)->token.type == 17U) {
#line 1306
      node->left = lower_subexp(& err, preg, node->left);
#line 1307
      if (node->left) {
#line 1308
        (node->left)->parent = node;
      }
    }
  }
#line 1310
  if (node->right) {
#line 1310
    if ((unsigned int )(node->right)->token.type == 17U) {
#line 1312
      node->right = lower_subexp(& err, preg, node->right);
#line 1313
      if (node->right) {
#line 1314
        (node->right)->parent = node;
      }
    }
  }
#line 1317
  return (err);
}
}
#line 1320 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *lower_subexp(reg_errcode_t *err , regex_t *preg , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *body ;
  bin_tree_t *op ;
  bin_tree_t *cls ;
  bin_tree_t *tree1 ;
  bin_tree_t *tree ;
  bin_tree_t *tmp ;
  int tmp___0 ;
  long tmp___1 ;
  Idx tmp___2 ;
  unsigned int tmp___3 ;

  {
#line 1323
  dfa = (re_dfa_t *)preg->buffer;
#line 1324
  body = node->left;
#line 1327
  if (preg->no_sub) {
#line 1327
    if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1327
      if (node->token.opr.idx >= 64UL) {
#line 1336
        return (node->left);
      } else
#line 1327
      if (! (dfa->used_bkref_map & (1UL << node->token.opr.idx))) {
#line 1336
        return (node->left);
      }
    }
  }
#line 1340
  op = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )8);
#line 1341
  cls = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )9);
#line 1342
  if (body) {
#line 1342
    tmp = create_tree(dfa, body, cls, (re_token_type_t )16);
#line 1342
    tree1 = tmp;
  } else {
#line 1342
    tree1 = cls;
  }
#line 1343
  tree = create_tree(dfa, op, tree1, (re_token_type_t )16);
#line 1344
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 1344
    tmp___0 = 1;
  } else
#line 1344
  if ((unsigned long )tree1 == (unsigned long )((void *)0)) {
#line 1344
    tmp___0 = 1;
  } else
#line 1344
  if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 1344
    tmp___0 = 1;
  } else
#line 1344
  if ((unsigned long )cls == (unsigned long )((void *)0)) {
#line 1344
    tmp___0 = 1;
  } else {
#line 1344
    tmp___0 = 0;
  }
#line 1344
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
#line 1344
  if (tmp___1) {
#line 1346
    *err = (reg_errcode_t )12;
#line 1347
    return ((bin_tree_t *)((void *)0));
  }
#line 1350
  tmp___2 = node->token.opr.idx;
#line 1350
  cls->token.opr.idx = tmp___2;
#line 1350
  op->token.opr.idx = tmp___2;
#line 1351
  tmp___3 = node->token.opt_subexp;
#line 1351
  cls->token.opt_subexp = tmp___3;
#line 1351
  op->token.opt_subexp = tmp___3;
#line 1352
  return (tree);
}
}
#line 1357 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t calc_first(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  long tmp ;

  {
#line 1360
  dfa = (re_dfa_t *)extra;
#line 1361
  if ((unsigned int )node->token.type == 16U) {
#line 1363
    node->first = (node->left)->first;
#line 1364
    node->node_idx = (node->left)->node_idx;
  } else {
#line 1368
    node->first = node;
#line 1369
    node->node_idx = re_dfa_add_node(dfa, node->token);
#line 1370
    tmp = __builtin_expect((long )(node->node_idx == 0xffffffffffffffffUL), 0L);
#line 1370
    if (tmp) {
#line 1371
      return ((reg_errcode_t )12);
    }
#line 1372
    if ((unsigned int )node->token.type == 12U) {
#line 1373
      (dfa->nodes + node->node_idx)->constraint = (unsigned int )node->token.opr.ctx_type;
    }
  }
#line 1375
  return ((reg_errcode_t )0);
}
}
#line 1379 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t calc_next(void *extra  __attribute__((__unused__)) , bin_tree_t *node ) 
{ 


  {
#line 1382
  switch ((unsigned int )node->token.type) {
  case 11U: 
#line 1385
  (node->left)->next = node;
#line 1386
  break;
  case 16U: 
#line 1388
  (node->left)->next = (node->right)->first;
#line 1389
  (node->right)->next = node->next;
#line 1390
  break;
  default: 
#line 1392
  if (node->left) {
#line 1393
    (node->left)->next = node->next;
  }
#line 1394
  if (node->right) {
#line 1395
    (node->right)->next = node->next;
  }
#line 1396
  break;
  }
#line 1398
  return ((reg_errcode_t )0);
}
}
#line 1402 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t link_nfa_nodes(void *extra , bin_tree_t *node ) 
{ 
  re_dfa_t *dfa ;
  Idx idx ;
  reg_errcode_t err ;
  Idx left ;
  Idx right ;

  {
#line 1405
  dfa = (re_dfa_t *)extra;
#line 1406
  idx = node->node_idx;
#line 1407
  err = (reg_errcode_t )0;
#line 1409
  switch ((unsigned int )node->token.type) {
  case 16U: 
#line 1412
  break;
  case 2U: 
#line 1415
  if (! ((unsigned long )node->next == (unsigned long )((void *)0))) {
#line 1415
    __assert_fail("node->next == NULL", "/home/wslee/project/coreutils-8.1/lib/regcomp.c",
                  1415U, "link_nfa_nodes");
  }
#line 1416
  break;
  case 10U: 
  case 11U: 
#line 1422
  dfa->has_plural_match = 1U;
#line 1423
  if ((unsigned long )node->left != (unsigned long )((void *)0)) {
#line 1424
    left = ((node->left)->first)->node_idx;
  } else {
#line 1426
    left = (node->next)->node_idx;
  }
#line 1427
  if ((unsigned long )node->right != (unsigned long )((void *)0)) {
#line 1428
    right = ((node->right)->first)->node_idx;
  } else {
#line 1430
    right = (node->next)->node_idx;
  }
#line 1431
  if (! (left < 0xfffffffffffffffeUL)) {
#line 1431
    __assert_fail("REG_VALID_INDEX (left)", "/home/wslee/project/coreutils-8.1/lib/regcomp.c",
                  1431U, "link_nfa_nodes");
  }
#line 1432
  if (! (right < 0xfffffffffffffffeUL)) {
#line 1432
    __assert_fail("REG_VALID_INDEX (right)", "/home/wslee/project/coreutils-8.1/lib/regcomp.c",
                  1432U, "link_nfa_nodes");
  }
#line 1433
  err = re_node_set_init_2(dfa->edests + idx, left, right);
#line 1435
  break;
  case 9U: 
  case 8U: 
  case 12U: 
#line 1440
  err = re_node_set_init_1(dfa->edests + idx, (node->next)->node_idx);
#line 1441
  break;
  case 4U: 
#line 1444
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1445
  if ((unsigned int )node->token.type == 4U) {
#line 1446
    re_node_set_init_1(dfa->edests + idx, *(dfa->nexts + idx));
  }
#line 1447
  break;
  default: 
#line 1450
  if (! (! ((unsigned int )node->token.type & 8U))) {
#line 1450
    __assert_fail("!IS_EPSILON_NODE (node->token.type)", "/home/wslee/project/coreutils-8.1/lib/regcomp.c",
                  1450U, "link_nfa_nodes");
  }
#line 1451
  *(dfa->nexts + idx) = (node->next)->node_idx;
#line 1452
  break;
  }
#line 1455
  return (err);
}
}
#line 1462 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t duplicate_node_closure(re_dfa_t *dfa , Idx top_org_node , Idx top_clone_node ,
                                            Idx root_node , unsigned int init_constraint ) 
{ 
  Idx org_node ;
  Idx clone_node ;
  _Bool ok ;
  unsigned int constraint ;
  Idx org_dest ;
  Idx clone_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  reg_errcode_t err ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
#line 1469
  constraint = init_constraint;
#line 1470
  org_node = top_org_node;
#line 1470
  clone_node = top_clone_node;
#line 1470
  while (1) {
#line 1473
    if ((unsigned int )(dfa->nodes + org_node)->type == 4U) {
#line 1479
      org_dest = *(dfa->nexts + org_node);
#line 1480
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1481
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1482
      tmp = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
#line 1482
      if (tmp) {
#line 1483
        return ((reg_errcode_t )12);
      }
#line 1484
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1485
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1486
      tmp___0 = __builtin_expect((long )(! ok), 0L);
#line 1486
      if (tmp___0) {
#line 1487
        return ((reg_errcode_t )12);
      }
    } else
#line 1489
    if ((dfa->edests + org_node)->nelem == 0UL) {
#line 1494
      *(dfa->nexts + clone_node) = *(dfa->nexts + org_node);
#line 1495
      break;
    } else
#line 1497
    if ((dfa->edests + org_node)->nelem == 1UL) {
#line 1501
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1502
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1503
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa, org_dest, constraint);
#line 1506
      if (org_node == root_node) {
#line 1506
        if (clone_node != org_node) {
#line 1508
          ok = re_node_set_insert(dfa->edests + clone_node, org_dest);
#line 1509
          tmp___1 = __builtin_expect((long )(! ok), 0L);
#line 1509
          if (tmp___1) {
#line 1510
            return ((reg_errcode_t )12);
          }
#line 1511
          break;
        }
      }
#line 1514
      constraint |= (dfa->nodes + org_node)->constraint;
#line 1515
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1516
      tmp___2 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
#line 1516
      if (tmp___2) {
#line 1517
        return ((reg_errcode_t )12);
      }
#line 1518
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1519
      tmp___3 = __builtin_expect((long )(! ok), 0L);
#line 1519
      if (tmp___3) {
#line 1520
        return ((reg_errcode_t )12);
      }
    } else {
#line 1526
      org_dest = *((dfa->edests + org_node)->elems + 0);
#line 1527
      (dfa->edests + clone_node)->nelem = (Idx )0;
#line 1529
      clone_dest = search_duplicated_node((re_dfa_t const   *)dfa, org_dest, constraint);
#line 1530
      if (clone_dest == 0xffffffffffffffffUL) {
#line 1534
        clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1535
        tmp___4 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
#line 1535
        if (tmp___4) {
#line 1536
          return ((reg_errcode_t )12);
        }
#line 1537
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1538
        tmp___5 = __builtin_expect((long )(! ok), 0L);
#line 1538
        if (tmp___5) {
#line 1539
          return ((reg_errcode_t )12);
        }
#line 1540
        err = duplicate_node_closure(dfa, org_dest, clone_dest, root_node, constraint);
#line 1542
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
#line 1542
        if (tmp___6) {
#line 1543
          return (err);
        }
      } else {
#line 1549
        ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1550
        tmp___7 = __builtin_expect((long )(! ok), 0L);
#line 1550
        if (tmp___7) {
#line 1551
          return ((reg_errcode_t )12);
        }
      }
#line 1554
      org_dest = *((dfa->edests + org_node)->elems + 1);
#line 1555
      clone_dest = duplicate_node(dfa, org_dest, constraint);
#line 1556
      tmp___8 = __builtin_expect((long )(clone_dest == 0xffffffffffffffffUL), 0L);
#line 1556
      if (tmp___8) {
#line 1557
        return ((reg_errcode_t )12);
      }
#line 1558
      ok = re_node_set_insert(dfa->edests + clone_node, clone_dest);
#line 1559
      tmp___9 = __builtin_expect((long )(! ok), 0L);
#line 1559
      if (tmp___9) {
#line 1560
        return ((reg_errcode_t )12);
      }
    }
#line 1562
    org_node = org_dest;
#line 1563
    clone_node = clone_dest;
  }
#line 1565
  return ((reg_errcode_t )0);
}
}
#line 1571 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static Idx search_duplicated_node(re_dfa_t const   *dfa , Idx org_node , unsigned int constraint ) 
{ 
  Idx idx ;

  {
#line 1576
  idx = (Idx )(dfa->nodes_len - 1UL);
#line 1576
  while (1) {
#line 1576
    if ((dfa->nodes + idx)->duplicated) {
#line 1576
      if (! (idx > 0UL)) {
#line 1576
        break;
      }
    } else {
#line 1576
      break;
    }
#line 1578
    if (org_node == *(dfa->org_indices + idx)) {
#line 1578
      if (constraint == (dfa->nodes + idx)->constraint) {
#line 1580
        return (idx);
      }
    }
#line 1576
    idx --;
  }
#line 1582
  return ((Idx )-1);
}
}
#line 1589 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static Idx duplicate_node(re_dfa_t *dfa , Idx org_idx , unsigned int constraint ) 
{ 
  Idx dup_idx ;
  Idx tmp ;
  long tmp___0 ;

  {
#line 1592
  tmp = re_dfa_add_node(dfa, *(dfa->nodes + org_idx));
#line 1592
  dup_idx = tmp;
#line 1593
  tmp___0 = __builtin_expect((long )(dup_idx != 0xffffffffffffffffUL), 1L);
#line 1593
  if (tmp___0) {
#line 1595
    (dfa->nodes + dup_idx)->constraint = constraint;
#line 1596
    (dfa->nodes + dup_idx)->constraint |= (dfa->nodes + org_idx)->constraint;
#line 1597
    (dfa->nodes + dup_idx)->duplicated = 1U;
#line 1600
    *(dfa->org_indices + dup_idx) = org_idx;
  }
#line 1602
  return (dup_idx);
}
}
#line 1605 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t calc_inveclosure(re_dfa_t *dfa ) 
{ 
  Idx src ;
  Idx idx ;
  _Bool ok ;
  Idx *elems ;
  long tmp ;

  {
#line 1610
  idx = (Idx )0;
#line 1610
  while (idx < dfa->nodes_len) {
#line 1611
    memset((void *)(dfa->inveclosures + idx), '\000', sizeof(re_node_set ));
#line 1610
    idx ++;
  }
#line 1613
  src = (Idx )0;
#line 1613
  while (src < dfa->nodes_len) {
#line 1615
    elems = (dfa->eclosures + src)->elems;
#line 1616
    idx = (Idx )0;
#line 1616
    while (idx < (dfa->eclosures + src)->nelem) {
#line 1618
      ok = re_node_set_insert_last(dfa->inveclosures + *(elems + idx), src);
#line 1619
      tmp = __builtin_expect((long )(! ok), 0L);
#line 1619
      if (tmp) {
#line 1620
        return ((reg_errcode_t )12);
      }
#line 1616
      idx ++;
    }
#line 1613
    src ++;
  }
#line 1624
  return ((reg_errcode_t )0);
}
}
#line 1629 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t calc_eclosure(re_dfa_t *dfa ) 
{ 
  Idx node_idx ;
  _Bool incomplete ;
  reg_errcode_t err ;
  re_node_set eclosure_elem ;
  long tmp ;

  {
#line 1637
  incomplete = (_Bool)0;
#line 1639
  node_idx = (Idx )0;
#line 1639
  while (1) {
#line 1643
    if (node_idx == dfa->nodes_len) {
#line 1645
      if (! incomplete) {
#line 1646
        break;
      }
#line 1647
      incomplete = (_Bool)0;
#line 1648
      node_idx = (Idx )0;
    }
#line 1656
    if ((dfa->eclosures + node_idx)->nelem != 0UL) {
#line 1657
      goto __Cont;
    }
#line 1659
    err = calc_eclosure_iter(& eclosure_elem, dfa, node_idx, (_Bool)1);
#line 1660
    tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 1660
    if (tmp) {
#line 1661
      return (err);
    }
#line 1663
    if ((dfa->eclosures + node_idx)->nelem == 0UL) {
#line 1665
      incomplete = (_Bool)1;
#line 1666
      free((void *)eclosure_elem.elems);
    }
    __Cont: /* CIL Label */ 
#line 1639
    node_idx ++;
  }
#line 1669
  return ((reg_errcode_t )0);
}
}
#line 1674 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t calc_eclosure_iter(re_node_set *new_set , re_dfa_t *dfa , Idx node ,
                                        _Bool root ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  _Bool incomplete ;
  _Bool ok ;
  re_node_set eclosure ;
  long tmp ;
  long tmp___0 ;
  re_node_set eclosure_elem ;
  Idx edest ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1682
  incomplete = (_Bool)0;
#line 1683
  err = re_node_set_alloc(& eclosure, (dfa->edests + node)->nelem + 1UL);
#line 1684
  tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 1684
  if (tmp) {
#line 1685
    return (err);
  }
#line 1689
  (dfa->eclosures + node)->nelem = (Idx )-1;
#line 1693
  if ((dfa->nodes + node)->constraint) {
#line 1693
    if ((dfa->edests + node)->nelem) {
#line 1693
      if (! (dfa->nodes + *((dfa->edests + node)->elems + 0))->duplicated) {
#line 1697
        err = duplicate_node_closure(dfa, node, node, node, (dfa->nodes + node)->constraint);
#line 1699
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1699
        if (tmp___0) {
#line 1700
          return (err);
        }
      }
    }
  }
#line 1704
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
#line 1705
    i = (Idx )0;
#line 1705
    while (i < (dfa->edests + node)->nelem) {
#line 1708
      edest = *((dfa->edests + node)->elems + i);
#line 1711
      if ((dfa->eclosures + edest)->nelem == 0xffffffffffffffffUL) {
#line 1713
        incomplete = (_Bool)1;
#line 1714
        goto __Cont;
      }
#line 1718
      if ((dfa->eclosures + edest)->nelem == 0UL) {
#line 1720
        err = calc_eclosure_iter(& eclosure_elem, dfa, edest, (_Bool)0);
#line 1721
        tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 1721
        if (tmp___1) {
#line 1722
          return (err);
        }
      } else {
#line 1725
        eclosure_elem = *(dfa->eclosures + edest);
      }
#line 1727
      re_node_set_merge(& eclosure, (re_node_set const   *)(& eclosure_elem));
#line 1730
      if ((dfa->eclosures + edest)->nelem == 0UL) {
#line 1732
        incomplete = (_Bool)1;
#line 1733
        free((void *)eclosure_elem.elems);
      }
      __Cont: /* CIL Label */ 
#line 1705
      i ++;
    }
  }
#line 1738
  ok = re_node_set_insert(& eclosure, node);
#line 1739
  tmp___2 = __builtin_expect((long )(! ok), 0L);
#line 1739
  if (tmp___2) {
#line 1740
    return ((reg_errcode_t )12);
  }
#line 1741
  if (incomplete) {
#line 1741
    if (! root) {
#line 1742
      (dfa->eclosures + node)->nelem = (Idx )0;
    } else {
#line 1744
      *(dfa->eclosures + node) = eclosure;
    }
  } else {
#line 1744
    *(dfa->eclosures + node) = eclosure;
  }
#line 1745
  *new_set = eclosure;
#line 1746
  return ((reg_errcode_t )0);
}
}
#line 1754 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void fetch_token(re_token_t *result , re_string_t *input , reg_syntax_t syntax ) 
{ 
  int tmp ;

  {
#line 1758
  tmp = peek_token(result, input, syntax);
#line 1758
  input->cur_idx += (Idx )tmp;
#line 1759
  return;
}
}
#line 1764 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static int peek_token(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char __attribute__((__pure__))  tmp ;
  wint_t wc ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  wint_t wc___0 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  int tmp___9 ;
  char prev ;
  re_token_t next ;

  {
#line 1770
  if (input->stop <= input->cur_idx) {
#line 1772
    token->type = (re_token_type_t )2;
#line 1773
    return (0);
  }
#line 1776
  c = *(input->mbs + input->cur_idx);
#line 1777
  token->opr.c = c;
#line 1779
  token->word_char = 0U;
#line 1781
  token->mb_partial = 0U;
#line 1782
  if (input->mb_cur_max > 1) {
#line 1782
    if (! (input->cur_idx == input->valid_len)) {
#line 1782
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 1785
        token->type = (re_token_type_t )1;
#line 1786
        token->mb_partial = 1U;
#line 1787
        return (1);
      }
    }
  }
#line 1790
  if ((int )c == 92) {
#line 1793
    if (input->cur_idx + 1UL >= input->len) {
#line 1795
      token->type = (re_token_type_t )36;
#line 1796
      return (1);
    }
#line 1799
    tmp = re_string_peek_byte_case((re_string_t const   *)input, (Idx )1);
#line 1799
    c2 = (unsigned char )tmp;
#line 1800
    token->opr.c = c2;
#line 1801
    token->type = (re_token_type_t )1;
#line 1803
    if (input->mb_cur_max > 1) {
#line 1805
      tmp___0 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx + 1UL);
#line 1805
      wc = (wint_t )tmp___0;
#line 1807
      tmp___1 = iswalnum(wc);
#line 1807
      if (tmp___1) {
#line 1807
        tmp___2 = 1;
      } else
#line 1807
      if (wc == 95U) {
#line 1807
        tmp___2 = 1;
      } else {
#line 1807
        tmp___2 = 0;
      }
#line 1807
      token->word_char = (unsigned int )(tmp___2 != 0);
    } else {
#line 1811
      tmp___3 = __ctype_b_loc();
#line 1811
      if ((int const   )*(*tmp___3 + (int )c2) & 8) {
#line 1811
        tmp___4 = 1;
      } else
#line 1811
      if ((int )c2 == 95) {
#line 1811
        tmp___4 = 1;
      } else {
#line 1811
        tmp___4 = 0;
      }
#line 1811
      token->word_char = (unsigned int )(tmp___4 != 0);
    }
#line 1813
    switch ((int )c2) {
    case 124: 
#line 1816
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1816
      if (! (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1817
        token->type = (re_token_type_t )10;
      }
    }
#line 1818
    break;
    case 57: 
    case 56: 
    case 55: 
    case 54: 
    case 53: 
    case 52: 
    case 51: 
    case 50: 
    case 49: 
#line 1821
    if (! (syntax & ((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1823
      token->type = (re_token_type_t )4;
#line 1824
      token->opr.idx = (Idx )((int )c2 - 49);
    }
#line 1826
    break;
    case 60: 
#line 1828
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1830
      token->type = (re_token_type_t )12;
#line 1831
      token->opr.ctx_type = (re_context_type )6;
    }
#line 1833
    break;
    case 62: 
#line 1835
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1837
      token->type = (re_token_type_t )12;
#line 1838
      token->opr.ctx_type = (re_context_type )9;
    }
#line 1840
    break;
    case 98: 
#line 1842
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1844
      token->type = (re_token_type_t )12;
#line 1845
      token->opr.ctx_type = (re_context_type )256;
    }
#line 1847
    break;
    case 66: 
#line 1849
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1851
      token->type = (re_token_type_t )12;
#line 1852
      token->opr.ctx_type = (re_context_type )512;
    }
#line 1854
    break;
    case 119: 
#line 1856
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1857
      token->type = (re_token_type_t )32;
    }
#line 1858
    break;
    case 87: 
#line 1860
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1861
      token->type = (re_token_type_t )33;
    }
#line 1862
    break;
    case 115: 
#line 1864
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1865
      token->type = (re_token_type_t )34;
    }
#line 1866
    break;
    case 83: 
#line 1868
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1869
      token->type = (re_token_type_t )35;
    }
#line 1870
    break;
    case 96: 
#line 1872
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1874
      token->type = (re_token_type_t )12;
#line 1875
      token->opr.ctx_type = (re_context_type )64;
    }
#line 1877
    break;
    case 39: 
#line 1879
    if (! (syntax & (((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1881
      token->type = (re_token_type_t )12;
#line 1882
      token->opr.ctx_type = (re_context_type )128;
    }
#line 1884
    break;
    case 40: 
#line 1886
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1887
      token->type = (re_token_type_t )8;
    }
#line 1888
    break;
    case 41: 
#line 1890
    if (! (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1891
      token->type = (re_token_type_t )9;
    }
#line 1892
    break;
    case 43: 
#line 1894
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1894
      if (syntax & (1UL << 1)) {
#line 1895
        token->type = (re_token_type_t )18;
      }
    }
#line 1896
    break;
    case 63: 
#line 1898
    if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1898
      if (syntax & (1UL << 1)) {
#line 1899
        token->type = (re_token_type_t )19;
      }
    }
#line 1900
    break;
    case 123: 
#line 1902
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1902
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1903
        token->type = (re_token_type_t )23;
      }
    }
#line 1904
    break;
    case 125: 
#line 1906
    if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1906
      if (! (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1907
        token->type = (re_token_type_t )24;
      }
    }
#line 1908
    break;
    default: 
#line 1910
    break;
    }
#line 1912
    return (2);
  }
#line 1915
  token->type = (re_token_type_t )1;
#line 1917
  if (input->mb_cur_max > 1) {
#line 1919
    tmp___5 = re_string_wchar_at((re_string_t const   *)input, input->cur_idx);
#line 1919
    wc___0 = (wint_t )tmp___5;
#line 1920
    tmp___6 = iswalnum(wc___0);
#line 1920
    if (tmp___6) {
#line 1920
      tmp___7 = 1;
    } else
#line 1920
    if (wc___0 == 95U) {
#line 1920
      tmp___7 = 1;
    } else {
#line 1920
      tmp___7 = 0;
    }
#line 1920
    token->word_char = (unsigned int )(tmp___7 != 0);
  } else {
#line 1924
    tmp___8 = __ctype_b_loc();
#line 1924
    if ((int const   )*(*tmp___8 + (int )token->opr.c) & 8) {
#line 1924
      tmp___9 = 1;
    } else
#line 1924
    if ((int )token->opr.c == 95) {
#line 1924
      tmp___9 = 1;
    } else {
#line 1924
      tmp___9 = 0;
    }
#line 1924
    token->word_char = (unsigned int )tmp___9;
  }
#line 1926
  switch ((int )c) {
  case 10: 
#line 1929
  if (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1930
    token->type = (re_token_type_t )10;
  }
#line 1931
  break;
  case 124: 
#line 1933
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1933
    if (syntax & (((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1934
      token->type = (re_token_type_t )10;
    }
  }
#line 1935
  break;
  case 42: 
#line 1937
  token->type = (re_token_type_t )11;
#line 1938
  break;
  case 43: 
#line 1940
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1940
    if (! (syntax & (1UL << 1))) {
#line 1941
      token->type = (re_token_type_t )18;
    }
  }
#line 1942
  break;
  case 63: 
#line 1944
  if (! (syntax & ((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1944
    if (! (syntax & (1UL << 1))) {
#line 1945
      token->type = (re_token_type_t )19;
    }
  }
#line 1946
  break;
  case 123: 
#line 1948
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1948
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1949
      token->type = (re_token_type_t )23;
    }
  }
#line 1950
  break;
  case 125: 
#line 1952
  if (syntax & (((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1952
    if (syntax & ((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1953
      token->type = (re_token_type_t )24;
    }
  }
#line 1954
  break;
  case 40: 
#line 1956
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1957
    token->type = (re_token_type_t )8;
  }
#line 1958
  break;
  case 41: 
#line 1960
  if (syntax & (((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 1961
    token->type = (re_token_type_t )9;
  }
#line 1962
  break;
  case 91: 
#line 1964
  token->type = (re_token_type_t )20;
#line 1965
  break;
  case 46: 
#line 1967
  token->type = (re_token_type_t )5;
#line 1968
  break;
  case 94: 
#line 1970
  if (! (syntax & ((((1UL << 1) << 1) << 1) | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)))) {
#line 1970
    if (input->cur_idx != 0UL) {
#line 1973
      prev = (char )*(input->mbs + (input->cur_idx + 0xffffffffffffffffUL));
#line 1974
      if (! (syntax & (((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 1975
        break;
      } else
#line 1974
      if ((int )prev != 10) {
#line 1975
        break;
      }
    }
  }
#line 1977
  token->type = (re_token_type_t )12;
#line 1978
  token->opr.ctx_type = (re_context_type )16;
#line 1979
  break;
  case 36: 
#line 1981
  if (! (syntax & (((1UL << 1) << 1) << 1))) {
#line 1981
    if (input->cur_idx + 1UL != input->len) {
#line 1985
      (input->cur_idx) ++;
#line 1986
      peek_token(& next, input, syntax);
#line 1987
      (input->cur_idx) --;
#line 1988
      if ((unsigned int )next.type != 10U) {
#line 1988
        if ((unsigned int )next.type != 9U) {
#line 1989
          break;
        }
      }
    }
  }
#line 1991
  token->type = (re_token_type_t )12;
#line 1992
  token->opr.ctx_type = (re_context_type )32;
#line 1993
  break;
  default: 
#line 1995
  break;
  }
#line 1997
  return (1);
}
}
#line 2003 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static int peek_token_bracket(re_token_t *token , re_string_t *input , reg_syntax_t syntax ) 
{ 
  unsigned char c ;
  unsigned char c2 ;
  unsigned char c2___0 ;
  int token_len ;

  {
#line 2008
  if (input->stop <= input->cur_idx) {
#line 2010
    token->type = (re_token_type_t )2;
#line 2011
    return (0);
  }
#line 2013
  c = *(input->mbs + input->cur_idx);
#line 2014
  token->opr.c = c;
#line 2017
  if (input->mb_cur_max > 1) {
#line 2017
    if (! (input->cur_idx == input->valid_len)) {
#line 2017
      if (! (*(input->wcs + input->cur_idx) != 4294967295U)) {
#line 2020
        token->type = (re_token_type_t )1;
#line 2021
        return (1);
      }
    }
  }
#line 2025
  if ((int )c == 92) {
#line 2025
    if (syntax & 1UL) {
#line 2025
      if (input->cur_idx + 1UL < input->len) {
#line 2030
        (input->cur_idx) ++;
#line 2031
        c2 = *(input->mbs + input->cur_idx);
#line 2032
        token->opr.c = c2;
#line 2033
        token->type = (re_token_type_t )1;
#line 2034
        return (1);
      }
    }
  }
#line 2036
  if ((int )c == 91) {
#line 2040
    if (input->cur_idx + 1UL < input->len) {
#line 2041
      c2___0 = *(input->mbs + (input->cur_idx + 1UL));
    } else {
#line 2043
      c2___0 = (unsigned char)0;
    }
#line 2044
    token->opr.c = c2___0;
#line 2045
    token_len = 2;
#line 2046
    switch ((int )c2___0) {
    case 46: 
#line 2049
    token->type = (re_token_type_t )26;
#line 2050
    break;
    case 61: 
#line 2052
    token->type = (re_token_type_t )28;
#line 2053
    break;
    case 58: 
#line 2055
    if (syntax & ((1UL << 1) << 1)) {
#line 2057
      token->type = (re_token_type_t )30;
#line 2058
      break;
    }
    default: 
#line 2062
    token->type = (re_token_type_t )1;
#line 2063
    token->opr.c = c;
#line 2064
    token_len = 1;
#line 2065
    break;
    }
#line 2067
    return (token_len);
  }
#line 2069
  switch ((int )c) {
  case 45: 
#line 2072
  token->type = (re_token_type_t )22;
#line 2073
  break;
  case 93: 
#line 2075
  token->type = (re_token_type_t )21;
#line 2076
  break;
  case 94: 
#line 2078
  token->type = (re_token_type_t )25;
#line 2079
  break;
  default: 
#line 2081
  token->type = (re_token_type_t )1;
  }
#line 2083
  return (1);
}
}
#line 2100 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *parse(re_string_t *regexp , regex_t *preg , reg_syntax_t syntax ,
                         reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *eor ;
  bin_tree_t *root ;
  re_token_t current_token ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2104
  dfa = (re_dfa_t *)preg->buffer;
#line 2107
  dfa->syntax = syntax;
#line 2108
  fetch_token(& current_token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2109
  tree = parse_reg_exp(regexp, preg, & current_token, syntax, (Idx )0, err);
#line 2110
  if ((int )*err != 0) {
#line 2110
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2110
      tmp = 1;
    } else {
#line 2110
      tmp = 0;
    }
  } else {
#line 2110
    tmp = 0;
  }
#line 2110
  tmp___0 = __builtin_expect((long )tmp, 0L);
#line 2110
  if (tmp___0) {
#line 2111
    return ((bin_tree_t *)((void *)0));
  }
#line 2112
  eor = create_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0), (re_token_type_t )2);
#line 2113
  if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 2114
    root = create_tree(dfa, tree, eor, (re_token_type_t )16);
  } else {
#line 2116
    root = eor;
  }
#line 2117
  if ((unsigned long )eor == (unsigned long )((void *)0)) {
#line 2117
    tmp___1 = 1;
  } else
#line 2117
  if ((unsigned long )root == (unsigned long )((void *)0)) {
#line 2117
    tmp___1 = 1;
  } else {
#line 2117
    tmp___1 = 0;
  }
#line 2117
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 2117
  if (tmp___2) {
#line 2119
    *err = (reg_errcode_t )12;
#line 2120
    return ((bin_tree_t *)((void *)0));
  }
#line 2122
  return (root);
}
}
#line 2134 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *parse_reg_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  bin_tree_t *branch ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2138
  dfa = (re_dfa_t *)preg->buffer;
#line 2139
  branch = (bin_tree_t *)((void *)0);
#line 2140
  tree = parse_branch(regexp, preg, token, syntax, nest, err);
#line 2141
  if ((int )*err != 0) {
#line 2141
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2141
      tmp = 1;
    } else {
#line 2141
      tmp = 0;
    }
  } else {
#line 2141
    tmp = 0;
  }
#line 2141
  tmp___0 = __builtin_expect((long )tmp, 0L);
#line 2141
  if (tmp___0) {
#line 2142
    return ((bin_tree_t *)((void *)0));
  }
#line 2144
  while ((unsigned int )token->type == 10U) {
#line 2146
    fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2147
    if ((unsigned int )token->type != 10U) {
#line 2147
      if ((unsigned int )token->type != 2U) {
#line 2147
        if (nest == 0UL) {
#line 2147
          goto _L;
        } else
#line 2147
        if ((unsigned int )token->type != 9U) {
          _L: /* CIL Label */ 
#line 2150
          branch = parse_branch(regexp, preg, token, syntax, nest, err);
#line 2151
          if ((int )*err != 0) {
#line 2151
            if ((unsigned long )branch == (unsigned long )((void *)0)) {
#line 2151
              tmp___1 = 1;
            } else {
#line 2151
              tmp___1 = 0;
            }
          } else {
#line 2151
            tmp___1 = 0;
          }
#line 2151
          tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 2151
          if (tmp___2) {
#line 2152
            return ((bin_tree_t *)((void *)0));
          }
        } else {
#line 2155
          branch = (bin_tree_t *)((void *)0);
        }
      } else {
#line 2155
        branch = (bin_tree_t *)((void *)0);
      }
    } else {
#line 2155
      branch = (bin_tree_t *)((void *)0);
    }
#line 2156
    tree = create_tree(dfa, tree, branch, (re_token_type_t )10);
#line 2157
    tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                               0L);
#line 2157
    if (tmp___3) {
#line 2159
      *err = (reg_errcode_t )12;
#line 2160
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2163
  return (tree);
}
}
#line 2175 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *parse_branch(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *expr ;
  re_dfa_t *dfa ;
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2180
  dfa = (re_dfa_t *)preg->buffer;
#line 2181
  tree = parse_expression(regexp, preg, token, syntax, nest, err);
#line 2182
  if ((int )*err != 0) {
#line 2182
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2182
      tmp = 1;
    } else {
#line 2182
      tmp = 0;
    }
  } else {
#line 2182
    tmp = 0;
  }
#line 2182
  tmp___0 = __builtin_expect((long )tmp, 0L);
#line 2182
  if (tmp___0) {
#line 2183
    return ((bin_tree_t *)((void *)0));
  }
#line 2185
  while (1) {
#line 2185
    if ((unsigned int )token->type != 10U) {
#line 2185
      if ((unsigned int )token->type != 2U) {
#line 2185
        if (! (nest == 0UL)) {
#line 2185
          if (! ((unsigned int )token->type != 9U)) {
#line 2185
            break;
          }
        }
      } else {
#line 2185
        break;
      }
    } else {
#line 2185
      break;
    }
#line 2188
    expr = parse_expression(regexp, preg, token, syntax, nest, err);
#line 2189
    if ((int )*err != 0) {
#line 2189
      if ((unsigned long )expr == (unsigned long )((void *)0)) {
#line 2189
        tmp___1 = 1;
      } else {
#line 2189
        tmp___1 = 0;
      }
    } else {
#line 2189
      tmp___1 = 0;
    }
#line 2189
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 2189
    if (tmp___2) {
#line 2191
      return ((bin_tree_t *)((void *)0));
    }
#line 2193
    if ((unsigned long )tree != (unsigned long )((void *)0)) {
#line 2193
      if ((unsigned long )expr != (unsigned long )((void *)0)) {
#line 2195
        tree = create_tree(dfa, tree, expr, (re_token_type_t )16);
#line 2196
        if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2198
          *err = (reg_errcode_t )12;
#line 2199
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2193
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2202
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2203
      tree = expr;
    }
  }
#line 2206
  return (tree);
}
}
#line 2215 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *parse_expression(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                    reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  long tmp ;
  bin_tree_t *mbc_remain ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  bin_tree_t *tmp___8 ;
  long tmp___9 ;
  bin_tree_t *tree_first ;
  bin_tree_t *tree_last ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  long tmp___17 ;
  int tmp___18 ;
  long tmp___19 ;

  {
#line 2219
  dfa = (re_dfa_t *)preg->buffer;
#line 2221
  switch ((unsigned int )token->type) {
  case 1U: 
#line 2224
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2225
  tmp = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                         0L);
#line 2225
  if (tmp) {
#line 2227
    *err = (reg_errcode_t )12;
#line 2228
    return ((bin_tree_t *)((void *)0));
  }
#line 2231
  if (dfa->mb_cur_max > 1) {
#line 2233
    while (1) {
#line 2233
      if (! (regexp->stop <= regexp->cur_idx)) {
#line 2233
        if (regexp->cur_idx == regexp->valid_len) {
#line 2233
          break;
        } else
#line 2233
        if (*(regexp->wcs + regexp->cur_idx) != 4294967295U) {
#line 2233
          break;
        }
      } else {
#line 2233
        break;
      }
#line 2237
      fetch_token(token, regexp, syntax);
#line 2238
      mbc_remain = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2239
      tree = create_tree(dfa, tree, mbc_remain, (re_token_type_t )16);
#line 2240
      if ((unsigned long )mbc_remain == (unsigned long )((void *)0)) {
#line 2240
        tmp___0 = 1;
      } else
#line 2240
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2240
        tmp___0 = 1;
      } else {
#line 2240
        tmp___0 = 0;
      }
#line 2240
      tmp___1 = __builtin_expect((long )tmp___0, 0L);
#line 2240
      if (tmp___1) {
#line 2242
        *err = (reg_errcode_t )12;
#line 2243
        return ((bin_tree_t *)((void *)0));
      }
    }
  }
#line 2248
  break;
  case 8U: 
#line 2250
  tree = parse_sub_exp(regexp, preg, token, syntax, nest + 1UL, err);
#line 2251
  if ((int )*err != 0) {
#line 2251
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2251
      tmp___2 = 1;
    } else {
#line 2251
      tmp___2 = 0;
    }
  } else {
#line 2251
    tmp___2 = 0;
  }
#line 2251
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
#line 2251
  if (tmp___3) {
#line 2252
    return ((bin_tree_t *)((void *)0));
  }
#line 2253
  break;
  case 20U: 
#line 2255
  tree = parse_bracket_exp(regexp, dfa, token, syntax, err);
#line 2256
  if ((int )*err != 0) {
#line 2256
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2256
      tmp___4 = 1;
    } else {
#line 2256
      tmp___4 = 0;
    }
  } else {
#line 2256
    tmp___4 = 0;
  }
#line 2256
  tmp___5 = __builtin_expect((long )tmp___4, 0L);
#line 2256
  if (tmp___5) {
#line 2257
    return ((bin_tree_t *)((void *)0));
  }
#line 2258
  break;
  case 4U: 
#line 2260
  tmp___6 = __builtin_expect((long )(dfa->completed_bkref_map & (unsigned long )(1 << token->opr.idx)),
                             1L);
#line 2260
  if (! tmp___6) {
#line 2262
    *err = (reg_errcode_t )6;
#line 2263
    return ((bin_tree_t *)((void *)0));
  }
#line 2265
  dfa->used_bkref_map |= (unsigned long )(1 << token->opr.idx);
#line 2266
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2267
  tmp___7 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
#line 2267
  if (tmp___7) {
#line 2269
    *err = (reg_errcode_t )12;
#line 2270
    return ((bin_tree_t *)((void *)0));
  }
#line 2272
  (dfa->nbackref) ++;
#line 2273
  dfa->has_mb_node = 1U;
#line 2274
  break;
  case 23U: 
#line 2276
  if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2278
    *err = (reg_errcode_t )13;
#line 2279
    return ((bin_tree_t *)((void *)0));
  }
  case 19U: 
  case 18U: 
  case 11U: 
#line 2285
  if (syntax & (((((1UL << 1) << 1) << 1) << 1) << 1)) {
#line 2287
    *err = (reg_errcode_t )13;
#line 2288
    return ((bin_tree_t *)((void *)0));
  } else
#line 2290
  if (syntax & ((((1UL << 1) << 1) << 1) << 1)) {
#line 2292
    fetch_token(token, regexp, syntax);
#line 2293
    tmp___8 = parse_expression(regexp, preg, token, syntax, nest, err);
#line 2293
    return (tmp___8);
  }
  case 9U: 
#line 2297
  if ((unsigned int )token->type == 9U) {
#line 2297
    if (! (syntax & (((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 2300
      *err = (reg_errcode_t )16;
#line 2301
      return ((bin_tree_t *)((void *)0));
    }
  }
  case 24U: 
#line 2308
  token->type = (re_token_type_t )1;
#line 2311
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2312
  tmp___9 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
#line 2312
  if (tmp___9) {
#line 2314
    *err = (reg_errcode_t )12;
#line 2315
    return ((bin_tree_t *)((void *)0));
  }
#line 2317
  break;
  case 12U: 
#line 2319
  if ((unsigned int )token->opr.ctx_type & 783U) {
#line 2319
    if (dfa->word_ops_used == 0U) {
#line 2322
      init_word_char(dfa);
    }
  }
#line 2323
  if ((unsigned int )token->opr.ctx_type == 256U) {
#line 2323
    goto _L;
  } else
#line 2323
  if ((unsigned int )token->opr.ctx_type == 512U) {
    _L: /* CIL Label */ 
#line 2327
    if ((unsigned int )token->opr.ctx_type == 256U) {
#line 2329
      token->opr.ctx_type = (re_context_type )6;
#line 2330
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2331
      token->opr.ctx_type = (re_context_type )9;
    } else {
#line 2335
      token->opr.ctx_type = (re_context_type )5;
#line 2336
      tree_first = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                     (re_token_t const   *)token);
#line 2337
      token->opr.ctx_type = (re_context_type )10;
    }
#line 2339
    tree_last = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)token);
#line 2340
    tree = create_tree(dfa, tree_first, tree_last, (re_token_type_t )10);
#line 2341
    if ((unsigned long )tree_first == (unsigned long )((void *)0)) {
#line 2341
      tmp___10 = 1;
    } else
#line 2341
    if ((unsigned long )tree_last == (unsigned long )((void *)0)) {
#line 2341
      tmp___10 = 1;
    } else
#line 2341
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2341
      tmp___10 = 1;
    } else {
#line 2341
      tmp___10 = 0;
    }
#line 2341
    tmp___11 = __builtin_expect((long )tmp___10, 0L);
#line 2341
    if (tmp___11) {
#line 2343
      *err = (reg_errcode_t )12;
#line 2344
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2349
    tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                             (re_token_t const   *)token);
#line 2350
    tmp___12 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                0L);
#line 2350
    if (tmp___12) {
#line 2352
      *err = (reg_errcode_t )12;
#line 2353
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2360
  fetch_token(token, regexp, syntax);
#line 2361
  return (tree);
  case 5U: 
#line 2363
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)token);
#line 2364
  tmp___13 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
#line 2364
  if (tmp___13) {
#line 2366
    *err = (reg_errcode_t )12;
#line 2367
    return ((bin_tree_t *)((void *)0));
  }
#line 2369
  if (dfa->mb_cur_max > 1) {
#line 2370
    dfa->has_mb_node = 1U;
  }
#line 2371
  break;
  case 33U: 
  case 32U: 
#line 2374
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"alnum",
                            (unsigned char const   *)"_", (_Bool )((unsigned int )token->type == 33U),
                            err);
#line 2378
  if ((int )*err != 0) {
#line 2378
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2378
      tmp___14 = 1;
    } else {
#line 2378
      tmp___14 = 0;
    }
  } else {
#line 2378
    tmp___14 = 0;
  }
#line 2378
  tmp___15 = __builtin_expect((long )tmp___14, 0L);
#line 2378
  if (tmp___15) {
#line 2379
    return ((bin_tree_t *)((void *)0));
  }
#line 2380
  break;
  case 35U: 
  case 34U: 
#line 2383
  tree = build_charclass_op(dfa, regexp->trans, (unsigned char const   *)"space",
                            (unsigned char const   *)"", (_Bool )((unsigned int )token->type == 35U),
                            err);
#line 2387
  if ((int )*err != 0) {
#line 2387
    if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2387
      tmp___16 = 1;
    } else {
#line 2387
      tmp___16 = 0;
    }
  } else {
#line 2387
    tmp___16 = 0;
  }
#line 2387
  tmp___17 = __builtin_expect((long )tmp___16, 0L);
#line 2387
  if (tmp___17) {
#line 2388
    return ((bin_tree_t *)((void *)0));
  }
#line 2389
  break;
  case 2U: 
  case 10U: 
#line 2392
  return ((bin_tree_t *)((void *)0));
  case 36U: 
#line 2394
  *err = (reg_errcode_t )5;
#line 2395
  return ((bin_tree_t *)((void *)0));
  default: 
#line 2401
  return ((bin_tree_t *)((void *)0));
  }
#line 2403
  fetch_token(token, regexp, syntax);
#line 2405
  while (1) {
#line 2405
    if (! ((unsigned int )token->type == 11U)) {
#line 2405
      if (! ((unsigned int )token->type == 18U)) {
#line 2405
        if (! ((unsigned int )token->type == 19U)) {
#line 2405
          if (! ((unsigned int )token->type == 23U)) {
#line 2405
            break;
          }
        }
      }
    }
#line 2408
    tree = parse_dup_op(tree, regexp, dfa, token, syntax, err);
#line 2409
    if ((int )*err != 0) {
#line 2409
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2409
        tmp___18 = 1;
      } else {
#line 2409
        tmp___18 = 0;
      }
    } else {
#line 2409
      tmp___18 = 0;
    }
#line 2409
    tmp___19 = __builtin_expect((long )tmp___18, 0L);
#line 2409
    if (tmp___19) {
#line 2410
      return ((bin_tree_t *)((void *)0));
    }
#line 2412
    if (syntax & ((((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 2412
      if ((unsigned int )token->type == 11U) {
#line 2416
        *err = (reg_errcode_t )13;
#line 2417
        return ((bin_tree_t *)((void *)0));
      } else
#line 2412
      if ((unsigned int )token->type == 23U) {
#line 2416
        *err = (reg_errcode_t )13;
#line 2417
        return ((bin_tree_t *)((void *)0));
      }
    }
  }
#line 2421
  return (tree);
}
}
#line 2431 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *parse_sub_exp(re_string_t *regexp , regex_t *preg , re_token_t *token ,
                                 reg_syntax_t syntax , Idx nest , reg_errcode_t *err ) 
{ 
  re_dfa_t *dfa ;
  bin_tree_t *tree ;
  size_t cur_nsub ;
  size_t tmp ;
  int tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2435
  dfa = (re_dfa_t *)preg->buffer;
#line 2438
  tmp = preg->re_nsub;
#line 2438
  (preg->re_nsub) ++;
#line 2438
  cur_nsub = tmp;
#line 2440
  fetch_token(token, regexp, syntax | (((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1));
#line 2443
  if ((unsigned int )token->type == 9U) {
#line 2444
    tree = (bin_tree_t *)((void *)0);
  } else {
#line 2447
    tree = parse_reg_exp(regexp, preg, token, syntax, nest, err);
#line 2448
    if ((int )*err == 0) {
#line 2448
      if ((unsigned int )token->type != 9U) {
#line 2448
        tmp___0 = 1;
      } else {
#line 2448
        tmp___0 = 0;
      }
    } else {
#line 2448
      tmp___0 = 0;
    }
#line 2448
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
#line 2448
    if (tmp___1) {
#line 2449
      *err = (reg_errcode_t )8;
    }
#line 2450
    tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
#line 2450
    if (tmp___2) {
#line 2451
      return ((bin_tree_t *)((void *)0));
    }
  }
#line 2454
  if (cur_nsub <= 8UL) {
#line 2455
    dfa->completed_bkref_map |= (unsigned long )(1 << cur_nsub);
  }
#line 2457
  tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )17);
#line 2458
  tmp___3 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
#line 2458
  if (tmp___3) {
#line 2460
    *err = (reg_errcode_t )12;
#line 2461
    return ((bin_tree_t *)((void *)0));
  }
#line 2463
  tree->token.opr.idx = cur_nsub;
#line 2464
  return (tree);
}
}
#line 2469 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *parse_dup_op(bin_tree_t *elem , re_string_t *regexp , re_dfa_t *dfa ,
                                re_token_t *token , reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  bin_tree_t *tree ;
  bin_tree_t *old_tree ;
  Idx i ;
  Idx start ;
  Idx end ;
  Idx start_idx ;
  re_token_t start_token ;
  Idx tmp ;
  Idx tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;

  {
#line 2473
  tree = (bin_tree_t *)((void *)0);
#line 2473
  old_tree = (bin_tree_t *)((void *)0);
#line 2474
  start_idx = regexp->cur_idx;
#line 2475
  start_token = *token;
#line 2477
  if ((unsigned int )token->type == 23U) {
#line 2479
    end = (Idx )0;
#line 2480
    start = fetch_number(regexp, token, syntax);
#line 2481
    if (start == 0xffffffffffffffffUL) {
#line 2483
      if ((unsigned int )token->type == 1U) {
#line 2483
        if ((int )token->opr.c == 44) {
#line 2484
          start = (Idx )0;
        } else {
#line 2487
          *err = (reg_errcode_t )10;
#line 2488
          return ((bin_tree_t *)((void *)0));
        }
      } else {
#line 2487
        *err = (reg_errcode_t )10;
#line 2488
        return ((bin_tree_t *)((void *)0));
      }
    }
#line 2491
    tmp___1 = __builtin_expect((long )(start != 0xfffffffffffffffeUL), 1L);
#line 2491
    if (tmp___1) {
#line 2494
      if ((unsigned int )token->type == 24U) {
#line 2494
        end = start;
      } else {
#line 2494
        if ((unsigned int )token->type == 1U) {
#line 2494
          if ((int )token->opr.c == 44) {
#line 2494
            tmp = fetch_number(regexp, token, syntax);
#line 2494
            tmp___0 = tmp;
          } else {
#line 2494
            tmp___0 = (Idx )-2;
          }
        } else {
#line 2494
          tmp___0 = (Idx )-2;
        }
#line 2494
        end = tmp___0;
      }
    }
#line 2498
    if (start == 0xfffffffffffffffeUL) {
#line 2498
      tmp___3 = 1;
    } else
#line 2498
    if (end == 0xfffffffffffffffeUL) {
#line 2498
      tmp___3 = 1;
    } else {
#line 2498
      tmp___3 = 0;
    }
#line 2498
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
#line 2498
    if (tmp___4) {
#line 2501
      tmp___2 = __builtin_expect((long )(! (syntax & (((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1))),
                                 0L);
#line 2501
      if (tmp___2) {
#line 2503
        if ((unsigned int )token->type == 2U) {
#line 2504
          *err = (reg_errcode_t )9;
        } else {
#line 2506
          *err = (reg_errcode_t )10;
        }
#line 2508
        return ((bin_tree_t *)((void *)0));
      }
#line 2512
      regexp->cur_idx = start_idx;
#line 2513
      *token = start_token;
#line 2514
      token->type = (re_token_type_t )1;
#line 2517
      return (elem);
    }
#line 2520
    if (end != 0xffffffffffffffffUL) {
#line 2520
      if (start > end) {
#line 2520
        tmp___5 = 1;
      } else {
#line 2520
        tmp___5 = 0;
      }
    } else {
#line 2520
      tmp___5 = 0;
    }
#line 2520
    tmp___6 = __builtin_expect((long )tmp___5, 0L);
#line 2520
    if (tmp___6) {
#line 2523
      *err = (reg_errcode_t )10;
#line 2524
      return ((bin_tree_t *)((void *)0));
    }
  } else {
#line 2529
    if ((unsigned int )token->type == 18U) {
#line 2529
      start = (Idx )1;
    } else {
#line 2529
      start = (Idx )0;
    }
#line 2530
    if ((unsigned int )token->type == 19U) {
#line 2530
      end = (Idx )1;
    } else {
#line 2530
      end = (Idx )-1;
    }
  }
#line 2533
  fetch_token(token, regexp, syntax);
#line 2535
  tmp___7 = __builtin_expect((long )((unsigned long )elem == (unsigned long )((void *)0)),
                             0L);
#line 2535
  if (tmp___7) {
#line 2536
    return ((bin_tree_t *)((void *)0));
  }
#line 2537
  if (start == 0UL) {
#line 2537
    if (end == 0UL) {
#line 2537
      tmp___8 = 1;
    } else {
#line 2537
      tmp___8 = 0;
    }
  } else {
#line 2537
    tmp___8 = 0;
  }
#line 2537
  tmp___9 = __builtin_expect((long )tmp___8, 0L);
#line 2537
  if (tmp___9) {
#line 2539
    postorder(elem, & free_tree, (void *)0);
#line 2540
    return ((bin_tree_t *)((void *)0));
  }
#line 2544
  tmp___12 = __builtin_expect((long )(start > 0UL), 0L);
#line 2544
  if (tmp___12) {
#line 2546
    tree = elem;
#line 2547
    i = (Idx )2;
#line 2547
    while (i <= start) {
#line 2549
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2550
      tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
#line 2551
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2551
        tmp___10 = 1;
      } else
#line 2551
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2551
        tmp___10 = 1;
      } else {
#line 2551
        tmp___10 = 0;
      }
#line 2551
      tmp___11 = __builtin_expect((long )tmp___10, 0L);
#line 2551
      if (tmp___11) {
#line 2552
        goto parse_dup_op_espace;
      }
#line 2547
      i ++;
    }
#line 2555
    if (start == end) {
#line 2556
      return (tree);
    }
#line 2559
    elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2560
    old_tree = tree;
  } else {
#line 2563
    old_tree = (bin_tree_t *)((void *)0);
  }
#line 2565
  if ((unsigned int )elem->token.type == 17U) {
#line 2566
    postorder(elem, & mark_opt_subexp, (void *)((long )elem->token.opr.idx));
  }
#line 2568
  if (end == 0xffffffffffffffffUL) {
#line 2568
    tmp___13 = 11;
  } else {
#line 2568
    tmp___13 = 10;
  }
#line 2568
  tree = create_tree(dfa, elem, (bin_tree_t *)((void *)0), (re_token_type_t )tmp___13);
#line 2570
  tmp___14 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                              0L);
#line 2570
  if (tmp___14) {
#line 2571
    goto parse_dup_op_espace;
  }
#line 2577
  if (end != 0xffffffffffffffffUL) {
#line 2578
    i = start + 2UL;
#line 2578
    while (i <= end) {
#line 2580
      elem = duplicate_tree((bin_tree_t const   *)elem, dfa);
#line 2581
      tree = create_tree(dfa, tree, elem, (re_token_type_t )16);
#line 2582
      if ((unsigned long )elem == (unsigned long )((void *)0)) {
#line 2582
        tmp___15 = 1;
      } else
#line 2582
      if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 2582
        tmp___15 = 1;
      } else {
#line 2582
        tmp___15 = 0;
      }
#line 2582
      tmp___16 = __builtin_expect((long )tmp___15, 0L);
#line 2582
      if (tmp___16) {
#line 2583
        goto parse_dup_op_espace;
      }
#line 2585
      tree = create_tree(dfa, tree, (bin_tree_t *)((void *)0), (re_token_type_t )10);
#line 2586
      tmp___17 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                                  0L);
#line 2586
      if (tmp___17) {
#line 2587
        goto parse_dup_op_espace;
      }
#line 2578
      i ++;
    }
  }
#line 2590
  if (old_tree) {
#line 2591
    tree = create_tree(dfa, old_tree, tree, (re_token_type_t )16);
  }
#line 2593
  return (tree);
  parse_dup_op_espace: 
#line 2596
  *err = (reg_errcode_t )12;
#line 2597
  return ((bin_tree_t *)((void *)0));
}
}
#line 2612 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t build_range_exp(bitset_word_t *sbcset , re_charset_t *mbcset ,
                                     Idx *range_alloc , bracket_elem_t *start_elem ,
                                     bracket_elem_t *end_elem ) 
{ 
  unsigned int start_ch ;
  unsigned int end_ch ;
  int tmp ;
  long tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  wchar_t wc ;
  wint_t start_wc ;
  wint_t end_wc ;
  wchar_t cmp_buf[6] ;
  int tmp___5 ;
  int tmp___6 ;
  wint_t tmp___7 ;
  wint_t tmp___8 ;
  int tmp___9 ;
  wchar_t *new_array_start ;
  wchar_t *new_array_end ;
  Idx new_nranges ;
  void *tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  Idx tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 2624
  if ((unsigned int )start_elem->type == 2U) {
#line 2624
    tmp = 1;
  } else
#line 2624
  if ((unsigned int )start_elem->type == 4U) {
#line 2624
    tmp = 1;
  } else
#line 2624
  if ((unsigned int )end_elem->type == 2U) {
#line 2624
    tmp = 1;
  } else
#line 2624
  if ((unsigned int )end_elem->type == 4U) {
#line 2624
    tmp = 1;
  } else {
#line 2624
    tmp = 0;
  }
#line 2624
  tmp___0 = __builtin_expect((long )tmp, 0L);
#line 2624
  if (tmp___0) {
#line 2627
    return ((reg_errcode_t )11);
  }
#line 2631
  if ((unsigned int )start_elem->type == 3U) {
#line 2631
    tmp___1 = strlen((char const   *)((char *)start_elem->opr.name));
#line 2631
    if (tmp___1 > 1UL) {
#line 2631
      tmp___3 = 1;
    } else {
#line 2631
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2631
  if ((unsigned int )end_elem->type == 3U) {
#line 2631
    tmp___2 = strlen((char const   *)((char *)end_elem->opr.name));
#line 2631
    if (tmp___2 > 1UL) {
#line 2631
      tmp___3 = 1;
    } else {
#line 2631
      tmp___3 = 0;
    }
  } else {
#line 2631
    tmp___3 = 0;
  }
#line 2631
  tmp___4 = __builtin_expect((long )tmp___3, 0L);
#line 2631
  if (tmp___4) {
#line 2635
    return ((reg_errcode_t )3);
  }
#line 2642
  cmp_buf[0] = 0;
#line 2642
  cmp_buf[1] = 0;
#line 2642
  cmp_buf[2] = 0;
#line 2642
  cmp_buf[3] = 0;
#line 2642
  cmp_buf[4] = 0;
#line 2642
  cmp_buf[5] = 0;
#line 2644
  if ((unsigned int )start_elem->type == 0U) {
#line 2644
    start_ch = (unsigned int )start_elem->opr.ch;
  } else {
#line 2644
    if ((unsigned int )start_elem->type == 3U) {
#line 2644
      tmp___5 = (int )*(start_elem->opr.name + 0);
    } else {
#line 2644
      tmp___5 = 0;
    }
#line 2644
    start_ch = (unsigned int )tmp___5;
  }
#line 2647
  if ((unsigned int )end_elem->type == 0U) {
#line 2647
    end_ch = (unsigned int )end_elem->opr.ch;
  } else {
#line 2647
    if ((unsigned int )end_elem->type == 3U) {
#line 2647
      tmp___6 = (int )*(end_elem->opr.name + 0);
    } else {
#line 2647
      tmp___6 = 0;
    }
#line 2647
    end_ch = (unsigned int )tmp___6;
  }
#line 2650
  if ((unsigned int )start_elem->type == 0U) {
#line 2650
    tmp___7 = btowc((int )start_ch);
#line 2650
    start_wc = tmp___7;
  } else
#line 2650
  if ((unsigned int )start_elem->type == 3U) {
#line 2650
    tmp___7 = btowc((int )start_ch);
#line 2650
    start_wc = tmp___7;
  } else {
#line 2650
    start_wc = (wint_t )start_elem->opr.wch;
  }
#line 2652
  if ((unsigned int )end_elem->type == 0U) {
#line 2652
    tmp___8 = btowc((int )end_ch);
#line 2652
    end_wc = tmp___8;
  } else
#line 2652
  if ((unsigned int )end_elem->type == 3U) {
#line 2652
    tmp___8 = btowc((int )end_ch);
#line 2652
    end_wc = tmp___8;
  } else {
#line 2652
    end_wc = (wint_t )end_elem->opr.wch;
  }
#line 2654
  if (start_wc == 4294967295U) {
#line 2655
    return ((reg_errcode_t )3);
  } else
#line 2654
  if (end_wc == 4294967295U) {
#line 2655
    return ((reg_errcode_t )3);
  }
#line 2656
  cmp_buf[0] = (wchar_t )start_wc;
#line 2657
  cmp_buf[4] = (wchar_t )end_wc;
#line 2658
  tmp___9 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 4));
#line 2658
  if (tmp___9 > 0) {
#line 2659
    return ((reg_errcode_t )11);
  }
#line 2666
  if (mbcset) {
#line 2669
    tmp___14 = __builtin_expect((long )(*range_alloc == mbcset->nranges), 0L);
#line 2669
    if (tmp___14) {
#line 2676
      new_nranges = 2UL * mbcset->nranges + 1UL;
#line 2679
      tmp___10 = realloc((void *)mbcset->range_starts, new_nranges * sizeof(wchar_t ));
#line 2679
      new_array_start = (wchar_t *)tmp___10;
#line 2681
      tmp___11 = realloc((void *)mbcset->range_ends, new_nranges * sizeof(wchar_t ));
#line 2681
      new_array_end = (wchar_t *)tmp___11;
#line 2684
      if ((unsigned long )new_array_start == (unsigned long )((void *)0)) {
#line 2684
        tmp___12 = 1;
      } else
#line 2684
      if ((unsigned long )new_array_end == (unsigned long )((void *)0)) {
#line 2684
        tmp___12 = 1;
      } else {
#line 2684
        tmp___12 = 0;
      }
#line 2684
      tmp___13 = __builtin_expect((long )tmp___12, 0L);
#line 2684
      if (tmp___13) {
#line 2685
        return ((reg_errcode_t )12);
      }
#line 2687
      mbcset->range_starts = new_array_start;
#line 2688
      mbcset->range_ends = new_array_end;
#line 2689
      *range_alloc = new_nranges;
    }
#line 2692
    *(mbcset->range_starts + mbcset->nranges) = (wchar_t )start_wc;
#line 2693
    tmp___15 = mbcset->nranges;
#line 2693
    (mbcset->nranges) ++;
#line 2693
    *(mbcset->range_ends + tmp___15) = (wchar_t )end_wc;
  }
#line 2697
  wc = 0;
#line 2697
  while (wc < 256) {
#line 2699
    cmp_buf[2] = wc;
#line 2700
    tmp___16 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
#line 2700
    if (tmp___16 <= 0) {
#line 2700
      tmp___17 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
#line 2700
      if (tmp___17 <= 0) {
#line 2702
        bitset_set(sbcset, (Idx )wc);
      }
    }
#line 2697
    wc ++;
  }
#line 2722
  return ((reg_errcode_t )0);
}
}
#line 2733 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t build_collating_symbol(bitset_word_t *sbcset , re_charset_t *mbcset  __attribute__((__unused__)) ,
                                            Idx *coll_sym_alloc  __attribute__((__unused__)) ,
                                            unsigned char const   *name ) 
{ 
  size_t name_len ;
  size_t tmp ;
  long tmp___0 ;

  {
#line 2742
  tmp = strlen((char const   *)name);
#line 2742
  name_len = tmp;
#line 2743
  tmp___0 = __builtin_expect((long )(name_len != 1UL), 0L);
#line 2743
  if (tmp___0) {
#line 2744
    return ((reg_errcode_t )3);
  } else {
#line 2747
    bitset_set(sbcset, (Idx )*(name + 0));
#line 2748
    return ((reg_errcode_t )0);
  }
}
}
#line 2756 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *parse_bracket_exp(re_string_t *regexp , re_dfa_t *dfa , re_token_t *token ,
                                     reg_syntax_t syntax , reg_errcode_t *err ) 
{ 
  re_token_t br_token ;
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx coll_sym_alloc ;
  Idx range_alloc ;
  Idx mbchar_alloc ;
  Idx equiv_class_alloc ;
  Idx char_class_alloc ;
  _Bool non_match ;
  bin_tree_t *work_tree ;
  int token_len ;
  _Bool first_round ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bracket_elem_t start_elem ;
  bracket_elem_t end_elem ;
  unsigned char start_name_buf[32] ;
  unsigned char end_name_buf[32] ;
  reg_errcode_t ret ;
  int token_len2 ;
  _Bool is_range_exp ;
  re_token_t token2 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  re_charset_t *tmp___9 ;
  long tmp___10 ;
  wchar_t *new_mbchars ;
  void *tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  Idx tmp___14 ;
  long tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  bin_tree_t *mbc_tree ;
  int sbc_idx ;
  long tmp___19 ;
  long tmp___20 ;
  long tmp___21 ;
  long tmp___22 ;

  {
#line 3027
  coll_sym_alloc = (Idx )0;
#line 3027
  range_alloc = (Idx )0;
#line 3027
  mbchar_alloc = (Idx )0;
#line 3028
  equiv_class_alloc = (Idx )0;
#line 3028
  char_class_alloc = (Idx )0;
#line 3030
  non_match = (_Bool)0;
#line 3033
  first_round = (_Bool)1;
#line 3051
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3051
  sbcset = (re_bitset_ptr_t )tmp;
#line 3053
  tmp___0 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3053
  mbcset = (re_charset_t *)tmp___0;
#line 3056
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3056
    tmp___1 = 1;
  } else
#line 3056
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3056
    tmp___1 = 1;
  } else {
#line 3056
    tmp___1 = 0;
  }
#line 3056
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 3056
  if (tmp___2) {
#line 3061
    *err = (reg_errcode_t )12;
#line 3062
    return ((bin_tree_t *)((void *)0));
  }
#line 3065
  token_len = peek_token_bracket(token, regexp, syntax);
#line 3066
  tmp___3 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
#line 3066
  if (tmp___3) {
#line 3068
    *err = (reg_errcode_t )2;
#line 3069
    goto parse_bracket_exp_free_return;
  }
#line 3071
  if ((unsigned int )token->type == 25U) {
#line 3074
    mbcset->non_match = 1U;
#line 3076
    non_match = (_Bool)1;
#line 3077
    if (syntax & ((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3078
      bitset_set((bitset_word_t *)sbcset, (Idx )'\n');
    }
#line 3079
    regexp->cur_idx += (Idx )token_len;
#line 3080
    token_len = peek_token_bracket(token, regexp, syntax);
#line 3081
    tmp___4 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
#line 3081
    if (tmp___4) {
#line 3083
      *err = (reg_errcode_t )2;
#line 3084
      goto parse_bracket_exp_free_return;
    }
  }
#line 3089
  if ((unsigned int )token->type == 21U) {
#line 3090
    token->type = (re_token_type_t )1;
  }
#line 3092
  while (1) {
#line 3098
    token_len2 = 0;
#line 3099
    is_range_exp = (_Bool)0;
#line 3102
    start_elem.opr.name = start_name_buf;
#line 3103
    ret = parse_bracket_element(& start_elem, regexp, token, token_len, dfa, syntax,
                                first_round);
#line 3105
    tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
#line 3105
    if (tmp___5) {
#line 3107
      *err = ret;
#line 3108
      goto parse_bracket_exp_free_return;
    }
#line 3110
    first_round = (_Bool)0;
#line 3113
    token_len = peek_token_bracket(token, regexp, syntax);
#line 3116
    if ((unsigned int )start_elem.type != 4U) {
#line 3116
      if ((unsigned int )start_elem.type != 2U) {
#line 3118
        tmp___6 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
#line 3118
        if (tmp___6) {
#line 3120
          *err = (reg_errcode_t )7;
#line 3121
          goto parse_bracket_exp_free_return;
        }
#line 3123
        if ((unsigned int )token->type == 22U) {
#line 3125
          regexp->cur_idx += (Idx )token_len;
#line 3126
          token_len2 = peek_token_bracket(& token2, regexp, syntax);
#line 3127
          tmp___7 = __builtin_expect((long )((unsigned int )token2.type == 2U), 0L);
#line 3127
          if (tmp___7) {
#line 3129
            *err = (reg_errcode_t )7;
#line 3130
            goto parse_bracket_exp_free_return;
          }
#line 3132
          if ((unsigned int )token2.type == 21U) {
#line 3135
            regexp->cur_idx += (Idx )(- token_len);
#line 3136
            token->type = (re_token_type_t )1;
          } else {
#line 3139
            is_range_exp = (_Bool)1;
          }
        }
      }
    }
#line 3143
    if ((int )is_range_exp == 1) {
#line 3145
      end_elem.opr.name = end_name_buf;
#line 3146
      ret = parse_bracket_element(& end_elem, regexp, & token2, token_len2, dfa, syntax,
                                  (_Bool)1);
#line 3148
      tmp___8 = __builtin_expect((long )((int )ret != 0), 0L);
#line 3148
      if (tmp___8) {
#line 3150
        *err = ret;
#line 3151
        goto parse_bracket_exp_free_return;
      }
#line 3154
      token_len = peek_token_bracket(token, regexp, syntax);
#line 3161
      if (dfa->mb_cur_max > 1) {
#line 3161
        tmp___9 = mbcset;
      } else {
#line 3161
        tmp___9 = (re_charset_t *)((void *)0);
      }
#line 3161
      *err = build_range_exp((bitset_word_t *)sbcset, tmp___9, & range_alloc, & start_elem,
                             & end_elem);
#line 3168
      tmp___10 = __builtin_expect((long )((int )*err != 0), 0L);
#line 3168
      if (tmp___10) {
#line 3169
        goto parse_bracket_exp_free_return;
      }
    } else {
#line 3173
      switch ((unsigned int )start_elem.type) {
      case 0U: 
#line 3176
      bitset_set((bitset_word_t *)sbcset, (Idx )start_elem.opr.ch);
#line 3177
      break;
      case 1U: 
#line 3181
      tmp___13 = __builtin_expect((long )(mbchar_alloc == mbcset->nmbchars), 0L);
#line 3181
      if (tmp___13) {
#line 3186
        mbchar_alloc = 2UL * mbcset->nmbchars + 1UL;
#line 3188
        tmp___11 = realloc((void *)mbcset->mbchars, mbchar_alloc * sizeof(wchar_t ));
#line 3188
        new_mbchars = (wchar_t *)tmp___11;
#line 3190
        tmp___12 = __builtin_expect((long )((unsigned long )new_mbchars == (unsigned long )((void *)0)),
                                    0L);
#line 3190
        if (tmp___12) {
#line 3191
          goto parse_bracket_exp_espace;
        }
#line 3192
        mbcset->mbchars = new_mbchars;
      }
#line 3194
      tmp___14 = mbcset->nmbchars;
#line 3194
      (mbcset->nmbchars) ++;
#line 3194
      *(mbcset->mbchars + tmp___14) = start_elem.opr.wch;
#line 3195
      break;
      case 2U: 
#line 3198
      *err = build_equiv_class((bitset_word_t *)sbcset, mbcset, & equiv_class_alloc,
                               (unsigned char const   *)start_elem.opr.name);
#line 3203
      tmp___15 = __builtin_expect((long )((int )*err != 0), 0L);
#line 3203
      if (tmp___15) {
#line 3204
        goto parse_bracket_exp_free_return;
      }
#line 3205
      break;
      case 3U: 
#line 3207
      *err = build_collating_symbol((bitset_word_t *)sbcset, mbcset, & coll_sym_alloc,
                                    (unsigned char const   *)start_elem.opr.name);
#line 3212
      tmp___16 = __builtin_expect((long )((int )*err != 0), 0L);
#line 3212
      if (tmp___16) {
#line 3213
        goto parse_bracket_exp_free_return;
      }
#line 3214
      break;
      case 4U: 
#line 3216
      *err = build_charclass(regexp->trans, (bitset_word_t *)sbcset, mbcset, & char_class_alloc,
                             (unsigned char const   *)start_elem.opr.name, syntax);
#line 3221
      tmp___17 = __builtin_expect((long )((int )*err != 0), 0L);
#line 3221
      if (tmp___17) {
#line 3222
        goto parse_bracket_exp_free_return;
      }
#line 3223
      break;
      default: 
#line 3225
      __assert_fail("0", "/home/wslee/project/coreutils-8.1/lib/regcomp.c", 3225U,
                    "parse_bracket_exp");
#line 3226
      break;
      }
    }
#line 3229
    tmp___18 = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
#line 3229
    if (tmp___18) {
#line 3231
      *err = (reg_errcode_t )7;
#line 3232
      goto parse_bracket_exp_free_return;
    }
#line 3234
    if ((unsigned int )token->type == 21U) {
#line 3235
      break;
    }
  }
#line 3238
  regexp->cur_idx += (Idx )token_len;
#line 3241
  if (non_match) {
#line 3242
    bitset_not((bitset_word_t *)sbcset);
  }
#line 3246
  if (dfa->mb_cur_max > 1) {
#line 3247
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t * const  )dfa->sb_char);
  }
#line 3249
  if (mbcset->nmbchars) {
#line 3249
    goto _L___1;
  } else
#line 3249
  if (mbcset->ncoll_syms) {
#line 3249
    goto _L___1;
  } else
#line 3249
  if (mbcset->nequiv_classes) {
#line 3249
    goto _L___1;
  } else
#line 3249
  if (mbcset->nranges) {
#line 3249
    goto _L___1;
  } else
#line 3249
  if (dfa->mb_cur_max > 1) {
#line 3249
    if (mbcset->nchar_classes) {
#line 3249
      goto _L___1;
    } else
#line 3249
    if (mbcset->non_match) {
      _L___1: /* CIL Label */ 
#line 3256
      dfa->has_mb_node = 1U;
#line 3257
      br_token.type = (re_token_type_t )6;
#line 3258
      br_token.opr.mbcset = mbcset;
#line 3259
      mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                   (re_token_t const   *)(& br_token));
#line 3260
      tmp___19 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                                  0L);
#line 3260
      if (tmp___19) {
#line 3261
        goto parse_bracket_exp_espace;
      }
#line 3262
      sbc_idx = 0;
#line 3262
      while (sbc_idx < 4) {
#line 3263
        if (*(sbcset + sbc_idx)) {
#line 3264
          break;
        }
#line 3262
        sbc_idx ++;
      }
#line 3267
      if (sbc_idx < 4) {
#line 3270
        br_token.type = (re_token_type_t )3;
#line 3271
        br_token.opr.sbcset = sbcset;
#line 3272
        work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                      (re_token_t const   *)(& br_token));
#line 3273
        tmp___20 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
#line 3273
        if (tmp___20) {
#line 3274
          goto parse_bracket_exp_espace;
        }
#line 3277
        work_tree = create_tree(dfa, work_tree, mbc_tree, (re_token_type_t )10);
#line 3278
        tmp___21 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                    0L);
#line 3278
        if (tmp___21) {
#line 3279
          goto parse_bracket_exp_espace;
        }
      } else {
#line 3283
        free((void *)sbcset);
#line 3284
        work_tree = mbc_tree;
      }
    } else {
#line 3249
      goto _L___0;
    }
  } else {
    _L___0: /* CIL Label */ 
#line 3291
    free_charset(mbcset);
#line 3294
    br_token.type = (re_token_type_t )3;
#line 3295
    br_token.opr.sbcset = sbcset;
#line 3296
    work_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                  (re_token_t const   *)(& br_token));
#line 3297
    tmp___22 = __builtin_expect((long )((unsigned long )work_tree == (unsigned long )((void *)0)),
                                0L);
#line 3297
    if (tmp___22) {
#line 3298
      goto parse_bracket_exp_espace;
    }
  }
#line 3300
  return (work_tree);
  parse_bracket_exp_espace: 
#line 3303
  *err = (reg_errcode_t )12;
  parse_bracket_exp_free_return: 
#line 3305
  free((void *)sbcset);
#line 3307
  free_charset(mbcset);
#line 3309
  return ((bin_tree_t *)((void *)0));
}
}
#line 3314 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t parse_bracket_element(bracket_elem_t *elem , re_string_t *regexp ,
                                           re_token_t *token , int token_len , re_dfa_t *dfa  __attribute__((__unused__)) ,
                                           reg_syntax_t syntax , _Bool accept_hyphen ) 
{ 
  int cur_char_size ;
  int __attribute__((__pure__))  tmp ;
  wint_t __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  re_token_t token2 ;
  long tmp___2 ;

  {
#line 3322
  tmp = re_string_char_size_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3322
  cur_char_size = (int )tmp;
#line 3323
  if (cur_char_size > 1) {
#line 3325
    elem->type = (bracket_elem_type )1;
#line 3326
    tmp___0 = re_string_wchar_at((re_string_t const   *)regexp, regexp->cur_idx);
#line 3326
    elem->opr.wch = (wchar_t )tmp___0;
#line 3327
    regexp->cur_idx += (Idx )cur_char_size;
#line 3328
    return ((reg_errcode_t )0);
  }
#line 3331
  regexp->cur_idx += (Idx )token_len;
#line 3332
  if ((unsigned int )token->type == 26U) {
#line 3334
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
#line 3334
    return (tmp___1);
  } else
#line 3332
  if ((unsigned int )token->type == 30U) {
#line 3334
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
#line 3334
    return (tmp___1);
  } else
#line 3332
  if ((unsigned int )token->type == 28U) {
#line 3334
    tmp___1 = parse_bracket_symbol(elem, regexp, token);
#line 3334
    return (tmp___1);
  }
#line 3335
  tmp___2 = __builtin_expect((long )((unsigned int )token->type == 22U), 0L);
#line 3335
  if (tmp___2) {
#line 3335
    if (! accept_hyphen) {
#line 3340
      peek_token_bracket(& token2, regexp, syntax);
#line 3341
      if ((unsigned int )token2.type != 21U) {
#line 3344
        return ((reg_errcode_t )11);
      }
    }
  }
#line 3346
  elem->type = (bracket_elem_type )0;
#line 3347
  elem->opr.ch = token->opr.c;
#line 3348
  return ((reg_errcode_t )0);
}
}
#line 3355 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t parse_bracket_symbol(bracket_elem_t *elem , re_string_t *regexp ,
                                          re_token_t *token ) 
{ 
  unsigned char ch ;
  unsigned char delim ;
  int i ;
  unsigned char __attribute__((__pure__))  tmp ;
  Idx tmp___0 ;

  {
#line 3359
  delim = token->opr.c;
#line 3360
  i = 0;
#line 3361
  if (regexp->stop <= regexp->cur_idx) {
#line 3362
    return ((reg_errcode_t )7);
  }
#line 3363
  while (1) {
#line 3365
    if (i >= 32) {
#line 3366
      return ((reg_errcode_t )7);
    }
#line 3367
    if ((unsigned int )token->type == 30U) {
#line 3368
      tmp = re_string_fetch_byte_case(regexp);
#line 3368
      ch = (unsigned char )tmp;
    } else {
#line 3370
      tmp___0 = regexp->cur_idx;
#line 3370
      (regexp->cur_idx) ++;
#line 3370
      ch = *(regexp->mbs + tmp___0);
    }
#line 3371
    if (regexp->stop <= regexp->cur_idx) {
#line 3372
      return ((reg_errcode_t )7);
    }
#line 3373
    if ((int )ch == (int )delim) {
#line 3373
      if ((int )*(regexp->mbs + regexp->cur_idx) == 93) {
#line 3374
        break;
      }
    }
#line 3375
    *(elem->opr.name + i) = ch;
#line 3363
    i ++;
  }
#line 3377
  (regexp->cur_idx) ++;
#line 3378
  *(elem->opr.name + i) = (unsigned char )'\000';
#line 3379
  switch ((unsigned int )token->type) {
  case 26U: 
#line 3382
  elem->type = (bracket_elem_type )3;
#line 3383
  break;
  case 28U: 
#line 3385
  elem->type = (bracket_elem_type )2;
#line 3386
  break;
  case 30U: 
#line 3388
  elem->type = (bracket_elem_type )4;
#line 3389
  break;
  default: 
#line 3391
  break;
  }
#line 3393
  return ((reg_errcode_t )0);
}
}
#line 3402 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t build_equiv_class(bitset_word_t *sbcset , re_charset_t *mbcset  __attribute__((__unused__)) ,
                                       Idx *equiv_class_alloc  __attribute__((__unused__)) ,
                                       unsigned char const   *name ) 
{ 
  size_t tmp ;
  long tmp___0 ;

  {
#line 3482
  tmp = strlen((char const   *)name);
#line 3482
  tmp___0 = __builtin_expect((long )(tmp != 1UL), 0L);
#line 3482
  if (tmp___0) {
#line 3483
    return ((reg_errcode_t )3);
  }
#line 3484
  bitset_set(sbcset, (Idx )*name);
#line 3486
  return ((reg_errcode_t )0);
}
}
#line 3495 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t build_charclass(unsigned char *trans , bitset_word_t *sbcset ,
                                     re_charset_t *mbcset , Idx *char_class_alloc ,
                                     unsigned char const   *class_name , reg_syntax_t syntax ) 
{ 
  int i ;
  char const   *name ;
  int tmp ;
  int tmp___0 ;
  Idx new_char_class_alloc ;
  wctype_t *new_char_classes ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  long tmp___7 ;
  unsigned short const   **tmp___8 ;
  unsigned short const   **tmp___9 ;
  long tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  long tmp___13 ;
  unsigned short const   **tmp___14 ;
  unsigned short const   **tmp___15 ;
  long tmp___16 ;
  unsigned short const   **tmp___17 ;
  unsigned short const   **tmp___18 ;
  long tmp___19 ;
  unsigned short const   **tmp___20 ;
  unsigned short const   **tmp___21 ;
  long tmp___22 ;
  unsigned short const   **tmp___23 ;
  unsigned short const   **tmp___24 ;
  long tmp___25 ;
  unsigned short const   **tmp___26 ;
  unsigned short const   **tmp___27 ;
  long tmp___28 ;
  unsigned short const   **tmp___29 ;
  unsigned short const   **tmp___30 ;
  long tmp___31 ;
  unsigned short const   **tmp___32 ;
  unsigned short const   **tmp___33 ;
  long tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  long tmp___37 ;
  unsigned short const   **tmp___38 ;
  unsigned short const   **tmp___39 ;
  long tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;

  {
#line 3506
  name = (char const   *)class_name;
#line 3510
  if (syntax & ((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3510
    tmp = strcmp(name, "upper");
#line 3510
    if (tmp == 0) {
#line 3512
      name = "alpha";
    } else {
#line 3510
      tmp___0 = strcmp(name, "lower");
#line 3510
      if (tmp___0 == 0) {
#line 3512
        name = "alpha";
      }
    }
  }
#line 3516
  tmp___3 = __builtin_expect((long )(*char_class_alloc == mbcset->nchar_classes),
                             0L);
#line 3516
  if (tmp___3) {
#line 3520
    new_char_class_alloc = 2UL * mbcset->nchar_classes + 1UL;
#line 3522
    tmp___1 = realloc((void *)mbcset->char_classes, new_char_class_alloc * sizeof(wctype_t ));
#line 3522
    new_char_classes = (wctype_t *)tmp___1;
#line 3524
    tmp___2 = __builtin_expect((long )((unsigned long )new_char_classes == (unsigned long )((void *)0)),
                               0L);
#line 3524
    if (tmp___2) {
#line 3525
      return ((reg_errcode_t )12);
    }
#line 3526
    mbcset->char_classes = new_char_classes;
#line 3527
    *char_class_alloc = new_char_class_alloc;
  }
#line 3529
  tmp___4 = mbcset->nchar_classes;
#line 3529
  (mbcset->nchar_classes) ++;
#line 3529
  *(mbcset->char_classes + tmp___4) = wctype(name);
#line 3548
  tmp___52 = strcmp(name, "alnum");
#line 3548
  if (tmp___52 == 0) {
#line 3549
    while (1) {
#line 3549
      tmp___7 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                 0L);
#line 3549
      if (tmp___7) {
#line 3549
        i = 0;
#line 3549
        while (i < 256) {
#line 3549
          tmp___5 = __ctype_b_loc();
#line 3549
          if ((int const   )*(*tmp___5 + i) & 8) {
#line 3549
            bitset_set(sbcset, (Idx )*(trans + i));
          }
#line 3549
          i ++;
        }
      } else {
#line 3549
        i = 0;
#line 3549
        while (i < 256) {
#line 3549
          tmp___6 = __ctype_b_loc();
#line 3549
          if ((int const   )*(*tmp___6 + i) & 8) {
#line 3549
            bitset_set(sbcset, (Idx )i);
          }
#line 3549
          i ++;
        }
      }
#line 3549
      break;
    }
  } else {
#line 3550
    tmp___51 = strcmp(name, "cntrl");
#line 3550
    if (tmp___51 == 0) {
#line 3551
      while (1) {
#line 3551
        tmp___10 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                    0L);
#line 3551
        if (tmp___10) {
#line 3551
          i = 0;
#line 3551
          while (i < 256) {
#line 3551
            tmp___8 = __ctype_b_loc();
#line 3551
            if ((int const   )*(*tmp___8 + i) & 2) {
#line 3551
              bitset_set(sbcset, (Idx )*(trans + i));
            }
#line 3551
            i ++;
          }
        } else {
#line 3551
          i = 0;
#line 3551
          while (i < 256) {
#line 3551
            tmp___9 = __ctype_b_loc();
#line 3551
            if ((int const   )*(*tmp___9 + i) & 2) {
#line 3551
              bitset_set(sbcset, (Idx )i);
            }
#line 3551
            i ++;
          }
        }
#line 3551
        break;
      }
    } else {
#line 3552
      tmp___50 = strcmp(name, "lower");
#line 3552
      if (tmp___50 == 0) {
#line 3553
        while (1) {
#line 3553
          tmp___13 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                      0L);
#line 3553
          if (tmp___13) {
#line 3553
            i = 0;
#line 3553
            while (i < 256) {
#line 3553
              tmp___11 = __ctype_b_loc();
#line 3553
              if ((int const   )*(*tmp___11 + i) & 512) {
#line 3553
                bitset_set(sbcset, (Idx )*(trans + i));
              }
#line 3553
              i ++;
            }
          } else {
#line 3553
            i = 0;
#line 3553
            while (i < 256) {
#line 3553
              tmp___12 = __ctype_b_loc();
#line 3553
              if ((int const   )*(*tmp___12 + i) & 512) {
#line 3553
                bitset_set(sbcset, (Idx )i);
              }
#line 3553
              i ++;
            }
          }
#line 3553
          break;
        }
      } else {
#line 3554
        tmp___49 = strcmp(name, "space");
#line 3554
        if (tmp___49 == 0) {
#line 3555
          while (1) {
#line 3555
            tmp___16 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                        0L);
#line 3555
            if (tmp___16) {
#line 3555
              i = 0;
#line 3555
              while (i < 256) {
#line 3555
                tmp___14 = __ctype_b_loc();
#line 3555
                if ((int const   )*(*tmp___14 + i) & 8192) {
#line 3555
                  bitset_set(sbcset, (Idx )*(trans + i));
                }
#line 3555
                i ++;
              }
            } else {
#line 3555
              i = 0;
#line 3555
              while (i < 256) {
#line 3555
                tmp___15 = __ctype_b_loc();
#line 3555
                if ((int const   )*(*tmp___15 + i) & 8192) {
#line 3555
                  bitset_set(sbcset, (Idx )i);
                }
#line 3555
                i ++;
              }
            }
#line 3555
            break;
          }
        } else {
#line 3556
          tmp___48 = strcmp(name, "alpha");
#line 3556
          if (tmp___48 == 0) {
#line 3557
            while (1) {
#line 3557
              tmp___19 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                          0L);
#line 3557
              if (tmp___19) {
#line 3557
                i = 0;
#line 3557
                while (i < 256) {
#line 3557
                  tmp___17 = __ctype_b_loc();
#line 3557
                  if ((int const   )*(*tmp___17 + i) & 1024) {
#line 3557
                    bitset_set(sbcset, (Idx )*(trans + i));
                  }
#line 3557
                  i ++;
                }
              } else {
#line 3557
                i = 0;
#line 3557
                while (i < 256) {
#line 3557
                  tmp___18 = __ctype_b_loc();
#line 3557
                  if ((int const   )*(*tmp___18 + i) & 1024) {
#line 3557
                    bitset_set(sbcset, (Idx )i);
                  }
#line 3557
                  i ++;
                }
              }
#line 3557
              break;
            }
          } else {
#line 3558
            tmp___47 = strcmp(name, "digit");
#line 3558
            if (tmp___47 == 0) {
#line 3559
              while (1) {
#line 3559
                tmp___22 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                            0L);
#line 3559
                if (tmp___22) {
#line 3559
                  i = 0;
#line 3559
                  while (i < 256) {
#line 3559
                    tmp___20 = __ctype_b_loc();
#line 3559
                    if ((int const   )*(*tmp___20 + i) & 2048) {
#line 3559
                      bitset_set(sbcset, (Idx )*(trans + i));
                    }
#line 3559
                    i ++;
                  }
                } else {
#line 3559
                  i = 0;
#line 3559
                  while (i < 256) {
#line 3559
                    tmp___21 = __ctype_b_loc();
#line 3559
                    if ((int const   )*(*tmp___21 + i) & 2048) {
#line 3559
                      bitset_set(sbcset, (Idx )i);
                    }
#line 3559
                    i ++;
                  }
                }
#line 3559
                break;
              }
            } else {
#line 3560
              tmp___46 = strcmp(name, "print");
#line 3560
              if (tmp___46 == 0) {
#line 3561
                while (1) {
#line 3561
                  tmp___25 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                              0L);
#line 3561
                  if (tmp___25) {
#line 3561
                    i = 0;
#line 3561
                    while (i < 256) {
#line 3561
                      tmp___23 = __ctype_b_loc();
#line 3561
                      if ((int const   )*(*tmp___23 + i) & 16384) {
#line 3561
                        bitset_set(sbcset, (Idx )*(trans + i));
                      }
#line 3561
                      i ++;
                    }
                  } else {
#line 3561
                    i = 0;
#line 3561
                    while (i < 256) {
#line 3561
                      tmp___24 = __ctype_b_loc();
#line 3561
                      if ((int const   )*(*tmp___24 + i) & 16384) {
#line 3561
                        bitset_set(sbcset, (Idx )i);
                      }
#line 3561
                      i ++;
                    }
                  }
#line 3561
                  break;
                }
              } else {
#line 3562
                tmp___45 = strcmp(name, "upper");
#line 3562
                if (tmp___45 == 0) {
#line 3563
                  while (1) {
#line 3563
                    tmp___28 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                0L);
#line 3563
                    if (tmp___28) {
#line 3563
                      i = 0;
#line 3563
                      while (i < 256) {
#line 3563
                        tmp___26 = __ctype_b_loc();
#line 3563
                        if ((int const   )*(*tmp___26 + i) & 256) {
#line 3563
                          bitset_set(sbcset, (Idx )*(trans + i));
                        }
#line 3563
                        i ++;
                      }
                    } else {
#line 3563
                      i = 0;
#line 3563
                      while (i < 256) {
#line 3563
                        tmp___27 = __ctype_b_loc();
#line 3563
                        if ((int const   )*(*tmp___27 + i) & 256) {
#line 3563
                          bitset_set(sbcset, (Idx )i);
                        }
#line 3563
                        i ++;
                      }
                    }
#line 3563
                    break;
                  }
                } else {
#line 3564
                  tmp___44 = strcmp(name, "blank");
#line 3564
                  if (tmp___44 == 0) {
#line 3565
                    while (1) {
#line 3565
                      tmp___31 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                  0L);
#line 3565
                      if (tmp___31) {
#line 3565
                        i = 0;
#line 3565
                        while (i < 256) {
#line 3565
                          tmp___29 = __ctype_b_loc();
#line 3565
                          if ((int const   )*(*tmp___29 + i) & 1) {
#line 3565
                            bitset_set(sbcset, (Idx )*(trans + i));
                          }
#line 3565
                          i ++;
                        }
                      } else {
#line 3565
                        i = 0;
#line 3565
                        while (i < 256) {
#line 3565
                          tmp___30 = __ctype_b_loc();
#line 3565
                          if ((int const   )*(*tmp___30 + i) & 1) {
#line 3565
                            bitset_set(sbcset, (Idx )i);
                          }
#line 3565
                          i ++;
                        }
                      }
#line 3565
                      break;
                    }
                  } else {
#line 3566
                    tmp___43 = strcmp(name, "graph");
#line 3566
                    if (tmp___43 == 0) {
#line 3567
                      while (1) {
#line 3567
                        tmp___34 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                    0L);
#line 3567
                        if (tmp___34) {
#line 3567
                          i = 0;
#line 3567
                          while (i < 256) {
#line 3567
                            tmp___32 = __ctype_b_loc();
#line 3567
                            if ((int const   )*(*tmp___32 + i) & 32768) {
#line 3567
                              bitset_set(sbcset, (Idx )*(trans + i));
                            }
#line 3567
                            i ++;
                          }
                        } else {
#line 3567
                          i = 0;
#line 3567
                          while (i < 256) {
#line 3567
                            tmp___33 = __ctype_b_loc();
#line 3567
                            if ((int const   )*(*tmp___33 + i) & 32768) {
#line 3567
                              bitset_set(sbcset, (Idx )i);
                            }
#line 3567
                            i ++;
                          }
                        }
#line 3567
                        break;
                      }
                    } else {
#line 3568
                      tmp___42 = strcmp(name, "punct");
#line 3568
                      if (tmp___42 == 0) {
#line 3569
                        while (1) {
#line 3569
                          tmp___37 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                      0L);
#line 3569
                          if (tmp___37) {
#line 3569
                            i = 0;
#line 3569
                            while (i < 256) {
#line 3569
                              tmp___35 = __ctype_b_loc();
#line 3569
                              if ((int const   )*(*tmp___35 + i) & 4) {
#line 3569
                                bitset_set(sbcset, (Idx )*(trans + i));
                              }
#line 3569
                              i ++;
                            }
                          } else {
#line 3569
                            i = 0;
#line 3569
                            while (i < 256) {
#line 3569
                              tmp___36 = __ctype_b_loc();
#line 3569
                              if ((int const   )*(*tmp___36 + i) & 4) {
#line 3569
                                bitset_set(sbcset, (Idx )i);
                              }
#line 3569
                              i ++;
                            }
                          }
#line 3569
                          break;
                        }
                      } else {
#line 3570
                        tmp___41 = strcmp(name, "xdigit");
#line 3570
                        if (tmp___41 == 0) {
#line 3571
                          while (1) {
#line 3571
                            tmp___40 = __builtin_expect((long )((unsigned long )trans != (unsigned long )((void *)0)),
                                                        0L);
#line 3571
                            if (tmp___40) {
#line 3571
                              i = 0;
#line 3571
                              while (i < 256) {
#line 3571
                                tmp___38 = __ctype_b_loc();
#line 3571
                                if ((int const   )*(*tmp___38 + i) & 4096) {
#line 3571
                                  bitset_set(sbcset, (Idx )*(trans + i));
                                }
#line 3571
                                i ++;
                              }
                            } else {
#line 3571
                              i = 0;
#line 3571
                              while (i < 256) {
#line 3571
                                tmp___39 = __ctype_b_loc();
#line 3571
                                if ((int const   )*(*tmp___39 + i) & 4096) {
#line 3571
                                  bitset_set(sbcset, (Idx )i);
                                }
#line 3571
                                i ++;
                              }
                            }
#line 3571
                            break;
                          }
                        } else {
#line 3573
                          return ((reg_errcode_t )4);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 3575
  return ((reg_errcode_t )0);
}
}
#line 3578 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *build_charclass_op(re_dfa_t *dfa , unsigned char *trans , unsigned char const   *class_name ,
                                      unsigned char const   *extra , _Bool non_match ,
                                      reg_errcode_t *err ) 
{ 
  re_bitset_ptr_t sbcset ;
  re_charset_t *mbcset ;
  Idx alloc ;
  reg_errcode_t ret ;
  re_token_t br_token ;
  bin_tree_t *tree ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  bin_tree_t *mbc_tree ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 3587
  alloc = (Idx )0;
#line 3593
  tmp = calloc(sizeof(bitset_t ), (size_t )1);
#line 3593
  sbcset = (re_bitset_ptr_t )tmp;
#line 3595
  tmp___0 = calloc(sizeof(re_charset_t ), (size_t )1);
#line 3595
  mbcset = (re_charset_t *)tmp___0;
#line 3599
  if ((unsigned long )sbcset == (unsigned long )((void *)0)) {
#line 3599
    tmp___1 = 1;
  } else
#line 3599
  if ((unsigned long )mbcset == (unsigned long )((void *)0)) {
#line 3599
    tmp___1 = 1;
  } else {
#line 3599
    tmp___1 = 0;
  }
#line 3599
  tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 3599
  if (tmp___2) {
#line 3604
    *err = (reg_errcode_t )12;
#line 3605
    return ((bin_tree_t *)((void *)0));
  }
#line 3608
  if (non_match) {
#line 3611
    mbcset->non_match = 1U;
  }
#line 3616
  ret = build_charclass(trans, (bitset_word_t *)sbcset, mbcset, & alloc, class_name,
                        (reg_syntax_t )0);
#line 3622
  tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
#line 3622
  if (tmp___3) {
#line 3624
    free((void *)sbcset);
#line 3626
    free_charset(mbcset);
#line 3628
    *err = ret;
#line 3629
    return ((bin_tree_t *)((void *)0));
  }
#line 3632
  while (*extra) {
#line 3633
    bitset_set((bitset_word_t *)sbcset, (Idx )*extra);
#line 3632
    extra ++;
  }
#line 3636
  if (non_match) {
#line 3637
    bitset_not((bitset_word_t *)sbcset);
  }
#line 3641
  if (dfa->mb_cur_max > 1) {
#line 3642
    bitset_mask((bitset_word_t *)sbcset, (bitset_word_t * const  )dfa->sb_char);
  }
#line 3646
  br_token.type = (re_token_type_t )3;
#line 3647
  br_token.opr.sbcset = sbcset;
#line 3648
  tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                           (re_token_t const   *)(& br_token));
#line 3649
  tmp___4 = __builtin_expect((long )((unsigned long )tree == (unsigned long )((void *)0)),
                             0L);
#line 3649
  if (tmp___4) {
#line 3650
    goto build_word_op_espace;
  }
#line 3653
  if (dfa->mb_cur_max > 1) {
#line 3657
    br_token.type = (re_token_type_t )6;
#line 3658
    br_token.opr.mbcset = mbcset;
#line 3659
    dfa->has_mb_node = 1U;
#line 3660
    mbc_tree = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                                 (re_token_t const   *)(& br_token));
#line 3661
    tmp___5 = __builtin_expect((long )((unsigned long )mbc_tree == (unsigned long )((void *)0)),
                               0L);
#line 3661
    if (tmp___5) {
#line 3662
      goto build_word_op_espace;
    }
#line 3664
    tree = create_tree(dfa, tree, mbc_tree, (re_token_type_t )10);
#line 3665
    tmp___6 = __builtin_expect((long )((unsigned long )mbc_tree != (unsigned long )((void *)0)),
                               1L);
#line 3665
    if (tmp___6) {
#line 3666
      return (tree);
    }
  } else {
#line 3670
    free_charset(mbcset);
#line 3671
    return (tree);
  }
  build_word_op_espace: 
#line 3678
  free((void *)sbcset);
#line 3680
  free_charset(mbcset);
#line 3682
  *err = (reg_errcode_t )12;
#line 3683
  return ((bin_tree_t *)((void *)0));
}
}
#line 3691 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static Idx fetch_number(re_string_t *input , re_token_t *token , reg_syntax_t syntax ) 
{ 
  Idx num ;
  unsigned char c ;
  long tmp ;
  Idx tmp___0 ;

  {
#line 3694
  num = (Idx )-1;
#line 3696
  while (1) {
#line 3698
    fetch_token(token, input, syntax);
#line 3699
    c = token->opr.c;
#line 3700
    tmp = __builtin_expect((long )((unsigned int )token->type == 2U), 0L);
#line 3700
    if (tmp) {
#line 3701
      return ((Idx )-2);
    }
#line 3702
    if ((unsigned int )token->type == 24U) {
#line 3703
      break;
    } else
#line 3702
    if ((int )c == 44) {
#line 3703
      break;
    }
#line 3704
    if ((unsigned int )token->type != 1U) {
#line 3704
      num = (Idx )-2;
    } else
#line 3704
    if ((int )c < 48) {
#line 3704
      num = (Idx )-2;
    } else
#line 3704
    if (57 < (int )c) {
#line 3704
      num = (Idx )-2;
    } else
#line 3704
    if (num == 0xfffffffffffffffeUL) {
#line 3704
      num = (Idx )-2;
    } else {
#line 3704
      if (num == 0xffffffffffffffffUL) {
#line 3704
        tmp___0 = (Idx )((int )c - 48);
      } else {
#line 3704
        tmp___0 = (num * 10UL + (Idx )c) - 48UL;
      }
#line 3704
      num = tmp___0;
    }
#line 3708
    if (num > 32767UL) {
#line 3708
      num = (Idx )-2;
    } else {
#line 3708
      num = num;
    }
  }
#line 3710
  return (num);
}
}
#line 3714 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void free_charset(re_charset_t *cset ) 
{ 


  {
#line 3717
  free((void *)cset->mbchars);
#line 3724
  free((void *)cset->char_classes);
#line 3725
  free((void *)cset);
#line 3726
  return;
}
}
#line 3733 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *create_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                               re_token_type_t type ) 
{ 
  re_token_t t ;
  bin_tree_t *tmp ;

  {
#line 3738
  t.type = type;
#line 3739
  tmp = create_token_tree(dfa, left, right, (re_token_t const   *)(& t));
#line 3739
  return (tmp);
}
}
#line 3742 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *create_token_tree(re_dfa_t *dfa , bin_tree_t *left , bin_tree_t *right ,
                                     re_token_t const   *token ) 
{ 
  bin_tree_t *tree ;
  bin_tree_storage_t *storage ;
  void *tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
#line 3747
  tmp___0 = __builtin_expect((long )((unsigned long )dfa->str_tree_storage_idx == (1024UL - sizeof(void *)) / sizeof(bin_tree_t )),
                             0L);
#line 3747
  if (tmp___0) {
#line 3749
    tmp = malloc(sizeof(bin_tree_storage_t ));
#line 3749
    storage = (bin_tree_storage_t *)tmp;
#line 3751
    if ((unsigned long )storage == (unsigned long )((void *)0)) {
#line 3752
      return ((bin_tree_t *)((void *)0));
    }
#line 3753
    storage->next = dfa->str_tree_storage;
#line 3754
    dfa->str_tree_storage = storage;
#line 3755
    dfa->str_tree_storage_idx = 0;
  }
#line 3757
  tmp___1 = dfa->str_tree_storage_idx;
#line 3757
  (dfa->str_tree_storage_idx) ++;
#line 3757
  tree = & (dfa->str_tree_storage)->data[tmp___1];
#line 3759
  tree->parent = (struct bin_tree_t *)((void *)0);
#line 3760
  tree->left = left;
#line 3761
  tree->right = right;
#line 3762
  tree->token = (re_token_t )*token;
#line 3763
  tree->token.duplicated = 0U;
#line 3764
  tree->token.opt_subexp = 0U;
#line 3765
  tree->first = (struct bin_tree_t *)((void *)0);
#line 3766
  tree->next = (struct bin_tree_t *)((void *)0);
#line 3767
  tree->node_idx = (Idx )-1;
#line 3769
  if ((unsigned long )left != (unsigned long )((void *)0)) {
#line 3770
    left->parent = tree;
  }
#line 3771
  if ((unsigned long )right != (unsigned long )((void *)0)) {
#line 3772
    right->parent = tree;
  }
#line 3773
  return (tree);
}
}
#line 3779 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t mark_opt_subexp(void *extra , bin_tree_t *node ) 
{ 
  Idx idx ;

  {
#line 3782
  idx = (Idx )((long )extra);
#line 3783
  if ((unsigned int )node->token.type == 17U) {
#line 3783
    if (node->token.opr.idx == idx) {
#line 3784
      node->token.opt_subexp = 1U;
    }
  }
#line 3786
  return ((reg_errcode_t )0);
}
}
#line 3791 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static void free_token(re_token_t *node ) 
{ 


  {
#line 3795
  if ((unsigned int )node->type == 6U) {
#line 3795
    if (node->duplicated == 0U) {
#line 3796
      free_charset(node->opr.mbcset);
    } else {
#line 3795
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3799
  if ((unsigned int )node->type == 3U) {
#line 3799
    if (node->duplicated == 0U) {
#line 3800
      free((void *)node->opr.sbcset);
    }
  }
#line 3801
  return;
}
}
#line 3806 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static reg_errcode_t free_tree(void *extra  __attribute__((__unused__)) , bin_tree_t *node ) 
{ 


  {
#line 3809
  free_token(& node->token);
#line 3810
  return ((reg_errcode_t )0);
}
}
#line 3819 "/home/wslee/project/coreutils-8.1/lib/regcomp.c"
static bin_tree_t *duplicate_tree(bin_tree_t const   *root , re_dfa_t *dfa ) 
{ 
  bin_tree_t const   *node ;
  bin_tree_t *dup_root ;
  bin_tree_t **p_new ;
  bin_tree_t *dup_node ;
  bin_tree_t const   *prev ;

  {
#line 3824
  p_new = & dup_root;
#line 3824
  dup_node = (bin_tree_t *)root->parent;
#line 3826
  node = root;
#line 3826
  while (1) {
#line 3829
    *p_new = create_token_tree(dfa, (bin_tree_t *)((void *)0), (bin_tree_t *)((void *)0),
                               & node->token);
#line 3830
    if ((unsigned long )*p_new == (unsigned long )((void *)0)) {
#line 3831
      return ((bin_tree_t *)((void *)0));
    }
#line 3832
    (*p_new)->parent = dup_node;
#line 3833
    (*p_new)->token.duplicated = 1U;
#line 3834
    dup_node = *p_new;
#line 3837
    if (node->left) {
#line 3839
      node = (bin_tree_t const   *)node->left;
#line 3840
      p_new = & dup_node->left;
    } else {
#line 3844
      prev = (bin_tree_t const   *)((void *)0);
#line 3845
      while (1) {
#line 3845
        if (! ((unsigned long )node->right == (unsigned long )prev)) {
#line 3845
          if (! ((unsigned long )node->right == (unsigned long )((void *)0))) {
#line 3845
            break;
          }
        }
#line 3847
        prev = node;
#line 3848
        node = (bin_tree_t const   *)node->parent;
#line 3849
        dup_node = dup_node->parent;
#line 3850
        if (! node) {
#line 3851
          return (dup_root);
        }
      }
#line 3853
      node = (bin_tree_t const   *)node->right;
#line 3854
      p_new = & dup_node->right;
    }
  }
}
}
#line 23 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , Idx n ) ;
#line 25
static void match_ctx_clean(re_match_context_t *mctx ) ;
#line 26
static void match_ctx_free(re_match_context_t *mctx ) ;
#line 27
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , Idx node , Idx str_idx ,
                                         Idx from , Idx to ) ;
#line 30
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) ;
#line 32
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , Idx node , Idx str_idx ) ;
#line 34
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) ;
#line 37
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) ;
#line 41
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        Idx length , Idx start , Idx last_start ,
                                        Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                        int eflags ) ;
#line 46
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) ;
#line 52
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) ;
#line 57
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) ;
#line 60
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) ;
#line 62
static Idx check_matching(re_match_context_t *mctx , _Bool fl_longest_match , Idx *p_match_first ) ;
#line 64
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    Idx idx ) ;
#line 67
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) ;
#line 70
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , Idx str_idx , Idx dest_node ,
                                     Idx nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) ;
#line 75
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) ;
#line 79
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) ;
#line 83
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) ;
#line 88
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) ;
#line 91
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         Idx str_idx , re_node_set *cur_dest ) ;
#line 95
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) ;
#line 100
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) ;
#line 104
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) ;
#line 108
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) ;
#line 112
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) ;
#line 116
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) ;
#line 122
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       Idx str_idx , re_node_set const   *candidates ) ;
#line 126
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) ;
#line 130
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) ;
#line 132
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state ) ;
#line 135
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) ;
#line 139
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) ;
#line 149
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) ;
#line 153
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) ;
#line 156
static reg_errcode_t get_subexp(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) ;
#line 159
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) ;
#line 164
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) ;
#line 166
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   Idx top_node , Idx top_str , Idx last_node , Idx last_str ,
                                   int type ) ;
#line 170
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , Idx str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) ;
#line 175
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) ;
#line 179
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  Idx target , Idx ex_subexp , int type ) ;
#line 183
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        Idx cur_str , Idx subexp_num , int type ) ;
#line 187
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) ;
#line 190
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) ;
#line 199
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) ;
#line 203
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) ;
#line 206
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) ;
#line 225 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
int rpl_regexec(regex_t const   * __restrict  preg , char const   * __restrict  string ,
                size_t nmatch , regmatch_t * __restrict  pmatch , int eflags ) 
{ 
  reg_errcode_t err ;
  Idx start ;
  Idx length ;

  {
#line 239
  if (eflags & ~ ((1 | (1 << 1)) | (1 << 2))) {
#line 240
    return (2);
  }
#line 242
  if (eflags & (1 << 2)) {
#line 244
    start = (Idx )(pmatch + 0)->rm_so;
#line 245
    length = (Idx )(pmatch + 0)->rm_eo;
  } else {
#line 249
    start = (Idx )0;
#line 250
    length = strlen((char const   *)string);
  }
#line 253
  while (1) {
#line 253
    break;
  }
#line 254
  if (preg->no_sub) {
#line 255
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length, length, (size_t )0, (regmatch_t *)((void *)0),
                             eflags);
  } else {
#line 258
    err = re_search_internal((regex_t const   *)preg, (char const   *)string, length,
                             start, length, length, nmatch, (regmatch_t *)pmatch,
                             eflags);
  }
#line 260
  while (1) {
#line 260
    break;
  }
#line 261
  return ((int )err != 0);
}
}
#line 313 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
regoff_t rpl_re_match(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                      __re_idx_t start , struct re_registers *regs ) 
{ 
  regoff_t tmp ;

  {
#line 320
  tmp = re_search_stub(bufp, string, length, start, (regoff_t )0, length, regs, (_Bool)1);
#line 320
  return (tmp);
}
}
#line 326 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
regoff_t rpl_re_search(struct re_pattern_buffer *bufp , char const   *string , __re_idx_t length ,
                       __re_idx_t start , regoff_t range , struct re_registers *regs ) 
{ 
  regoff_t tmp ;

  {
#line 334
  tmp = re_search_stub(bufp, string, length, start, range, length, regs, (_Bool)0);
#line 334
  return (tmp);
}
}
#line 341 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
regoff_t rpl_re_match_2(struct re_pattern_buffer *bufp , char const   *string1 , __re_idx_t length1 ,
                        char const   *string2 , __re_idx_t length2 , __re_idx_t start ,
                        struct re_registers *regs , __re_idx_t stop ) 
{ 
  regoff_t tmp ;

  {
#line 348
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, (regoff_t )0,
                         regs, stop, (_Bool)1);
#line 348
  return (tmp);
}
}
#line 355 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
regoff_t rpl_re_search_2(struct re_pattern_buffer *bufp , char const   *string1 ,
                         __re_idx_t length1 , char const   *string2 , __re_idx_t length2 ,
                         __re_idx_t start , regoff_t range , struct re_registers *regs ,
                         __re_idx_t stop ) 
{ 
  regoff_t tmp ;

  {
#line 363
  tmp = re_search_2_stub(bufp, string1, length1, string2, length2, start, range, regs,
                         stop, (_Bool)0);
#line 363
  return (tmp);
}
}
#line 370 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static regoff_t re_search_2_stub(struct re_pattern_buffer *bufp , char const   *string1 ,
                                 Idx length1 , char const   *string2 , Idx length2 ,
                                 Idx start , regoff_t range , struct re_registers *regs ,
                                 Idx stop , _Bool ret_len ) 
{ 
  char const   *str ;
  regoff_t rval ;
  Idx len ;
  char *s ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;

  {
#line 380
  len = length1 + length2;
#line 381
  s = (char *)((void *)0);
#line 384
  tmp = __builtin_expect((long )(len < length1), 0L);
#line 384
  if (tmp) {
#line 385
    return ((regoff_t )-2);
  }
#line 390
  if (length2 > 0UL) {
#line 391
    if (length1 > 0UL) {
#line 393
      tmp___0 = malloc(len * sizeof(char ));
#line 393
      s = (char *)tmp___0;
#line 395
      tmp___1 = __builtin_expect((long )((unsigned long )s == (unsigned long )((void *)0)),
                                 0L);
#line 395
      if (tmp___1) {
#line 396
        return ((regoff_t )-2);
      }
#line 400
      memcpy((void * __restrict  )s, (void const   * __restrict  )string1, length1);
#line 401
      memcpy((void * __restrict  )(s + length1), (void const   * __restrict  )string2,
             length2);
#line 403
      str = (char const   *)s;
    } else {
#line 406
      str = string2;
    }
  } else {
#line 408
    str = string1;
  }
#line 410
  rval = re_search_stub(bufp, str, len, start, range, stop, regs, ret_len);
#line 412
  free((void *)s);
#line 413
  return (rval);
}
}
#line 421 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static regoff_t re_search_stub(struct re_pattern_buffer *bufp , char const   *string ,
                               Idx length , Idx start , regoff_t range , Idx stop ,
                               struct re_registers *regs , _Bool ret_len ) 
{ 
  reg_errcode_t result ;
  regmatch_t *pmatch ;
  Idx nregs ;
  regoff_t rval ;
  int eflags ;
  Idx last_start ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  void *tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;

  {
#line 432
  eflags = 0;
#line 436
  last_start = start + (Idx )range;
#line 442
  tmp = __builtin_expect((long )(start > length), 0L);
#line 442
  if (tmp) {
#line 443
    return ((regoff_t )-1);
  }
#line 444
  if (length < last_start) {
#line 444
    tmp___2 = 1;
  } else
#line 444
  if (0L <= range) {
#line 444
    if (last_start < start) {
#line 444
      tmp___2 = 1;
    } else {
#line 444
      tmp___2 = 0;
    }
  } else {
#line 444
    tmp___2 = 0;
  }
#line 444
  tmp___3 = __builtin_expect((long )tmp___2, 0L);
#line 444
  if (tmp___3) {
#line 445
    last_start = length;
  } else {
#line 446
    if (range < 0L) {
#line 446
      if (start <= last_start) {
#line 446
        tmp___0 = 1;
      } else {
#line 446
        tmp___0 = 0;
      }
    } else {
#line 446
      tmp___0 = 0;
    }
#line 446
    tmp___1 = __builtin_expect((long )tmp___0, 0L);
#line 446
    if (tmp___1) {
#line 447
      last_start = (Idx )0;
    }
  }
#line 449
  while (1) {
#line 449
    break;
  }
#line 451
  if (bufp->not_bol) {
#line 451
    tmp___4 = 1;
  } else {
#line 451
    tmp___4 = 0;
  }
#line 451
  eflags |= tmp___4;
#line 452
  if (bufp->not_eol) {
#line 452
    tmp___5 = 1 << 1;
  } else {
#line 452
    tmp___5 = 0;
  }
#line 452
  eflags |= tmp___5;
#line 455
  if (start < last_start) {
#line 455
    if ((unsigned long )bufp->fastmap != (unsigned long )((void *)0)) {
#line 455
      if (! bufp->fastmap_accurate) {
#line 456
        rpl_re_compile_fastmap(bufp);
      }
    }
  }
#line 458
  tmp___6 = __builtin_expect((long )bufp->no_sub, 0L);
#line 458
  if (tmp___6) {
#line 459
    regs = (struct re_registers *)((void *)0);
  }
#line 462
  if ((unsigned long )regs == (unsigned long )((void *)0)) {
#line 463
    nregs = (Idx )1;
  } else {
#line 464
    if (bufp->regs_allocated == 2U) {
#line 464
      if (regs->num_regs <= bufp->re_nsub) {
#line 464
        tmp___8 = 1;
      } else {
#line 464
        tmp___8 = 0;
      }
    } else {
#line 464
      tmp___8 = 0;
    }
#line 464
    tmp___9 = __builtin_expect((long )tmp___8, 0L);
#line 464
    if (tmp___9) {
#line 467
      nregs = regs->num_regs;
#line 468
      tmp___7 = __builtin_expect((long )(nregs < 1UL), 0L);
#line 468
      if (tmp___7) {
#line 471
        regs = (struct re_registers *)((void *)0);
#line 472
        nregs = (Idx )1;
      }
    } else {
#line 476
      nregs = bufp->re_nsub + 1UL;
    }
  }
#line 477
  tmp___10 = malloc(nregs * sizeof(regmatch_t ));
#line 477
  pmatch = (regmatch_t *)tmp___10;
#line 478
  tmp___11 = __builtin_expect((long )((unsigned long )pmatch == (unsigned long )((void *)0)),
                              0L);
#line 478
  if (tmp___11) {
#line 480
    rval = (regoff_t )-2;
#line 481
    goto out;
  }
#line 484
  result = re_search_internal((regex_t const   *)bufp, string, length, start, last_start,
                              stop, nregs, pmatch, eflags);
#line 487
  rval = (regoff_t )0;
#line 490
  if ((int )result != 0) {
#line 491
    rval = (regoff_t )-1;
  } else
#line 492
  if ((unsigned long )regs != (unsigned long )((void *)0)) {
#line 495
    bufp->regs_allocated = re_copy_regs(regs, pmatch, nregs, (int )bufp->regs_allocated);
#line 497
    tmp___12 = __builtin_expect((long )(bufp->regs_allocated == 0U), 0L);
#line 497
    if (tmp___12) {
#line 498
      rval = (regoff_t )-2;
    }
  }
#line 501
  tmp___13 = __builtin_expect((long )(rval == 0L), 1L);
#line 501
  if (tmp___13) {
#line 503
    if (ret_len) {
#line 505
      if (! ((Idx )(pmatch + 0)->rm_so == start)) {
#line 505
        __assert_fail("pmatch[0].rm_so == start", "/home/wslee/project/coreutils-8.1/lib/regexec.c",
                      505U, "re_search_stub");
      }
#line 506
      rval = (regoff_t )((Idx )(pmatch + 0)->rm_eo - start);
    } else {
#line 509
      rval = (pmatch + 0)->rm_so;
    }
  }
#line 511
  free((void *)pmatch);
  out: 
#line 513
  while (1) {
#line 513
    break;
  }
#line 514
  return (rval);
}
}
#line 517 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static unsigned int re_copy_regs(struct re_registers *regs , regmatch_t *pmatch ,
                                 Idx nregs , int regs_allocated ) 
{ 
  int rval ;
  Idx i ;
  Idx need_regs ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  regoff_t *new_start ;
  void *tmp___3 ;
  regoff_t *new_end ;
  long tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  regoff_t tmp___8 ;

  {
#line 522
  rval = 1;
#line 524
  need_regs = nregs + 1UL;
#line 529
  if (regs_allocated == 0) {
#line 531
    tmp = malloc(need_regs * sizeof(regoff_t ));
#line 531
    regs->start = (regoff_t *)tmp;
#line 532
    tmp___0 = __builtin_expect((long )((unsigned long )regs->start == (unsigned long )((void *)0)),
                               0L);
#line 532
    if (tmp___0) {
#line 533
      return (0U);
    }
#line 534
    tmp___1 = malloc(need_regs * sizeof(regoff_t ));
#line 534
    regs->end = (regoff_t *)tmp___1;
#line 535
    tmp___2 = __builtin_expect((long )((unsigned long )regs->end == (unsigned long )((void *)0)),
                               0L);
#line 535
    if (tmp___2) {
#line 537
      free((void *)regs->start);
#line 538
      return (0U);
    }
#line 540
    regs->num_regs = need_regs;
  } else
#line 542
  if (regs_allocated == 1) {
#line 546
    tmp___7 = __builtin_expect((long )(need_regs > regs->num_regs), 0L);
#line 546
    if (tmp___7) {
#line 548
      tmp___3 = realloc((void *)regs->start, need_regs * sizeof(regoff_t ));
#line 548
      new_start = (regoff_t *)tmp___3;
#line 550
      tmp___4 = __builtin_expect((long )((unsigned long )new_start == (unsigned long )((void *)0)),
                                 0L);
#line 550
      if (tmp___4) {
#line 551
        return (0U);
      }
#line 552
      tmp___5 = realloc((void *)regs->end, need_regs * sizeof(regoff_t ));
#line 552
      new_end = (regoff_t *)tmp___5;
#line 553
      tmp___6 = __builtin_expect((long )((unsigned long )new_end == (unsigned long )((void *)0)),
                                 0L);
#line 553
      if (tmp___6) {
#line 555
        free((void *)new_start);
#line 556
        return (0U);
      }
#line 558
      regs->start = new_start;
#line 559
      regs->end = new_end;
#line 560
      regs->num_regs = need_regs;
    }
  } else {
#line 565
    if (! (regs_allocated == 2)) {
#line 565
      __assert_fail("regs_allocated == REGS_FIXED", "/home/wslee/project/coreutils-8.1/lib/regexec.c",
                    565U, "re_copy_regs");
    }
#line 567
    if (! (regs->num_regs >= nregs)) {
#line 567
      __assert_fail("regs->num_regs >= nregs", "/home/wslee/project/coreutils-8.1/lib/regexec.c",
                    567U, "re_copy_regs");
    }
#line 568
    rval = 2;
  }
#line 572
  i = (Idx )0;
#line 572
  while (i < nregs) {
#line 574
    *(regs->start + i) = (pmatch + i)->rm_so;
#line 575
    *(regs->end + i) = (pmatch + i)->rm_eo;
#line 572
    i ++;
  }
#line 577
  while (i < regs->num_regs) {
#line 578
    tmp___8 = (regoff_t )-1;
#line 578
    *(regs->end + i) = tmp___8;
#line 578
    *(regs->start + i) = tmp___8;
#line 577
    i ++;
  }
#line 580
  return ((unsigned int )rval);
}
}
#line 596 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
void rpl_re_set_registers(struct re_pattern_buffer *bufp , struct re_registers *regs ,
                          __re_size_t num_regs , regoff_t *starts , regoff_t *ends ) 
{ 
  regoff_t *tmp ;

  {
#line 603
  if (num_regs) {
#line 605
    bufp->regs_allocated = 1U;
#line 606
    regs->num_regs = num_regs;
#line 607
    regs->start = starts;
#line 608
    regs->end = ends;
  } else {
#line 612
    bufp->regs_allocated = 0U;
#line 613
    regs->num_regs = (__re_size_t )0;
#line 614
    tmp = (regoff_t *)((void *)0);
#line 614
    regs->end = tmp;
#line 614
    regs->start = tmp;
  }
#line 616
  return;
}
}
#line 647 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t re_search_internal(regex_t const   *preg , char const   *string ,
                                        Idx length , Idx start , Idx last_start ,
                                        Idx stop , size_t nmatch , regmatch_t *pmatch ,
                                        int eflags ) 
{ 
  reg_errcode_t err ;
  re_dfa_t const   *dfa ;
  Idx left_lim ;
  Idx right_lim ;
  int incr ;
  _Bool fl_longest_match ;
  int match_kind ;
  Idx match_first ;
  Idx match_last ;
  Idx extra_nmatch ;
  _Bool sb ;
  int ch ;
  re_match_context_t mctx ;
  char *fastmap ;
  char *tmp ;
  unsigned char *t ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  void *tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  __re_size_t offset ;
  long tmp___16 ;
  long tmp___17 ;
  long tmp___18 ;
  Idx *tmp___19 ;
  re_dfastate_t *pstate ;
  long tmp___20 ;
  long tmp___21 ;
  Idx reg_idx ;
  regoff_t tmp___22 ;
  int tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;

  {
#line 656
  dfa = (re_dfa_t const   *)preg->buffer;
#line 662
  match_last = (Idx )-1;
#line 667
  mctx.input.raw_mbs = (unsigned char const   *)0;
#line 667
  mctx.input.mbs = (unsigned char *)0;
#line 667
  mctx.input.wcs = (wint_t *)0;
#line 667
  mctx.input.offsets = (Idx *)0;
#line 667
  mctx.input.cur_state.__count = 0;
#line 667
  mctx.input.cur_state.__value.__wch = 0U;
#line 667
  mctx.input.raw_mbs_idx = 0UL;
#line 667
  mctx.input.valid_len = 0UL;
#line 667
  mctx.input.valid_raw_len = 0UL;
#line 667
  mctx.input.bufs_len = 0UL;
#line 667
  mctx.input.cur_idx = 0UL;
#line 667
  mctx.input.raw_len = 0UL;
#line 667
  mctx.input.len = 0UL;
#line 667
  mctx.input.raw_stop = 0UL;
#line 667
  mctx.input.stop = 0UL;
#line 667
  mctx.input.tip_context = 0U;
#line 667
  mctx.input.trans = (unsigned char *)0;
#line 667
  mctx.input.word_char = (bitset_word_t const   *)0;
#line 667
  mctx.input.icase = (unsigned char)0;
#line 667
  mctx.input.is_utf8 = (unsigned char)0;
#line 667
  mctx.input.map_notascii = (unsigned char)0;
#line 667
  mctx.input.mbs_allocated = (unsigned char)0;
#line 667
  mctx.input.offsets_needed = (unsigned char)0;
#line 667
  mctx.input.newline_anchor = (unsigned char)0;
#line 667
  mctx.input.word_ops_used = (unsigned char)0;
#line 667
  mctx.input.mb_cur_max = 0;
#line 667
  mctx.dfa = dfa;
#line 667
  mctx.eflags = 0;
#line 667
  mctx.match_last = 0UL;
#line 667
  mctx.last_node = 0UL;
#line 667
  mctx.state_log = (re_dfastate_t **)0;
#line 667
  mctx.state_log_top = 0UL;
#line 667
  mctx.nbkref_ents = 0UL;
#line 667
  mctx.abkref_ents = 0UL;
#line 667
  mctx.bkref_ents = (struct re_backref_cache_entry *)0;
#line 667
  mctx.max_mb_elem_len = 0;
#line 667
  mctx.nsub_tops = 0UL;
#line 667
  mctx.asub_tops = 0UL;
#line 667
  mctx.sub_tops = (re_sub_match_top_t **)0;
#line 671
  if ((unsigned long )preg->fastmap != (unsigned long )((void *)0)) {
#line 671
    if (preg->fastmap_accurate) {
#line 671
      if (start != last_start) {
#line 671
        if (! preg->can_be_null) {
#line 671
          tmp = preg->fastmap;
        } else {
#line 671
          tmp = (char * const  )((void *)0);
        }
      } else {
#line 671
        tmp = (char * const  )((void *)0);
      }
    } else {
#line 671
      tmp = (char * const  )((void *)0);
    }
  } else {
#line 671
    tmp = (char * const  )((void *)0);
  }
#line 671
  fastmap = (char *)tmp;
#line 674
  t = (unsigned char *)preg->translate;
#line 681
  if (nmatch > (size_t )preg->re_nsub) {
#line 681
    extra_nmatch = nmatch - (size_t )(preg->re_nsub + 1UL);
  } else {
#line 681
    extra_nmatch = (Idx )0;
  }
#line 682
  nmatch -= extra_nmatch;
#line 685
  if (preg->used == 0UL) {
#line 685
    tmp___0 = 1;
  } else
#line 685
  if ((unsigned long )dfa->init_state == (unsigned long )((void *)0)) {
#line 685
    tmp___0 = 1;
  } else
#line 685
  if ((unsigned long )dfa->init_state_word == (unsigned long )((void *)0)) {
#line 685
    tmp___0 = 1;
  } else
#line 685
  if ((unsigned long )dfa->init_state_nl == (unsigned long )((void *)0)) {
#line 685
    tmp___0 = 1;
  } else
#line 685
  if ((unsigned long )dfa->init_state_begbuf == (unsigned long )((void *)0)) {
#line 685
    tmp___0 = 1;
  } else {
#line 685
    tmp___0 = 0;
  }
#line 685
  tmp___1 = __builtin_expect((long )tmp___0, 0L);
#line 685
  if (tmp___1) {
#line 688
    return ((reg_errcode_t )1);
  }
#line 698
  if ((dfa->init_state)->nodes.nelem == 0UL) {
#line 698
    if ((dfa->init_state_word)->nodes.nelem == 0UL) {
#line 698
      if ((dfa->init_state_nl)->nodes.nelem == 0UL) {
#line 698
        goto _L;
      } else
#line 698
      if (! preg->newline_anchor) {
        _L: /* CIL Label */ 
#line 703
        if (start != 0UL) {
#line 703
          if (last_start != 0UL) {
#line 704
            return ((reg_errcode_t )1);
          }
        }
#line 705
        last_start = (Idx )0;
#line 705
        start = last_start;
      }
    }
  }
#line 709
  if (nmatch != 0UL) {
#line 709
    tmp___2 = 1;
  } else
#line 709
  if (dfa->nbackref) {
#line 709
    tmp___2 = 1;
  } else {
#line 709
    tmp___2 = 0;
  }
#line 709
  fl_longest_match = (_Bool )tmp___2;
#line 711
  err = re_string_allocate(& mctx.input, string, length, (Idx )(dfa->nodes_len + 1UL),
                           (unsigned char *)preg->translate, (_Bool )((preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) != 0UL),
                           dfa);
#line 714
  tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
#line 714
  if (tmp___3) {
#line 715
    goto free_return;
  }
#line 716
  mctx.input.stop = stop;
#line 717
  mctx.input.raw_stop = stop;
#line 718
  mctx.input.newline_anchor = (unsigned char )preg->newline_anchor;
#line 720
  err = match_ctx_init(& mctx, eflags, (Idx )(dfa->nbackref * 2UL));
#line 721
  tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
#line 721
  if (tmp___4) {
#line 722
    goto free_return;
  }
#line 728
  if (nmatch > 1UL) {
#line 728
    goto _L___0;
  } else
#line 728
  if (dfa->has_mb_node) {
    _L___0: /* CIL Label */ 
#line 731
    tmp___5 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= mctx.input.bufs_len),
                               0L);
#line 731
    if (tmp___5) {
#line 733
      err = (reg_errcode_t )12;
#line 734
      goto free_return;
    }
#line 737
    tmp___6 = malloc((mctx.input.bufs_len + 1UL) * sizeof(re_dfastate_t *));
#line 737
    mctx.state_log = (re_dfastate_t **)tmp___6;
#line 738
    tmp___7 = __builtin_expect((long )((unsigned long )mctx.state_log == (unsigned long )((void *)0)),
                               0L);
#line 738
    if (tmp___7) {
#line 740
      err = (reg_errcode_t )12;
#line 741
      goto free_return;
    }
  } else {
#line 745
    mctx.state_log = (re_dfastate_t **)((void *)0);
  }
#line 747
  match_first = start;
#line 748
  if (eflags & 1) {
#line 748
    mctx.input.tip_context = (unsigned int )((1 << 1) << 1);
  } else {
#line 748
    mctx.input.tip_context = (unsigned int )((1 << 1) | ((1 << 1) << 1));
  }
#line 752
  if (last_start < start) {
#line 752
    incr = -1;
  } else {
#line 752
    incr = 1;
  }
#line 753
  if (last_start < start) {
#line 753
    left_lim = last_start;
  } else {
#line 753
    left_lim = start;
  }
#line 754
  if (last_start < start) {
#line 754
    right_lim = start;
  } else {
#line 754
    right_lim = last_start;
  }
#line 755
  sb = (_Bool )(dfa->mb_cur_max == 1);
#line 756
  if (fastmap) {
#line 756
    if (sb) {
#line 756
      tmp___8 = 4;
    } else
#line 756
    if (preg->syntax & (unsigned long const   )((((((((((((((((((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 756
      tmp___8 = 0;
    } else
#line 756
    if (t) {
#line 756
      tmp___8 = 0;
    } else {
#line 756
      tmp___8 = 4;
    }
#line 756
    if (start <= last_start) {
#line 756
      tmp___9 = 2;
    } else {
#line 756
      tmp___9 = 0;
    }
#line 756
    if ((unsigned long )t != (unsigned long )((void *)0)) {
#line 756
      tmp___10 = 1;
    } else {
#line 756
      tmp___10 = 0;
    }
#line 756
    match_kind = (tmp___8 | tmp___9) | tmp___10;
  } else {
#line 756
    match_kind = 8;
  }
#line 763
  while (1) {
#line 765
    err = (reg_errcode_t )1;
#line 766
    if (match_first < left_lim) {
#line 767
      goto free_return;
    } else
#line 766
    if (right_lim < match_first) {
#line 767
      goto free_return;
    }
#line 774
    switch (match_kind) {
    case 8: 
#line 778
    break;
    case 7: 
#line 782
    while (1) {
#line 782
      tmp___11 = __builtin_expect((long )(match_first < right_lim), 1L);
#line 782
      if (tmp___11) {
#line 782
        if (! (! *(fastmap + *(t + (unsigned char )*(string + match_first))))) {
#line 782
          break;
        }
      } else {
#line 782
        break;
      }
#line 784
      match_first ++;
    }
#line 785
    goto forward_match_found_start_or_reached_end;
    case 6: 
#line 789
    while (1) {
#line 789
      tmp___12 = __builtin_expect((long )(match_first < right_lim), 1L);
#line 789
      if (tmp___12) {
#line 789
        if (! (! *(fastmap + (unsigned char )*(string + match_first)))) {
#line 789
          break;
        }
      } else {
#line 789
        break;
      }
#line 791
      match_first ++;
    }
    forward_match_found_start_or_reached_end: 
#line 794
    tmp___14 = __builtin_expect((long )(match_first == right_lim), 0L);
#line 794
    if (tmp___14) {
#line 796
      if (match_first >= length) {
#line 796
        ch = 0;
      } else {
#line 796
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 798
      if (t) {
#line 798
        tmp___13 = (int )*(t + ch);
      } else {
#line 798
        tmp___13 = ch;
      }
#line 798
      if (! *(fastmap + tmp___13)) {
#line 799
        goto free_return;
      }
    }
#line 801
    break;
    case 5: 
    case 4: 
#line 806
    while (match_first >= left_lim) {
#line 808
      if (match_first >= length) {
#line 808
        ch = 0;
      } else {
#line 808
        ch = (int )((unsigned char )*(string + match_first));
      }
#line 810
      if (t) {
#line 810
        tmp___15 = (int )*(t + ch);
      } else {
#line 810
        tmp___15 = ch;
      }
#line 810
      if (*(fastmap + tmp___15)) {
#line 811
        break;
      }
#line 812
      match_first --;
    }
#line 814
    if (match_first < left_lim) {
#line 815
      goto free_return;
    }
#line 816
    break;
    default: 
#line 822
    while (1) {
#line 826
      offset = match_first - mctx.input.raw_mbs_idx;
#line 827
      tmp___17 = __builtin_expect((long )(offset >= mctx.input.valid_raw_len), 0L);
#line 827
      if (tmp___17) {
#line 829
        err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 831
        tmp___16 = __builtin_expect((long )((int )err != 0), 0L);
#line 831
        if (tmp___16) {
#line 832
          goto free_return;
        }
#line 834
        offset = match_first - mctx.input.raw_mbs_idx;
      }
#line 838
      if (match_first >= length) {
#line 838
        ch = 0;
      } else {
#line 838
        ch = (int )*(mctx.input.mbs + offset);
      }
#line 840
      if (*(fastmap + ch)) {
#line 841
        break;
      }
#line 842
      match_first += (Idx )incr;
#line 843
      if (match_first < left_lim) {
#line 845
        err = (reg_errcode_t )1;
#line 846
        goto free_return;
      } else
#line 843
      if (match_first > right_lim) {
#line 845
        err = (reg_errcode_t )1;
#line 846
        goto free_return;
      }
    }
#line 849
    break;
    }
#line 854
    err = re_string_reconstruct(& mctx.input, match_first, eflags);
#line 855
    tmp___18 = __builtin_expect((long )((int )err != 0), 0L);
#line 855
    if (tmp___18) {
#line 856
      goto free_return;
    }
#line 861
    if (! sb) {
#line 861
      if (! (0UL == mctx.input.valid_len)) {
#line 861
        if (! (*(mctx.input.wcs + 0) != 4294967295U)) {
#line 862
          goto __Cont;
        }
      }
    }
#line 867
    mctx.max_mb_elem_len = 0;
#line 867
    mctx.nbkref_ents = (Idx )mctx.max_mb_elem_len;
#line 867
    mctx.state_log_top = mctx.nbkref_ents;
#line 868
    if (start <= last_start) {
#line 868
      tmp___19 = & match_first;
    } else {
#line 868
      tmp___19 = (Idx *)((void *)0);
    }
#line 868
    match_last = check_matching(& mctx, fl_longest_match, tmp___19);
#line 870
    if (match_last != 0xffffffffffffffffUL) {
#line 872
      tmp___21 = __builtin_expect((long )(match_last == 0xfffffffffffffffeUL), 0L);
#line 872
      if (tmp___21) {
#line 874
        err = (reg_errcode_t )12;
#line 875
        goto free_return;
      } else {
#line 879
        mctx.match_last = match_last;
#line 880
        if (! preg->no_sub) {
#line 880
          if (nmatch > 1UL) {
#line 882
            pstate = *(mctx.state_log + match_last);
#line 883
            mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                      (re_dfastate_t const   *)pstate,
                                                      match_last);
          } else {
#line 880
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 880
        if (dfa->nbackref) {
#line 882
          pstate = *(mctx.state_log + match_last);
#line 883
          mctx.last_node = check_halt_state_context((re_match_context_t const   *)(& mctx),
                                                    (re_dfastate_t const   *)pstate,
                                                    match_last);
        }
#line 886
        if (! preg->no_sub) {
#line 886
          if (nmatch > 1UL) {
#line 886
            if (dfa->has_plural_match) {
#line 886
              goto _L___2;
            } else {
#line 886
              goto _L___4;
            }
          } else {
#line 886
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 886
        if (dfa->nbackref) {
          _L___2: /* CIL Label */ 
#line 889
          err = prune_impossible_nodes(& mctx);
#line 890
          if ((int )err == 0) {
#line 891
            break;
          }
#line 892
          tmp___20 = __builtin_expect((long )((int )err != 1), 0L);
#line 892
          if (tmp___20) {
#line 893
            goto free_return;
          }
#line 894
          match_last = (Idx )-1;
        } else {
#line 897
          break;
        }
      }
    }
#line 901
    match_ctx_clean(& mctx);
    __Cont: /* CIL Label */ 
#line 763
    match_first += (Idx )incr;
  }
#line 910
  if (nmatch > 0UL) {
#line 915
    reg_idx = (Idx )1;
#line 915
    while (reg_idx < nmatch) {
#line 916
      tmp___22 = (regoff_t )-1;
#line 916
      (pmatch + reg_idx)->rm_eo = tmp___22;
#line 916
      (pmatch + reg_idx)->rm_so = tmp___22;
#line 915
      reg_idx ++;
    }
#line 919
    (pmatch + 0)->rm_so = (regoff_t )0;
#line 920
    (pmatch + 0)->rm_eo = (regoff_t )mctx.match_last;
#line 925
    if (! preg->no_sub) {
#line 925
      if (nmatch > 1UL) {
#line 927
        if (dfa->has_plural_match) {
#line 927
          if (dfa->nbackref > 0UL) {
#line 927
            tmp___23 = 1;
          } else {
#line 927
            tmp___23 = 0;
          }
        } else {
#line 927
          tmp___23 = 0;
        }
#line 927
        err = set_regs(preg, (re_match_context_t const   *)(& mctx), nmatch, pmatch,
                       (_Bool )tmp___23);
#line 929
        tmp___24 = __builtin_expect((long )((int )err != 0), 0L);
#line 929
        if (tmp___24) {
#line 930
          goto free_return;
        }
      }
    }
#line 936
    reg_idx = (Idx )0;
#line 936
    while (reg_idx < nmatch) {
#line 937
      if ((pmatch + reg_idx)->rm_so != -1L) {
#line 940
        tmp___25 = __builtin_expect((long )((int )mctx.input.offsets_needed != 0),
                                    0L);
#line 940
        if (tmp___25) {
#line 942
          if ((Idx )(pmatch + reg_idx)->rm_so == mctx.input.valid_len) {
#line 942
            (pmatch + reg_idx)->rm_so = (regoff_t )mctx.input.valid_raw_len;
          } else {
#line 942
            (pmatch + reg_idx)->rm_so = (regoff_t )*(mctx.input.offsets + (pmatch + reg_idx)->rm_so);
          }
#line 946
          if ((Idx )(pmatch + reg_idx)->rm_eo == mctx.input.valid_len) {
#line 946
            (pmatch + reg_idx)->rm_eo = (regoff_t )mctx.input.valid_raw_len;
          } else {
#line 946
            (pmatch + reg_idx)->rm_eo = (regoff_t )*(mctx.input.offsets + (pmatch + reg_idx)->rm_eo);
          }
        }
#line 954
        (pmatch + reg_idx)->rm_so = (regoff_t )((Idx )(pmatch + reg_idx)->rm_so + match_first);
#line 955
        (pmatch + reg_idx)->rm_eo = (regoff_t )((Idx )(pmatch + reg_idx)->rm_eo + match_first);
      }
#line 936
      reg_idx ++;
    }
#line 957
    reg_idx = (Idx )0;
#line 957
    while (reg_idx < extra_nmatch) {
#line 959
      (pmatch + (nmatch + reg_idx))->rm_so = (regoff_t )-1;
#line 960
      (pmatch + (nmatch + reg_idx))->rm_eo = (regoff_t )-1;
#line 957
      reg_idx ++;
    }
#line 963
    if (dfa->subexp_map) {
#line 964
      reg_idx = (Idx )0;
#line 964
      while (reg_idx + 1UL < nmatch) {
#line 965
        if (*(dfa->subexp_map + reg_idx) != reg_idx) {
#line 967
          (pmatch + (reg_idx + 1UL))->rm_so = (pmatch + (*(dfa->subexp_map + reg_idx) + 1UL))->rm_so;
#line 969
          (pmatch + (reg_idx + 1UL))->rm_eo = (pmatch + (*(dfa->subexp_map + reg_idx) + 1UL))->rm_eo;
        }
#line 964
        reg_idx ++;
      }
    }
  }
  free_return: 
#line 975
  free((void *)mctx.state_log);
#line 976
  if (dfa->nbackref) {
#line 977
    match_ctx_free(& mctx);
  }
#line 978
  re_string_destruct(& mctx.input);
#line 979
  return (err);
}
}
#line 982 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t prune_impossible_nodes(re_match_context_t *mctx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx halt_node ;
  Idx match_last ;
  reg_errcode_t ret ;
  re_dfastate_t **sifted_states ;
  re_dfastate_t **lim_states ;
  re_sift_context_t sctx ;
  long tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 986
  dfa = mctx->dfa;
#line 990
  lim_states = (re_dfastate_t **)((void *)0);
#line 995
  match_last = mctx->match_last;
#line 996
  halt_node = mctx->last_node;
#line 999
  tmp = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) <= match_last),
                         0L);
#line 999
  if (tmp) {
#line 1000
    return ((reg_errcode_t )12);
  }
#line 1002
  tmp___0 = malloc((match_last + 1UL) * sizeof(re_dfastate_t *));
#line 1002
  sifted_states = (re_dfastate_t **)tmp___0;
#line 1003
  tmp___1 = __builtin_expect((long )((unsigned long )sifted_states == (unsigned long )((void *)0)),
                             0L);
#line 1003
  if (tmp___1) {
#line 1005
    ret = (reg_errcode_t )12;
#line 1006
    goto free_return;
  }
#line 1008
  if (dfa->nbackref) {
#line 1010
    tmp___2 = malloc((match_last + 1UL) * sizeof(re_dfastate_t *));
#line 1010
    lim_states = (re_dfastate_t **)tmp___2;
#line 1011
    tmp___3 = __builtin_expect((long )((unsigned long )lim_states == (unsigned long )((void *)0)),
                               0L);
#line 1011
    if (tmp___3) {
#line 1013
      ret = (reg_errcode_t )12;
#line 1014
      goto free_return;
    }
#line 1016
    while (1) {
#line 1018
      memset((void *)lim_states, '\000', sizeof(re_dfastate_t *) * (match_last + 1UL));
#line 1020
      sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1022
      ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1023
      free((void *)sctx.limits.elems);
#line 1024
      tmp___4 = __builtin_expect((long )((int )ret != 0), 0L);
#line 1024
      if (tmp___4) {
#line 1025
        goto free_return;
      }
#line 1026
      if ((unsigned long )*(sifted_states + 0) != (unsigned long )((void *)0)) {
#line 1027
        break;
      } else
#line 1026
      if ((unsigned long )*(lim_states + 0) != (unsigned long )((void *)0)) {
#line 1027
        break;
      }
#line 1028
      while (1) {
#line 1030
        match_last --;
#line 1031
        if (! (match_last < 0xfffffffffffffffeUL)) {
#line 1033
          ret = (reg_errcode_t )1;
#line 1034
          goto free_return;
        }
#line 1028
        if (! ((unsigned long )*(mctx->state_log + match_last) == (unsigned long )((void *)0))) {
#line 1028
          if (! (! (*(mctx->state_log + match_last))->halt)) {
#line 1028
            break;
          }
        }
      }
#line 1038
      halt_node = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)*(mctx->state_log + match_last),
                                           match_last);
    }
#line 1042
    ret = merge_state_array(dfa, sifted_states, lim_states, match_last + 1UL);
#line 1044
    free((void *)lim_states);
#line 1045
    lim_states = (re_dfastate_t **)((void *)0);
#line 1046
    tmp___5 = __builtin_expect((long )((int )ret != 0), 0L);
#line 1046
    if (tmp___5) {
#line 1047
      goto free_return;
    }
  } else {
#line 1051
    sift_ctx_init(& sctx, sifted_states, lim_states, halt_node, match_last);
#line 1052
    ret = sift_states_backward((re_match_context_t const   *)mctx, & sctx);
#line 1053
    free((void *)sctx.limits.elems);
#line 1054
    tmp___6 = __builtin_expect((long )((int )ret != 0), 0L);
#line 1054
    if (tmp___6) {
#line 1055
      goto free_return;
    }
#line 1056
    if ((unsigned long )*(sifted_states + 0) == (unsigned long )((void *)0)) {
#line 1058
      ret = (reg_errcode_t )1;
#line 1059
      goto free_return;
    }
  }
#line 1062
  free((void *)mctx->state_log);
#line 1063
  mctx->state_log = sifted_states;
#line 1064
  sifted_states = (re_dfastate_t **)((void *)0);
#line 1065
  mctx->last_node = halt_node;
#line 1066
  mctx->match_last = match_last;
#line 1067
  ret = (reg_errcode_t )0;
  free_return: 
#line 1069
  free((void *)sifted_states);
#line 1070
  free((void *)lim_states);
#line 1071
  return (ret);
}
}
#line 1078 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
__inline static re_dfastate_t *( __attribute__((__always_inline__)) acquire_init_state_context)(reg_errcode_t *err ,
                                                                                                re_match_context_t const   *mctx ,
                                                                                                Idx idx ) 
{ 
  re_dfa_t const   *dfa ;
  unsigned int context ;
  re_dfastate_t *tmp ;

  {
#line 1083
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1084
  if ((dfa->init_state)->has_constraint) {
#line 1087
    context = re_string_context_at(& mctx->input, idx - 1UL, (int )mctx->eflags);
#line 1088
    if (context & 1U) {
#line 1089
      return ((re_dfastate_t *)dfa->init_state_word);
    } else
#line 1090
    if (context == 0U) {
#line 1091
      return ((re_dfastate_t *)dfa->init_state);
    } else
#line 1092
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 1092
      if (context & (unsigned int )(1 << 1)) {
#line 1093
        return ((re_dfastate_t *)dfa->init_state_begbuf);
      } else {
#line 1092
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1094
    if (context & (unsigned int )(1 << 1)) {
#line 1095
      return ((re_dfastate_t *)dfa->init_state_nl);
    } else
#line 1096
    if (context & (unsigned int )((1 << 1) << 1)) {
#line 1099
      tmp = re_acquire_state_context(err, dfa, (re_node_set const   *)(dfa->init_state)->entrance_nodes,
                                     context);
#line 1099
      return (tmp);
    } else {
#line 1105
      return ((re_dfastate_t *)dfa->init_state);
    }
  } else {
#line 1108
    return ((re_dfastate_t *)dfa->init_state);
  }
}
}
#line 1120 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static Idx check_matching(re_match_context_t *mctx , _Bool fl_longest_match , Idx *p_match_first ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx match ;
  Idx match_last ;
  Idx cur_str_idx ;
  re_dfastate_t *cur_state ;
  _Bool at_init_state ;
  Idx next_start_idx ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  Idx tmp___3 ;
  long tmp___4 ;
  re_dfastate_t *old_state ;
  Idx next_char_idx ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  Idx tmp___10 ;

  {
#line 1125
  dfa = mctx->dfa;
#line 1127
  match = (Idx )0;
#line 1128
  match_last = (Idx )-1;
#line 1129
  cur_str_idx = mctx->input.cur_idx;
#line 1131
  at_init_state = (_Bool )((unsigned long )p_match_first != (unsigned long )((void *)0));
#line 1132
  next_start_idx = cur_str_idx;
#line 1134
  err = (reg_errcode_t )0;
#line 1135
  cur_state = acquire_init_state_context(& err, (re_match_context_t const   *)mctx,
                                         cur_str_idx);
#line 1137
  tmp = __builtin_expect((long )((unsigned long )cur_state == (unsigned long )((void *)0)),
                         0L);
#line 1137
  if (tmp) {
#line 1139
    if (! ((int )err == 12)) {
#line 1139
      __assert_fail("err == REG_ESPACE", "/home/wslee/project/coreutils-8.1/lib/regexec.c",
                    1139U, "check_matching");
    }
#line 1140
    return ((Idx )-2);
  }
#line 1143
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
#line 1145
    *(mctx->state_log + cur_str_idx) = cur_state;
#line 1149
    tmp___2 = __builtin_expect((long )dfa->nbackref, 0L);
#line 1149
    if (tmp___2) {
#line 1151
      at_init_state = (_Bool)0;
#line 1152
      err = check_subexp_matching_top(mctx, & cur_state->nodes, (Idx )0);
#line 1153
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1153
      if (tmp___0) {
#line 1154
        return ((Idx )err);
      }
#line 1156
      if (cur_state->has_backref) {
#line 1158
        err = transit_state_bkref(mctx, (re_node_set const   *)(& cur_state->nodes));
#line 1159
        tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 1159
        if (tmp___1) {
#line 1160
          return ((Idx )err);
        }
      }
    }
  }
#line 1166
  tmp___4 = __builtin_expect((long )cur_state->halt, 0L);
#line 1166
  if (tmp___4) {
#line 1168
    if (! cur_state->has_constraint) {
#line 1168
      goto _L;
    } else {
#line 1168
      tmp___3 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                         cur_str_idx);
#line 1168
      if (tmp___3) {
        _L: /* CIL Label */ 
#line 1171
        if (! fl_longest_match) {
#line 1172
          return (cur_str_idx);
        } else {
#line 1175
          match_last = cur_str_idx;
#line 1176
          match = (Idx )1;
        }
      }
    }
  }
#line 1181
  while (! (mctx->input.stop <= mctx->input.cur_idx)) {
#line 1183
    old_state = cur_state;
#line 1184
    next_char_idx = mctx->input.cur_idx + 1UL;
#line 1186
    tmp___6 = __builtin_expect((long )(next_char_idx >= mctx->input.bufs_len), 0L);
#line 1186
    if (tmp___6) {
#line 1186
      goto _L___0;
    } else {
#line 1186
      tmp___7 = __builtin_expect((long )(next_char_idx >= mctx->input.valid_len),
                                 0L);
#line 1186
      if (tmp___7) {
#line 1186
        if (mctx->input.valid_len < mctx->input.len) {
          _L___0: /* CIL Label */ 
#line 1190
          err = extend_buffers(mctx);
#line 1191
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
#line 1191
          if (tmp___5) {
#line 1193
            if (! ((int )err == 12)) {
#line 1193
              __assert_fail("err == REG_ESPACE", "/home/wslee/project/coreutils-8.1/lib/regexec.c",
                            1193U, "check_matching");
            }
#line 1194
            return ((Idx )-2);
          }
        }
      }
    }
#line 1198
    cur_state = transit_state(& err, mctx, cur_state);
#line 1199
    if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
#line 1200
      cur_state = merge_state_with_log(& err, mctx, cur_state);
    }
#line 1202
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 1207
      tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
#line 1207
      if (tmp___8) {
#line 1208
        return ((Idx )-2);
      }
#line 1210
      if ((unsigned long )mctx->state_log == (unsigned long )((void *)0)) {
#line 1213
        break;
      } else
#line 1210
      if (match) {
#line 1210
        if (! fl_longest_match) {
#line 1213
          break;
        } else {
#line 1210
          goto _L___1;
        }
      } else {
        _L___1: /* CIL Label */ 
#line 1210
        cur_state = find_recover_state(& err, mctx);
#line 1210
        if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 1213
          break;
        }
      }
    }
#line 1216
    tmp___9 = __builtin_expect((long )at_init_state, 0L);
#line 1216
    if (tmp___9) {
#line 1218
      if ((unsigned long )old_state == (unsigned long )cur_state) {
#line 1219
        next_start_idx = next_char_idx;
      } else {
#line 1221
        at_init_state = (_Bool)0;
      }
    }
#line 1224
    if (cur_state->halt) {
#line 1228
      if (! cur_state->has_constraint) {
#line 1228
        goto _L___2;
      } else {
#line 1228
        tmp___10 = check_halt_state_context((re_match_context_t const   *)mctx, (re_dfastate_t const   *)cur_state,
                                            mctx->input.cur_idx);
#line 1228
        if (tmp___10) {
          _L___2: /* CIL Label */ 
#line 1233
          match_last = mctx->input.cur_idx;
#line 1234
          match = (Idx )1;
#line 1237
          p_match_first = (Idx *)((void *)0);
#line 1238
          if (! fl_longest_match) {
#line 1239
            break;
          }
        }
      }
    }
  }
#line 1244
  if (p_match_first) {
#line 1245
    *p_match_first += next_start_idx;
  }
#line 1247
  return (match_last);
}
}
#line 1252 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static _Bool check_halt_node_context(re_dfa_t const   *dfa , Idx node , unsigned int context ) 
{ 
  re_token_type_t type ;
  unsigned int constraint ;

  {
#line 1256
  type = (dfa->nodes + node)->type;
#line 1257
  constraint = (dfa->nodes + node)->constraint;
#line 1258
  if ((unsigned int )type != 2U) {
#line 1259
    return ((_Bool)0);
  }
#line 1260
  if (! constraint) {
#line 1261
    return ((_Bool)1);
  }
#line 1262
  if (constraint & 4U) {
#line 1262
    if (! (context & 1U)) {
#line 1263
      return ((_Bool)0);
    } else {
#line 1262
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1262
  if (constraint & 8U) {
#line 1262
    if (context & 1U) {
#line 1263
      return ((_Bool)0);
    } else {
#line 1262
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1262
  if (constraint & 32U) {
#line 1262
    if (! (context & (unsigned int )(1 << 1))) {
#line 1263
      return ((_Bool)0);
    } else {
#line 1262
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1262
  if (constraint & 128U) {
#line 1262
    if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 1263
      return ((_Bool)0);
    }
  }
#line 1264
  return ((_Bool)1);
}
}
#line 1271 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static Idx check_halt_state_context(re_match_context_t const   *mctx , re_dfastate_t const   *state ,
                                    Idx idx ) 
{ 
  Idx i ;
  unsigned int context ;
  _Bool tmp ;

  {
#line 1281
  context = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 1282
  i = (Idx )0;
#line 1282
  while (i < (Idx )state->nodes.nelem) {
#line 1283
    tmp = check_halt_node_context((re_dfa_t const   *)mctx->dfa, *(state->nodes.elems + i),
                                  context);
#line 1283
    if (tmp) {
#line 1284
      return (*(state->nodes.elems + i));
    }
#line 1282
    i ++;
  }
#line 1285
  return ((Idx )0);
}
}
#line 1293 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static Idx proceed_next_node(re_match_context_t const   *mctx , Idx nregs , regmatch_t *regs ,
                             Idx *pidx , Idx node , re_node_set *eps_via_nodes , struct re_fail_stack_t *fs ) 
{ 
  re_dfa_t const   *dfa ;
  Idx i ;
  _Bool ok ;
  re_node_set *cur_nodes ;
  re_node_set *edests ;
  Idx dest_node ;
  long tmp ;
  Idx candidate ;
  Idx __attribute__((__pure__))  tmp___0 ;
  reg_errcode_t tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx naccepted ;
  re_token_type_t type ;
  int tmp___3 ;
  Idx subexp_idx ;
  char *buf___0 ;
  int tmp___4 ;
  Idx dest_node___0 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  Idx dest_node___1 ;
  Idx __attribute__((__pure__))  tmp___7 ;
  _Bool tmp___8 ;

  {
#line 1299
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1302
  if ((unsigned int )(dfa->nodes + node)->type & 8U) {
#line 1304
    cur_nodes = & (*(mctx->state_log + *pidx))->nodes;
#line 1305
    edests = dfa->edests + node;
#line 1307
    ok = re_node_set_insert(eps_via_nodes, node);
#line 1308
    tmp = __builtin_expect((long )(! ok), 0L);
#line 1308
    if (tmp) {
#line 1309
      return ((Idx )-2);
    }
#line 1312
    dest_node = (Idx )-1;
#line 1312
    i = (Idx )0;
#line 1312
    while (i < edests->nelem) {
#line 1314
      candidate = *(edests->elems + i);
#line 1315
      tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, candidate);
#line 1315
      if (! tmp___0) {
#line 1316
        goto __Cont;
      }
#line 1317
      if (dest_node == 0xffffffffffffffffUL) {
#line 1318
        dest_node = candidate;
      } else {
#line 1324
        tmp___2 = re_node_set_contains((re_node_set const   *)eps_via_nodes, dest_node);
#line 1324
        if (tmp___2) {
#line 1325
          return (candidate);
        } else
#line 1328
        if ((unsigned long )fs != (unsigned long )((void *)0)) {
#line 1328
          tmp___1 = push_fail_stack(fs, *pidx, candidate, nregs, regs, eps_via_nodes);
#line 1328
          if (tmp___1) {
#line 1331
            return ((Idx )-2);
          }
        }
#line 1334
        break;
      }
      __Cont: /* CIL Label */ 
#line 1312
      i ++;
    }
#line 1337
    return (dest_node);
  } else {
#line 1341
    naccepted = (Idx )0;
#line 1342
    type = (dfa->nodes + node)->type;
#line 1345
    if ((dfa->nodes + node)->accept_mb) {
#line 1346
      tmp___3 = check_node_accept_bytes(dfa, node, & mctx->input, *pidx);
#line 1346
      naccepted = (Idx )tmp___3;
    } else
#line 1349
    if ((unsigned int )type == 4U) {
#line 1351
      subexp_idx = (dfa->nodes + node)->opr.idx + 1UL;
#line 1352
      naccepted = (Idx )((regs + subexp_idx)->rm_eo - (regs + subexp_idx)->rm_so);
#line 1353
      if ((unsigned long )fs != (unsigned long )((void *)0)) {
#line 1355
        if ((regs + subexp_idx)->rm_so == -1L) {
#line 1356
          return ((Idx )-1);
        } else
#line 1355
        if ((regs + subexp_idx)->rm_eo == -1L) {
#line 1356
          return ((Idx )-1);
        } else
#line 1357
        if (naccepted) {
#line 1359
          buf___0 = (char *)mctx->input.mbs;
#line 1360
          tmp___4 = memcmp((void const   *)(buf___0 + (regs + subexp_idx)->rm_so),
                           (void const   *)(buf___0 + *pidx), naccepted);
#line 1360
          if (tmp___4 != 0) {
#line 1362
            return ((Idx )-1);
          }
        }
      }
#line 1366
      if (naccepted == 0UL) {
#line 1369
        ok = re_node_set_insert(eps_via_nodes, node);
#line 1370
        tmp___5 = __builtin_expect((long )(! ok), 0L);
#line 1370
        if (tmp___5) {
#line 1371
          return ((Idx )-2);
        }
#line 1372
        dest_node___0 = *((dfa->edests + node)->elems + 0);
#line 1373
        tmp___6 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                       dest_node___0);
#line 1373
        if (tmp___6) {
#line 1375
          return (dest_node___0);
        }
      }
    }
#line 1379
    if (naccepted != 0UL) {
#line 1379
      goto _L;
    } else {
#line 1379
      tmp___8 = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + node),
                                  *pidx);
#line 1379
      if (tmp___8) {
        _L: /* CIL Label */ 
#line 1382
        dest_node___1 = *(dfa->nexts + node);
#line 1383
        if (naccepted == 0UL) {
#line 1383
          (*pidx) ++;
        } else {
#line 1383
          *pidx += naccepted;
        }
#line 1384
        if (fs) {
#line 1384
          if (*pidx > (Idx )mctx->match_last) {
#line 1387
            return ((Idx )-1);
          } else
#line 1384
          if ((unsigned long )*(mctx->state_log + *pidx) == (unsigned long )((void *)0)) {
#line 1387
            return ((Idx )-1);
          } else {
#line 1384
            tmp___7 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + *pidx))->nodes),
                                           dest_node___1);
#line 1384
            if (! tmp___7) {
#line 1387
              return ((Idx )-1);
            }
          }
        }
#line 1388
        eps_via_nodes->nelem = (Idx )0;
#line 1389
        return (dest_node___1);
      }
    }
  }
#line 1392
  return ((Idx )-1);
}
}
#line 1395 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t push_fail_stack(struct re_fail_stack_t *fs , Idx str_idx , Idx dest_node ,
                                     Idx nregs , regmatch_t *regs , re_node_set *eps_via_nodes ) 
{ 
  reg_errcode_t err ;
  Idx num ;
  Idx tmp ;
  struct re_fail_stack_ent_t *new_array ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 1401
  tmp = fs->num;
#line 1401
  (fs->num) ++;
#line 1401
  num = tmp;
#line 1402
  if (fs->num == fs->alloc) {
#line 1405
    tmp___0 = realloc((void *)fs->stack, (sizeof(struct re_fail_stack_ent_t ) * fs->alloc) * 2UL);
#line 1405
    new_array = (struct re_fail_stack_ent_t *)tmp___0;
#line 1407
    if ((unsigned long )new_array == (unsigned long )((void *)0)) {
#line 1408
      return ((reg_errcode_t )12);
    }
#line 1409
    fs->alloc *= 2UL;
#line 1410
    fs->stack = new_array;
  }
#line 1412
  (fs->stack + num)->idx = str_idx;
#line 1413
  (fs->stack + num)->node = dest_node;
#line 1414
  tmp___1 = malloc(nregs * sizeof(regmatch_t ));
#line 1414
  (fs->stack + num)->regs = (regmatch_t *)tmp___1;
#line 1415
  if ((unsigned long )(fs->stack + num)->regs == (unsigned long )((void *)0)) {
#line 1416
    return ((reg_errcode_t )12);
  }
#line 1417
  memcpy((void * __restrict  )(fs->stack + num)->regs, (void const   * __restrict  )regs,
         sizeof(regmatch_t ) * nregs);
#line 1418
  err = re_node_set_init_copy(& (fs->stack + num)->eps_via_nodes, (re_node_set const   *)eps_via_nodes);
#line 1419
  return (err);
}
}
#line 1422 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static Idx pop_fail_stack(struct re_fail_stack_t *fs , Idx *pidx , Idx nregs , regmatch_t *regs ,
                          re_node_set *eps_via_nodes ) 
{ 
  Idx num ;

  {
#line 1427
  (fs->num) --;
#line 1427
  num = fs->num;
#line 1428
  if (! (num < 0xfffffffffffffffeUL)) {
#line 1428
    __assert_fail("REG_VALID_INDEX (num)", "/home/wslee/project/coreutils-8.1/lib/regexec.c",
                  1428U, "pop_fail_stack");
  }
#line 1429
  *pidx = (fs->stack + num)->idx;
#line 1430
  memcpy((void * __restrict  )regs, (void const   * __restrict  )(fs->stack + num)->regs,
         sizeof(regmatch_t ) * nregs);
#line 1431
  free((void *)eps_via_nodes->elems);
#line 1432
  free((void *)(fs->stack + num)->regs);
#line 1433
  *eps_via_nodes = (fs->stack + num)->eps_via_nodes;
#line 1434
  return ((fs->stack + num)->node);
}
}
#line 1442 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t set_regs(regex_t const   *preg , re_match_context_t const   *mctx ,
                              size_t nmatch , regmatch_t *pmatch , _Bool fl_backtrack ) 
{ 
  re_dfa_t const   *dfa ;
  Idx idx ;
  Idx cur_node ;
  re_node_set eps_via_nodes ;
  struct re_fail_stack_t *fs ;
  struct re_fail_stack_t fs_body ;
  regmatch_t *prev_idx_match ;
  _Bool prev_idx_match_malloced ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  Idx reg_idx ;
  reg_errcode_t tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  reg_errcode_t tmp___5 ;

  {
#line 1447
  dfa = (re_dfa_t const   *)preg->buffer;
#line 1451
  fs_body.num = (Idx )0;
#line 1451
  fs_body.alloc = (Idx )2;
#line 1451
  fs_body.stack = (struct re_fail_stack_ent_t *)((void *)0);
#line 1453
  prev_idx_match_malloced = (_Bool)0;
#line 1459
  if (fl_backtrack) {
#line 1461
    fs = & fs_body;
#line 1462
    tmp = malloc(fs->alloc * sizeof(struct re_fail_stack_ent_t ));
#line 1462
    fs->stack = (struct re_fail_stack_ent_t *)tmp;
#line 1463
    if ((unsigned long )fs->stack == (unsigned long )((void *)0)) {
#line 1464
      return ((reg_errcode_t )12);
    }
  } else {
#line 1467
    fs = (struct re_fail_stack_t *)((void *)0);
  }
#line 1469
  cur_node = (Idx )dfa->init_node;
#line 1470
  memset((void *)(& eps_via_nodes), '\000', sizeof(re_node_set ));
#line 1472
  if (nmatch * sizeof(regmatch_t ) < 4032UL) {
#line 1473
    tmp___0 = __builtin_alloca(nmatch * sizeof(regmatch_t ));
#line 1473
    prev_idx_match = (regmatch_t *)tmp___0;
  } else {
#line 1476
    tmp___1 = malloc(nmatch * sizeof(regmatch_t ));
#line 1476
    prev_idx_match = (regmatch_t *)tmp___1;
#line 1477
    if ((unsigned long )prev_idx_match == (unsigned long )((void *)0)) {
#line 1479
      free_fail_stack_return(fs);
#line 1480
      return ((reg_errcode_t )12);
    }
#line 1482
    prev_idx_match_malloced = (_Bool)1;
  }
#line 1484
  memcpy((void * __restrict  )prev_idx_match, (void const   * __restrict  )pmatch,
         sizeof(regmatch_t ) * nmatch);
#line 1486
  idx = (Idx )(pmatch + 0)->rm_so;
#line 1486
  while (idx <= (Idx )(pmatch + 0)->rm_eo) {
#line 1488
    update_regs(dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);
#line 1490
    if (idx == (Idx )(pmatch + 0)->rm_eo) {
#line 1490
      if (cur_node == (Idx )mctx->last_node) {
#line 1493
        if (fs) {
#line 1495
          reg_idx = (Idx )0;
#line 1495
          while (reg_idx < nmatch) {
#line 1496
            if ((pmatch + reg_idx)->rm_so > -1L) {
#line 1496
              if ((pmatch + reg_idx)->rm_eo == -1L) {
#line 1497
                break;
              }
            }
#line 1495
            reg_idx ++;
          }
#line 1498
          if (reg_idx == nmatch) {
#line 1500
            free((void *)eps_via_nodes.elems);
#line 1501
            if (prev_idx_match_malloced) {
#line 1502
              free((void *)prev_idx_match);
            }
#line 1503
            tmp___2 = free_fail_stack_return(fs);
#line 1503
            return (tmp___2);
          }
#line 1505
          cur_node = pop_fail_stack(fs, & idx, nmatch, pmatch, & eps_via_nodes);
        } else {
#line 1510
          free((void *)eps_via_nodes.elems);
#line 1511
          if (prev_idx_match_malloced) {
#line 1512
            free((void *)prev_idx_match);
          }
#line 1513
          return ((reg_errcode_t )0);
        }
      }
    }
#line 1518
    cur_node = proceed_next_node(mctx, nmatch, pmatch, & idx, cur_node, & eps_via_nodes,
                                 fs);
#line 1521
    tmp___4 = __builtin_expect((long )(! (cur_node < 0xfffffffffffffffeUL)), 0L);
#line 1521
    if (tmp___4) {
#line 1523
      tmp___3 = __builtin_expect((long )(cur_node == 0xfffffffffffffffeUL), 0L);
#line 1523
      if (tmp___3) {
#line 1525
        free((void *)eps_via_nodes.elems);
#line 1526
        if (prev_idx_match_malloced) {
#line 1527
          free((void *)prev_idx_match);
        }
#line 1528
        free_fail_stack_return(fs);
#line 1529
        return ((reg_errcode_t )12);
      }
#line 1531
      if (fs) {
#line 1532
        cur_node = pop_fail_stack(fs, & idx, nmatch, pmatch, & eps_via_nodes);
      } else {
#line 1536
        free((void *)eps_via_nodes.elems);
#line 1537
        if (prev_idx_match_malloced) {
#line 1538
          free((void *)prev_idx_match);
        }
#line 1539
        return ((reg_errcode_t )1);
      }
    }
  }
#line 1543
  free((void *)eps_via_nodes.elems);
#line 1544
  if (prev_idx_match_malloced) {
#line 1545
    free((void *)prev_idx_match);
  }
#line 1546
  tmp___5 = free_fail_stack_return(fs);
#line 1546
  return (tmp___5);
}
}
#line 1549 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t free_fail_stack_return(struct re_fail_stack_t *fs ) 
{ 
  Idx fs_idx ;

  {
#line 1553
  if (fs) {
#line 1556
    fs_idx = (Idx )0;
#line 1556
    while (fs_idx < fs->num) {
#line 1558
      free((void *)(fs->stack + fs_idx)->eps_via_nodes.elems);
#line 1559
      free((void *)(fs->stack + fs_idx)->regs);
#line 1556
      fs_idx ++;
    }
#line 1561
    free((void *)fs->stack);
  }
#line 1563
  return ((reg_errcode_t )0);
}
}
#line 1566 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static void update_regs(re_dfa_t const   *dfa , regmatch_t *pmatch , regmatch_t *prev_idx_match ,
                        Idx cur_node , Idx cur_idx , Idx nmatch ) 
{ 
  int type ;
  Idx reg_num ;
  Idx reg_num___0 ;

  {
#line 1571
  type = (int )(dfa->nodes + cur_node)->type;
#line 1572
  if (type == 8) {
#line 1574
    reg_num = (dfa->nodes + cur_node)->opr.idx + 1UL;
#line 1577
    if (reg_num < nmatch) {
#line 1579
      (pmatch + reg_num)->rm_so = (regoff_t )cur_idx;
#line 1580
      (pmatch + reg_num)->rm_eo = (regoff_t )-1;
    }
  } else
#line 1583
  if (type == 9) {
#line 1585
    reg_num___0 = (dfa->nodes + cur_node)->opr.idx + 1UL;
#line 1586
    if (reg_num___0 < nmatch) {
#line 1589
      if ((Idx )(pmatch + reg_num___0)->rm_so < cur_idx) {
#line 1591
        (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
#line 1594
        memcpy((void * __restrict  )prev_idx_match, (void const   * __restrict  )pmatch,
               sizeof(regmatch_t ) * nmatch);
      } else
#line 1598
      if ((dfa->nodes + cur_node)->opt_subexp) {
#line 1598
        if ((prev_idx_match + reg_num___0)->rm_so != -1L) {
#line 1605
          memcpy((void * __restrict  )pmatch, (void const   * __restrict  )prev_idx_match,
                 sizeof(regmatch_t ) * nmatch);
        } else {
#line 1609
          (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
        }
      } else {
#line 1609
        (pmatch + reg_num___0)->rm_eo = (regoff_t )cur_idx;
      }
    }
  }
#line 1613
  return;
}
}
#line 1638 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t sift_states_backward(re_match_context_t const   *mctx , re_sift_context_t *sctx ) 
{ 
  reg_errcode_t err ;
  int null_cnt ;
  Idx str_idx ;
  re_node_set cur_dest ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1643
  null_cnt = 0;
#line 1644
  str_idx = sctx->last_str_idx;
#line 1653
  err = re_node_set_init_1(& cur_dest, sctx->last_node);
#line 1654
  tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 1654
  if (tmp) {
#line 1655
    return (err);
  }
#line 1656
  err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1657
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1657
  if (tmp___0) {
#line 1658
    goto free_return;
  }
#line 1661
  while (str_idx > 0UL) {
#line 1664
    if ((unsigned long )*(sctx->sifted_states + str_idx) == (unsigned long )((void *)0)) {
#line 1664
      null_cnt ++;
    } else {
#line 1664
      null_cnt = 0;
    }
#line 1665
    if (null_cnt > (int )mctx->max_mb_elem_len) {
#line 1667
      memset((void *)sctx->sifted_states, '\000', sizeof(re_dfastate_t *) * str_idx);
#line 1669
      free((void *)cur_dest.elems);
#line 1670
      return ((reg_errcode_t )0);
    }
#line 1672
    cur_dest.nelem = (Idx )0;
#line 1673
    str_idx --;
#line 1675
    if (*(mctx->state_log + str_idx)) {
#line 1677
      err = build_sifted_states(mctx, sctx, str_idx, & cur_dest);
#line 1678
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 1678
      if (tmp___1) {
#line 1679
        goto free_return;
      }
    }
#line 1686
    err = update_cur_sifted_state(mctx, sctx, str_idx, & cur_dest);
#line 1687
    tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
#line 1687
    if (tmp___2) {
#line 1688
      goto free_return;
    }
  }
#line 1690
  err = (reg_errcode_t )0;
  free_return: 
#line 1692
  free((void *)cur_dest.elems);
#line 1693
  return (err);
}
}
#line 1696 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t build_sifted_states(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                         Idx str_idx , re_node_set *cur_dest ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *cur_src ;
  Idx i ;
  Idx prev_node ;
  int naccepted ;
  _Bool ok ;
  _Bool tmp ;
  Idx __attribute__((__pure__))  tmp___0 ;
  Idx to_idx ;
  _Bool tmp___1 ;
  long tmp___2 ;

  {
#line 1701
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1702
  cur_src = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->non_eps_nodes);
#line 1712
  i = (Idx )0;
#line 1712
  while (i < (Idx )cur_src->nelem) {
#line 1714
    prev_node = *(cur_src->elems + i);
#line 1715
    naccepted = 0;
#line 1724
    if ((dfa->nodes + prev_node)->accept_mb) {
#line 1725
      naccepted = sift_states_iter_mb(mctx, sctx, prev_node, str_idx, sctx->last_str_idx);
    }
#line 1731
    if (! naccepted) {
#line 1731
      tmp = check_node_accept(mctx, (re_token_t const   *)(dfa->nodes + prev_node),
                              str_idx);
#line 1731
      if (tmp) {
#line 1731
        if ((unsigned long )*(sctx->sifted_states + (str_idx + 1UL)) != (unsigned long )((void *)0)) {
#line 1731
          tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + 1UL)))->nodes),
                                         *(dfa->nexts + prev_node));
#line 1731
          if (tmp___0) {
#line 1735
            naccepted = 1;
          }
        }
      }
    }
#line 1737
    if (naccepted == 0) {
#line 1738
      goto __Cont;
    }
#line 1740
    if (sctx->limits.nelem) {
#line 1742
      to_idx = str_idx + (Idx )naccepted;
#line 1743
      tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits), *(dfa->nexts + prev_node),
                                 to_idx, prev_node, str_idx);
#line 1743
      if (tmp___1) {
#line 1746
        goto __Cont;
      }
    }
#line 1748
    ok = re_node_set_insert(cur_dest, prev_node);
#line 1749
    tmp___2 = __builtin_expect((long )(! ok), 0L);
#line 1749
    if (tmp___2) {
#line 1750
      return ((reg_errcode_t )12);
    }
    __Cont: /* CIL Label */ 
#line 1712
    i ++;
  }
#line 1753
  return ((reg_errcode_t )0);
}
}
#line 1758 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t clean_state_log_if_needed(re_match_context_t *mctx , Idx next_state_log_idx ) 
{ 
  Idx top ;
  reg_errcode_t err ;
  long tmp ;

  {
#line 1762
  top = mctx->state_log_top;
#line 1764
  if (next_state_log_idx >= mctx->input.bufs_len) {
#line 1764
    goto _L;
  } else
#line 1764
  if (next_state_log_idx >= mctx->input.valid_len) {
#line 1764
    if (mctx->input.valid_len < mctx->input.len) {
      _L: /* CIL Label */ 
#line 1769
      err = extend_buffers(mctx);
#line 1770
      tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 1770
      if (tmp) {
#line 1771
        return (err);
      }
    }
  }
#line 1774
  if (top < next_state_log_idx) {
#line 1776
    memset((void *)((mctx->state_log + top) + 1), '\000', sizeof(re_dfastate_t *) * (next_state_log_idx - top));
#line 1778
    mctx->state_log_top = next_state_log_idx;
  }
#line 1780
  return ((reg_errcode_t )0);
}
}
#line 1783 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t merge_state_array(re_dfa_t const   *dfa , re_dfastate_t **dst ,
                                       re_dfastate_t **src , Idx num ) 
{ 
  Idx st_idx ;
  reg_errcode_t err ;
  re_node_set merged_set ;
  long tmp ;
  long tmp___0 ;

  {
#line 1790
  st_idx = (Idx )0;
#line 1790
  while (st_idx < num) {
#line 1792
    if ((unsigned long )*(dst + st_idx) == (unsigned long )((void *)0)) {
#line 1793
      *(dst + st_idx) = *(src + st_idx);
    } else
#line 1794
    if ((unsigned long )*(src + st_idx) != (unsigned long )((void *)0)) {
#line 1797
      err = re_node_set_init_union(& merged_set, (re_node_set const   *)(& (*(dst + st_idx))->nodes),
                                   (re_node_set const   *)(& (*(src + st_idx))->nodes));
#line 1799
      tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 1799
      if (tmp) {
#line 1800
        return (err);
      }
#line 1801
      *(dst + st_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& merged_set));
#line 1802
      free((void *)merged_set.elems);
#line 1803
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1803
      if (tmp___0) {
#line 1804
        return (err);
      }
    }
#line 1790
    st_idx ++;
  }
#line 1807
  return ((reg_errcode_t )0);
}
}
#line 1810 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t update_cur_sifted_state(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                             Idx str_idx , re_node_set *dest_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  re_node_set const   *candidates ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;

  {
#line 1816
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1817
  err = (reg_errcode_t )0;
#line 1819
  if ((unsigned long )*(mctx->state_log + str_idx) == (unsigned long )((void *)0)) {
#line 1819
    candidates = (re_node_set const   *)((void *)0);
  } else {
#line 1819
    candidates = (re_node_set const   *)(& (*(mctx->state_log + str_idx))->nodes);
  }
#line 1822
  if (dest_nodes->nelem == 0UL) {
#line 1823
    *(sctx->sifted_states + str_idx) = (re_dfastate_t *)((void *)0);
  } else {
#line 1826
    if (candidates) {
#line 1830
      err = add_epsilon_src_nodes(dfa, dest_nodes, candidates);
#line 1831
      tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 1831
      if (tmp) {
#line 1832
        return (err);
      }
#line 1835
      if (sctx->limits.nelem) {
#line 1837
        err = check_subexp_limits(dfa, dest_nodes, candidates, & sctx->limits, (struct re_backref_cache_entry *)mctx->bkref_ents,
                                  str_idx);
#line 1839
        tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1839
        if (tmp___0) {
#line 1840
          return (err);
        }
      }
    }
#line 1844
    *(sctx->sifted_states + str_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1845
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 1845
    if (tmp___1) {
#line 1846
      return (err);
    }
  }
#line 1849
  if (candidates) {
#line 1849
    if ((*(mctx->state_log + str_idx))->has_backref) {
#line 1851
      err = sift_states_bkref(mctx, sctx, str_idx, candidates);
#line 1852
      tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
#line 1852
      if (tmp___2) {
#line 1853
        return (err);
      }
    }
  }
#line 1855
  return ((reg_errcode_t )0);
}
}
#line 1858 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t add_epsilon_src_nodes(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  re_dfastate_t *state ;
  re_dfastate_t *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  reg_errcode_t tmp___2 ;

  {
#line 1863
  err = (reg_errcode_t )0;
#line 1866
  tmp = re_acquire_state(& err, dfa, (re_node_set const   *)dest_nodes);
#line 1866
  state = tmp;
#line 1867
  tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1867
  if (tmp___0) {
#line 1868
    return (err);
  }
#line 1870
  if (! state->inveclosure.alloc) {
#line 1872
    err = re_node_set_alloc(& state->inveclosure, dest_nodes->nelem);
#line 1873
    tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 1873
    if (tmp___1) {
#line 1874
      return ((reg_errcode_t )12);
    }
#line 1875
    i = (Idx )0;
#line 1875
    while (i < dest_nodes->nelem) {
#line 1876
      re_node_set_merge(& state->inveclosure, (re_node_set const   *)(dfa->inveclosures + *(dest_nodes->elems + i)));
#line 1875
      i ++;
    }
  }
#line 1879
  tmp___2 = re_node_set_add_intersect(dest_nodes, candidates, (re_node_set const   *)(& state->inveclosure));
#line 1879
  return (tmp___2);
}
}
#line 1883 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t sub_epsilon_src_nodes(re_dfa_t const   *dfa , Idx node , re_node_set *dest_nodes ,
                                           re_node_set const   *candidates ) 
{ 
  Idx ecl_idx ;
  reg_errcode_t err ;
  re_node_set *inv_eclosure ;
  re_node_set except_nodes ;
  Idx cur_node ;
  Idx edst1 ;
  Idx edst2 ;
  Idx tmp ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx __attribute__((__pure__))  tmp___3 ;
  Idx __attribute__((__pure__))  tmp___4 ;
  Idx cur_node___0 ;
  Idx idx ;
  Idx __attribute__((__pure__))  tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;

  {
#line 1890
  inv_eclosure = (re_node_set *)(dfa->inveclosures + node);
#line 1892
  memset((void *)(& except_nodes), '\000', sizeof(re_node_set ));
#line 1893
  ecl_idx = (Idx )0;
#line 1893
  while (ecl_idx < inv_eclosure->nelem) {
#line 1895
    cur_node = *(inv_eclosure->elems + ecl_idx);
#line 1896
    if (cur_node == node) {
#line 1897
      goto __Cont;
    }
#line 1898
    if ((unsigned int )(dfa->nodes + cur_node)->type & 8U) {
#line 1900
      edst1 = *((dfa->edests + cur_node)->elems + 0);
#line 1901
      if ((dfa->edests + cur_node)->nelem > 1UL) {
#line 1901
        tmp = *((dfa->edests + cur_node)->elems + 1);
      } else {
#line 1901
        tmp = (Idx )-1;
      }
#line 1901
      edst2 = tmp;
#line 1903
      tmp___1 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst1);
#line 1903
      if (tmp___1) {
        _L___0: /* CIL Label */ 
#line 1903
        if (edst2 - 1UL < 0xfffffffffffffffdUL) {
#line 1903
          tmp___3 = re_node_set_contains((re_node_set const   *)inv_eclosure, edst2);
#line 1903
          if (! tmp___3) {
#line 1903
            tmp___4 = re_node_set_contains((re_node_set const   *)dest_nodes, edst2);
#line 1903
            if (tmp___4) {
              _L: /* CIL Label */ 
#line 1909
              err = re_node_set_add_intersect(& except_nodes, candidates, (re_node_set const   *)(dfa->inveclosures + cur_node));
#line 1911
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 1911
              if (tmp___0) {
#line 1913
                free((void *)except_nodes.elems);
#line 1914
                return (err);
              }
            }
          }
        }
      } else {
#line 1903
        tmp___2 = re_node_set_contains((re_node_set const   *)dest_nodes, edst1);
#line 1903
        if (tmp___2) {
#line 1903
          goto _L;
        } else {
#line 1903
          goto _L___0;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1893
    ecl_idx ++;
  }
#line 1919
  ecl_idx = (Idx )0;
#line 1919
  while (ecl_idx < inv_eclosure->nelem) {
#line 1921
    cur_node___0 = *(inv_eclosure->elems + ecl_idx);
#line 1922
    tmp___6 = re_node_set_contains((re_node_set const   *)(& except_nodes), cur_node___0);
#line 1922
    if (! tmp___6) {
#line 1924
      tmp___5 = re_node_set_contains((re_node_set const   *)dest_nodes, cur_node___0);
#line 1924
      idx = (Idx )(tmp___5 - (Idx __attribute__((__pure__))  )1);
#line 1925
      re_node_set_remove_at(dest_nodes, idx);
    }
#line 1919
    ecl_idx ++;
  }
#line 1928
  free((void *)except_nodes.elems);
#line 1929
  return ((reg_errcode_t )0);
}
}
#line 1932 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static _Bool check_dst_limits(re_match_context_t const   *mctx , re_node_set const   *limits ,
                              Idx dst_node , Idx dst_idx , Idx src_node , Idx src_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx lim_idx ;
  Idx src_pos ;
  Idx dst_pos ;
  Idx dst_bkref_idx ;
  Idx tmp ;
  Idx src_bkref_idx ;
  Idx tmp___0 ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1937
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1940
  tmp = search_cur_bkref_entry(mctx, dst_idx);
#line 1940
  dst_bkref_idx = tmp;
#line 1941
  tmp___0 = search_cur_bkref_entry(mctx, src_idx);
#line 1941
  src_bkref_idx = tmp___0;
#line 1942
  lim_idx = (Idx )0;
#line 1942
  while (lim_idx < (Idx )limits->nelem) {
#line 1946
    ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + *(limits->elems + lim_idx));
#line 1947
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 1949
    tmp___1 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        dst_node, dst_idx, dst_bkref_idx);
#line 1949
    dst_pos = (Idx )tmp___1;
#line 1952
    tmp___2 = check_dst_limits_calc_pos(mctx, *(limits->elems + lim_idx), subexp_idx,
                                        src_node, src_idx, src_bkref_idx);
#line 1952
    src_pos = (Idx )tmp___2;
#line 1960
    if (! (src_pos == dst_pos)) {
#line 1963
      return ((_Bool)1);
    }
#line 1942
    lim_idx ++;
  }
#line 1965
  return ((_Bool)0);
}
}
#line 1968 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static int check_dst_limits_calc_pos_1(re_match_context_t const   *mctx , int boundaries ,
                                       Idx subexp_idx , Idx from_node , Idx bkref_idx ) 
{ 
  re_dfa_t const   *dfa ;
  re_node_set const   *eclosures ;
  Idx node_idx ;
  Idx node ;
  struct re_backref_cache_entry *ent ;
  Idx dst ;
  int cpos ;
  struct re_backref_cache_entry *tmp ;
  int tmp___0 ;

  {
#line 1973
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 1974
  eclosures = (re_node_set const   *)(dfa->eclosures + from_node);
#line 1979
  node_idx = (Idx )0;
#line 1979
  while (node_idx < (Idx )eclosures->nelem) {
#line 1981
    node = *(eclosures->elems + node_idx);
#line 1982
    switch ((unsigned int )(dfa->nodes + node)->type) {
    case 4U: 
#line 1985
    if (bkref_idx != 0xffffffffffffffffUL) {
#line 1987
      ent = (struct re_backref_cache_entry *)(mctx->bkref_ents + bkref_idx);
#line 1988
      while (1) {
#line 1993
        if (ent->node != node) {
#line 1994
          goto __Cont;
        }
#line 1996
        if (subexp_idx < 64UL) {
#line 1996
          if (! ((unsigned long )ent->eps_reachable_subexps_map & (1UL << subexp_idx))) {
#line 1999
            goto __Cont;
          }
        }
#line 2007
        dst = *((dfa->edests + node)->elems + 0);
#line 2008
        if (dst == from_node) {
#line 2010
          if (boundaries & 1) {
#line 2011
            return (-1);
          } else {
#line 2013
            return (0);
          }
        }
#line 2016
        cpos = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, dst, bkref_idx);
#line 2019
        if (cpos == -1) {
#line 2020
          return (-1);
        }
#line 2021
        if (cpos == 0) {
#line 2021
          if (boundaries & 2) {
#line 2022
            return (0);
          }
        }
#line 2024
        if (subexp_idx < 64UL) {
#line 2025
          ent->eps_reachable_subexps_map = (unsigned short )((unsigned long )ent->eps_reachable_subexps_map & ~ (1UL << subexp_idx));
        }
        __Cont: /* CIL Label */ 
#line 1988
        tmp = ent;
#line 1988
        ent ++;
#line 1988
        if (! tmp->more) {
#line 1988
          break;
        }
      }
    }
#line 2030
    break;
    case 8U: 
#line 2033
    if (boundaries & 1) {
#line 2033
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2034
        return (-1);
      }
    }
#line 2035
    break;
    case 9U: 
#line 2038
    if (boundaries & 2) {
#line 2038
      if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2039
        return (0);
      }
    }
#line 2040
    break;
    default: 
#line 2043
    break;
    }
#line 1979
    node_idx ++;
  }
#line 2047
  if (boundaries & 2) {
#line 2047
    tmp___0 = 1;
  } else {
#line 2047
    tmp___0 = 0;
  }
#line 2047
  return (tmp___0);
}
}
#line 2050 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static int check_dst_limits_calc_pos(re_match_context_t const   *mctx , Idx limit ,
                                     Idx subexp_idx , Idx from_node , Idx str_idx ,
                                     Idx bkref_idx ) 
{ 
  struct re_backref_cache_entry *lim ;
  int boundaries ;
  int tmp ;

  {
#line 2056
  lim = (struct re_backref_cache_entry *)(mctx->bkref_ents + limit);
#line 2060
  if (str_idx < lim->subexp_from) {
#line 2061
    return (-1);
  }
#line 2063
  if (lim->subexp_to < str_idx) {
#line 2064
    return (1);
  }
#line 2067
  boundaries = str_idx == lim->subexp_from;
#line 2068
  boundaries |= (str_idx == lim->subexp_to) << 1;
#line 2069
  if (boundaries == 0) {
#line 2070
    return (0);
  }
#line 2073
  tmp = check_dst_limits_calc_pos_1(mctx, boundaries, subexp_idx, from_node, bkref_idx);
#line 2073
  return (tmp);
}
}
#line 2080 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t check_subexp_limits(re_dfa_t const   *dfa , re_node_set *dest_nodes ,
                                         re_node_set const   *candidates , re_node_set *limits ,
                                         struct re_backref_cache_entry *bkref_ents ,
                                         Idx str_idx ) 
{ 
  reg_errcode_t err ;
  Idx node_idx ;
  Idx lim_idx ;
  Idx subexp_idx ;
  struct re_backref_cache_entry *ent ;
  Idx ops_node ;
  Idx cls_node ;
  Idx node ;
  re_token_type_t type ;
  long tmp ;
  Idx node___0 ;
  long tmp___0 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;
  Idx node___1 ;
  re_token_type_t type___0 ;
  long tmp___3 ;

  {
#line 2089
  lim_idx = (Idx )0;
#line 2089
  while (lim_idx < limits->nelem) {
#line 2093
    ent = bkref_ents + *(limits->elems + lim_idx);
#line 2095
    if (str_idx <= ent->subexp_from) {
#line 2096
      goto __Cont;
    } else
#line 2095
    if (ent->str_idx < str_idx) {
#line 2096
      goto __Cont;
    }
#line 2098
    subexp_idx = (dfa->nodes + ent->node)->opr.idx;
#line 2099
    if (ent->subexp_to == str_idx) {
#line 2101
      ops_node = (Idx )-1;
#line 2102
      cls_node = (Idx )-1;
#line 2103
      node_idx = (Idx )0;
#line 2103
      while (node_idx < dest_nodes->nelem) {
#line 2105
        node = *(dest_nodes->elems + node_idx);
#line 2106
        type = (dfa->nodes + node)->type;
#line 2107
        if ((unsigned int )type == 8U) {
#line 2107
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2109
            ops_node = node;
          } else {
#line 2107
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 2110
        if ((unsigned int )type == 9U) {
#line 2110
          if (subexp_idx == (dfa->nodes + node)->opr.idx) {
#line 2112
            cls_node = node;
          }
        }
#line 2103
        node_idx ++;
      }
#line 2117
      if (ops_node < 0xfffffffffffffffeUL) {
#line 2119
        err = sub_epsilon_src_nodes(dfa, ops_node, dest_nodes, candidates);
#line 2121
        tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 2121
        if (tmp) {
#line 2122
          return (err);
        }
      }
#line 2126
      if (cls_node < 0xfffffffffffffffeUL) {
#line 2127
        node_idx = (Idx )0;
#line 2127
        while (node_idx < dest_nodes->nelem) {
#line 2129
          node___0 = *(dest_nodes->elems + node_idx);
#line 2130
          tmp___1 = re_node_set_contains((re_node_set const   *)(dfa->inveclosures + node___0),
                                         cls_node);
#line 2130
          if (! tmp___1) {
#line 2130
            tmp___2 = re_node_set_contains((re_node_set const   *)(dfa->eclosures + node___0),
                                           cls_node);
#line 2130
            if (! tmp___2) {
#line 2137
              err = sub_epsilon_src_nodes(dfa, node___0, dest_nodes, candidates);
#line 2139
              tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 2139
              if (tmp___0) {
#line 2140
                return (err);
              }
#line 2141
              node_idx --;
            }
          }
#line 2127
          node_idx ++;
        }
      }
    } else {
#line 2147
      node_idx = (Idx )0;
#line 2147
      while (node_idx < dest_nodes->nelem) {
#line 2149
        node___1 = *(dest_nodes->elems + node_idx);
#line 2150
        type___0 = (dfa->nodes + node___1)->type;
#line 2151
        if ((unsigned int )type___0 == 9U) {
#line 2151
          goto _L___0;
        } else
#line 2151
        if ((unsigned int )type___0 == 8U) {
          _L___0: /* CIL Label */ 
#line 2153
          if (subexp_idx != (dfa->nodes + node___1)->opr.idx) {
#line 2154
            goto __Cont___0;
          }
#line 2157
          err = sub_epsilon_src_nodes(dfa, node___1, dest_nodes, candidates);
#line 2159
          tmp___3 = __builtin_expect((long )((int )err != 0), 0L);
#line 2159
          if (tmp___3) {
#line 2160
            return (err);
          }
        }
        __Cont___0: /* CIL Label */ 
#line 2147
        node_idx ++;
      }
    }
    __Cont: /* CIL Label */ 
#line 2089
    lim_idx ++;
  }
#line 2165
  return ((reg_errcode_t )0);
}
}
#line 2168 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t sift_states_bkref(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                                       Idx str_idx , re_node_set const   *candidates ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx node_idx ;
  Idx node ;
  re_sift_context_t local_sctx ;
  Idx first_idx ;
  Idx tmp ;
  Idx enabled_idx ;
  re_token_type_t type ;
  struct re_backref_cache_entry *entry ;
  Idx subexp_len ;
  Idx to_idx ;
  Idx dst_node ;
  _Bool ok ;
  re_dfastate_t *cur_state ;
  Idx __attribute__((__pure__))  tmp___0 ;
  _Bool tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  Idx __attribute__((__pure__))  tmp___6 ;
  struct re_backref_cache_entry *tmp___7 ;

  {
#line 2173
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2177
  tmp = search_cur_bkref_entry(mctx, str_idx);
#line 2177
  first_idx = tmp;
#line 2179
  if (first_idx == 0xffffffffffffffffUL) {
#line 2180
    return ((reg_errcode_t )0);
  }
#line 2182
  local_sctx.sifted_states = (re_dfastate_t **)((void *)0);
#line 2184
  node_idx = (Idx )0;
#line 2184
  while (node_idx < (Idx )candidates->nelem) {
#line 2189
    node = *(candidates->elems + node_idx);
#line 2190
    type = (dfa->nodes + node)->type;
#line 2192
    if (node == sctx->last_node) {
#line 2192
      if (str_idx == sctx->last_str_idx) {
#line 2193
        goto __Cont;
      }
    }
#line 2194
    if ((unsigned int )type != 4U) {
#line 2195
      goto __Cont;
    }
#line 2197
    entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + first_idx);
#line 2198
    enabled_idx = first_idx;
#line 2199
    while (1) {
#line 2207
      if (entry->node != node) {
#line 2208
        goto __Cont___0;
      }
#line 2209
      subexp_len = entry->subexp_to - entry->subexp_from;
#line 2210
      to_idx = str_idx + subexp_len;
#line 2211
      if (subexp_len) {
#line 2211
        dst_node = *(dfa->nexts + node);
      } else {
#line 2211
        dst_node = *((dfa->edests + node)->elems + 0);
      }
#line 2214
      if (to_idx > sctx->last_str_idx) {
#line 2219
        goto __Cont___0;
      } else
#line 2214
      if ((unsigned long )*(sctx->sifted_states + to_idx) == (unsigned long )((void *)0)) {
#line 2219
        goto __Cont___0;
      } else
#line 2214
      if ((unsigned long )*(sctx->sifted_states + to_idx) != (unsigned long )((void *)0)) {
#line 2214
        tmp___0 = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + to_idx))->nodes),
                                       dst_node);
#line 2214
        if (tmp___0) {
#line 2214
          tmp___1 = check_dst_limits(mctx, (re_node_set const   *)(& sctx->limits),
                                     node, str_idx, dst_node, to_idx);
#line 2214
          if (tmp___1) {
#line 2219
            goto __Cont___0;
          }
        } else {
#line 2219
          goto __Cont___0;
        }
      } else {
#line 2219
        goto __Cont___0;
      }
#line 2221
      if ((unsigned long )local_sctx.sifted_states == (unsigned long )((void *)0)) {
#line 2223
        local_sctx = *sctx;
#line 2224
        err = re_node_set_init_copy(& local_sctx.limits, (re_node_set const   *)(& sctx->limits));
#line 2225
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
#line 2225
        if (tmp___2) {
#line 2226
          goto free_return;
        }
      }
#line 2228
      local_sctx.last_node = node;
#line 2229
      local_sctx.last_str_idx = str_idx;
#line 2230
      ok = re_node_set_insert(& local_sctx.limits, enabled_idx);
#line 2231
      tmp___3 = __builtin_expect((long )(! ok), 0L);
#line 2231
      if (tmp___3) {
#line 2233
        err = (reg_errcode_t )12;
#line 2234
        goto free_return;
      }
#line 2236
      cur_state = *(local_sctx.sifted_states + str_idx);
#line 2237
      err = sift_states_backward(mctx, & local_sctx);
#line 2238
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
#line 2238
      if (tmp___4) {
#line 2239
        goto free_return;
      }
#line 2240
      if ((unsigned long )sctx->limited_states != (unsigned long )((void *)0)) {
#line 2242
        err = merge_state_array(dfa, sctx->limited_states, local_sctx.sifted_states,
                                str_idx + 1UL);
#line 2245
        tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
#line 2245
        if (tmp___5) {
#line 2246
          goto free_return;
        }
      }
#line 2248
      *(local_sctx.sifted_states + str_idx) = cur_state;
#line 2249
      tmp___6 = re_node_set_contains((re_node_set const   *)(& local_sctx.limits),
                                     enabled_idx);
#line 2249
      re_node_set_remove_at(& local_sctx.limits, (Idx )(tmp___6 - (Idx __attribute__((__pure__))  )1));
#line 2252
      entry = (struct re_backref_cache_entry *)(mctx->bkref_ents + enabled_idx);
      __Cont___0: /* CIL Label */ 
#line 2199
      enabled_idx ++;
#line 2199
      tmp___7 = entry;
#line 2199
      entry ++;
#line 2199
      if (! tmp___7->more) {
#line 2199
        break;
      }
    }
    __Cont: /* CIL Label */ 
#line 2184
    node_idx ++;
  }
#line 2256
  err = (reg_errcode_t )0;
  free_return: 
#line 2258
  if ((unsigned long )local_sctx.sifted_states != (unsigned long )((void *)0)) {
#line 2260
    free((void *)local_sctx.limits.elems);
  }
#line 2263
  return (err);
}
}
#line 2268 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static int sift_states_iter_mb(re_match_context_t const   *mctx , re_sift_context_t *sctx ,
                               Idx node_idx , Idx str_idx , Idx max_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  int naccepted ;
  Idx __attribute__((__pure__))  tmp ;

  {
#line 2273
  dfa = (re_dfa_t const   *)mctx->dfa;
#line 2276
  naccepted = check_node_accept_bytes(dfa, node_idx, & mctx->input, str_idx);
#line 2277
  if (naccepted > 0) {
#line 2277
    if (str_idx + (Idx )naccepted <= max_str_idx) {
#line 2277
      if ((unsigned long )*(sctx->sifted_states + (str_idx + (Idx )naccepted)) != (unsigned long )((void *)0)) {
#line 2277
        tmp = re_node_set_contains((re_node_set const   *)(& (*(sctx->sifted_states + (str_idx + (Idx )naccepted)))->nodes),
                                   *(dfa->nexts + node_idx));
#line 2277
        if (! tmp) {
#line 2283
          naccepted = 0;
        }
      } else {
#line 2283
        naccepted = 0;
      }
    }
  }
#line 2286
  return (naccepted);
}
}
#line 2298 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static re_dfastate_t *transit_state(reg_errcode_t *err , re_match_context_t *mctx ,
                                    re_dfastate_t *state ) 
{ 
  re_dfastate_t **trtable ;
  unsigned char ch ;
  long tmp ;
  long tmp___0 ;
  Idx tmp___1 ;
  long tmp___2 ;
  unsigned int context ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
#line 2308
  tmp___0 = __builtin_expect((long )state->accept_mb, 0L);
#line 2308
  if (tmp___0) {
#line 2310
    *err = transit_state_mb(mctx, state);
#line 2311
    tmp = __builtin_expect((long )((int )*err != 0), 0L);
#line 2311
    if (tmp) {
#line 2312
      return ((re_dfastate_t *)((void *)0));
    }
  }
#line 2324
  tmp___1 = mctx->input.cur_idx;
#line 2324
  (mctx->input.cur_idx) ++;
#line 2324
  ch = *(mctx->input.mbs + tmp___1);
#line 2325
  while (1) {
#line 2327
    trtable = state->trtable;
#line 2328
    tmp___2 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
#line 2328
    if (tmp___2) {
#line 2329
      return (*(trtable + ch));
    }
#line 2331
    trtable = state->word_trtable;
#line 2332
    tmp___3 = __builtin_expect((long )((unsigned long )trtable != (unsigned long )((void *)0)),
                               1L);
#line 2332
    if (tmp___3) {
#line 2335
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1UL,
                                     mctx->eflags);
#line 2339
      if (context & 1U) {
#line 2340
        return (*(trtable + ((int )ch + 256)));
      } else {
#line 2342
        return (*(trtable + ch));
      }
    }
#line 2345
    tmp___4 = build_trtable(mctx->dfa, state);
#line 2345
    if (! tmp___4) {
#line 2347
      *err = (reg_errcode_t )12;
#line 2348
      return ((re_dfastate_t *)((void *)0));
    }
  }
}
}
#line 2356 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static re_dfastate_t *merge_state_with_log(reg_errcode_t *err , re_match_context_t *mctx ,
                                           re_dfastate_t *next_state ) 
{ 
  re_dfa_t const   *dfa ;
  Idx cur_idx ;
  re_dfastate_t *pstate ;
  unsigned int context ;
  re_node_set next_nodes ;
  re_node_set *log_nodes ;
  re_node_set *table_nodes ;
  long tmp ;
  re_dfastate_t *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 2361
  dfa = mctx->dfa;
#line 2362
  cur_idx = mctx->input.cur_idx;
#line 2364
  if (cur_idx > mctx->state_log_top) {
#line 2366
    *(mctx->state_log + cur_idx) = next_state;
#line 2367
    mctx->state_log_top = cur_idx;
  } else
#line 2369
  if ((unsigned long )*(mctx->state_log + cur_idx) == (unsigned long )((re_dfastate_t *)0)) {
#line 2371
    *(mctx->state_log + cur_idx) = next_state;
  } else {
#line 2377
    table_nodes = (re_node_set *)((void *)0);
#line 2382
    pstate = *(mctx->state_log + cur_idx);
#line 2383
    log_nodes = pstate->entrance_nodes;
#line 2384
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
#line 2386
      table_nodes = next_state->entrance_nodes;
#line 2387
      *err = re_node_set_init_union(& next_nodes, (re_node_set const   *)table_nodes,
                                    (re_node_set const   *)log_nodes);
#line 2389
      tmp = __builtin_expect((long )((int )*err != 0), 0L);
#line 2389
      if (tmp) {
#line 2390
        return ((re_dfastate_t *)((void *)0));
      }
    } else {
#line 2393
      next_nodes = *log_nodes;
    }
#line 2397
    context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx - 1UL,
                                   mctx->eflags);
#line 2400
    tmp___0 = re_acquire_state_context(err, dfa, (re_node_set const   *)(& next_nodes),
                                       context);
#line 2400
    *(mctx->state_log + cur_idx) = tmp___0;
#line 2400
    next_state = tmp___0;
#line 2405
    if ((unsigned long )table_nodes != (unsigned long )((void *)0)) {
#line 2406
      free((void *)next_nodes.elems);
    }
  }
#line 2409
  tmp___3 = __builtin_expect((long )dfa->nbackref, 0L);
#line 2409
  if (tmp___3) {
#line 2409
    if ((unsigned long )next_state != (unsigned long )((void *)0)) {
#line 2414
      *err = check_subexp_matching_top(mctx, & next_state->nodes, cur_idx);
#line 2416
      tmp___1 = __builtin_expect((long )((int )*err != 0), 0L);
#line 2416
      if (tmp___1) {
#line 2417
        return ((re_dfastate_t *)((void *)0));
      }
#line 2420
      if (next_state->has_backref) {
#line 2422
        *err = transit_state_bkref(mctx, (re_node_set const   *)(& next_state->nodes));
#line 2423
        tmp___2 = __builtin_expect((long )((int )*err != 0), 0L);
#line 2423
        if (tmp___2) {
#line 2424
          return ((re_dfastate_t *)((void *)0));
        }
#line 2425
        next_state = *(mctx->state_log + cur_idx);
      }
    }
  }
#line 2429
  return (next_state);
}
}
#line 2435 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static re_dfastate_t *find_recover_state(reg_errcode_t *err , re_match_context_t *mctx ) 
{ 
  re_dfastate_t *cur_state ;
  Idx max ;
  Idx cur_str_idx ;

  {
#line 2440
  while (1) {
#line 2442
    max = mctx->state_log_top;
#line 2443
    cur_str_idx = mctx->input.cur_idx;
#line 2445
    while (1) {
#line 2447
      cur_str_idx ++;
#line 2447
      if (cur_str_idx > max) {
#line 2448
        return ((re_dfastate_t *)((void *)0));
      }
#line 2449
      (mctx->input.cur_idx) ++;
#line 2445
      if (! ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0))) {
#line 2445
        break;
      }
    }
#line 2453
    cur_state = merge_state_with_log(err, mctx, (re_dfastate_t *)((void *)0));
#line 2440
    if ((int )*err == 0) {
#line 2440
      if (! ((unsigned long )cur_state == (unsigned long )((void *)0))) {
#line 2440
        break;
      }
    } else {
#line 2440
      break;
    }
  }
#line 2456
  return (cur_state);
}
}
#line 2466 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t check_subexp_matching_top(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                               Idx str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx node_idx ;
  reg_errcode_t err ;
  Idx node ;
  long tmp ;

  {
#line 2471
  dfa = mctx->dfa;
#line 2480
  node_idx = (Idx )0;
#line 2480
  while (node_idx < cur_nodes->nelem) {
#line 2482
    node = *(cur_nodes->elems + node_idx);
#line 2483
    if ((unsigned int )(dfa->nodes + node)->type == 8U) {
#line 2483
      if ((dfa->nodes + node)->opr.idx < 64UL) {
#line 2483
        if (dfa->used_bkref_map & (unsigned long const   )(1UL << (dfa->nodes + node)->opr.idx)) {
#line 2488
          err = match_ctx_add_subtop(mctx, node, str_idx);
#line 2489
          tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 2489
          if (tmp) {
#line 2490
            return (err);
          }
        }
      }
    }
#line 2480
    node_idx ++;
  }
#line 2493
  return ((reg_errcode_t )0);
}
}
#line 2539 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t transit_state_mb(re_match_context_t *mctx , re_dfastate_t *pstate ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  re_node_set dest_nodes ;
  re_node_set *new_nodes ;
  Idx cur_node_idx ;
  int naccepted ;
  Idx dest_idx ;
  unsigned int context ;
  re_dfastate_t *dest_state ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
#line 2543
  dfa = mctx->dfa;
#line 2547
  i = (Idx )0;
#line 2547
  while (i < pstate->nodes.nelem) {
#line 2550
    cur_node_idx = *(pstate->nodes.elems + i);
#line 2556
    if (! (dfa->nodes + cur_node_idx)->accept_mb) {
#line 2557
      goto __Cont;
    }
#line 2559
    if ((dfa->nodes + cur_node_idx)->constraint) {
#line 2561
      context = re_string_context_at((re_string_t const   *)(& mctx->input), mctx->input.cur_idx,
                                     mctx->eflags);
#line 2564
      if ((dfa->nodes + cur_node_idx)->constraint & 4U) {
#line 2564
        if (! (context & 1U)) {
#line 2566
          goto __Cont;
        } else {
#line 2564
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2564
      if ((dfa->nodes + cur_node_idx)->constraint & 8U) {
#line 2564
        if (context & 1U) {
#line 2566
          goto __Cont;
        } else {
#line 2564
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2564
      if ((dfa->nodes + cur_node_idx)->constraint & 32U) {
#line 2564
        if (! (context & (unsigned int )(1 << 1))) {
#line 2566
          goto __Cont;
        } else {
#line 2564
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2564
      if ((dfa->nodes + cur_node_idx)->constraint & 128U) {
#line 2564
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2566
          goto __Cont;
        }
      }
    }
#line 2570
    naccepted = check_node_accept_bytes(dfa, cur_node_idx, (re_string_t const   *)(& mctx->input),
                                        mctx->input.cur_idx);
#line 2572
    if (naccepted == 0) {
#line 2573
      goto __Cont;
    }
#line 2576
    dest_idx = mctx->input.cur_idx + (Idx )naccepted;
#line 2577
    if (mctx->max_mb_elem_len < naccepted) {
#line 2577
      mctx->max_mb_elem_len = naccepted;
    } else {
#line 2577
      mctx->max_mb_elem_len = mctx->max_mb_elem_len;
    }
#line 2579
    err = clean_state_log_if_needed(mctx, dest_idx);
#line 2580
    tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 2580
    if (tmp) {
#line 2581
      return (err);
    }
#line 2585
    new_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + cur_node_idx));
#line 2587
    dest_state = *(mctx->state_log + dest_idx);
#line 2588
    if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
#line 2589
      dest_nodes = *new_nodes;
    } else {
#line 2592
      err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                   (re_node_set const   *)new_nodes);
#line 2594
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 2594
      if (tmp___0) {
#line 2595
        return (err);
      }
    }
#line 2597
    context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_idx - 1UL,
                                   mctx->eflags);
#line 2599
    *(mctx->state_log + dest_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                             context);
#line 2601
    if ((unsigned long )dest_state != (unsigned long )((void *)0)) {
#line 2602
      free((void *)dest_nodes.elems);
    }
#line 2603
    if ((unsigned long )*(mctx->state_log + dest_idx) == (unsigned long )((void *)0)) {
#line 2603
      if ((int )err != 0) {
#line 2603
        tmp___1 = 1;
      } else {
#line 2603
        tmp___1 = 0;
      }
    } else {
#line 2603
      tmp___1 = 0;
    }
#line 2603
    tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 2603
    if (tmp___2) {
#line 2604
      return (err);
    }
    __Cont: /* CIL Label */ 
#line 2547
    i ++;
  }
#line 2606
  return ((reg_errcode_t )0);
}
}
#line 2610 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t transit_state_bkref(re_match_context_t *mctx , re_node_set const   *nodes ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx i ;
  Idx cur_str_idx ;
  Idx dest_str_idx ;
  Idx prev_nelem ;
  Idx bkc_idx ;
  Idx node_idx ;
  unsigned int context ;
  re_token_t const   *node ;
  re_node_set *new_dest_nodes ;
  long tmp ;
  Idx subexp_len ;
  re_dfastate_t *dest_state ;
  struct re_backref_cache_entry *bkref_ent ;
  int tmp___0 ;
  long tmp___1 ;
  re_node_set dest_nodes ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;

  {
#line 2614
  dfa = mctx->dfa;
#line 2617
  cur_str_idx = mctx->input.cur_idx;
#line 2619
  i = (Idx )0;
#line 2619
  while (i < (Idx )nodes->nelem) {
#line 2622
    node_idx = *(nodes->elems + i);
#line 2624
    node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 2628
    if ((unsigned int const   )node->type != 4U) {
#line 2629
      goto __Cont;
    }
#line 2631
    if (node->constraint) {
#line 2633
      context = re_string_context_at((re_string_t const   *)(& mctx->input), cur_str_idx,
                                     mctx->eflags);
#line 2635
      if (node->constraint & 4U) {
#line 2635
        if (! (context & 1U)) {
#line 2636
          goto __Cont;
        } else {
#line 2635
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2635
      if (node->constraint & 8U) {
#line 2635
        if (context & 1U) {
#line 2636
          goto __Cont;
        } else {
#line 2635
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 2635
      if (node->constraint & 32U) {
#line 2635
        if (! (context & (unsigned int )(1 << 1))) {
#line 2636
          goto __Cont;
        } else {
#line 2635
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 2635
      if (node->constraint & 128U) {
#line 2635
        if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 2636
          goto __Cont;
        }
      }
    }
#line 2641
    bkc_idx = mctx->nbkref_ents;
#line 2642
    err = get_subexp(mctx, node_idx, cur_str_idx);
#line 2643
    tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 2643
    if (tmp) {
#line 2644
      goto free_return;
    }
#line 2651
    while (bkc_idx < mctx->nbkref_ents) {
#line 2656
      bkref_ent = mctx->bkref_ents + bkc_idx;
#line 2657
      if (bkref_ent->node != node_idx) {
#line 2658
        goto __Cont___0;
      } else
#line 2657
      if (bkref_ent->str_idx != cur_str_idx) {
#line 2658
        goto __Cont___0;
      }
#line 2659
      subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;
#line 2660
      if (subexp_len == 0UL) {
#line 2660
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *((dfa->edests + node_idx)->elems + 0));
      } else {
#line 2660
        new_dest_nodes = (re_node_set *)(dfa->eclosures + *(dfa->nexts + node_idx));
      }
#line 2663
      dest_str_idx = (cur_str_idx + bkref_ent->subexp_to) - bkref_ent->subexp_from;
#line 2665
      context = re_string_context_at((re_string_t const   *)(& mctx->input), dest_str_idx - 1UL,
                                     mctx->eflags);
#line 2667
      dest_state = *(mctx->state_log + dest_str_idx);
#line 2668
      if ((unsigned long )*(mctx->state_log + cur_str_idx) == (unsigned long )((void *)0)) {
#line 2668
        prev_nelem = (Idx )0;
      } else {
#line 2668
        prev_nelem = (*(mctx->state_log + cur_str_idx))->nodes.nelem;
      }
#line 2671
      if ((unsigned long )dest_state == (unsigned long )((void *)0)) {
#line 2673
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)new_dest_nodes,
                                                                     context);
#line 2676
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2676
          if ((int )err != 0) {
#line 2676
            tmp___0 = 1;
          } else {
#line 2676
            tmp___0 = 0;
          }
        } else {
#line 2676
          tmp___0 = 0;
        }
#line 2676
        tmp___1 = __builtin_expect((long )tmp___0, 0L);
#line 2676
        if (tmp___1) {
#line 2678
          goto free_return;
        }
      } else {
#line 2683
        err = re_node_set_init_union(& dest_nodes, (re_node_set const   *)dest_state->entrance_nodes,
                                     (re_node_set const   *)new_dest_nodes);
#line 2686
        tmp___2 = __builtin_expect((long )((int )err != 0), 0L);
#line 2686
        if (tmp___2) {
#line 2688
          free((void *)dest_nodes.elems);
#line 2689
          goto free_return;
        }
#line 2691
        *(mctx->state_log + dest_str_idx) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& dest_nodes),
                                                                     context);
#line 2693
        free((void *)dest_nodes.elems);
#line 2694
        if ((unsigned long )*(mctx->state_log + dest_str_idx) == (unsigned long )((void *)0)) {
#line 2694
          if ((int )err != 0) {
#line 2694
            tmp___3 = 1;
          } else {
#line 2694
            tmp___3 = 0;
          }
        } else {
#line 2694
          tmp___3 = 0;
        }
#line 2694
        tmp___4 = __builtin_expect((long )tmp___3, 0L);
#line 2694
        if (tmp___4) {
#line 2696
          goto free_return;
        }
      }
#line 2700
      if (subexp_len == 0UL) {
#line 2700
        if ((*(mctx->state_log + cur_str_idx))->nodes.nelem > prev_nelem) {
#line 2703
          err = check_subexp_matching_top(mctx, new_dest_nodes, cur_str_idx);
#line 2705
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
#line 2705
          if (tmp___5) {
#line 2706
            goto free_return;
          }
#line 2707
          err = transit_state_bkref(mctx, (re_node_set const   *)new_dest_nodes);
#line 2708
          tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
#line 2708
          if (tmp___6) {
#line 2709
            goto free_return;
          }
        }
      }
      __Cont___0: /* CIL Label */ 
#line 2651
      bkc_idx ++;
    }
    __Cont: /* CIL Label */ 
#line 2619
    i ++;
  }
#line 2713
  err = (reg_errcode_t )0;
  free_return: 
#line 2715
  return (err);
}
}
#line 2724 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t get_subexp(re_match_context_t *mctx , Idx bkref_node , Idx bkref_str_idx ) 
{ 
  re_dfa_t const   *dfa ;
  Idx subexp_num ;
  Idx sub_top_idx ;
  char const   *buf___0 ;
  Idx cache_idx ;
  Idx tmp ;
  struct re_backref_cache_entry  const  *entry ;
  struct re_backref_cache_entry  const  *tmp___0 ;
  reg_errcode_t err ;
  re_sub_match_top_t *sub_top ;
  re_sub_match_last_t *sub_last ;
  Idx sub_last_idx ;
  Idx sl_str ;
  Idx bkref_str_off ;
  regoff_t sl_str_diff ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  Idx cls_node ;
  regoff_t sl_str_off ;
  re_node_set const   *nodes ;
  long tmp___5 ;
  long tmp___6 ;
  Idx tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
#line 2728
  dfa = mctx->dfa;
#line 2730
  buf___0 = (char const   *)mctx->input.mbs;
#line 2732
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, bkref_str_idx);
#line 2732
  cache_idx = tmp;
#line 2733
  if (cache_idx != 0xffffffffffffffffUL) {
#line 2735
    entry = (struct re_backref_cache_entry  const  *)(mctx->bkref_ents + cache_idx);
#line 2737
    while (1) {
#line 2738
      if (entry->node == (Idx const   )bkref_node) {
#line 2739
        return ((reg_errcode_t )0);
      }
#line 2737
      tmp___0 = entry;
#line 2737
      entry ++;
#line 2737
      if (! tmp___0->more) {
#line 2737
        break;
      }
    }
  }
#line 2743
  subexp_num = (dfa->nodes + bkref_node)->opr.idx;
#line 2746
  sub_top_idx = (Idx )0;
#line 2746
  while (sub_top_idx < mctx->nsub_tops) {
#line 2749
    sub_top = *(mctx->sub_tops + sub_top_idx);
#line 2753
    if ((dfa->nodes + sub_top->node)->opr.idx != subexp_num) {
#line 2754
      goto __Cont;
    }
#line 2756
    sl_str = sub_top->str_idx;
#line 2757
    bkref_str_off = bkref_str_idx;
#line 2760
    sub_last_idx = (Idx )0;
#line 2760
    while (sub_last_idx < sub_top->nlasts) {
#line 2763
      sub_last = *(sub_top->lasts + sub_last_idx);
#line 2764
      sl_str_diff = (regoff_t )(sub_last->str_idx - sl_str);
#line 2767
      if (sl_str_diff > 0L) {
#line 2769
        tmp___2 = __builtin_expect((long )(bkref_str_off + (Idx )sl_str_diff > mctx->input.valid_len),
                                   0L);
#line 2769
        if (tmp___2) {
#line 2772
          if (bkref_str_off + (Idx )sl_str_diff > mctx->input.len) {
#line 2773
            break;
          }
#line 2775
          err = clean_state_log_if_needed(mctx, bkref_str_off + (Idx )sl_str_diff);
#line 2778
          tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 2778
          if (tmp___1) {
#line 2779
            return (err);
          }
#line 2780
          buf___0 = (char const   *)mctx->input.mbs;
        }
#line 2782
        tmp___3 = memcmp((void const   *)(buf___0 + bkref_str_off), (void const   *)(buf___0 + sl_str),
                         (size_t )sl_str_diff);
#line 2782
        if (tmp___3 != 0) {
#line 2784
          break;
        }
      }
#line 2786
      bkref_str_off += (Idx )sl_str_diff;
#line 2787
      sl_str += (Idx )sl_str_diff;
#line 2788
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
#line 2793
      buf___0 = (char const   *)mctx->input.mbs;
#line 2795
      if ((int )err == 1) {
#line 2796
        goto __Cont___0;
      }
#line 2797
      tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
#line 2797
      if (tmp___4) {
#line 2798
        return (err);
      }
      __Cont___0: /* CIL Label */ 
#line 2760
      sub_last_idx ++;
    }
#line 2801
    if (sub_last_idx < sub_top->nlasts) {
#line 2802
      goto __Cont;
    }
#line 2803
    if (sub_last_idx > 0UL) {
#line 2804
      sl_str ++;
    }
#line 2806
    while (sl_str <= bkref_str_idx) {
#line 2811
      sl_str_off = (regoff_t )(sl_str - sub_top->str_idx);
#line 2814
      if (sl_str_off > 0L) {
#line 2816
        tmp___6 = __builtin_expect((long )(bkref_str_off >= mctx->input.valid_len),
                                   0L);
#line 2816
        if (tmp___6) {
#line 2819
          if (bkref_str_off >= mctx->input.len) {
#line 2820
            break;
          }
#line 2822
          err = extend_buffers(mctx);
#line 2823
          tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
#line 2823
          if (tmp___5) {
#line 2824
            return (err);
          }
#line 2826
          buf___0 = (char const   *)mctx->input.mbs;
        }
#line 2828
        tmp___7 = bkref_str_off;
#line 2828
        bkref_str_off ++;
#line 2828
        if ((int const   )*(buf___0 + tmp___7) != (int const   )*(buf___0 + (sl_str - 1UL))) {
#line 2829
          break;
        }
      }
#line 2832
      if ((unsigned long )*(mctx->state_log + sl_str) == (unsigned long )((void *)0)) {
#line 2833
        goto __Cont___1;
      }
#line 2835
      nodes = (re_node_set const   *)(& (*(mctx->state_log + sl_str))->nodes);
#line 2836
      cls_node = find_subexp_node(dfa, nodes, subexp_num, 9);
#line 2838
      if (cls_node == 0xffffffffffffffffUL) {
#line 2839
        goto __Cont___1;
      }
#line 2840
      if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
#line 2842
        tmp___8 = calloc(sizeof(state_array_t ), (sl_str - sub_top->str_idx) + 1UL);
#line 2842
        sub_top->path = (state_array_t *)tmp___8;
#line 2844
        if ((unsigned long )sub_top->path == (unsigned long )((void *)0)) {
#line 2845
          return ((reg_errcode_t )12);
        }
      }
#line 2849
      err = check_arrival(mctx, sub_top->path, sub_top->node, sub_top->str_idx, cls_node,
                          sl_str, 9);
#line 2852
      if ((int )err == 1) {
#line 2853
        goto __Cont___1;
      }
#line 2854
      tmp___9 = __builtin_expect((long )((int )err != 0), 0L);
#line 2854
      if (tmp___9) {
#line 2855
        return (err);
      }
#line 2856
      sub_last = match_ctx_add_sublast(sub_top, cls_node, sl_str);
#line 2857
      tmp___10 = __builtin_expect((long )((unsigned long )sub_last == (unsigned long )((void *)0)),
                                  0L);
#line 2857
      if (tmp___10) {
#line 2858
        return ((reg_errcode_t )12);
      }
#line 2859
      err = get_subexp_sub(mctx, (re_sub_match_top_t const   *)sub_top, sub_last,
                           bkref_node, bkref_str_idx);
#line 2861
      if ((int )err == 1) {

      }
      __Cont___1: /* CIL Label */ 
#line 2806
      sl_str ++;
    }
    __Cont: /* CIL Label */ 
#line 2746
    sub_top_idx ++;
  }
#line 2865
  return ((reg_errcode_t )0);
}
}
#line 2874 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t get_subexp_sub(re_match_context_t *mctx , re_sub_match_top_t const   *sub_top ,
                                    re_sub_match_last_t *sub_last , Idx bkref_node ,
                                    Idx bkref_str ) 
{ 
  reg_errcode_t err ;
  Idx to_idx ;
  long tmp ;
  reg_errcode_t tmp___0 ;

  {
#line 2882
  err = check_arrival(mctx, & sub_last->path, sub_last->node, sub_last->str_idx, bkref_node,
                      bkref_str, 8);
#line 2885
  if ((int )err != 0) {
#line 2886
    return (err);
  }
#line 2887
  err = match_ctx_add_entry(mctx, bkref_node, bkref_str, (Idx )sub_top->str_idx, sub_last->str_idx);
#line 2889
  tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 2889
  if (tmp) {
#line 2890
    return (err);
  }
#line 2891
  to_idx = (bkref_str + sub_last->str_idx) - (Idx )sub_top->str_idx;
#line 2892
  tmp___0 = clean_state_log_if_needed(mctx, to_idx);
#line 2892
  return (tmp___0);
}
}
#line 2903 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static Idx find_subexp_node(re_dfa_t const   *dfa , re_node_set const   *nodes , Idx subexp_idx ,
                            int type ) 
{ 
  Idx cls_idx ;
  Idx cls_node ;
  re_token_t const   *node ;

  {
#line 2909
  cls_idx = (Idx )0;
#line 2909
  while (cls_idx < (Idx )nodes->nelem) {
#line 2911
    cls_node = *(nodes->elems + cls_idx);
#line 2912
    node = (re_token_t const   *)(dfa->nodes + cls_node);
#line 2913
    if ((unsigned int const   )node->type == (unsigned int const   )type) {
#line 2913
      if (node->opr.idx == (Idx const   )subexp_idx) {
#line 2915
        return (cls_node);
      }
    }
#line 2909
    cls_idx ++;
  }
#line 2917
  return ((Idx )-1);
}
}
#line 2925 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t check_arrival(re_match_context_t *mctx , state_array_t *path ,
                                   Idx top_node , Idx top_str , Idx last_node , Idx last_str ,
                                   int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx subexp_num ;
  Idx backup_cur_idx ;
  Idx str_idx ;
  Idx null_cnt ;
  re_dfastate_t *cur_state ;
  re_node_set *cur_nodes ;
  re_node_set next_nodes ;
  re_dfastate_t **backup_state_log ;
  unsigned int context ;
  re_dfastate_t **new_array ;
  Idx old_alloc ;
  Idx new_alloc ;
  long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;
  int tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;
  long tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  int tmp___14 ;
  long tmp___15 ;
  Idx __attribute__((__pure__))  tmp___16 ;

  {
#line 2930
  dfa = mctx->dfa;
#line 2931
  err = (reg_errcode_t )0;
#line 2933
  cur_state = (re_dfastate_t *)((void *)0);
#line 2938
  subexp_num = (dfa->nodes + top_node)->opr.idx;
#line 2940
  tmp___3 = __builtin_expect((long )(path->alloc < (last_str + (Idx )mctx->max_mb_elem_len) + 1UL),
                             0L);
#line 2940
  if (tmp___3) {
#line 2943
    old_alloc = path->alloc;
#line 2944
    new_alloc = ((old_alloc + last_str) + (Idx )mctx->max_mb_elem_len) + 1UL;
#line 2945
    tmp = __builtin_expect((long )(new_alloc < old_alloc), 0L);
#line 2945
    if (tmp) {
#line 2947
      return ((reg_errcode_t )12);
    } else {
#line 2945
      tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / sizeof(re_dfastate_t *) < new_alloc),
                                 0L);
#line 2945
      if (tmp___0) {
#line 2947
        return ((reg_errcode_t )12);
      }
    }
#line 2948
    tmp___1 = realloc((void *)path->array, new_alloc * sizeof(re_dfastate_t *));
#line 2948
    new_array = (re_dfastate_t **)tmp___1;
#line 2949
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
#line 2949
    if (tmp___2) {
#line 2950
      return ((reg_errcode_t )12);
    }
#line 2951
    path->array = new_array;
#line 2952
    path->alloc = new_alloc;
#line 2953
    memset((void *)(new_array + old_alloc), '\000', sizeof(re_dfastate_t *) * (path->alloc - old_alloc));
  }
#line 2957
  if (path->next_idx) {
#line 2957
    str_idx = path->next_idx;
  } else {
#line 2957
    str_idx = top_str;
  }
#line 2960
  backup_state_log = mctx->state_log;
#line 2961
  backup_cur_idx = mctx->input.cur_idx;
#line 2962
  mctx->state_log = path->array;
#line 2963
  mctx->input.cur_idx = str_idx;
#line 2966
  context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1UL,
                                 mctx->eflags);
#line 2967
  if (str_idx == top_str) {
#line 2969
    err = re_node_set_init_1(& next_nodes, top_node);
#line 2970
    tmp___4 = __builtin_expect((long )((int )err != 0), 0L);
#line 2970
    if (tmp___4) {
#line 2971
      return (err);
    }
#line 2972
    err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 2973
    tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
#line 2973
    if (tmp___5) {
#line 2975
      free((void *)next_nodes.elems);
#line 2976
      return (err);
    }
  } else {
#line 2981
    cur_state = *(mctx->state_log + str_idx);
#line 2982
    if (cur_state) {
#line 2982
      if (cur_state->has_backref) {
#line 2984
        err = re_node_set_init_copy(& next_nodes, (re_node_set const   *)(& cur_state->nodes));
#line 2985
        tmp___6 = __builtin_expect((long )((int )err != 0), 0L);
#line 2985
        if (tmp___6) {
#line 2986
          return (err);
        }
      } else {
#line 2989
        memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
      }
    } else {
#line 2989
      memset((void *)(& next_nodes), '\000', sizeof(re_node_set ));
    }
  }
#line 2991
  if (str_idx == top_str) {
#line 2991
    goto _L;
  } else
#line 2991
  if (cur_state) {
#line 2991
    if (cur_state->has_backref) {
      _L: /* CIL Label */ 
#line 2993
      if (next_nodes.nelem) {
#line 2995
        err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 2997
        tmp___7 = __builtin_expect((long )((int )err != 0), 0L);
#line 2997
        if (tmp___7) {
#line 2999
          free((void *)next_nodes.elems);
#line 3000
          return (err);
        }
      }
#line 3003
      cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                           context);
#line 3004
      if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3004
        if ((int )err != 0) {
#line 3004
          tmp___8 = 1;
        } else {
#line 3004
          tmp___8 = 0;
        }
      } else {
#line 3004
        tmp___8 = 0;
      }
#line 3004
      tmp___9 = __builtin_expect((long )tmp___8, 0L);
#line 3004
      if (tmp___9) {
#line 3006
        free((void *)next_nodes.elems);
#line 3007
        return (err);
      }
#line 3009
      *(mctx->state_log + str_idx) = cur_state;
    }
  }
#line 3012
  null_cnt = (Idx )0;
#line 3012
  while (1) {
#line 3012
    if (str_idx < last_str) {
#line 3012
      if (! (null_cnt <= (Idx )mctx->max_mb_elem_len)) {
#line 3012
        break;
      }
    } else {
#line 3012
      break;
    }
#line 3014
    next_nodes.nelem = (Idx )0;
#line 3015
    if (*(mctx->state_log + (str_idx + 1UL))) {
#line 3017
      err = re_node_set_merge(& next_nodes, (re_node_set const   *)(& (*(mctx->state_log + (str_idx + 1UL)))->nodes));
#line 3019
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
#line 3019
      if (tmp___10) {
#line 3021
        free((void *)next_nodes.elems);
#line 3022
        return (err);
      }
    }
#line 3025
    if (cur_state) {
#line 3027
      err = check_arrival_add_next_nodes(mctx, str_idx, & cur_state->non_eps_nodes,
                                         & next_nodes);
#line 3030
      tmp___11 = __builtin_expect((long )((int )err != 0), 0L);
#line 3030
      if (tmp___11) {
#line 3032
        free((void *)next_nodes.elems);
#line 3033
        return (err);
      }
    }
#line 3036
    str_idx ++;
#line 3037
    if (next_nodes.nelem) {
#line 3039
      err = check_arrival_expand_ecl(dfa, & next_nodes, subexp_num, type);
#line 3040
      tmp___12 = __builtin_expect((long )((int )err != 0), 0L);
#line 3040
      if (tmp___12) {
#line 3042
        free((void *)next_nodes.elems);
#line 3043
        return (err);
      }
#line 3045
      err = expand_bkref_cache(mctx, & next_nodes, str_idx, subexp_num, type);
#line 3047
      tmp___13 = __builtin_expect((long )((int )err != 0), 0L);
#line 3047
      if (tmp___13) {
#line 3049
        free((void *)next_nodes.elems);
#line 3050
        return (err);
      }
    }
#line 3053
    context = re_string_context_at((re_string_t const   *)(& mctx->input), str_idx - 1UL,
                                   mctx->eflags);
#line 3054
    cur_state = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& next_nodes),
                                         context);
#line 3055
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3055
      if ((int )err != 0) {
#line 3055
        tmp___14 = 1;
      } else {
#line 3055
        tmp___14 = 0;
      }
    } else {
#line 3055
      tmp___14 = 0;
    }
#line 3055
    tmp___15 = __builtin_expect((long )tmp___14, 0L);
#line 3055
    if (tmp___15) {
#line 3057
      free((void *)next_nodes.elems);
#line 3058
      return (err);
    }
#line 3060
    *(mctx->state_log + str_idx) = cur_state;
#line 3061
    if ((unsigned long )cur_state == (unsigned long )((void *)0)) {
#line 3061
      null_cnt ++;
    } else {
#line 3061
      null_cnt = (Idx )0;
    }
  }
#line 3063
  free((void *)next_nodes.elems);
#line 3064
  if ((unsigned long )*(mctx->state_log + last_str) == (unsigned long )((void *)0)) {
#line 3064
    cur_nodes = (re_node_set *)((void *)0);
  } else {
#line 3064
    cur_nodes = & (*(mctx->state_log + last_str))->nodes;
  }
#line 3066
  path->next_idx = str_idx;
#line 3069
  mctx->state_log = backup_state_log;
#line 3070
  mctx->input.cur_idx = backup_cur_idx;
#line 3073
  if ((unsigned long )cur_nodes != (unsigned long )((void *)0)) {
#line 3073
    tmp___16 = re_node_set_contains((re_node_set const   *)cur_nodes, last_node);
#line 3073
    if (tmp___16) {
#line 3074
      return ((reg_errcode_t )0);
    }
  }
#line 3076
  return ((reg_errcode_t )1);
}
}
#line 3087 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t check_arrival_add_next_nodes(re_match_context_t *mctx , Idx str_idx ,
                                                  re_node_set *cur_nodes , re_node_set *next_nodes ) 
{ 
  re_dfa_t const   *dfa ;
  _Bool ok ;
  Idx cur_idx ;
  reg_errcode_t err ;
  re_node_set union_set ;
  int naccepted ;
  Idx cur_node ;
  re_dfastate_t *dest_state ;
  Idx next_node ;
  Idx next_idx ;
  long tmp ;
  long tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  _Bool tmp___4 ;

  {
#line 3092
  dfa = mctx->dfa;
#line 3096
  err = (reg_errcode_t )0;
#line 3099
  memset((void *)(& union_set), '\000', sizeof(re_node_set ));
#line 3100
  cur_idx = (Idx )0;
#line 3100
  while (cur_idx < cur_nodes->nelem) {
#line 3102
    naccepted = 0;
#line 3103
    cur_node = *(cur_nodes->elems + cur_idx);
#line 3110
    if ((dfa->nodes + cur_node)->accept_mb) {
#line 3112
      naccepted = check_node_accept_bytes(dfa, cur_node, (re_string_t const   *)(& mctx->input),
                                          str_idx);
#line 3114
      if (naccepted > 1) {
#line 3117
        next_node = *(dfa->nexts + cur_node);
#line 3118
        next_idx = str_idx + (Idx )naccepted;
#line 3119
        dest_state = *(mctx->state_log + next_idx);
#line 3120
        union_set.nelem = (Idx )0;
#line 3121
        if (dest_state) {
#line 3123
          err = re_node_set_merge(& union_set, (re_node_set const   *)(& dest_state->nodes));
#line 3124
          tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 3124
          if (tmp) {
#line 3126
            free((void *)union_set.elems);
#line 3127
            return (err);
          }
        }
#line 3130
        ok = re_node_set_insert(& union_set, next_node);
#line 3131
        tmp___0 = __builtin_expect((long )(! ok), 0L);
#line 3131
        if (tmp___0) {
#line 3133
          free((void *)union_set.elems);
#line 3134
          return ((reg_errcode_t )12);
        }
#line 3136
        *(mctx->state_log + next_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
#line 3138
        if ((unsigned long )*(mctx->state_log + next_idx) == (unsigned long )((void *)0)) {
#line 3138
          if ((int )err != 0) {
#line 3138
            tmp___1 = 1;
          } else {
#line 3138
            tmp___1 = 0;
          }
        } else {
#line 3138
          tmp___1 = 0;
        }
#line 3138
        tmp___2 = __builtin_expect((long )tmp___1, 0L);
#line 3138
        if (tmp___2) {
#line 3141
          free((void *)union_set.elems);
#line 3142
          return (err);
        }
      }
    }
#line 3147
    if (naccepted) {
#line 3147
      goto _L;
    } else {
#line 3147
      tmp___4 = check_node_accept((re_match_context_t const   *)mctx, (re_token_t const   *)(dfa->nodes + cur_node),
                                  str_idx);
#line 3147
      if (tmp___4) {
        _L: /* CIL Label */ 
#line 3150
        ok = re_node_set_insert(next_nodes, *(dfa->nexts + cur_node));
#line 3151
        tmp___3 = __builtin_expect((long )(! ok), 0L);
#line 3151
        if (tmp___3) {
#line 3153
          free((void *)union_set.elems);
#line 3154
          return ((reg_errcode_t )12);
        }
      }
    }
#line 3100
    cur_idx ++;
  }
#line 3158
  free((void *)union_set.elems);
#line 3159
  return ((reg_errcode_t )0);
}
}
#line 3168 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t check_arrival_expand_ecl(re_dfa_t const   *dfa , re_node_set *cur_nodes ,
                                              Idx ex_subexp , int type ) 
{ 
  reg_errcode_t err ;
  Idx idx ;
  Idx outside_node ;
  re_node_set new_nodes ;
  long tmp ;
  Idx cur_node ;
  re_node_set const   *eclosure ;
  long tmp___0 ;
  long tmp___1 ;

  {
#line 3179
  err = re_node_set_alloc(& new_nodes, cur_nodes->nelem);
#line 3180
  tmp = __builtin_expect((long )((int )err != 0), 0L);
#line 3180
  if (tmp) {
#line 3181
    return (err);
  }
#line 3185
  idx = (Idx )0;
#line 3185
  while (idx < cur_nodes->nelem) {
#line 3187
    cur_node = *(cur_nodes->elems + idx);
#line 3188
    eclosure = (re_node_set const   *)(dfa->eclosures + cur_node);
#line 3189
    outside_node = find_subexp_node(dfa, eclosure, ex_subexp, type);
#line 3190
    if (outside_node == 0xffffffffffffffffUL) {
#line 3193
      err = re_node_set_merge(& new_nodes, eclosure);
#line 3194
      tmp___0 = __builtin_expect((long )((int )err != 0), 0L);
#line 3194
      if (tmp___0) {
#line 3196
        free((void *)new_nodes.elems);
#line 3197
        return (err);
      }
    } else {
#line 3203
      err = check_arrival_expand_ecl_sub(dfa, & new_nodes, cur_node, ex_subexp, type);
#line 3205
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 3205
      if (tmp___1) {
#line 3207
        free((void *)new_nodes.elems);
#line 3208
        return (err);
      }
    }
#line 3185
    idx ++;
  }
#line 3212
  free((void *)cur_nodes->elems);
#line 3213
  *cur_nodes = new_nodes;
#line 3214
  return ((reg_errcode_t )0);
}
}
#line 3221 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t check_arrival_expand_ecl_sub(re_dfa_t const   *dfa , re_node_set *dst_nodes ,
                                                  Idx target , Idx ex_subexp , int type ) 
{ 
  Idx cur_node ;
  _Bool ok ;
  long tmp ;
  long tmp___0 ;
  reg_errcode_t err ;
  long tmp___1 ;
  Idx __attribute__((__pure__))  tmp___2 ;

  {
#line 3227
  cur_node = target;
#line 3227
  while (1) {
#line 3227
    tmp___2 = re_node_set_contains((re_node_set const   *)dst_nodes, cur_node);
#line 3227
    if (tmp___2) {
#line 3227
      break;
    }
#line 3231
    if ((unsigned int )(dfa->nodes + cur_node)->type == (unsigned int )type) {
#line 3231
      if ((dfa->nodes + cur_node)->opr.idx == ex_subexp) {
#line 3234
        if (type == 9) {
#line 3236
          ok = re_node_set_insert(dst_nodes, cur_node);
#line 3237
          tmp = __builtin_expect((long )(! ok), 0L);
#line 3237
          if (tmp) {
#line 3238
            return ((reg_errcode_t )12);
          }
        }
#line 3240
        break;
      }
    }
#line 3242
    ok = re_node_set_insert(dst_nodes, cur_node);
#line 3243
    tmp___0 = __builtin_expect((long )(! ok), 0L);
#line 3243
    if (tmp___0) {
#line 3244
      return ((reg_errcode_t )12);
    }
#line 3245
    if ((dfa->edests + cur_node)->nelem == 0UL) {
#line 3246
      break;
    }
#line 3247
    if ((dfa->edests + cur_node)->nelem == 2UL) {
#line 3250
      err = check_arrival_expand_ecl_sub(dfa, dst_nodes, *((dfa->edests + cur_node)->elems + 1),
                                         ex_subexp, type);
#line 3253
      tmp___1 = __builtin_expect((long )((int )err != 0), 0L);
#line 3253
      if (tmp___1) {
#line 3254
        return (err);
      }
    }
#line 3256
    cur_node = *((dfa->edests + cur_node)->elems + 0);
  }
#line 3258
  return ((reg_errcode_t )0);
}
}
#line 3266 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t expand_bkref_cache(re_match_context_t *mctx , re_node_set *cur_nodes ,
                                        Idx cur_str , Idx subexp_num , int type ) 
{ 
  re_dfa_t const   *dfa ;
  reg_errcode_t err ;
  Idx cache_idx_start ;
  Idx tmp ;
  struct re_backref_cache_entry *ent ;
  Idx to_idx ;
  Idx next_node ;
  Idx __attribute__((__pure__))  tmp___0 ;
  re_node_set new_dests ;
  reg_errcode_t err2 ;
  reg_errcode_t err3 ;
  Idx __attribute__((__pure__))  tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  re_node_set union_set ;
  _Bool ok ;
  Idx __attribute__((__pure__))  tmp___5 ;
  int tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  long tmp___10 ;
  struct re_backref_cache_entry *tmp___11 ;

  {
#line 3271
  dfa = mctx->dfa;
#line 3273
  tmp = search_cur_bkref_entry((re_match_context_t const   *)mctx, cur_str);
#line 3273
  cache_idx_start = tmp;
#line 3276
  if (cache_idx_start == 0xffffffffffffffffUL) {
#line 3277
    return ((reg_errcode_t )0);
  }
  restart: 
#line 3280
  ent = mctx->bkref_ents + cache_idx_start;
#line 3281
  while (1) {
#line 3286
    tmp___0 = re_node_set_contains((re_node_set const   *)cur_nodes, ent->node);
#line 3286
    if (! tmp___0) {
#line 3287
      goto __Cont;
    }
#line 3289
    to_idx = (cur_str + ent->subexp_to) - ent->subexp_from;
#line 3292
    if (to_idx == cur_str) {
#line 3298
      next_node = *((dfa->edests + ent->node)->elems + 0);
#line 3299
      tmp___1 = re_node_set_contains((re_node_set const   *)cur_nodes, next_node);
#line 3299
      if (tmp___1) {
#line 3300
        goto __Cont;
      }
#line 3301
      err = re_node_set_init_1(& new_dests, next_node);
#line 3302
      err2 = check_arrival_expand_ecl(dfa, & new_dests, subexp_num, type);
#line 3303
      err3 = re_node_set_merge(cur_nodes, (re_node_set const   *)(& new_dests));
#line 3304
      free((void *)new_dests.elems);
#line 3305
      if ((int )err != 0) {
#line 3305
        tmp___3 = 1;
      } else
#line 3305
      if ((int )err2 != 0) {
#line 3305
        tmp___3 = 1;
      } else
#line 3305
      if ((int )err3 != 0) {
#line 3305
        tmp___3 = 1;
      } else {
#line 3305
        tmp___3 = 0;
      }
#line 3305
      tmp___4 = __builtin_expect((long )tmp___3, 0L);
#line 3305
      if (tmp___4) {
#line 3308
        if ((int )err != 0) {
#line 3308
          err = err;
        } else {
#line 3308
          if ((int )err2 != 0) {
#line 3308
            tmp___2 = (int )err2;
          } else {
#line 3308
            tmp___2 = (int )err3;
          }
#line 3308
          err = (reg_errcode_t )tmp___2;
        }
#line 3310
        return (err);
      }
#line 3313
      goto restart;
    } else {
#line 3318
      next_node = *(dfa->nexts + ent->node);
#line 3319
      if (*(mctx->state_log + to_idx)) {
#line 3322
        tmp___5 = re_node_set_contains((re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes),
                                       next_node);
#line 3322
        if (tmp___5) {
#line 3324
          goto __Cont;
        }
#line 3325
        err = re_node_set_init_copy(& union_set, (re_node_set const   *)(& (*(mctx->state_log + to_idx))->nodes));
#line 3327
        ok = re_node_set_insert(& union_set, next_node);
#line 3328
        if ((int )err != 0) {
#line 3328
          tmp___6 = 1;
        } else
#line 3328
        if (! ok) {
#line 3328
          tmp___6 = 1;
        } else {
#line 3328
          tmp___6 = 0;
        }
#line 3328
        tmp___7 = __builtin_expect((long )tmp___6, 0L);
#line 3328
        if (tmp___7) {
#line 3330
          free((void *)union_set.elems);
#line 3331
          if ((int )err != 0) {
#line 3331
            err = err;
          } else {
#line 3331
            err = (reg_errcode_t )12;
          }
#line 3332
          return (err);
        }
      } else {
#line 3337
        err = re_node_set_init_1(& union_set, next_node);
#line 3338
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
#line 3338
        if (tmp___8) {
#line 3339
          return (err);
        }
      }
#line 3341
      *(mctx->state_log + to_idx) = re_acquire_state(& err, dfa, (re_node_set const   *)(& union_set));
#line 3342
      free((void *)union_set.elems);
#line 3343
      if ((unsigned long )*(mctx->state_log + to_idx) == (unsigned long )((void *)0)) {
#line 3343
        if ((int )err != 0) {
#line 3343
          tmp___9 = 1;
        } else {
#line 3343
          tmp___9 = 0;
        }
      } else {
#line 3343
        tmp___9 = 0;
      }
#line 3343
      tmp___10 = __builtin_expect((long )tmp___9, 0L);
#line 3343
      if (tmp___10) {
#line 3345
        return (err);
      }
    }
    __Cont: /* CIL Label */ 
#line 3281
    tmp___11 = ent;
#line 3281
    ent ++;
#line 3281
    if (! tmp___11->more) {
#line 3281
      break;
    }
  }
#line 3349
  return ((reg_errcode_t )0);
}
}
#line 3355 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static _Bool build_trtable(re_dfa_t const   *dfa , re_dfastate_t *state ) 
{ 
  reg_errcode_t err ;
  Idx i ;
  Idx j ;
  int ch ;
  _Bool need_word_trtable ;
  bitset_word_t elem ;
  bitset_word_t mask ;
  _Bool dests_node_malloced ;
  _Bool dest_states_malloced ;
  Idx ndests ;
  re_dfastate_t **trtable ;
  re_dfastate_t **dest_states ;
  re_dfastate_t **dest_states_word ;
  re_dfastate_t **dest_states_nl ;
  re_node_set follows ;
  re_node_set *dests_node ;
  bitset_t *dests_ch ;
  bitset_t acceptable ;
  struct dests_alloc *dests_alloc ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  struct re_dfastate_t **tmp___2 ;
  void *tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  long tmp___9 ;
  Idx next_node ;
  long tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  long tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  struct re_dfastate_t **tmp___17 ;
  void *tmp___18 ;
  long tmp___19 ;
  long tmp___20 ;
  struct re_dfastate_t **tmp___21 ;
  void *tmp___22 ;
  long tmp___23 ;
  long tmp___24 ;
  long tmp___25 ;
  _Bool tmp___26 ;
  _Bool tmp___27 ;

  {
#line 3362
  need_word_trtable = (_Bool)0;
#line 3364
  dests_node_malloced = (_Bool)0;
#line 3365
  dest_states_malloced = (_Bool)0;
#line 3368
  dest_states = (re_dfastate_t **)((void *)0);
#line 3383
  if (sizeof(struct dests_alloc ) < 4032UL) {
#line 3384
    tmp = __builtin_alloca(sizeof(struct dests_alloc ));
#line 3384
    dests_alloc = (struct dests_alloc *)tmp;
  } else {
#line 3387
    tmp___0 = malloc(sizeof(struct dests_alloc ));
#line 3387
    dests_alloc = (struct dests_alloc *)tmp___0;
#line 3388
    tmp___1 = __builtin_expect((long )((unsigned long )dests_alloc == (unsigned long )((void *)0)),
                               0L);
#line 3388
    if (tmp___1) {
#line 3389
      return ((_Bool)0);
    }
#line 3390
    dests_node_malloced = (_Bool)1;
  }
#line 3392
  dests_node = dests_alloc->dests_node;
#line 3393
  dests_ch = dests_alloc->dests_ch;
#line 3396
  tmp___2 = (struct re_dfastate_t **)((void *)0);
#line 3396
  state->trtable = tmp___2;
#line 3396
  state->word_trtable = tmp___2;
#line 3400
  ndests = group_nodes_into_DFAstates(dfa, (re_dfastate_t const   *)state, dests_node,
                                      dests_ch);
#line 3401
  tmp___4 = __builtin_expect((long )(! (ndests - 1UL < 0xfffffffffffffffdUL)), 0L);
#line 3401
  if (tmp___4) {
#line 3403
    if (dests_node_malloced) {
#line 3404
      free((void *)dests_alloc);
    }
#line 3405
    if (ndests == 0UL) {
#line 3407
      tmp___3 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3407
      state->trtable = (re_dfastate_t **)tmp___3;
#line 3409
      return ((_Bool)1);
    }
#line 3411
    return ((_Bool)0);
  }
#line 3414
  err = re_node_set_alloc(& follows, ndests + 1UL);
#line 3415
  tmp___5 = __builtin_expect((long )((int )err != 0), 0L);
#line 3415
  if (tmp___5) {
#line 3416
    goto out_free;
  }
#line 3419
  tmp___6 = __builtin_expect((long )((0xffffffffffffffffUL - (sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL) / (3UL * sizeof(re_dfastate_t *)) < ndests),
                             0L);
#line 3419
  if (tmp___6) {
#line 3423
    goto out_free;
  }
#line 3425
  if ((sizeof(re_node_set ) + sizeof(bitset_t )) * 256UL + (ndests * 3UL) * sizeof(re_dfastate_t *) < 4032UL) {
#line 3427
    tmp___7 = __builtin_alloca((ndests * 3UL) * sizeof(re_dfastate_t *));
#line 3427
    dest_states = (re_dfastate_t **)tmp___7;
  } else {
#line 3431
    tmp___8 = malloc((ndests * 3UL) * sizeof(re_dfastate_t *));
#line 3431
    dest_states = (re_dfastate_t **)tmp___8;
#line 3433
    tmp___9 = __builtin_expect((long )((unsigned long )dest_states == (unsigned long )((void *)0)),
                               0L);
#line 3433
    if (tmp___9) {
      out_free: 
#line 3436
      if (dest_states_malloced) {
#line 3437
        free((void *)dest_states);
      }
#line 3438
      free((void *)follows.elems);
#line 3439
      i = (Idx )0;
#line 3439
      while (i < ndests) {
#line 3440
        free((void *)(dests_node + i)->elems);
#line 3439
        i ++;
      }
#line 3441
      if (dests_node_malloced) {
#line 3442
        free((void *)dests_alloc);
      }
#line 3443
      return ((_Bool)0);
    }
#line 3445
    dest_states_malloced = (_Bool)1;
  }
#line 3447
  dest_states_word = dest_states + ndests;
#line 3448
  dest_states_nl = dest_states_word + ndests;
#line 3449
  bitset_empty((bitset_word_t *)(acceptable));
#line 3452
  i = (Idx )0;
#line 3452
  while (i < ndests) {
#line 3455
    follows.nelem = (Idx )0;
#line 3457
    j = (Idx )0;
#line 3457
    while (j < (dests_node + i)->nelem) {
#line 3459
      next_node = *(dfa->nexts + *((dests_node + i)->elems + j));
#line 3460
      if (next_node != 0xffffffffffffffffUL) {
#line 3462
        err = re_node_set_merge(& follows, (re_node_set const   *)(dfa->eclosures + next_node));
#line 3463
        tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
#line 3463
        if (tmp___10) {
#line 3464
          goto out_free;
        }
      }
#line 3457
      j ++;
    }
#line 3467
    *(dest_states + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                  0U);
#line 3468
    if ((unsigned long )*(dest_states + i) == (unsigned long )((void *)0)) {
#line 3468
      if ((int )err != 0) {
#line 3468
        tmp___11 = 1;
      } else {
#line 3468
        tmp___11 = 0;
      }
    } else {
#line 3468
      tmp___11 = 0;
    }
#line 3468
    tmp___12 = __builtin_expect((long )tmp___11, 0L);
#line 3468
    if (tmp___12) {
#line 3469
      goto out_free;
    }
#line 3472
    if ((*(dest_states + i))->has_constraint) {
#line 3474
      *(dest_states_word + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                         1U);
#line 3476
      if ((unsigned long )*(dest_states_word + i) == (unsigned long )((void *)0)) {
#line 3476
        if ((int )err != 0) {
#line 3476
          tmp___13 = 1;
        } else {
#line 3476
          tmp___13 = 0;
        }
      } else {
#line 3476
        tmp___13 = 0;
      }
#line 3476
      tmp___14 = __builtin_expect((long )tmp___13, 0L);
#line 3476
      if (tmp___14) {
#line 3477
        goto out_free;
      }
#line 3479
      if ((unsigned long )*(dest_states + i) != (unsigned long )*(dest_states_word + i)) {
#line 3479
        if (dfa->mb_cur_max > 1) {
#line 3480
          need_word_trtable = (_Bool)1;
        }
      }
#line 3482
      *(dest_states_nl + i) = re_acquire_state_context(& err, dfa, (re_node_set const   *)(& follows),
                                                       (unsigned int )(1 << 1));
#line 3484
      if ((unsigned long )*(dest_states_nl + i) == (unsigned long )((void *)0)) {
#line 3484
        if ((int )err != 0) {
#line 3484
          tmp___15 = 1;
        } else {
#line 3484
          tmp___15 = 0;
        }
      } else {
#line 3484
        tmp___15 = 0;
      }
#line 3484
      tmp___16 = __builtin_expect((long )tmp___15, 0L);
#line 3484
      if (tmp___16) {
#line 3485
        goto out_free;
      }
    } else {
#line 3489
      *(dest_states_word + i) = *(dest_states + i);
#line 3490
      *(dest_states_nl + i) = *(dest_states + i);
    }
#line 3492
    bitset_merge((bitset_word_t *)(acceptable), (bitset_word_t * const  )(*(dests_ch + i)));
#line 3452
    i ++;
  }
#line 3495
  tmp___25 = __builtin_expect((long )need_word_trtable, 0L);
#line 3495
  if (tmp___25) {
#line 3532
    tmp___22 = calloc(sizeof(re_dfastate_t *), (size_t )512);
#line 3532
    tmp___21 = (re_dfastate_t **)tmp___22;
#line 3532
    state->word_trtable = tmp___21;
#line 3532
    trtable = tmp___21;
#line 3534
    tmp___23 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
#line 3534
    if (tmp___23) {
#line 3535
      goto out_free;
    }
#line 3538
    i = (Idx )0;
#line 3538
    while (i < 4UL) {
#line 3539
      ch = (int )(i * 64UL);
#line 3539
      elem = acceptable[i];
#line 3539
      mask = (bitset_word_t )1;
#line 3539
      while (elem) {
#line 3542
        tmp___24 = __builtin_expect((long )(elem & 1UL), 0L);
#line 3542
        if (tmp___24) {
#line 3546
          j = (Idx )0;
#line 3546
          while (((*(dests_ch + j))[i] & mask) == 0UL) {
#line 3546
            j ++;
          }
#line 3550
          *(trtable + ch) = *(dest_states + j);
#line 3551
          *(trtable + (ch + 256)) = *(dest_states_word + j);
        }
#line 3539
        mask <<= 1;
#line 3539
        elem >>= 1;
#line 3539
        ch ++;
      }
#line 3538
      i ++;
    }
  } else {
#line 3501
    tmp___18 = calloc(sizeof(re_dfastate_t *), (size_t )256);
#line 3501
    tmp___17 = (re_dfastate_t **)tmp___18;
#line 3501
    state->trtable = tmp___17;
#line 3501
    trtable = tmp___17;
#line 3503
    tmp___19 = __builtin_expect((long )((unsigned long )trtable == (unsigned long )((void *)0)),
                                0L);
#line 3503
    if (tmp___19) {
#line 3504
      goto out_free;
    }
#line 3507
    i = (Idx )0;
#line 3507
    while (i < 4UL) {
#line 3508
      ch = (int )(i * 64UL);
#line 3508
      elem = acceptable[i];
#line 3508
      mask = (bitset_word_t )1;
#line 3508
      while (elem) {
#line 3511
        tmp___20 = __builtin_expect((long )(elem & 1UL), 0L);
#line 3511
        if (tmp___20) {
#line 3515
          j = (Idx )0;
#line 3515
          while (((*(dests_ch + j))[i] & mask) == 0UL) {
#line 3515
            j ++;
          }
#line 3519
          if (dfa->word_char[i] & mask) {
#line 3520
            *(trtable + ch) = *(dest_states_word + j);
          } else {
#line 3522
            *(trtable + ch) = *(dest_states + j);
          }
        }
#line 3508
        mask <<= 1;
#line 3508
        elem >>= 1;
#line 3508
        ch ++;
      }
#line 3507
      i ++;
    }
  }
#line 3556
  tmp___27 = bitset_contain((bitset_word_t * const  )(acceptable), (Idx )'\n');
#line 3556
  if (tmp___27) {
#line 3559
    j = (Idx )0;
#line 3559
    while (j < ndests) {
#line 3560
      tmp___26 = bitset_contain((bitset_word_t * const  )(*(dests_ch + j)), (Idx )'\n');
#line 3560
      if (tmp___26) {
#line 3563
        *(trtable + '\n') = *(dest_states_nl + j);
#line 3564
        if (need_word_trtable) {
#line 3565
          *(trtable + 266) = *(dest_states_nl + j);
        }
#line 3568
        break;
      }
#line 3559
      j ++;
    }
  }
#line 3572
  if (dest_states_malloced) {
#line 3573
    free((void *)dest_states);
  }
#line 3575
  free((void *)follows.elems);
#line 3576
  i = (Idx )0;
#line 3576
  while (i < ndests) {
#line 3577
    free((void *)(dests_node + i)->elems);
#line 3576
    i ++;
  }
#line 3579
  if (dests_node_malloced) {
#line 3580
    free((void *)dests_alloc);
  }
#line 3582
  return ((_Bool)1);
}
}
#line 3590 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static Idx group_nodes_into_DFAstates(re_dfa_t const   *dfa , re_dfastate_t const   *state ,
                                      re_node_set *dests_node , bitset_t *dests_ch ) 
{ 
  reg_errcode_t err ;
  _Bool ok ;
  Idx i ;
  Idx j ;
  Idx k ;
  Idx ndests ;
  bitset_t accepts ;
  re_node_set const   *cur_nodes ;
  re_token_t *node ;
  re_token_type_t type ;
  unsigned int constraint ;
  _Bool accepts_newline ;
  _Bool tmp ;
  bitset_word_t any_set ;
  unsigned long tmp___0 ;
  unsigned long tmp___1 ;
  bitset_word_t any_set___0 ;
  unsigned long tmp___2 ;
  unsigned long tmp___3 ;
  bitset_t intersec ;
  bitset_t remains ;
  bitset_word_t has_intersec ;
  bitset_word_t not_subset ;
  bitset_word_t not_consumed ;
  _Bool tmp___4 ;
  bitset_word_t tmp___5 ;
  bitset_word_t tmp___6 ;
  bitset_word_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
#line 3600
  cur_nodes = & state->nodes;
#line 3601
  bitset_empty((bitset_word_t *)(accepts));
#line 3602
  ndests = (Idx )0;
#line 3605
  i = (Idx )0;
#line 3605
  while (i < (Idx )cur_nodes->nelem) {
#line 3607
    node = dfa->nodes + *(cur_nodes->elems + i);
#line 3608
    type = node->type;
#line 3609
    constraint = node->constraint;
#line 3612
    if ((unsigned int )type == 1U) {
#line 3613
      bitset_set((bitset_word_t *)(accepts), (Idx )node->opr.c);
    } else
#line 3614
    if ((unsigned int )type == 3U) {
#line 3616
      bitset_merge((bitset_word_t *)(accepts), (bitset_word_t * const  )node->opr.sbcset);
    } else
#line 3618
    if ((unsigned int )type == 5U) {
#line 3621
      if (dfa->mb_cur_max > 1) {
#line 3622
        bitset_merge((bitset_word_t *)(accepts), (bitset_word_t * const  )dfa->sb_char);
      } else {
#line 3625
        bitset_set_all((bitset_word_t *)(accepts));
      }
#line 3626
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3627
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
      }
#line 3628
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3629
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
      }
    } else
#line 3632
    if ((unsigned int )type == 7U) {
#line 3635
      memset((void *)(accepts), -1, (size_t )16);
#line 3638
      if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3639
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\n');
      }
#line 3640
      if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3641
        bitset_clear((bitset_word_t *)(accepts), (Idx )'\000');
      }
    } else {
#line 3645
      goto __Cont;
    }
#line 3649
    if (constraint) {
#line 3651
      if (constraint & 32U) {
#line 3653
        tmp = bitset_contain((bitset_word_t * const  )(accepts), (Idx )'\n');
#line 3653
        accepts_newline = tmp;
#line 3654
        bitset_empty((bitset_word_t *)(accepts));
#line 3655
        if (accepts_newline) {
#line 3656
          bitset_set((bitset_word_t *)(accepts), (Idx )'\n');
        } else {
#line 3658
          goto __Cont;
        }
      }
#line 3660
      if (constraint & 128U) {
#line 3662
        bitset_empty((bitset_word_t *)(accepts));
#line 3663
        goto __Cont;
      }
#line 3666
      if (constraint & 4U) {
#line 3668
        any_set = (bitset_word_t )0;
#line 3669
        if ((unsigned int )type == 1U) {
#line 3669
          if (! node->word_char) {
#line 3671
            bitset_empty((bitset_word_t *)(accepts));
#line 3672
            goto __Cont;
          }
        }
#line 3675
        if (dfa->mb_cur_max > 1) {
#line 3676
          j = (Idx )0;
#line 3676
          while (j < 4UL) {
#line 3677
            tmp___0 = accepts[j] & (dfa->word_char[j] | ~ *(dfa->sb_char + j));
#line 3677
            accepts[j] = tmp___0;
#line 3677
            any_set |= tmp___0;
#line 3676
            j ++;
          }
        } else {
#line 3680
          j = (Idx )0;
#line 3680
          while (j < 4UL) {
#line 3681
            tmp___1 = accepts[j] & dfa->word_char[j];
#line 3681
            accepts[j] = tmp___1;
#line 3681
            any_set |= tmp___1;
#line 3680
            j ++;
          }
        }
#line 3682
        if (! any_set) {
#line 3683
          goto __Cont;
        }
      }
#line 3685
      if (constraint & 8U) {
#line 3687
        any_set___0 = (bitset_word_t )0;
#line 3688
        if ((unsigned int )type == 1U) {
#line 3688
          if (node->word_char) {
#line 3690
            bitset_empty((bitset_word_t *)(accepts));
#line 3691
            goto __Cont;
          }
        }
#line 3694
        if (dfa->mb_cur_max > 1) {
#line 3695
          j = (Idx )0;
#line 3695
          while (j < 4UL) {
#line 3696
            tmp___2 = accepts[j] & ~ (dfa->word_char[j] & *(dfa->sb_char + j));
#line 3696
            accepts[j] = tmp___2;
#line 3696
            any_set___0 |= tmp___2;
#line 3695
            j ++;
          }
        } else {
#line 3699
          j = (Idx )0;
#line 3699
          while (j < 4UL) {
#line 3700
            tmp___3 = accepts[j] & ~ dfa->word_char[j];
#line 3700
            accepts[j] = tmp___3;
#line 3700
            any_set___0 |= tmp___3;
#line 3699
            j ++;
          }
        }
#line 3701
        if (! any_set___0) {
#line 3702
          goto __Cont;
        }
      }
    }
#line 3708
    j = (Idx )0;
#line 3708
    while (j < ndests) {
#line 3716
      if ((unsigned int )type == 1U) {
#line 3716
        tmp___4 = bitset_contain((bitset_word_t * const  )(*(dests_ch + j)), (Idx )node->opr.c);
#line 3716
        if (! tmp___4) {
#line 3717
          goto __Cont___0;
        }
      }
#line 3720
      has_intersec = (bitset_word_t )0;
#line 3721
      k = (Idx )0;
#line 3721
      while (k < 4UL) {
#line 3722
        tmp___5 = accepts[k] & (*(dests_ch + j))[k];
#line 3722
        intersec[k] = tmp___5;
#line 3722
        has_intersec |= tmp___5;
#line 3721
        k ++;
      }
#line 3724
      if (! has_intersec) {
#line 3725
        goto __Cont___0;
      }
#line 3728
      not_consumed = (bitset_word_t )0;
#line 3728
      not_subset = not_consumed;
#line 3729
      k = (Idx )0;
#line 3729
      while (k < 4UL) {
#line 3731
        tmp___6 = ~ accepts[k] & (*(dests_ch + j))[k];
#line 3731
        remains[k] = tmp___6;
#line 3731
        not_subset |= tmp___6;
#line 3732
        tmp___7 = accepts[k] & ~ (*(dests_ch + j))[k];
#line 3732
        accepts[k] = tmp___7;
#line 3732
        not_consumed |= tmp___7;
#line 3729
        k ++;
      }
#line 3737
      if (not_subset) {
#line 3739
        bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t * const  )(remains));
#line 3740
        bitset_copy((bitset_word_t *)(*(dests_ch + j)), (bitset_word_t * const  )(intersec));
#line 3741
        err = re_node_set_init_copy(dests_node + ndests, (re_node_set const   *)(dests_node + j));
#line 3742
        tmp___8 = __builtin_expect((long )((int )err != 0), 0L);
#line 3742
        if (tmp___8) {
#line 3743
          goto error_return;
        }
#line 3744
        ndests ++;
      }
#line 3748
      ok = re_node_set_insert(dests_node + j, *(cur_nodes->elems + i));
#line 3749
      tmp___9 = __builtin_expect((long )(! ok), 0L);
#line 3749
      if (tmp___9) {
#line 3750
        goto error_return;
      }
#line 3753
      if (! not_consumed) {
#line 3754
        break;
      }
      __Cont___0: /* CIL Label */ 
#line 3708
      j ++;
    }
#line 3757
    if (j == ndests) {
#line 3759
      bitset_copy((bitset_word_t *)(*(dests_ch + ndests)), (bitset_word_t * const  )(accepts));
#line 3760
      err = re_node_set_init_1(dests_node + ndests, *(cur_nodes->elems + i));
#line 3761
      tmp___10 = __builtin_expect((long )((int )err != 0), 0L);
#line 3761
      if (tmp___10) {
#line 3762
        goto error_return;
      }
#line 3763
      ndests ++;
#line 3764
      bitset_empty((bitset_word_t *)(accepts));
    }
    __Cont: /* CIL Label */ 
#line 3605
    i ++;
  }
#line 3767
  return (ndests);
  error_return: 
#line 3769
  j = (Idx )0;
#line 3769
  while (j < ndests) {
#line 3770
    free((void *)(dests_node + j)->elems);
#line 3769
    j ++;
  }
#line 3771
  return ((Idx )-1);
}
}
#line 3783 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static int check_node_accept_bytes(re_dfa_t const   *dfa , Idx node_idx , re_string_t const   *input ,
                                   Idx str_idx ) 
{ 
  re_token_t const   *node ;
  int char_len ;
  int elem_len ;
  Idx i ;
  unsigned char c ;
  unsigned char d ;
  long tmp ;
  int tmp___0 ;
  long tmp___1 ;
  int __attribute__((__pure__))  tmp___2 ;
  int __attribute__((__pure__))  tmp___3 ;
  re_charset_t const   *cset ;
  int match_len ;
  wchar_t wc ;
  wint_t __attribute__((__pure__))  tmp___4 ;
  wint_t __attribute__((__pure__))  tmp___5 ;
  wctype_t wt ;
  int tmp___6 ;
  wchar_t cmp_buf[6] ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 3788
  node = (re_token_t const   *)(dfa->nodes + node_idx);
#line 3792
  tmp___1 = __builtin_expect((long )((unsigned int const   )node->type == 7U), 0L);
#line 3792
  if (tmp___1) {
#line 3794
    c = *(input->mbs + str_idx);
#line 3795
    tmp = __builtin_expect((long )((int )c < 194), 1L);
#line 3795
    if (tmp) {
#line 3796
      return (0);
    }
#line 3798
    if (str_idx + 2UL > (Idx )input->len) {
#line 3799
      return (0);
    }
#line 3801
    d = *(input->mbs + (str_idx + 1UL));
#line 3802
    if ((int )c < 224) {
#line 3803
      if ((int )d < 128) {
#line 3803
        tmp___0 = 0;
      } else
#line 3803
      if ((int )d > 191) {
#line 3803
        tmp___0 = 0;
      } else {
#line 3803
        tmp___0 = 2;
      }
#line 3803
      return (tmp___0);
    } else
#line 3804
    if ((int )c < 240) {
#line 3806
      char_len = 3;
#line 3807
      if ((int )c == 224) {
#line 3807
        if ((int )d < 160) {
#line 3808
          return (0);
        }
      }
    } else
#line 3810
    if ((int )c < 248) {
#line 3812
      char_len = 4;
#line 3813
      if ((int )c == 240) {
#line 3813
        if ((int )d < 144) {
#line 3814
          return (0);
        }
      }
    } else
#line 3816
    if ((int )c < 252) {
#line 3818
      char_len = 5;
#line 3819
      if ((int )c == 248) {
#line 3819
        if ((int )d < 136) {
#line 3820
          return (0);
        }
      }
    } else
#line 3822
    if ((int )c < 254) {
#line 3824
      char_len = 6;
#line 3825
      if ((int )c == 252) {
#line 3825
        if ((int )d < 132) {
#line 3826
          return (0);
        }
      }
    } else {
#line 3829
      return (0);
    }
#line 3831
    if (str_idx + (Idx )char_len > (Idx )input->len) {
#line 3832
      return (0);
    }
#line 3834
    i = (Idx )1;
#line 3834
    while (i < (Idx )char_len) {
#line 3836
      d = *(input->mbs + (str_idx + i));
#line 3837
      if ((int )d < 128) {
#line 3838
        return (0);
      } else
#line 3837
      if ((int )d > 191) {
#line 3838
        return (0);
      }
#line 3834
      i ++;
    }
#line 3840
    return (char_len);
  }
#line 3843
  tmp___2 = re_string_char_size_at(input, str_idx);
#line 3843
  char_len = (int )tmp___2;
#line 3844
  if ((unsigned int const   )node->type == 5U) {
#line 3846
    if (char_len <= 1) {
#line 3847
      return (0);
    }
#line 3851
    if (! (dfa->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 3851
      if ((int )*(input->mbs + str_idx) == 10) {
#line 3855
        return (0);
      } else {
#line 3851
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 3851
    if (dfa->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 3851
      if ((int )*(input->mbs + str_idx) == 0) {
#line 3855
        return (0);
      }
    }
#line 3856
    return (char_len);
  }
#line 3859
  tmp___3 = re_string_elem_size_at(input, str_idx);
#line 3859
  elem_len = (int )tmp___3;
#line 3860
  if (elem_len <= 1) {
#line 3860
    if (char_len <= 1) {
#line 3861
      return (0);
    } else {
#line 3860
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3860
  if (char_len == 0) {
#line 3861
    return (0);
  }
#line 3863
  if ((unsigned int const   )node->type == 6U) {
#line 3865
    cset = (re_charset_t const   *)node->opr.mbcset;
#line 3872
    match_len = 0;
#line 3873
    if (cset->nranges) {
#line 3873
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3873
      tmp___5 = tmp___4;
    } else
#line 3873
    if (cset->nchar_classes) {
#line 3873
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3873
      tmp___5 = tmp___4;
    } else
#line 3873
    if (cset->nmbchars) {
#line 3873
      tmp___4 = re_string_wchar_at(input, str_idx);
#line 3873
      tmp___5 = tmp___4;
    } else {
#line 3873
      tmp___5 = (wint_t __attribute__((__pure__))  )0;
    }
#line 3873
    wc = (wchar_t )tmp___5;
#line 3877
    i = (Idx )0;
#line 3877
    while (i < (Idx )cset->nmbchars) {
#line 3878
      if (wc == *(cset->mbchars + i)) {
#line 3880
        match_len = char_len;
#line 3881
        goto check_node_accept_bytes_match;
      }
#line 3877
      i ++;
    }
#line 3884
    i = (Idx )0;
#line 3884
    while (i < (Idx )cset->nchar_classes) {
#line 3886
      wt = *(cset->char_classes + i);
#line 3887
      tmp___6 = iswctype((wint_t )wc, wt);
#line 3887
      if (tmp___6) {
#line 3889
        match_len = char_len;
#line 3890
        goto check_node_accept_bytes_match;
      }
#line 3884
      i ++;
    }
#line 3987
    cmp_buf[0] = 0;
#line 3987
    cmp_buf[1] = 0;
#line 3987
    cmp_buf[2] = wc;
#line 3987
    cmp_buf[3] = 0;
#line 3987
    cmp_buf[4] = 0;
#line 3987
    cmp_buf[5] = 0;
#line 3992
    i = (Idx )0;
#line 3992
    while (i < (Idx )cset->nranges) {
#line 3994
      cmp_buf[0] = *(cset->range_starts + i);
#line 3995
      cmp_buf[4] = *(cset->range_ends + i);
#line 3996
      tmp___7 = wcscoll((wchar_t const   *)(cmp_buf), (wchar_t const   *)(cmp_buf + 2));
#line 3996
      if (tmp___7 <= 0) {
#line 3996
        tmp___8 = wcscoll((wchar_t const   *)(cmp_buf + 2), (wchar_t const   *)(cmp_buf + 4));
#line 3996
        if (tmp___8 <= 0) {
#line 3999
          match_len = char_len;
#line 4000
          goto check_node_accept_bytes_match;
        }
      }
#line 3992
      i ++;
    }
    check_node_accept_bytes_match: 
#line 4005
    if (! cset->non_match) {
#line 4006
      return (match_len);
    } else
#line 4009
    if (match_len > 0) {
#line 4010
      return (0);
    } else {
#line 4012
      if (elem_len > char_len) {
#line 4012
        tmp___9 = elem_len;
      } else {
#line 4012
        tmp___9 = char_len;
      }
#line 4012
      return (tmp___9);
    }
  }
#line 4015
  return (0);
}
}
#line 4083 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static _Bool check_node_accept(re_match_context_t const   *mctx , re_token_t const   *node ,
                               Idx idx ) 
{ 
  unsigned char ch ;
  _Bool tmp ;
  unsigned int context ;
  unsigned int tmp___0 ;

  {
#line 4089
  ch = *(mctx->input.mbs + idx);
#line 4090
  switch ((unsigned int const   )node->type) {
  case 1U: 
#line 4093
  if ((int const   )node->opr.c != (int const   )ch) {
#line 4094
    return ((_Bool)0);
  }
#line 4095
  break;
  case 3U: 
#line 4098
  tmp = bitset_contain((bitset_word_t * const  )node->opr.sbcset, (Idx )ch);
#line 4098
  if (! tmp) {
#line 4099
    return ((_Bool)0);
  }
#line 4100
  break;
  case 7U: 
#line 4104
  if ((int )ch >= 128) {
#line 4105
    return ((_Bool)0);
  }
  case 5U: 
#line 4109
  if ((int )ch == 10) {
#line 4109
    if (! ((mctx->dfa)->syntax & (unsigned long const   )((((((1UL << 1) << 1) << 1) << 1) << 1) << 1))) {
#line 4111
      return ((_Bool)0);
    } else {
#line 4109
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 4109
  if ((int )ch == 0) {
#line 4109
    if ((mctx->dfa)->syntax & (unsigned long const   )(((((((1UL << 1) << 1) << 1) << 1) << 1) << 1) << 1)) {
#line 4111
      return ((_Bool)0);
    }
  }
#line 4112
  break;
  default: 
#line 4115
  return ((_Bool)0);
  }
#line 4118
  if (node->constraint) {
#line 4122
    tmp___0 = re_string_context_at(& mctx->input, idx, (int )mctx->eflags);
#line 4122
    context = tmp___0;
#line 4124
    if (node->constraint & 4U) {
#line 4124
      if (! (context & 1U)) {
#line 4125
        return ((_Bool)0);
      } else {
#line 4124
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 4124
    if (node->constraint & 8U) {
#line 4124
      if (context & 1U) {
#line 4125
        return ((_Bool)0);
      } else {
#line 4124
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 4124
    if (node->constraint & 32U) {
#line 4124
      if (! (context & (unsigned int )(1 << 1))) {
#line 4125
        return ((_Bool)0);
      } else {
#line 4124
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 4124
    if (node->constraint & 128U) {
#line 4124
      if (! (context & (unsigned int )(((1 << 1) << 1) << 1))) {
#line 4125
        return ((_Bool)0);
      }
    }
  }
#line 4128
  return ((_Bool)1);
}
}
#line 4133 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t extend_buffers(re_match_context_t *mctx ) 
{ 
  reg_errcode_t ret ;
  re_string_t *pstr ;
  long tmp ;
  long tmp___0 ;
  re_dfastate_t **new_array ;
  void *tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;

  {
#line 4138
  pstr = & mctx->input;
#line 4141
  tmp = __builtin_expect((long )(9223372036854775807UL / sizeof(re_dfastate_t *) <= pstr->bufs_len),
                         0L);
#line 4141
  if (tmp) {
#line 4142
    return ((reg_errcode_t )12);
  }
#line 4145
  ret = re_string_realloc_buffers(pstr, pstr->bufs_len * 2UL);
#line 4146
  tmp___0 = __builtin_expect((long )((int )ret != 0), 0L);
#line 4146
  if (tmp___0) {
#line 4147
    return (ret);
  }
#line 4149
  if ((unsigned long )mctx->state_log != (unsigned long )((void *)0)) {
#line 4155
    tmp___1 = realloc((void *)mctx->state_log, (pstr->bufs_len + 1UL) * sizeof(re_dfastate_t *));
#line 4155
    new_array = (re_dfastate_t **)tmp___1;
#line 4157
    tmp___2 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
#line 4157
    if (tmp___2) {
#line 4158
      return ((reg_errcode_t )12);
    }
#line 4159
    mctx->state_log = new_array;
  }
#line 4163
  if (pstr->icase) {
#line 4166
    if (pstr->mb_cur_max > 1) {
#line 4168
      ret = build_wcs_upper_buffer(pstr);
#line 4169
      tmp___3 = __builtin_expect((long )((int )ret != 0), 0L);
#line 4169
      if (tmp___3) {
#line 4170
        return (ret);
      }
    } else {
#line 4174
      build_upper_buffer(pstr);
    }
  } else
#line 4179
  if (pstr->mb_cur_max > 1) {
#line 4180
    build_wcs_buffer(pstr);
  } else
#line 4184
  if ((unsigned long )pstr->trans != (unsigned long )((void *)0)) {
#line 4185
    re_string_translate_buffer(pstr);
  }
#line 4188
  return ((reg_errcode_t )0);
}
}
#line 4196 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t match_ctx_init(re_match_context_t *mctx , int eflags , Idx n ) 
{ 
  size_t max_object_size ;
  unsigned long tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;

  {
#line 4200
  mctx->eflags = eflags;
#line 4201
  mctx->match_last = (Idx )-1;
#line 4202
  if (n > 0UL) {
#line 4205
    if (sizeof(struct re_backref_cache_entry ) < sizeof(re_sub_match_top_t *)) {
#line 4205
      tmp = sizeof(re_sub_match_top_t *);
    } else {
#line 4205
      tmp = sizeof(struct re_backref_cache_entry );
    }
#line 4205
    max_object_size = tmp;
#line 4208
    tmp___0 = __builtin_expect((long )(0xffffffffffffffffUL / max_object_size < n),
                               0L);
#line 4208
    if (tmp___0) {
#line 4209
      return ((reg_errcode_t )12);
    }
#line 4211
    tmp___1 = malloc(n * sizeof(struct re_backref_cache_entry ));
#line 4211
    mctx->bkref_ents = (struct re_backref_cache_entry *)tmp___1;
#line 4212
    tmp___2 = malloc(n * sizeof(re_sub_match_top_t *));
#line 4212
    mctx->sub_tops = (re_sub_match_top_t **)tmp___2;
#line 4213
    if ((unsigned long )mctx->bkref_ents == (unsigned long )((void *)0)) {
#line 4213
      tmp___3 = 1;
    } else
#line 4213
    if ((unsigned long )mctx->sub_tops == (unsigned long )((void *)0)) {
#line 4213
      tmp___3 = 1;
    } else {
#line 4213
      tmp___3 = 0;
    }
#line 4213
    tmp___4 = __builtin_expect((long )tmp___3, 0L);
#line 4213
    if (tmp___4) {
#line 4214
      return ((reg_errcode_t )12);
    }
  }
#line 4221
  mctx->abkref_ents = n;
#line 4222
  mctx->max_mb_elem_len = 1;
#line 4223
  mctx->asub_tops = n;
#line 4224
  return ((reg_errcode_t )0);
}
}
#line 4231 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static void match_ctx_clean(re_match_context_t *mctx ) 
{ 
  Idx st_idx ;
  Idx sl_idx ;
  re_sub_match_top_t *top ;
  re_sub_match_last_t *last ;

  {
#line 4236
  st_idx = (Idx )0;
#line 4236
  while (st_idx < mctx->nsub_tops) {
#line 4239
    top = *(mctx->sub_tops + st_idx);
#line 4240
    sl_idx = (Idx )0;
#line 4240
    while (sl_idx < top->nlasts) {
#line 4242
      last = *(top->lasts + sl_idx);
#line 4243
      free((void *)last->path.array);
#line 4244
      free((void *)last);
#line 4240
      sl_idx ++;
    }
#line 4246
    free((void *)top->lasts);
#line 4247
    if (top->path) {
#line 4249
      free((void *)(top->path)->array);
#line 4250
      free((void *)top->path);
    }
#line 4252
    free((void *)top);
#line 4236
    st_idx ++;
  }
#line 4255
  mctx->nsub_tops = (Idx )0;
#line 4256
  mctx->nbkref_ents = (Idx )0;
#line 4257
  return;
}
}
#line 4261 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static void match_ctx_free(re_match_context_t *mctx ) 
{ 


  {
#line 4266
  match_ctx_clean(mctx);
#line 4267
  free((void *)mctx->sub_tops);
#line 4268
  free((void *)mctx->bkref_ents);
#line 4269
  return;
}
}
#line 4276 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t match_ctx_add_entry(re_match_context_t *mctx , Idx node , Idx str_idx ,
                                         Idx from , Idx to ) 
{ 
  struct re_backref_cache_entry *new_entry ;
  void *tmp ;
  long tmp___0 ;
  Idx tmp___1 ;

  {
#line 4281
  if (mctx->nbkref_ents >= mctx->abkref_ents) {
#line 4284
    tmp = realloc((void *)mctx->bkref_ents, (mctx->abkref_ents * 2UL) * sizeof(struct re_backref_cache_entry ));
#line 4284
    new_entry = (struct re_backref_cache_entry *)tmp;
#line 4286
    tmp___0 = __builtin_expect((long )((unsigned long )new_entry == (unsigned long )((void *)0)),
                               0L);
#line 4286
    if (tmp___0) {
#line 4288
      free((void *)mctx->bkref_ents);
#line 4289
      return ((reg_errcode_t )12);
    }
#line 4291
    mctx->bkref_ents = new_entry;
#line 4292
    memset((void *)(mctx->bkref_ents + mctx->nbkref_ents), '\000', sizeof(struct re_backref_cache_entry ) * mctx->abkref_ents);
#line 4294
    mctx->abkref_ents *= 2UL;
  }
#line 4296
  if (mctx->nbkref_ents > 0UL) {
#line 4296
    if ((mctx->bkref_ents + (mctx->nbkref_ents - 1UL))->str_idx == str_idx) {
#line 4298
      (mctx->bkref_ents + (mctx->nbkref_ents - 1UL))->more = (char)1;
    }
  }
#line 4300
  (mctx->bkref_ents + mctx->nbkref_ents)->node = node;
#line 4301
  (mctx->bkref_ents + mctx->nbkref_ents)->str_idx = str_idx;
#line 4302
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_from = from;
#line 4303
  (mctx->bkref_ents + mctx->nbkref_ents)->subexp_to = to;
#line 4313
  if (from == to) {
#line 4313
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)65535;
  } else {
#line 4313
    (mctx->bkref_ents + mctx->nbkref_ents)->eps_reachable_subexps_map = (unsigned short)0;
  }
#line 4316
  tmp___1 = mctx->nbkref_ents;
#line 4316
  (mctx->nbkref_ents) ++;
#line 4316
  (mctx->bkref_ents + tmp___1)->more = (char)0;
#line 4317
  if ((Idx )mctx->max_mb_elem_len < to - from) {
#line 4318
    mctx->max_mb_elem_len = (int )(to - from);
  }
#line 4319
  return ((reg_errcode_t )0);
}
}
#line 4325 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static Idx search_cur_bkref_entry(re_match_context_t const   *mctx , Idx str_idx ) 
{ 
  Idx left ;
  Idx right ;
  Idx mid ;
  Idx last ;

  {
#line 4330
  right = (Idx )mctx->nbkref_ents;
#line 4330
  last = right;
#line 4331
  left = (Idx )0;
#line 4331
  while (left < right) {
#line 4333
    mid = (left + right) / 2UL;
#line 4334
    if ((mctx->bkref_ents + mid)->str_idx < str_idx) {
#line 4335
      left = mid + 1UL;
    } else {
#line 4337
      right = mid;
    }
  }
#line 4339
  if (left < last) {
#line 4339
    if ((mctx->bkref_ents + left)->str_idx == str_idx) {
#line 4340
      return (left);
    } else {
#line 4342
      return ((Idx )-1);
    }
  } else {
#line 4342
    return ((Idx )-1);
  }
}
}
#line 4348 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static reg_errcode_t match_ctx_add_subtop(re_match_context_t *mctx , Idx node , Idx str_idx ) 
{ 
  Idx new_asub_tops ;
  re_sub_match_top_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  Idx tmp___4 ;

  {
#line 4356
  tmp___1 = __builtin_expect((long )(mctx->nsub_tops == mctx->asub_tops), 0L);
#line 4356
  if (tmp___1) {
#line 4358
    new_asub_tops = mctx->asub_tops * 2UL;
#line 4359
    tmp = realloc((void *)mctx->sub_tops, new_asub_tops * sizeof(re_sub_match_top_t *));
#line 4359
    new_array = (re_sub_match_top_t **)tmp;
#line 4362
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
#line 4362
    if (tmp___0) {
#line 4363
      return ((reg_errcode_t )12);
    }
#line 4364
    mctx->sub_tops = new_array;
#line 4365
    mctx->asub_tops = new_asub_tops;
  }
#line 4367
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_top_t ));
#line 4367
  *(mctx->sub_tops + mctx->nsub_tops) = (re_sub_match_top_t *)tmp___2;
#line 4368
  tmp___3 = __builtin_expect((long )((unsigned long )*(mctx->sub_tops + mctx->nsub_tops) == (unsigned long )((void *)0)),
                             0L);
#line 4368
  if (tmp___3) {
#line 4369
    return ((reg_errcode_t )12);
  }
#line 4370
  (*(mctx->sub_tops + mctx->nsub_tops))->node = node;
#line 4371
  tmp___4 = mctx->nsub_tops;
#line 4371
  (mctx->nsub_tops) ++;
#line 4371
  (*(mctx->sub_tops + tmp___4))->str_idx = str_idx;
#line 4372
  return ((reg_errcode_t )0);
}
}
#line 4378 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static re_sub_match_last_t *match_ctx_add_sublast(re_sub_match_top_t *subtop , Idx node ,
                                                  Idx str_idx ) 
{ 
  re_sub_match_last_t *new_entry ;
  Idx new_alasts ;
  re_sub_match_last_t **new_array ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;

  {
#line 4383
  tmp___1 = __builtin_expect((long )(subtop->nlasts == subtop->alasts), 0L);
#line 4383
  if (tmp___1) {
#line 4385
    new_alasts = 2UL * subtop->alasts + 1UL;
#line 4386
    tmp = realloc((void *)subtop->lasts, new_alasts * sizeof(re_sub_match_last_t *));
#line 4386
    new_array = (re_sub_match_last_t **)tmp;
#line 4389
    tmp___0 = __builtin_expect((long )((unsigned long )new_array == (unsigned long )((void *)0)),
                               0L);
#line 4389
    if (tmp___0) {
#line 4390
      return ((re_sub_match_last_t *)((void *)0));
    }
#line 4391
    subtop->lasts = new_array;
#line 4392
    subtop->alasts = new_alasts;
  }
#line 4394
  tmp___2 = calloc((size_t )1, sizeof(re_sub_match_last_t ));
#line 4394
  new_entry = (re_sub_match_last_t *)tmp___2;
#line 4395
  tmp___3 = __builtin_expect((long )((unsigned long )new_entry != (unsigned long )((void *)0)),
                             1L);
#line 4395
  if (tmp___3) {
#line 4397
    *(subtop->lasts + subtop->nlasts) = new_entry;
#line 4398
    new_entry->node = node;
#line 4399
    new_entry->str_idx = str_idx;
#line 4400
    (subtop->nlasts) ++;
  }
#line 4402
  return (new_entry);
}
}
#line 4405 "/home/wslee/project/coreutils-8.1/lib/regexec.c"
static void sift_ctx_init(re_sift_context_t *sctx , re_dfastate_t **sifted_sts , re_dfastate_t **limited_sts ,
                          Idx last_node , Idx last_str_idx ) 
{ 


  {
#line 4410
  sctx->sifted_states = sifted_sts;
#line 4411
  sctx->limited_states = limited_sts;
#line 4412
  sctx->last_node = last_node;
#line 4413
  sctx->last_str_idx = last_str_idx;
#line 4414
  memset((void *)(& sctx->limits), '\000', sizeof(re_node_set ));
#line 4415
  return;
}
}
#line 1 "cil-545Fc12a.o"
#pragma merger("0","../lib/root-dev-ino.o.i","")
#line 24 "/home/wslee/project/coreutils-8.1/lib/root-dev-ino.h"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) ;
#line 28 "/home/wslee/project/coreutils-8.1/lib/root-dev-ino.c"
struct dev_ino *get_root_dev_ino(struct dev_ino *root_d_i ) 
{ 
  struct stat statbuf ;
  int tmp ;

  {
#line 32
  tmp = lstat((char const   * __restrict  )"/", (struct stat * __restrict  )(& statbuf));
#line 32
  if (tmp) {
#line 33
    return ((struct dev_ino *)((void *)0));
  }
#line 34
  root_d_i->st_ino = statbuf.st_ino;
#line 35
  root_d_i->st_dev = statbuf.st_dev;
#line 36
  return (root_d_i);
}
}
#line 1 "cil-H0kuAjDA.o"
#pragma merger("0","../lib/safe-read.o.i","")
#line 363 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 55 "/home/wslee/project/coreutils-8.1/lib/safe-read.c"
size_t safe_read(int fd , void *buf___0 , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 64
  while (1) {
#line 66
    tmp = read(fd, buf___0, count);
#line 66
    result = tmp;
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
#line 70
      tmp___1 = __errno_location();
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
#line 72
        tmp___0 = __errno_location();
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 1 "cil-yWfZNnvv.o"
#pragma merger("0","../lib/safe-write.o.i","")
#line 369 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 55 "/home/wslee/project/coreutils-8.1/lib/safe-read.c"
size_t safe_write(int fd , void const   *buf___0 , size_t count ) 
{ 
  ssize_t result ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 64
  while (1) {
#line 66
    tmp = write(fd, buf___0, count);
#line 66
    result = tmp;
#line 68
    if (0L <= result) {
#line 69
      return ((size_t )result);
    } else {
#line 70
      tmp___1 = __errno_location();
#line 70
      if (*tmp___1 == 4) {
#line 71
        goto __Cont;
      } else {
#line 72
        tmp___0 = __errno_location();
#line 72
        if (*tmp___0 == 22) {
#line 72
          if (2147475456UL < count) {
#line 73
            count = (size_t )2147475456;
          } else {
#line 75
            return ((size_t )result);
          }
        } else {
#line 75
          return ((size_t )result);
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
}
}
#line 1 "cil-GKSUlCai.o"
#pragma merger("0","../lib/same.o.i","")
#line 52 "/home/wslee/project/coreutils-8.1/lib/same.c"
_Bool same_name(char const   *source , char const   *dest ) 
{ 
  char const   *source_basename ;
  char *tmp ;
  char const   *dest_basename ;
  char *tmp___0 ;
  size_t source_baselen ;
  size_t tmp___1 ;
  size_t dest_baselen ;
  size_t tmp___2 ;
  _Bool identical_basenames ;
  int tmp___3 ;
  int tmp___4 ;
  _Bool compare_dirs ;
  _Bool same ;
  struct stat source_dir_stats ;
  struct stat dest_dir_stats ;
  char *source_dirname ;
  char *dest_dirname ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 56
  tmp = last_component(source);
#line 56
  source_basename = (char const   *)tmp;
#line 57
  tmp___0 = last_component(dest);
#line 57
  dest_basename = (char const   *)tmp___0;
#line 58
  tmp___1 = base_len(source_basename);
#line 58
  source_baselen = tmp___1;
#line 59
  tmp___2 = base_len(dest_basename);
#line 59
  dest_baselen = tmp___2;
#line 60
  if (source_baselen == dest_baselen) {
#line 60
    tmp___3 = memcmp((void const   *)source_basename, (void const   *)dest_basename,
                     dest_baselen);
#line 60
    if (tmp___3 == 0) {
#line 60
      tmp___4 = 1;
    } else {
#line 60
      tmp___4 = 0;
    }
  } else {
#line 60
    tmp___4 = 0;
  }
#line 60
  identical_basenames = (_Bool )tmp___4;
#line 63
  compare_dirs = identical_basenames;
#line 64
  same = (_Bool)0;
#line 77
  if (compare_dirs) {
#line 84
    source_dirname = dir_name(source);
#line 85
    dest_dirname = dir_name(dest);
#line 87
    tmp___6 = stat((char const   * __restrict  )source_dirname, (struct stat * __restrict  )(& source_dir_stats));
#line 87
    if (tmp___6) {
#line 90
      tmp___5 = __errno_location();
#line 90
      error(1, *tmp___5, "%s", source_dirname);
    }
#line 93
    tmp___8 = stat((char const   * __restrict  )dest_dirname, (struct stat * __restrict  )(& dest_dir_stats));
#line 93
    if (tmp___8) {
#line 96
      tmp___7 = __errno_location();
#line 96
      error(1, *tmp___7, "%s", dest_dirname);
    }
#line 99
    if (source_dir_stats.st_ino == dest_dir_stats.st_ino) {
#line 99
      if (source_dir_stats.st_dev == dest_dir_stats.st_dev) {
#line 99
        tmp___9 = 1;
      } else {
#line 99
        tmp___9 = 0;
      }
    } else {
#line 99
      tmp___9 = 0;
    }
#line 99
    same = (_Bool )tmp___9;
#line 120
    free((void *)source_dirname);
#line 121
    free((void *)dest_dirname);
  }
#line 124
  return (same);
}
}
#line 1 "cil-REHl02U6.o"
#pragma merger("0","../lib/save-cwd.o.i","")
#line 29 "/home/wslee/project/coreutils-8.1/lib/save-cwd.h"
int save_cwd(struct saved_cwd *cwd ) ;
#line 30
int restore_cwd(struct saved_cwd  const  *cwd ) ;
#line 31
void free_cwd(struct saved_cwd *cwd ) ;
#line 73 "/home/wslee/project/coreutils-8.1/lib/save-cwd.c"
int save_cwd(struct saved_cwd *cwd ) 
{ 
  int tmp ;

  {
#line 76
  cwd->name = (char *)((void *)0);
#line 78
  cwd->desc = open_safer(".", 0);
#line 81
  if (cwd->desc < 0) {
#line 83
    cwd->name = xgetcwd();
#line 84
    if (cwd->name) {
#line 84
      tmp = 0;
    } else {
#line 84
      tmp = -1;
    }
#line 84
    return (tmp);
  }
#line 87
  return (0);
}
}
#line 94 "/home/wslee/project/coreutils-8.1/lib/save-cwd.c"
int restore_cwd(struct saved_cwd  const  *cwd ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 97
  if (0 <= (int )cwd->desc) {
#line 98
    tmp = fchdir((int )cwd->desc);
#line 98
    return (tmp);
  } else {
#line 100
    tmp___0 = chdir_long((char *)cwd->name);
#line 100
    return (tmp___0);
  }
}
}
#line 103 "/home/wslee/project/coreutils-8.1/lib/save-cwd.c"
void free_cwd(struct saved_cwd *cwd ) 
{ 


  {
#line 106
  if (cwd->desc >= 0) {
#line 107
    close(cwd->desc);
  }
#line 108
  free((void *)cwd->name);
#line 109
  return;
}
}
#line 1 "cil-yy2KHHWQ.o"
#pragma merger("0","../lib/savedir.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/savedir.h"
char *savedir(char const   *dir ) ;
#line 24
char *fdsavedir(int fd ) ;
#line 50 "/home/wslee/project/coreutils-8.1/lib/savedir.c"
static char *savedirstream(DIR *dirp ) 
{ 
  char *name_space ;
  size_t allocated ;
  size_t used ;
  int save_errno ;
  void *tmp ;
  struct dirent  const  *dp ;
  char const   *entry ;
  int *tmp___0 ;
  struct dirent *tmp___1 ;
  size_t entry_size ;
  size_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;

  {
#line 54
  allocated = (size_t )512;
#line 55
  used = (size_t )0;
#line 58
  if ((unsigned long )dirp == (unsigned long )((void *)0)) {
#line 59
    return ((char *)((void *)0));
  }
#line 61
  tmp = xmalloc(allocated);
#line 61
  name_space = (char *)tmp;
#line 63
  while (1) {
#line 68
    tmp___0 = __errno_location();
#line 68
    *tmp___0 = 0;
#line 69
    tmp___1 = readdir(dirp);
#line 69
    dp = (struct dirent  const  *)tmp___1;
#line 70
    if (! dp) {
#line 71
      break;
    }
#line 75
    entry = (char const   *)(dp->d_name);
#line 76
    if ((int const   )*(entry + 0) != 46) {
#line 76
      tmp___5 = 0;
    } else {
#line 76
      if ((int const   )*(entry + 1) != 46) {
#line 76
        tmp___4 = 1;
      } else {
#line 76
        tmp___4 = 2;
      }
#line 76
      tmp___5 = tmp___4;
    }
#line 76
    if ((int const   )*(entry + tmp___5) != 0) {
#line 78
      tmp___2 = strlen((char const   *)(dp->d_name));
#line 78
      entry_size = tmp___2 + 1UL;
#line 79
      if (used + entry_size < used) {
#line 80
        xalloc_die();
      }
#line 81
      if (allocated <= used + entry_size) {
#line 83
        while (1) {
#line 85
          if (2UL * allocated < allocated) {
#line 86
            xalloc_die();
          }
#line 87
          allocated *= 2UL;
#line 83
          if (! (allocated <= used + entry_size)) {
#line 83
            break;
          }
        }
#line 91
        tmp___3 = xrealloc((void *)name_space, allocated);
#line 91
        name_space = (char *)tmp___3;
      }
#line 93
      memcpy((void * __restrict  )(name_space + used), (void const   * __restrict  )entry,
             entry_size);
#line 94
      used += entry_size;
    }
  }
#line 97
  *(name_space + used) = (char )'\000';
#line 98
  tmp___6 = __errno_location();
#line 98
  save_errno = *tmp___6;
#line 99
  tmp___8 = closedir(dirp);
#line 99
  if (tmp___8 != 0) {
#line 100
    tmp___7 = __errno_location();
#line 100
    save_errno = *tmp___7;
  }
#line 101
  if (save_errno != 0) {
#line 103
    free((void *)name_space);
#line 104
    tmp___9 = __errno_location();
#line 104
    *tmp___9 = save_errno;
#line 105
    return ((char *)((void *)0));
  }
#line 107
  return (name_space);
}
}
#line 115 "/home/wslee/project/coreutils-8.1/lib/savedir.c"
char *savedir(char const   *dir ) 
{ 
  DIR *tmp ;
  char *tmp___0 ;

  {
#line 118
  tmp = opendir_safer(dir);
#line 118
  tmp___0 = savedirstream(tmp);
#line 118
  return (tmp___0);
}
}
#line 126 "/home/wslee/project/coreutils-8.1/lib/savedir.c"
char *fdsavedir(int fd ) 
{ 
  DIR *tmp ;
  char *tmp___0 ;

  {
#line 129
  tmp = rpl_fdopendir(fd);
#line 129
  tmp___0 = savedirstream(tmp);
#line 129
  return (tmp___0);
}
}
#line 1 "cil-OtbnHNpv.o"
#pragma merger("0","../lib/savewd.o.i","")
#line 70 "/home/wslee/project/coreutils-8.1/lib/savewd.h"
__inline static void savewd_init(struct savewd *wd ) 
{ 


  {
#line 73
  wd->state = (enum __anonenum_state_467303978 )0;
#line 74
  return;
}
}
#line 117
int savewd_restore(struct savewd *wd , int status ) ;
#line 128
void savewd_finish(struct savewd *wd ) ;
#line 144
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) ;
#line 759 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 139 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 40 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
static _Bool savewd_save(struct savewd *wd ) 
{ 
  int fd ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;

  {
#line 43
  switch ((unsigned int )wd->state) {
  case 0U: 
#line 48
  tmp = open_safer(".", 0);
#line 48
  fd = tmp;
#line 49
  if (0 <= fd) {
#line 51
    wd->state = (enum __anonenum_state_467303978 )1;
#line 52
    wd->val.fd = fd;
#line 53
    break;
  }
#line 55
  tmp___1 = __errno_location();
#line 55
  if (*tmp___1 != 13) {
#line 55
    tmp___2 = __errno_location();
#line 55
    if (*tmp___2 != 116) {
#line 57
      wd->state = (enum __anonenum_state_467303978 )4;
#line 58
      tmp___0 = __errno_location();
#line 58
      wd->val.errnum = *tmp___0;
#line 59
      break;
    }
  }
#line 62
  wd->state = (enum __anonenum_state_467303978 )3;
#line 63
  wd->val.child = -1;
  case 3U: 
#line 66
  if (wd->val.child < 0) {
#line 71
    wd->val.child = fork();
#line 72
    if (wd->val.child != 0) {
#line 74
      if (0 < wd->val.child) {
#line 75
        return ((_Bool)1);
      }
#line 76
      wd->state = (enum __anonenum_state_467303978 )4;
#line 77
      tmp___3 = __errno_location();
#line 77
      wd->val.errnum = *tmp___3;
    }
  }
#line 80
  break;
  case 5U: 
  case 4U: 
  case 2U: 
  case 1U: 
#line 86
  break;
  default: 
#line 89
  __assert_fail("false", "/home/wslee/project/coreutils-8.1/lib/savewd.c", 89U, "savewd_save");
  }
#line 92
  return ((_Bool)0);
}
}
#line 95 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
int savewd_chdir(struct savewd *wd , char const   *dir , int options , int *open_result ) 
{ 
  int fd ;
  int result ;
  int tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  int e ;
  int *tmp___5 ;
  int *tmp___6 ;

  {
#line 99
  fd = -1;
#line 100
  result = 0;
#line 104
  if (open_result) {
#line 104
    goto _L;
  } else
#line 104
  if (options & 1) {
    _L: /* CIL Label */ 
#line 107
    if (options & 1) {
#line 107
      tmp = 131072;
    } else {
#line 107
      tmp = 0;
    }
#line 107
    fd = open(dir, 67840 | tmp);
#line 111
    if (open_result) {
#line 113
      *(open_result + 0) = fd;
#line 114
      tmp___0 = __errno_location();
#line 114
      *(open_result + 1) = *tmp___0;
    }
#line 117
    if (fd < 0) {
#line 117
      tmp___1 = __errno_location();
#line 117
      if (*tmp___1 != 13) {
#line 118
        result = -1;
      } else
#line 117
      if (options & 2) {
#line 118
        result = -1;
      }
    }
  }
#line 121
  if (result == 0) {
#line 121
    if (0 <= fd) {
#line 121
      if (! (options & 4)) {
#line 121
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 123
      tmp___4 = savewd_save(wd);
#line 123
      if (tmp___4) {
#line 125
        open_result = (int *)((void *)0);
#line 126
        result = -2;
      } else {
#line 130
        if (fd < 0) {
#line 130
          tmp___2 = chdir(dir);
#line 130
          result = tmp___2;
        } else {
#line 130
          tmp___3 = fchdir(fd);
#line 130
          result = tmp___3;
        }
#line 132
        if (result == 0) {
#line 133
          switch ((unsigned int )wd->state) {
          case 1U: 
#line 136
          wd->state = (enum __anonenum_state_467303978 )2;
#line 137
          break;
          case 5U: 
          case 2U: 
          case 4U: 
#line 142
          break;
          case 3U: 
#line 145
          if (! (wd->val.child == 0)) {
#line 145
            __assert_fail("wd->val.child == 0", "/home/wslee/project/coreutils-8.1/lib/savewd.c",
                          145U, "savewd_chdir");
          }
#line 146
          break;
          default: 
#line 149
          __assert_fail("false", "/home/wslee/project/coreutils-8.1/lib/savewd.c",
                        149U, "savewd_chdir");
          }
        }
      }
    }
  }
#line 154
  if (0 <= fd) {
#line 154
    if (! open_result) {
#line 156
      tmp___5 = __errno_location();
#line 156
      e = *tmp___5;
#line 157
      close(fd);
#line 158
      tmp___6 = __errno_location();
#line 158
      *tmp___6 = e;
    }
  }
#line 161
  return (result);
}
}
#line 164 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
int savewd_restore(struct savewd *wd , int status ) 
{ 
  int chdir_errno ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  pid_t child ;
  int child_status ;
  int *tmp___2 ;
  __pid_t tmp___3 ;
  union __anonunion_875737058 __constr_expr_28 ;
  union __anonunion_875737059 __constr_expr_29 ;
  union __anonunion_875737060 __constr_expr_30 ;

  {
#line 167
  switch ((unsigned int )wd->state) {
  case 1U: 
  case 0U: 
#line 173
  break;
  case 2U: 
#line 177
  tmp___0 = fchdir(wd->val.fd);
#line 177
  if (tmp___0 == 0) {
#line 179
    wd->state = (enum __anonenum_state_467303978 )1;
#line 180
    break;
  } else {
#line 184
    tmp = __errno_location();
#line 184
    chdir_errno = *tmp;
#line 185
    close(wd->val.fd);
#line 186
    wd->state = (enum __anonenum_state_467303978 )4;
#line 187
    wd->val.errnum = chdir_errno;
  }
  case 4U: 
#line 192
  tmp___1 = __errno_location();
#line 192
  *tmp___1 = wd->val.errnum;
#line 193
  return (-1);
  case 3U: 
#line 199
  child = wd->val.child;
#line 200
  if (child == 0) {
#line 201
    _exit(status);
  }
#line 202
  if (0 < child) {
#line 205
    while (1) {
#line 205
      tmp___3 = waitpid(child, & child_status, 0);
#line 205
      if (! (tmp___3 < 0)) {
#line 205
        break;
      }
#line 206
      tmp___2 = __errno_location();
#line 206
      if (! (*tmp___2 == 4)) {
#line 206
        __assert_fail("errno == EINTR", "/home/wslee/project/coreutils-8.1/lib/savewd.c",
                      206U, "savewd_restore");
      }
    }
#line 207
    wd->val.child = -1;
#line 208
    __constr_expr_29.__in = child_status;
#line 208
    if (! ((__constr_expr_29.__i & 127) == 0)) {
#line 209
      __constr_expr_28.__in = child_status;
#line 209
      raise(__constr_expr_28.__i & 127);
    }
#line 210
    __constr_expr_30.__in = child_status;
#line 210
    return ((__constr_expr_30.__i & 65280) >> 8);
  }
#line 213
  break;
  default: 
#line 216
  __assert_fail("false", "/home/wslee/project/coreutils-8.1/lib/savewd.c", 216U, "savewd_restore");
  }
#line 219
  return (0);
}
}
#line 222 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
void savewd_finish(struct savewd *wd ) 
{ 


  {
#line 225
  switch ((unsigned int )wd->state) {
  case 4U: 
  case 0U: 
#line 229
  break;
  case 2U: 
  case 1U: 
#line 233
  close(wd->val.fd);
#line 234
  break;
  case 3U: 
#line 237
  if (! (wd->val.child < 0)) {
#line 237
    __assert_fail("wd->val.child < 0", "/home/wslee/project/coreutils-8.1/lib/savewd.c",
                  237U, "savewd_finish");
  }
#line 238
  break;
  default: 
#line 241
  __assert_fail("false", "/home/wslee/project/coreutils-8.1/lib/savewd.c", 241U, "savewd_finish");
  }
#line 244
  wd->state = (enum __anonenum_state_467303978 )5;
#line 245
  return;
}
}
#line 257 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
__inline static _Bool savewd_delegating(struct savewd  const  *wd ) 
{ 
  int tmp ;

  {
#line 260
  if ((unsigned int const   )wd->state == 3U) {
#line 260
    if (0 < (int )wd->val.child) {
#line 260
      tmp = 1;
    } else {
#line 260
      tmp = 0;
    }
  } else {
#line 260
    tmp = 0;
  }
#line 260
  return ((_Bool )tmp);
}
}
#line 263 "/home/wslee/project/coreutils-8.1/lib/savewd.c"
int savewd_process_files(int n_files , char **file , int (*act)(char * , struct savewd * ,
                                                                void * ) , void *options ) 
{ 
  int i ;
  int last_relative ;
  int exit_status ;
  struct savewd wd ;
  int s ;
  int tmp ;
  _Bool tmp___0 ;
  int r ;
  int tmp___1 ;
  int s___0 ;
  int tmp___2 ;

  {
#line 268
  i = 0;
#line 270
  exit_status = 0;
#line 272
  savewd_init(& wd);
#line 274
  last_relative = n_files - 1;
#line 274
  while (0 <= last_relative) {
#line 275
    if (! ((int )*(*(file + last_relative) + 0) == 47)) {
#line 276
      break;
    }
#line 274
    last_relative --;
  }
#line 278
  while (i < last_relative) {
#line 280
    tmp___0 = savewd_delegating((struct savewd  const  *)(& wd));
#line 280
    if (! tmp___0) {
#line 282
      tmp = (*act)(*(file + i), & wd, options);
#line 282
      s = tmp;
#line 283
      if (exit_status < s) {
#line 284
        exit_status = s;
      }
    }
#line 287
    if (! ((int )*(*(file + (i + 1)) + 0) == 47)) {
#line 289
      tmp___1 = savewd_restore(& wd, exit_status);
#line 289
      r = tmp___1;
#line 290
      if (exit_status < r) {
#line 291
        exit_status = r;
      }
    }
#line 278
    i ++;
  }
#line 295
  savewd_finish(& wd);
#line 297
  while (i < n_files) {
#line 299
    tmp___2 = (*act)(*(file + i), & wd, options);
#line 299
    s___0 = tmp___2;
#line 300
    if (exit_status < s___0) {
#line 301
      exit_status = s___0;
    }
#line 297
    i ++;
  }
#line 304
  return (exit_status);
}
}
#line 1 "cil-HxWs59O3.o"
#pragma merger("0","../lib/selinux-at.o.i","")
#line 35 "./selinux/selinux.h"
__inline static int getfilecon(char const   *file  __attribute__((__unused__)) , char **con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
#line 37
  tmp = __errno_location();
#line 37
  *tmp = 95;
#line 37
  return (-1);
}
}
#line 44 "./selinux/selinux.h"
__inline static int setfilecon(char const   *file  __attribute__((__unused__)) , char *con  __attribute__((__unused__)) ) 
{ 
  int *tmp ;

  {
#line 46
  tmp = __errno_location();
#line 46
  *tmp = 95;
#line 46
  return (-1);
}
}
#line 34 "/home/wslee/project/coreutils-8.1/lib/selinux-at.h"
int getfileconat(int fd , char const   *file , char **con ) ;
#line 39
int lgetfileconat(int fd , char const   *file , char **con ) ;
#line 45
int setfileconat(int fd , char const   *file , char *con ) ;
#line 52
int lsetfileconat(int fd , char const   *file , char *con ) ;
#line 61 "/home/wslee/project/coreutils-8.1/lib/at-func.c"
int getfileconat(int fd , char const   *file , char **con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[512] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = getfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = getfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 61 "/home/wslee/project/coreutils-8.1/lib/at-func.c"
int lgetfileconat(int fd , char const   *file , char **con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[512] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = getfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = getfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = getfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 61 "/home/wslee/project/coreutils-8.1/lib/at-func.c"
int setfileconat(int fd , char const   *file , char *con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[512] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = setfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = setfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 61 "/home/wslee/project/coreutils-8.1/lib/at-func.c"
int lsetfileconat(int fd , char const   *file , char *con ) 
{ 
  struct saved_cwd saved_cwd ;
  int saved_errno ;
  int err ;
  int tmp ;
  char proc_buf[512] ;
  char *proc_file ;
  char *tmp___0 ;
  int proc_result ;
  int tmp___1 ;
  int proc_errno ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;

  {
#line 72
  if (fd == -100) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  } else
#line 72
  if ((int const   )*(file + 0) == 47) {
#line 73
    tmp = setfilecon(file, con);
#line 73
    return (tmp);
  }
#line 77
  tmp___0 = openat_proc_name((char *)(proc_buf), fd, file);
#line 77
  proc_file = tmp___0;
#line 78
  if (proc_file) {
#line 80
    tmp___1 = setfilecon((char const   *)proc_file, con);
#line 80
    proc_result = tmp___1;
#line 81
    tmp___2 = __errno_location();
#line 81
    proc_errno = *tmp___2;
#line 82
    if ((unsigned long )proc_file != (unsigned long )(proc_buf)) {
#line 83
      free((void *)proc_file);
    }
#line 87
    if (-1 != proc_result) {
#line 88
      return (proc_result);
    }
#line 89
    if (! (proc_errno == 20)) {
#line 89
      if (! (proc_errno == 2)) {
#line 89
        if (! (proc_errno == 1)) {
#line 89
          if (! (proc_errno == 13)) {
#line 89
            if (! (proc_errno == 38)) {
#line 89
              if (! (proc_errno == 95)) {
#line 91
                tmp___3 = __errno_location();
#line 91
                *tmp___3 = proc_errno;
#line 92
                return (proc_result);
              }
            }
          }
        }
      }
    }
  }
#line 97
  tmp___5 = save_cwd(& saved_cwd);
#line 97
  if (tmp___5 != 0) {
#line 98
    tmp___4 = __errno_location();
#line 98
    openat_save_fail(*tmp___4);
  }
#line 99
  if (0 <= fd) {
#line 99
    if (fd == saved_cwd.desc) {
#line 104
      free_cwd(& saved_cwd);
#line 105
      tmp___6 = __errno_location();
#line 105
      *tmp___6 = 9;
#line 106
      return (-1);
    }
  }
#line 109
  tmp___9 = fchdir(fd);
#line 109
  if (tmp___9 != 0) {
#line 111
    tmp___7 = __errno_location();
#line 111
    saved_errno = *tmp___7;
#line 112
    free_cwd(& saved_cwd);
#line 113
    tmp___8 = __errno_location();
#line 113
    *tmp___8 = saved_errno;
#line 114
    return (-1);
  }
#line 117
  err = setfilecon(file, con);
#line 118
  if (err == -1) {
#line 118
    tmp___10 = __errno_location();
#line 118
    saved_errno = *tmp___10;
  } else {
#line 118
    saved_errno = 0;
  }
#line 120
  tmp___12 = restore_cwd((struct saved_cwd  const  *)(& saved_cwd));
#line 120
  if (tmp___12 != 0) {
#line 121
    tmp___11 = __errno_location();
#line 121
    openat_restore_fail(*tmp___11);
  }
#line 123
  free_cwd(& saved_cwd);
#line 125
  if (saved_errno) {
#line 126
    tmp___13 = __errno_location();
#line 126
    *tmp___13 = saved_errno;
  }
#line 127
  return (err);
}
}
#line 1 "cil-5WlcV4DQ.o"
#pragma merger("0","../lib/set-mode-acl.o.i","")
#line 25 "/home/wslee/project/coreutils-8.1/lib/acl.h"
int set_acl(char const   *name , int desc , mode_t mode ) ;
#line 27
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) ;
#line 36 "/home/wslee/project/coreutils-8.1/lib/set-mode-acl.c"
int chmod_or_fchmod(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 39
  if (desc != -1) {
#line 40
    tmp = fchmod(desc, mode);
#line 40
    return (tmp);
  } else {
#line 42
    tmp___0 = chmod(name, mode);
#line 42
    return (tmp___0);
  }
}
}
#line 53 "/home/wslee/project/coreutils-8.1/lib/set-mode-acl.c"
int qset_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int tmp ;

  {
#line 580
  tmp = chmod_or_fchmod(name, desc, mode);
#line 580
  return (tmp);
}
}
#line 586 "/home/wslee/project/coreutils-8.1/lib/set-mode-acl.c"
int set_acl(char const   *name , int desc , mode_t mode ) 
{ 
  int r ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 589
  tmp = qset_acl(name, desc, mode);
#line 589
  r = tmp;
#line 590
  if (r != 0) {
#line 591
    tmp___0 = quote(name);
#line 591
    tmp___1 = gettext("setting permissions for %s");
#line 591
    tmp___2 = __errno_location();
#line 591
    error(0, *tmp___2, (char const   *)tmp___1, tmp___0);
  }
#line 592
  return (r);
}
}
#line 1 "cil-0g8LUZfe.o"
#pragma merger("0","../lib/settime.o.i","")
#line 345 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) clock_settime)(clockid_t __clock_id ,
                                                                                    struct timespec  const  *__tp ) ;
#line 36 "/home/wslee/project/coreutils-8.1/lib/timespec.h"
int settime(struct timespec  const  *ts ) ;
#line 77 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) settimeofday)(struct timeval  const  *__tv ,
                                                                                   struct timezone  const  *__tz ) ;
#line 32 "/home/wslee/project/coreutils-8.1/lib/settime.c"
int settime(struct timespec  const  *ts ) 
{ 
  int r ;
  int tmp ;
  int *tmp___0 ;
  struct timeval tv ;
  int tmp___1 ;

  {
#line 37
  tmp = clock_settime(0, ts);
#line 37
  r = tmp;
#line 38
  if (r == 0) {
#line 39
    return (r);
  } else {
#line 38
    tmp___0 = __errno_location();
#line 38
    if (*tmp___0 == 1) {
#line 39
      return (r);
    }
  }
#line 47
  tv.tv_sec = (__time_t )ts->tv_sec;
#line 48
  tv.tv_usec = (__suseconds_t )(ts->tv_nsec / 1000L);
#line 49
  tmp___1 = settimeofday((struct timeval  const  *)(& tv), (struct timezone  const  *)0);
#line 49
  return (tmp___1);
}
}
#line 1 "cil-rjMZDMvw.o"
#pragma merger("0","../lib/sha1.o.i","")
#line 48 "/home/wslee/project/coreutils-8.1/lib/sha1.h"
void sha1_init_ctx(struct sha1_ctx *ctx ) ;
#line 54
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 61
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) ;
#line 68
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) ;
#line 74
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) ;
#line 80
int sha1_stream(FILE *stream , void *resblock ) ;
#line 86
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 52 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
static unsigned char const   fillbuf___0[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 58 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
void sha1_init_ctx(struct sha1_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 61
  ctx->A = (uint32_t )1732584193;
#line 62
  ctx->B = 4023233417U;
#line 63
  ctx->C = 2562383102U;
#line 64
  ctx->D = (uint32_t )271733878;
#line 65
  ctx->E = 3285377520U;
#line 67
  tmp = (uint32_t )0;
#line 67
  ctx->total[1] = tmp;
#line 67
  ctx->total[0] = tmp;
#line 68
  ctx->buflen = (uint32_t )0;
#line 69
  return;
}
}
#line 82 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
void *sha1_read_ctx(struct sha1_ctx  const  *ctx , void *resbuf ) 
{ 
  char *r ;

  {
#line 85
  r = (char *)resbuf;
#line 86
  set_uint32(r + 0UL, (uint32_t )((((ctx->A << 24) | ((ctx->A & 65280U) << 8)) | ((ctx->A >> 8) & 65280U)) | (ctx->A >> 24)));
#line 87
  set_uint32(r + sizeof(ctx->B), (uint32_t )((((ctx->B << 24) | ((ctx->B & 65280U) << 8)) | ((ctx->B >> 8) & 65280U)) | (ctx->B >> 24)));
#line 88
  set_uint32(r + 2UL * sizeof(ctx->C), (uint32_t )((((ctx->C << 24) | ((ctx->C & 65280U) << 8)) | ((ctx->C >> 8) & 65280U)) | (ctx->C >> 24)));
#line 89
  set_uint32(r + 3UL * sizeof(ctx->D), (uint32_t )((((ctx->D << 24) | ((ctx->D & 65280U) << 8)) | ((ctx->D >> 8) & 65280U)) | (ctx->D >> 24)));
#line 90
  set_uint32(r + 4UL * sizeof(ctx->E), (uint32_t )((((ctx->E << 24) | ((ctx->E & 65280U) << 8)) | ((ctx->E >> 8) & 65280U)) | (ctx->E >> 24)));
#line 92
  return (resbuf);
}
}
#line 97 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
void *sha1_finish_ctx(struct sha1_ctx *ctx , void *resbuf ) 
{ 
  uint32_t bytes ;
  size_t size ;
  int tmp ;
  void *tmp___0 ;

  {
#line 101
  bytes = ctx->buflen;
#line 102
  if (bytes < 56U) {
#line 102
    tmp = 16;
  } else {
#line 102
    tmp = 32;
  }
#line 102
  size = (size_t )tmp;
#line 105
  ctx->total[0] += bytes;
#line 106
  if (ctx->total[0] < bytes) {
#line 107
    (ctx->total[1]) ++;
  }
#line 110
  ctx->buffer[size - 2UL] = (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24);
#line 111
  ctx->buffer[size - 1UL] = ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24);
#line 113
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___0),
         (size - 2UL) * 4UL - (size_t )bytes);
#line 116
  sha1_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 118
  tmp___0 = sha1_read_ctx((struct sha1_ctx  const  *)ctx, resbuf);
#line 118
  return (tmp___0);
}
}
#line 124 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
int sha1_stream(FILE *stream , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 130
  tmp = malloc((size_t )32840);
#line 130
  buffer = (char *)tmp;
#line 131
  if (! buffer) {
#line 132
    return (1);
  }
#line 135
  sha1_init_ctx(& ctx);
#line 138
  while (1) {
#line 144
    sum = (size_t )0;
#line 147
    while (1) {
#line 149
      n = fread_unlocked((void * __restrict  )(buffer + sum), (size_t )1, 32768UL - sum,
                         (FILE * __restrict  )stream);
#line 151
      sum += n;
#line 153
      if (sum == 32768UL) {
#line 154
        break;
      }
#line 156
      if (n == 0UL) {
#line 161
        tmp___0 = ferror_unlocked(stream);
#line 161
        if (tmp___0) {
#line 163
          free((void *)buffer);
#line 164
          return (1);
        }
#line 166
        goto process_partial_block;
      }
#line 172
      tmp___1 = feof_unlocked(stream);
#line 172
      if (tmp___1) {
#line 173
        goto process_partial_block;
      }
    }
#line 179
    sha1_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 185
  if (sum > 0UL) {
#line 186
    sha1_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 189
  sha1_finish_ctx(& ctx, resblock);
#line 190
  free((void *)buffer);
#line 191
  return (0);
}
}
#line 198 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
void *sha1_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha1_ctx ctx ;
  void *tmp ;

  {
#line 204
  sha1_init_ctx(& ctx);
#line 207
  sha1_process_bytes((void const   *)buffer, len, & ctx);
#line 210
  tmp = sha1_finish_ctx(& ctx, resblock);
#line 210
  return (tmp);
}
}
#line 213 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
void sha1_process_bytes(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 218
  if (ctx->buflen != 0U) {
#line 220
    left_over = (size_t )ctx->buflen;
#line 221
    if (128UL - left_over > len) {
#line 221
      tmp = len;
    } else {
#line 221
      tmp = 128UL - left_over;
    }
#line 221
    add = tmp;
#line 223
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 224
    ctx->buflen = (uint32_t )((size_t )ctx->buflen + add);
#line 226
    if (ctx->buflen > 64U) {
#line 228
      sha1_process_block((void const   *)(ctx->buffer), (size_t )(ctx->buflen & 4294967232U),
                         ctx);
#line 230
      ctx->buflen &= 63U;
#line 232
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             (size_t )ctx->buflen);
    }
#line 237
    buffer = (void const   *)((char const   *)buffer + add);
#line 238
    len -= add;
  }
#line 242
  if (len >= 64UL) {
#line 247
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_833865290___1 *)0)->x) != 0UL) {
#line 248
      while (len > 64UL) {
#line 250
        tmp___0 = memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )buffer,
                         (size_t )64);
#line 250
        sha1_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 251
        buffer = (void const   *)((char const   *)buffer + 64);
#line 252
        len -= 64UL;
      }
    } else {
#line 257
      sha1_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 258
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 259
      len &= 63UL;
    }
  }
#line 264
  if (len > 0UL) {
#line 266
    left_over___0 = (size_t )ctx->buflen;
#line 268
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 269
    left_over___0 += len;
#line 270
    if (left_over___0 >= 64UL) {
#line 272
      sha1_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 273
      left_over___0 -= 64UL;
#line 274
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 276
    ctx->buflen = (uint32_t )left_over___0;
  }
#line 278
  return;
}
}
#line 298 "/home/wslee/project/coreutils-8.1/lib/sha1.c"
void sha1_process_block(void const   *buffer , size_t len , struct sha1_ctx *ctx ) 
{ 
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t tm ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;

  {
#line 301
  words = (uint32_t const   *)buffer;
#line 302
  nwords = len / sizeof(uint32_t );
#line 303
  endp = words + nwords;
#line 305
  a = ctx->A;
#line 306
  b = ctx->B;
#line 307
  c = ctx->C;
#line 308
  d = ctx->D;
#line 309
  e = ctx->E;
#line 314
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 315
  if ((size_t )ctx->total[0] < len) {
#line 316
    (ctx->total[1]) ++;
  }
#line 331
  while ((unsigned long )words < (unsigned long )endp) {
#line 335
    t = 0;
#line 335
    while (t < 16) {
#line 337
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 338
      words ++;
#line 335
      t ++;
    }
#line 341
    while (1) {
#line 341
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[0];
#line 341
      b = (b << 30) | (b >> 2);
#line 341
      break;
    }
#line 342
    while (1) {
#line 342
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[1];
#line 342
      a = (a << 30) | (a >> 2);
#line 342
      break;
    }
#line 343
    while (1) {
#line 343
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[2];
#line 343
      e = (e << 30) | (e >> 2);
#line 343
      break;
    }
#line 344
    while (1) {
#line 344
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[3];
#line 344
      d = (d << 30) | (d >> 2);
#line 344
      break;
    }
#line 345
    while (1) {
#line 345
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[4];
#line 345
      c = (c << 30) | (c >> 2);
#line 345
      break;
    }
#line 346
    while (1) {
#line 346
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[5];
#line 346
      b = (b << 30) | (b >> 2);
#line 346
      break;
    }
#line 347
    while (1) {
#line 347
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[6];
#line 347
      a = (a << 30) | (a >> 2);
#line 347
      break;
    }
#line 348
    while (1) {
#line 348
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[7];
#line 348
      e = (e << 30) | (e >> 2);
#line 348
      break;
    }
#line 349
    while (1) {
#line 349
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[8];
#line 349
      d = (d << 30) | (d >> 2);
#line 349
      break;
    }
#line 350
    while (1) {
#line 350
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[9];
#line 350
      c = (c << 30) | (c >> 2);
#line 350
      break;
    }
#line 351
    while (1) {
#line 351
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[10];
#line 351
      b = (b << 30) | (b >> 2);
#line 351
      break;
    }
#line 352
    while (1) {
#line 352
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[11];
#line 352
      a = (a << 30) | (a >> 2);
#line 352
      break;
    }
#line 353
    while (1) {
#line 353
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[12];
#line 353
      e = (e << 30) | (e >> 2);
#line 353
      break;
    }
#line 354
    while (1) {
#line 354
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[13];
#line 354
      d = (d << 30) | (d >> 2);
#line 354
      break;
    }
#line 355
    while (1) {
#line 355
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[14];
#line 355
      c = (c << 30) | (c >> 2);
#line 355
      break;
    }
#line 356
    while (1) {
#line 356
      e += ((((a << 5) | (a >> 27)) + (d ^ (b & (c ^ d)))) + 1518500249U) + x[15];
#line 356
      b = (b << 30) | (b >> 2);
#line 356
      break;
    }
#line 357
    while (1) {
#line 357
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 357
      x[0] = (tm << 1) | (tm >> 31);
#line 357
      d += ((((e << 5) | (e >> 27)) + (c ^ (a & (b ^ c)))) + 1518500249U) + x[0];
#line 357
      a = (a << 30) | (a >> 2);
#line 357
      break;
    }
#line 358
    while (1) {
#line 358
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 358
      x[1] = (tm << 1) | (tm >> 31);
#line 358
      c += ((((d << 5) | (d >> 27)) + (b ^ (e & (a ^ b)))) + 1518500249U) + x[1];
#line 358
      e = (e << 30) | (e >> 2);
#line 358
      break;
    }
#line 359
    while (1) {
#line 359
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 359
      x[2] = (tm << 1) | (tm >> 31);
#line 359
      b += ((((c << 5) | (c >> 27)) + (a ^ (d & (e ^ a)))) + 1518500249U) + x[2];
#line 359
      d = (d << 30) | (d >> 2);
#line 359
      break;
    }
#line 360
    while (1) {
#line 360
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 360
      x[3] = (tm << 1) | (tm >> 31);
#line 360
      a += ((((b << 5) | (b >> 27)) + (e ^ (c & (d ^ e)))) + 1518500249U) + x[3];
#line 360
      c = (c << 30) | (c >> 2);
#line 360
      break;
    }
#line 361
    while (1) {
#line 361
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 361
      x[4] = (tm << 1) | (tm >> 31);
#line 361
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[4];
#line 361
      b = (b << 30) | (b >> 2);
#line 361
      break;
    }
#line 362
    while (1) {
#line 362
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 362
      x[5] = (tm << 1) | (tm >> 31);
#line 362
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[5];
#line 362
      a = (a << 30) | (a >> 2);
#line 362
      break;
    }
#line 363
    while (1) {
#line 363
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 363
      x[6] = (tm << 1) | (tm >> 31);
#line 363
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[6];
#line 363
      e = (e << 30) | (e >> 2);
#line 363
      break;
    }
#line 364
    while (1) {
#line 364
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 364
      x[7] = (tm << 1) | (tm >> 31);
#line 364
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[7];
#line 364
      d = (d << 30) | (d >> 2);
#line 364
      break;
    }
#line 365
    while (1) {
#line 365
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 365
      x[8] = (tm << 1) | (tm >> 31);
#line 365
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[8];
#line 365
      c = (c << 30) | (c >> 2);
#line 365
      break;
    }
#line 366
    while (1) {
#line 366
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 366
      x[9] = (tm << 1) | (tm >> 31);
#line 366
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[9];
#line 366
      b = (b << 30) | (b >> 2);
#line 366
      break;
    }
#line 367
    while (1) {
#line 367
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 367
      x[10] = (tm << 1) | (tm >> 31);
#line 367
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[10];
#line 367
      a = (a << 30) | (a >> 2);
#line 367
      break;
    }
#line 368
    while (1) {
#line 368
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 368
      x[11] = (tm << 1) | (tm >> 31);
#line 368
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[11];
#line 368
      e = (e << 30) | (e >> 2);
#line 368
      break;
    }
#line 369
    while (1) {
#line 369
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 369
      x[12] = (tm << 1) | (tm >> 31);
#line 369
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[12];
#line 369
      d = (d << 30) | (d >> 2);
#line 369
      break;
    }
#line 370
    while (1) {
#line 370
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 370
      x[13] = (tm << 1) | (tm >> 31);
#line 370
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[13];
#line 370
      c = (c << 30) | (c >> 2);
#line 370
      break;
    }
#line 371
    while (1) {
#line 371
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 371
      x[14] = (tm << 1) | (tm >> 31);
#line 371
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[14];
#line 371
      b = (b << 30) | (b >> 2);
#line 371
      break;
    }
#line 372
    while (1) {
#line 372
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 372
      x[15] = (tm << 1) | (tm >> 31);
#line 372
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[15];
#line 372
      a = (a << 30) | (a >> 2);
#line 372
      break;
    }
#line 373
    while (1) {
#line 373
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 373
      x[0] = (tm << 1) | (tm >> 31);
#line 373
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[0];
#line 373
      e = (e << 30) | (e >> 2);
#line 373
      break;
    }
#line 374
    while (1) {
#line 374
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 374
      x[1] = (tm << 1) | (tm >> 31);
#line 374
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[1];
#line 374
      d = (d << 30) | (d >> 2);
#line 374
      break;
    }
#line 375
    while (1) {
#line 375
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 375
      x[2] = (tm << 1) | (tm >> 31);
#line 375
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[2];
#line 375
      c = (c << 30) | (c >> 2);
#line 375
      break;
    }
#line 376
    while (1) {
#line 376
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 376
      x[3] = (tm << 1) | (tm >> 31);
#line 376
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 1859775393U) + x[3];
#line 376
      b = (b << 30) | (b >> 2);
#line 376
      break;
    }
#line 377
    while (1) {
#line 377
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 377
      x[4] = (tm << 1) | (tm >> 31);
#line 377
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 1859775393U) + x[4];
#line 377
      a = (a << 30) | (a >> 2);
#line 377
      break;
    }
#line 378
    while (1) {
#line 378
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 378
      x[5] = (tm << 1) | (tm >> 31);
#line 378
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 1859775393U) + x[5];
#line 378
      e = (e << 30) | (e >> 2);
#line 378
      break;
    }
#line 379
    while (1) {
#line 379
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 379
      x[6] = (tm << 1) | (tm >> 31);
#line 379
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 1859775393U) + x[6];
#line 379
      d = (d << 30) | (d >> 2);
#line 379
      break;
    }
#line 380
    while (1) {
#line 380
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 380
      x[7] = (tm << 1) | (tm >> 31);
#line 380
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 1859775393U) + x[7];
#line 380
      c = (c << 30) | (c >> 2);
#line 380
      break;
    }
#line 381
    while (1) {
#line 381
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 381
      x[8] = (tm << 1) | (tm >> 31);
#line 381
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[8];
#line 381
      b = (b << 30) | (b >> 2);
#line 381
      break;
    }
#line 382
    while (1) {
#line 382
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 382
      x[9] = (tm << 1) | (tm >> 31);
#line 382
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[9];
#line 382
      a = (a << 30) | (a >> 2);
#line 382
      break;
    }
#line 383
    while (1) {
#line 383
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 383
      x[10] = (tm << 1) | (tm >> 31);
#line 383
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[10];
#line 383
      e = (e << 30) | (e >> 2);
#line 383
      break;
    }
#line 384
    while (1) {
#line 384
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 384
      x[11] = (tm << 1) | (tm >> 31);
#line 384
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[11];
#line 384
      d = (d << 30) | (d >> 2);
#line 384
      break;
    }
#line 385
    while (1) {
#line 385
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 385
      x[12] = (tm << 1) | (tm >> 31);
#line 385
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[12];
#line 385
      c = (c << 30) | (c >> 2);
#line 385
      break;
    }
#line 386
    while (1) {
#line 386
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 386
      x[13] = (tm << 1) | (tm >> 31);
#line 386
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[13];
#line 386
      b = (b << 30) | (b >> 2);
#line 386
      break;
    }
#line 387
    while (1) {
#line 387
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 387
      x[14] = (tm << 1) | (tm >> 31);
#line 387
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[14];
#line 387
      a = (a << 30) | (a >> 2);
#line 387
      break;
    }
#line 388
    while (1) {
#line 388
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 388
      x[15] = (tm << 1) | (tm >> 31);
#line 388
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[15];
#line 388
      e = (e << 30) | (e >> 2);
#line 388
      break;
    }
#line 389
    while (1) {
#line 389
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 389
      x[0] = (tm << 1) | (tm >> 31);
#line 389
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[0];
#line 389
      d = (d << 30) | (d >> 2);
#line 389
      break;
    }
#line 390
    while (1) {
#line 390
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 390
      x[1] = (tm << 1) | (tm >> 31);
#line 390
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[1];
#line 390
      c = (c << 30) | (c >> 2);
#line 390
      break;
    }
#line 391
    while (1) {
#line 391
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 391
      x[2] = (tm << 1) | (tm >> 31);
#line 391
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[2];
#line 391
      b = (b << 30) | (b >> 2);
#line 391
      break;
    }
#line 392
    while (1) {
#line 392
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 392
      x[3] = (tm << 1) | (tm >> 31);
#line 392
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[3];
#line 392
      a = (a << 30) | (a >> 2);
#line 392
      break;
    }
#line 393
    while (1) {
#line 393
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 393
      x[4] = (tm << 1) | (tm >> 31);
#line 393
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[4];
#line 393
      e = (e << 30) | (e >> 2);
#line 393
      break;
    }
#line 394
    while (1) {
#line 394
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 394
      x[5] = (tm << 1) | (tm >> 31);
#line 394
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[5];
#line 394
      d = (d << 30) | (d >> 2);
#line 394
      break;
    }
#line 395
    while (1) {
#line 395
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 395
      x[6] = (tm << 1) | (tm >> 31);
#line 395
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[6];
#line 395
      c = (c << 30) | (c >> 2);
#line 395
      break;
    }
#line 396
    while (1) {
#line 396
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 396
      x[7] = (tm << 1) | (tm >> 31);
#line 396
      e += ((((a << 5) | (a >> 27)) + ((b & c) | (d & (b | c)))) + 2400959708U) + x[7];
#line 396
      b = (b << 30) | (b >> 2);
#line 396
      break;
    }
#line 397
    while (1) {
#line 397
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 397
      x[8] = (tm << 1) | (tm >> 31);
#line 397
      d += ((((e << 5) | (e >> 27)) + ((a & b) | (c & (a | b)))) + 2400959708U) + x[8];
#line 397
      a = (a << 30) | (a >> 2);
#line 397
      break;
    }
#line 398
    while (1) {
#line 398
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 398
      x[9] = (tm << 1) | (tm >> 31);
#line 398
      c += ((((d << 5) | (d >> 27)) + ((e & a) | (b & (e | a)))) + 2400959708U) + x[9];
#line 398
      e = (e << 30) | (e >> 2);
#line 398
      break;
    }
#line 399
    while (1) {
#line 399
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 399
      x[10] = (tm << 1) | (tm >> 31);
#line 399
      b += ((((c << 5) | (c >> 27)) + ((d & e) | (a & (d | e)))) + 2400959708U) + x[10];
#line 399
      d = (d << 30) | (d >> 2);
#line 399
      break;
    }
#line 400
    while (1) {
#line 400
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 400
      x[11] = (tm << 1) | (tm >> 31);
#line 400
      a += ((((b << 5) | (b >> 27)) + ((c & d) | (e & (c | d)))) + 2400959708U) + x[11];
#line 400
      c = (c << 30) | (c >> 2);
#line 400
      break;
    }
#line 401
    while (1) {
#line 401
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 401
      x[12] = (tm << 1) | (tm >> 31);
#line 401
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[12];
#line 401
      b = (b << 30) | (b >> 2);
#line 401
      break;
    }
#line 402
    while (1) {
#line 402
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 402
      x[13] = (tm << 1) | (tm >> 31);
#line 402
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[13];
#line 402
      a = (a << 30) | (a >> 2);
#line 402
      break;
    }
#line 403
    while (1) {
#line 403
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 403
      x[14] = (tm << 1) | (tm >> 31);
#line 403
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[14];
#line 403
      e = (e << 30) | (e >> 2);
#line 403
      break;
    }
#line 404
    while (1) {
#line 404
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 404
      x[15] = (tm << 1) | (tm >> 31);
#line 404
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[15];
#line 404
      d = (d << 30) | (d >> 2);
#line 404
      break;
    }
#line 405
    while (1) {
#line 405
      tm = ((x[0] ^ x[2]) ^ x[8]) ^ x[13];
#line 405
      x[0] = (tm << 1) | (tm >> 31);
#line 405
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[0];
#line 405
      c = (c << 30) | (c >> 2);
#line 405
      break;
    }
#line 406
    while (1) {
#line 406
      tm = ((x[1] ^ x[3]) ^ x[9]) ^ x[14];
#line 406
      x[1] = (tm << 1) | (tm >> 31);
#line 406
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[1];
#line 406
      b = (b << 30) | (b >> 2);
#line 406
      break;
    }
#line 407
    while (1) {
#line 407
      tm = ((x[2] ^ x[4]) ^ x[10]) ^ x[15];
#line 407
      x[2] = (tm << 1) | (tm >> 31);
#line 407
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[2];
#line 407
      a = (a << 30) | (a >> 2);
#line 407
      break;
    }
#line 408
    while (1) {
#line 408
      tm = ((x[3] ^ x[5]) ^ x[11]) ^ x[0];
#line 408
      x[3] = (tm << 1) | (tm >> 31);
#line 408
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[3];
#line 408
      e = (e << 30) | (e >> 2);
#line 408
      break;
    }
#line 409
    while (1) {
#line 409
      tm = ((x[4] ^ x[6]) ^ x[12]) ^ x[1];
#line 409
      x[4] = (tm << 1) | (tm >> 31);
#line 409
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[4];
#line 409
      d = (d << 30) | (d >> 2);
#line 409
      break;
    }
#line 410
    while (1) {
#line 410
      tm = ((x[5] ^ x[7]) ^ x[13]) ^ x[2];
#line 410
      x[5] = (tm << 1) | (tm >> 31);
#line 410
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[5];
#line 410
      c = (c << 30) | (c >> 2);
#line 410
      break;
    }
#line 411
    while (1) {
#line 411
      tm = ((x[6] ^ x[8]) ^ x[14]) ^ x[3];
#line 411
      x[6] = (tm << 1) | (tm >> 31);
#line 411
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[6];
#line 411
      b = (b << 30) | (b >> 2);
#line 411
      break;
    }
#line 412
    while (1) {
#line 412
      tm = ((x[7] ^ x[9]) ^ x[15]) ^ x[4];
#line 412
      x[7] = (tm << 1) | (tm >> 31);
#line 412
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[7];
#line 412
      a = (a << 30) | (a >> 2);
#line 412
      break;
    }
#line 413
    while (1) {
#line 413
      tm = ((x[8] ^ x[10]) ^ x[0]) ^ x[5];
#line 413
      x[8] = (tm << 1) | (tm >> 31);
#line 413
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[8];
#line 413
      e = (e << 30) | (e >> 2);
#line 413
      break;
    }
#line 414
    while (1) {
#line 414
      tm = ((x[9] ^ x[11]) ^ x[1]) ^ x[6];
#line 414
      x[9] = (tm << 1) | (tm >> 31);
#line 414
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[9];
#line 414
      d = (d << 30) | (d >> 2);
#line 414
      break;
    }
#line 415
    while (1) {
#line 415
      tm = ((x[10] ^ x[12]) ^ x[2]) ^ x[7];
#line 415
      x[10] = (tm << 1) | (tm >> 31);
#line 415
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[10];
#line 415
      c = (c << 30) | (c >> 2);
#line 415
      break;
    }
#line 416
    while (1) {
#line 416
      tm = ((x[11] ^ x[13]) ^ x[3]) ^ x[8];
#line 416
      x[11] = (tm << 1) | (tm >> 31);
#line 416
      e += ((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + 3395469782U) + x[11];
#line 416
      b = (b << 30) | (b >> 2);
#line 416
      break;
    }
#line 417
    while (1) {
#line 417
      tm = ((x[12] ^ x[14]) ^ x[4]) ^ x[9];
#line 417
      x[12] = (tm << 1) | (tm >> 31);
#line 417
      d += ((((e << 5) | (e >> 27)) + ((a ^ b) ^ c)) + 3395469782U) + x[12];
#line 417
      a = (a << 30) | (a >> 2);
#line 417
      break;
    }
#line 418
    while (1) {
#line 418
      tm = ((x[13] ^ x[15]) ^ x[5]) ^ x[10];
#line 418
      x[13] = (tm << 1) | (tm >> 31);
#line 418
      c += ((((d << 5) | (d >> 27)) + ((e ^ a) ^ b)) + 3395469782U) + x[13];
#line 418
      e = (e << 30) | (e >> 2);
#line 418
      break;
    }
#line 419
    while (1) {
#line 419
      tm = ((x[14] ^ x[0]) ^ x[6]) ^ x[11];
#line 419
      x[14] = (tm << 1) | (tm >> 31);
#line 419
      b += ((((c << 5) | (c >> 27)) + ((d ^ e) ^ a)) + 3395469782U) + x[14];
#line 419
      d = (d << 30) | (d >> 2);
#line 419
      break;
    }
#line 420
    while (1) {
#line 420
      tm = ((x[15] ^ x[1]) ^ x[7]) ^ x[12];
#line 420
      x[15] = (tm << 1) | (tm >> 31);
#line 420
      a += ((((b << 5) | (b >> 27)) + ((c ^ d) ^ e)) + 3395469782U) + x[15];
#line 420
      c = (c << 30) | (c >> 2);
#line 420
      break;
    }
#line 422
    tmp = ctx->A + a;
#line 422
    ctx->A = tmp;
#line 422
    a = tmp;
#line 423
    tmp___0 = ctx->B + b;
#line 423
    ctx->B = tmp___0;
#line 423
    b = tmp___0;
#line 424
    tmp___1 = ctx->C + c;
#line 424
    ctx->C = tmp___1;
#line 424
    c = tmp___1;
#line 425
    tmp___2 = ctx->D + d;
#line 425
    ctx->D = tmp___2;
#line 425
    d = tmp___2;
#line 426
    tmp___3 = ctx->E + e;
#line 426
    ctx->E = tmp___3;
#line 426
    e = tmp___3;
  }
#line 428
  return;
}
}
#line 1 "cil-_0hCt9eP.o"
#pragma merger("0","../lib/sha256.o.i","")
#line 42 "/home/wslee/project/coreutils-8.1/lib/sha256.h"
void sha256_init_ctx(struct sha256_ctx *ctx ) ;
#line 43
void sha224_init_ctx(struct sha256_ctx *ctx ) ;
#line 49
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 56
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) ;
#line 63
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 64
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) ;
#line 70
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 71
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) ;
#line 77
int sha256_stream(FILE *stream , void *resblock ) ;
#line 78
int sha224_stream(FILE *stream , void *resblock ) ;
#line 84
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 85
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 49 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
static unsigned char const   fillbuf___1[64]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 57 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void sha256_init_ctx(struct sha256_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 60
  ctx->state[0] = (uint32_t )1779033703UL;
#line 61
  ctx->state[1] = (uint32_t )3144134277UL;
#line 62
  ctx->state[2] = (uint32_t )1013904242UL;
#line 63
  ctx->state[3] = (uint32_t )2773480762UL;
#line 64
  ctx->state[4] = (uint32_t )1359893119UL;
#line 65
  ctx->state[5] = (uint32_t )2600822924UL;
#line 66
  ctx->state[6] = (uint32_t )528734635UL;
#line 67
  ctx->state[7] = (uint32_t )1541459225UL;
#line 69
  tmp = (uint32_t )0;
#line 69
  ctx->total[1] = tmp;
#line 69
  ctx->total[0] = tmp;
#line 70
  ctx->buflen = (size_t )0;
#line 71
  return;
}
}
#line 73 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void sha224_init_ctx(struct sha256_ctx *ctx ) 
{ 
  uint32_t tmp ;

  {
#line 76
  ctx->state[0] = (uint32_t )3238371032UL;
#line 77
  ctx->state[1] = (uint32_t )914150663UL;
#line 78
  ctx->state[2] = (uint32_t )812702999UL;
#line 79
  ctx->state[3] = (uint32_t )4144912697UL;
#line 80
  ctx->state[4] = (uint32_t )4290775857UL;
#line 81
  ctx->state[5] = (uint32_t )1750603025UL;
#line 82
  ctx->state[6] = (uint32_t )1694076839UL;
#line 83
  ctx->state[7] = (uint32_t )3204075428UL;
#line 85
  tmp = (uint32_t )0;
#line 85
  ctx->total[1] = tmp;
#line 85
  ctx->total[0] = tmp;
#line 86
  ctx->buflen = (size_t )0;
#line 87
  return;
}
}
#line 100 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void *sha256_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 104
  r = (char *)resbuf;
#line 106
  i = 0;
#line 106
  while (i < 8) {
#line 107
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
#line 106
    i ++;
  }
#line 109
  return (resbuf);
}
}
#line 112 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void *sha224_read_ctx(struct sha256_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 116
  r = (char *)resbuf;
#line 118
  i = 0;
#line 118
  while (i < 7) {
#line 119
    set_uint32(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 24) | ((ctx->state[i] & 65280U) << 8)) | ((ctx->state[i] >> 8) & 65280U)) | (ctx->state[i] >> 24));
#line 118
    i ++;
  }
#line 121
  return (resbuf);
}
}
#line 126 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
static void sha256_conclude_ctx(struct sha256_ctx *ctx ) 
{ 
  size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 130
  bytes = ctx->buflen;
#line 131
  if (bytes < 56UL) {
#line 131
    tmp = 16;
  } else {
#line 131
    tmp = 32;
  }
#line 131
  size = (size_t )tmp;
#line 134
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + bytes);
#line 135
  if ((size_t )ctx->total[0] < bytes) {
#line 136
    (ctx->total[1]) ++;
  }
#line 141
  set_uint32((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) & 65280U) << 8)) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 8) & 65280U)) | (((ctx->total[1] << 3) | (ctx->total[0] >> 29)) >> 24));
#line 143
  set_uint32((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 24) | (((ctx->total[0] << 3) & 65280U) << 8)) | (((ctx->total[0] << 3) >> 8) & 65280U)) | ((ctx->total[0] << 3) >> 24));
#line 146
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___1),
         (size - 2UL) * 4UL - bytes);
#line 149
  sha256_process_block((void const   *)(ctx->buffer), size * 4UL, ctx);
#line 150
  return;
}
}
#line 152 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void *sha256_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
#line 155
  sha256_conclude_ctx(ctx);
#line 156
  tmp = sha256_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
#line 156
  return (tmp);
}
}
#line 159 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void *sha224_finish_ctx(struct sha256_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
#line 162
  sha256_conclude_ctx(ctx);
#line 163
  tmp = sha224_read_ctx((struct sha256_ctx  const  *)ctx, resbuf);
#line 163
  return (tmp);
}
}
#line 169 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
int sha256_stream(FILE *stream , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 175
  tmp = malloc((size_t )32840);
#line 175
  buffer = (char *)tmp;
#line 176
  if (! buffer) {
#line 177
    return (1);
  }
#line 180
  sha256_init_ctx(& ctx);
#line 183
  while (1) {
#line 189
    sum = (size_t )0;
#line 192
    while (1) {
#line 194
      n = fread_unlocked((void * __restrict  )(buffer + sum), (size_t )1, 32768UL - sum,
                         (FILE * __restrict  )stream);
#line 196
      sum += n;
#line 198
      if (sum == 32768UL) {
#line 199
        break;
      }
#line 201
      if (n == 0UL) {
#line 206
        tmp___0 = ferror_unlocked(stream);
#line 206
        if (tmp___0) {
#line 208
          free((void *)buffer);
#line 209
          return (1);
        }
#line 211
        goto process_partial_block;
      }
#line 217
      tmp___1 = feof_unlocked(stream);
#line 217
      if (tmp___1) {
#line 218
        goto process_partial_block;
      }
    }
#line 224
    sha256_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 230
  if (sum > 0UL) {
#line 231
    sha256_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 234
  sha256_finish_ctx(& ctx, resblock);
#line 235
  free((void *)buffer);
#line 236
  return (0);
}
}
#line 240 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
int sha224_stream(FILE *stream , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 246
  tmp = malloc((size_t )32840);
#line 246
  buffer = (char *)tmp;
#line 247
  if (! buffer) {
#line 248
    return (1);
  }
#line 251
  sha224_init_ctx(& ctx);
#line 254
  while (1) {
#line 260
    sum = (size_t )0;
#line 263
    while (1) {
#line 265
      n = fread_unlocked((void * __restrict  )(buffer + sum), (size_t )1, 32768UL - sum,
                         (FILE * __restrict  )stream);
#line 267
      sum += n;
#line 269
      if (sum == 32768UL) {
#line 270
        break;
      }
#line 272
      if (n == 0UL) {
#line 277
        tmp___0 = ferror_unlocked(stream);
#line 277
        if (tmp___0) {
#line 279
          free((void *)buffer);
#line 280
          return (1);
        }
#line 282
        goto process_partial_block;
      }
#line 288
      tmp___1 = feof_unlocked(stream);
#line 288
      if (tmp___1) {
#line 289
        goto process_partial_block;
      }
    }
#line 295
    sha256_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 301
  if (sum > 0UL) {
#line 302
    sha256_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 305
  sha224_finish_ctx(& ctx, resblock);
#line 306
  free((void *)buffer);
#line 307
  return (0);
}
}
#line 314 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void *sha256_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  void *tmp ;

  {
#line 320
  sha256_init_ctx(& ctx);
#line 323
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 326
  tmp = sha256_finish_ctx(& ctx, resblock);
#line 326
  return (tmp);
}
}
#line 329 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void *sha224_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha256_ctx ctx ;
  void *tmp ;

  {
#line 335
  sha224_init_ctx(& ctx);
#line 338
  sha256_process_bytes((void const   *)buffer, len, & ctx);
#line 341
  tmp = sha224_finish_ctx(& ctx, resblock);
#line 341
  return (tmp);
}
}
#line 344 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void sha256_process_bytes(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 349
  if (ctx->buflen != 0UL) {
#line 351
    left_over = ctx->buflen;
#line 352
    if (128UL - left_over > len) {
#line 352
      tmp = len;
    } else {
#line 352
      tmp = 128UL - left_over;
    }
#line 352
    add = tmp;
#line 354
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 355
    ctx->buflen += add;
#line 357
    if (ctx->buflen > 64UL) {
#line 359
      sha256_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffffc0UL,
                           ctx);
#line 361
      ctx->buflen &= 63UL;
#line 363
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffffc0UL)),
             ctx->buflen);
    }
#line 368
    buffer = (void const   *)((char const   *)buffer + add);
#line 369
    len -= add;
  }
#line 373
  if (len >= 64UL) {
#line 378
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_833865290___2 *)0)->x) != 0UL) {
#line 379
      while (len > 64UL) {
#line 381
        tmp___0 = memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )buffer,
                         (size_t )64);
#line 381
        sha256_process_block((void const   *)tmp___0, (size_t )64, ctx);
#line 382
        buffer = (void const   *)((char const   *)buffer + 64);
#line 383
        len -= 64UL;
      }
    } else {
#line 388
      sha256_process_block(buffer, len & 0xffffffffffffffc0UL, ctx);
#line 389
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffffc0UL));
#line 390
      len &= 63UL;
    }
  }
#line 395
  if (len > 0UL) {
#line 397
    left_over___0 = ctx->buflen;
#line 399
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 400
    left_over___0 += len;
#line 401
    if (left_over___0 >= 64UL) {
#line 403
      sha256_process_block((void const   *)(ctx->buffer), (size_t )64, ctx);
#line 404
      left_over___0 -= 64UL;
#line 405
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 407
    ctx->buflen = left_over___0;
  }
#line 409
  return;
}
}
#line 415 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
static uint32_t const   sha256_round_constants[64]  = 
#line 415
  {      (uint32_t const   )1116352408UL,      (uint32_t const   )1899447441UL,      (uint32_t const   )3049323471UL,      (uint32_t const   )3921009573UL, 
        (uint32_t const   )961987163UL,      (uint32_t const   )1508970993UL,      (uint32_t const   )2453635748UL,      (uint32_t const   )2870763221UL, 
        (uint32_t const   )3624381080UL,      (uint32_t const   )310598401UL,      (uint32_t const   )607225278UL,      (uint32_t const   )1426881987UL, 
        (uint32_t const   )1925078388UL,      (uint32_t const   )2162078206UL,      (uint32_t const   )2614888103UL,      (uint32_t const   )3248222580UL, 
        (uint32_t const   )3835390401UL,      (uint32_t const   )4022224774UL,      (uint32_t const   )264347078UL,      (uint32_t const   )604807628UL, 
        (uint32_t const   )770255983UL,      (uint32_t const   )1249150122UL,      (uint32_t const   )1555081692UL,      (uint32_t const   )1996064986UL, 
        (uint32_t const   )2554220882UL,      (uint32_t const   )2821834349UL,      (uint32_t const   )2952996808UL,      (uint32_t const   )3210313671UL, 
        (uint32_t const   )3336571891UL,      (uint32_t const   )3584528711UL,      (uint32_t const   )113926993UL,      (uint32_t const   )338241895UL, 
        (uint32_t const   )666307205UL,      (uint32_t const   )773529912UL,      (uint32_t const   )1294757372UL,      (uint32_t const   )1396182291UL, 
        (uint32_t const   )1695183700UL,      (uint32_t const   )1986661051UL,      (uint32_t const   )2177026350UL,      (uint32_t const   )2456956037UL, 
        (uint32_t const   )2730485921UL,      (uint32_t const   )2820302411UL,      (uint32_t const   )3259730800UL,      (uint32_t const   )3345764771UL, 
        (uint32_t const   )3516065817UL,      (uint32_t const   )3600352804UL,      (uint32_t const   )4094571909UL,      (uint32_t const   )275423344UL, 
        (uint32_t const   )430227734UL,      (uint32_t const   )506948616UL,      (uint32_t const   )659060556UL,      (uint32_t const   )883997877UL, 
        (uint32_t const   )958139571UL,      (uint32_t const   )1322822218UL,      (uint32_t const   )1537002063UL,      (uint32_t const   )1747873779UL, 
        (uint32_t const   )1955562222UL,      (uint32_t const   )2024104815UL,      (uint32_t const   )2227730452UL,      (uint32_t const   )2361852424UL, 
        (uint32_t const   )2428436474UL,      (uint32_t const   )2756734187UL,      (uint32_t const   )3204031479UL,      (uint32_t const   )3329325298UL};
#line 442 "/home/wslee/project/coreutils-8.1/lib/sha256.c"
void sha256_process_block(void const   *buffer , size_t len , struct sha256_ctx *ctx ) 
{ 
  uint32_t const   *words ;
  size_t nwords ;
  uint32_t const   *endp ;
  uint32_t x[16] ;
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t f ;
  uint32_t g ;
  uint32_t h ;
  uint32_t tm ;
  uint32_t t0 ;
  uint32_t t1 ;
  int t ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;
  uint32_t tmp___2 ;
  uint32_t tmp___3 ;
  uint32_t tmp___4 ;
  uint32_t tmp___5 ;
  uint32_t tmp___6 ;

  {
#line 445
  words = (uint32_t const   *)buffer;
#line 446
  nwords = len / sizeof(uint32_t );
#line 447
  endp = words + nwords;
#line 449
  a = ctx->state[0];
#line 450
  b = ctx->state[1];
#line 451
  c = ctx->state[2];
#line 452
  d = ctx->state[3];
#line 453
  e = ctx->state[4];
#line 454
  f = ctx->state[5];
#line 455
  g = ctx->state[6];
#line 456
  h = ctx->state[7];
#line 461
  ctx->total[0] = (uint32_t )((size_t )ctx->total[0] + len);
#line 462
  if ((size_t )ctx->total[0] < len) {
#line 463
    (ctx->total[1]) ++;
  }
#line 483
  while ((unsigned long )words < (unsigned long )endp) {
#line 489
    t = 0;
#line 489
    while (t < 16) {
#line 491
      x[t] = (uint32_t )((((*words << 24) | ((*words & 65280U) << 8)) | ((*words >> 8) & 65280U)) | (*words >> 24));
#line 492
      words ++;
#line 489
      t ++;
    }
#line 495
    while (1) {
#line 495
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 495
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[0]) + x[0];
#line 495
      d += t1;
#line 495
      h = t0 + t1;
#line 495
      break;
    }
#line 496
    while (1) {
#line 496
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 496
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[1]) + x[1];
#line 496
      c += t1;
#line 496
      g = t0 + t1;
#line 496
      break;
    }
#line 497
    while (1) {
#line 497
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 497
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[2]) + x[2];
#line 497
      b += t1;
#line 497
      f = t0 + t1;
#line 497
      break;
    }
#line 498
    while (1) {
#line 498
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 498
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[3]) + x[3];
#line 498
      a += t1;
#line 498
      e = t0 + t1;
#line 498
      break;
    }
#line 499
    while (1) {
#line 499
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 499
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[4]) + x[4];
#line 499
      h += t1;
#line 499
      d = t0 + t1;
#line 499
      break;
    }
#line 500
    while (1) {
#line 500
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 500
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[5]) + x[5];
#line 500
      g += t1;
#line 500
      c = t0 + t1;
#line 500
      break;
    }
#line 501
    while (1) {
#line 501
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 501
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[6]) + x[6];
#line 501
      f += t1;
#line 501
      b = t0 + t1;
#line 501
      break;
    }
#line 502
    while (1) {
#line 502
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 502
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[7]) + x[7];
#line 502
      e += t1;
#line 502
      a = t0 + t1;
#line 502
      break;
    }
#line 503
    while (1) {
#line 503
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 503
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[8]) + x[8];
#line 503
      d += t1;
#line 503
      h = t0 + t1;
#line 503
      break;
    }
#line 504
    while (1) {
#line 504
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 504
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[9]) + x[9];
#line 504
      c += t1;
#line 504
      g = t0 + t1;
#line 504
      break;
    }
#line 505
    while (1) {
#line 505
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 505
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[10]) + x[10];
#line 505
      b += t1;
#line 505
      f = t0 + t1;
#line 505
      break;
    }
#line 506
    while (1) {
#line 506
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 506
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[11]) + x[11];
#line 506
      a += t1;
#line 506
      e = t0 + t1;
#line 506
      break;
    }
#line 507
    while (1) {
#line 507
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 507
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[12]) + x[12];
#line 507
      h += t1;
#line 507
      d = t0 + t1;
#line 507
      break;
    }
#line 508
    while (1) {
#line 508
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 508
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[13]) + x[13];
#line 508
      g += t1;
#line 508
      c = t0 + t1;
#line 508
      break;
    }
#line 509
    while (1) {
#line 509
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 509
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[14]) + x[14];
#line 509
      f += t1;
#line 509
      b = t0 + t1;
#line 509
      break;
    }
#line 510
    while (1) {
#line 510
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 510
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[15]) + x[15];
#line 510
      e += t1;
#line 510
      a = t0 + t1;
#line 510
      break;
    }
#line 511
    while (1) {
#line 511
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 511
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 511
      x[0] = tm;
#line 511
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[16]) + x[0];
#line 511
      d += t1;
#line 511
      h = t0 + t1;
#line 511
      break;
    }
#line 512
    while (1) {
#line 512
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 512
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 512
      x[1] = tm;
#line 512
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[17]) + x[1];
#line 512
      c += t1;
#line 512
      g = t0 + t1;
#line 512
      break;
    }
#line 513
    while (1) {
#line 513
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 513
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 513
      x[2] = tm;
#line 513
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[18]) + x[2];
#line 513
      b += t1;
#line 513
      f = t0 + t1;
#line 513
      break;
    }
#line 514
    while (1) {
#line 514
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 514
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 514
      x[3] = tm;
#line 514
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[19]) + x[3];
#line 514
      a += t1;
#line 514
      e = t0 + t1;
#line 514
      break;
    }
#line 515
    while (1) {
#line 515
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 515
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 515
      x[4] = tm;
#line 515
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[20]) + x[4];
#line 515
      h += t1;
#line 515
      d = t0 + t1;
#line 515
      break;
    }
#line 516
    while (1) {
#line 516
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 516
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 516
      x[5] = tm;
#line 516
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[21]) + x[5];
#line 516
      g += t1;
#line 516
      c = t0 + t1;
#line 516
      break;
    }
#line 517
    while (1) {
#line 517
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 517
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 517
      x[6] = tm;
#line 517
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[22]) + x[6];
#line 517
      f += t1;
#line 517
      b = t0 + t1;
#line 517
      break;
    }
#line 518
    while (1) {
#line 518
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 518
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 518
      x[7] = tm;
#line 518
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[23]) + x[7];
#line 518
      e += t1;
#line 518
      a = t0 + t1;
#line 518
      break;
    }
#line 519
    while (1) {
#line 519
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 519
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 519
      x[8] = tm;
#line 519
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[24]) + x[8];
#line 519
      d += t1;
#line 519
      h = t0 + t1;
#line 519
      break;
    }
#line 520
    while (1) {
#line 520
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 520
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 520
      x[9] = tm;
#line 520
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[25]) + x[9];
#line 520
      c += t1;
#line 520
      g = t0 + t1;
#line 520
      break;
    }
#line 521
    while (1) {
#line 521
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 521
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 521
      x[10] = tm;
#line 521
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[26]) + x[10];
#line 521
      b += t1;
#line 521
      f = t0 + t1;
#line 521
      break;
    }
#line 522
    while (1) {
#line 522
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 522
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 522
      x[11] = tm;
#line 522
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[27]) + x[11];
#line 522
      a += t1;
#line 522
      e = t0 + t1;
#line 522
      break;
    }
#line 523
    while (1) {
#line 523
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 523
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 523
      x[12] = tm;
#line 523
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[28]) + x[12];
#line 523
      h += t1;
#line 523
      d = t0 + t1;
#line 523
      break;
    }
#line 524
    while (1) {
#line 524
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 524
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 524
      x[13] = tm;
#line 524
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[29]) + x[13];
#line 524
      g += t1;
#line 524
      c = t0 + t1;
#line 524
      break;
    }
#line 525
    while (1) {
#line 525
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 525
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 525
      x[14] = tm;
#line 525
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[30]) + x[14];
#line 525
      f += t1;
#line 525
      b = t0 + t1;
#line 525
      break;
    }
#line 526
    while (1) {
#line 526
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 526
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 526
      x[15] = tm;
#line 526
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[31]) + x[15];
#line 526
      e += t1;
#line 526
      a = t0 + t1;
#line 526
      break;
    }
#line 527
    while (1) {
#line 527
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 527
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 527
      x[0] = tm;
#line 527
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[32]) + x[0];
#line 527
      d += t1;
#line 527
      h = t0 + t1;
#line 527
      break;
    }
#line 528
    while (1) {
#line 528
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 528
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 528
      x[1] = tm;
#line 528
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[33]) + x[1];
#line 528
      c += t1;
#line 528
      g = t0 + t1;
#line 528
      break;
    }
#line 529
    while (1) {
#line 529
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 529
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 529
      x[2] = tm;
#line 529
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[34]) + x[2];
#line 529
      b += t1;
#line 529
      f = t0 + t1;
#line 529
      break;
    }
#line 530
    while (1) {
#line 530
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 530
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 530
      x[3] = tm;
#line 530
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[35]) + x[3];
#line 530
      a += t1;
#line 530
      e = t0 + t1;
#line 530
      break;
    }
#line 531
    while (1) {
#line 531
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 531
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 531
      x[4] = tm;
#line 531
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[36]) + x[4];
#line 531
      h += t1;
#line 531
      d = t0 + t1;
#line 531
      break;
    }
#line 532
    while (1) {
#line 532
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 532
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 532
      x[5] = tm;
#line 532
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[37]) + x[5];
#line 532
      g += t1;
#line 532
      c = t0 + t1;
#line 532
      break;
    }
#line 533
    while (1) {
#line 533
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 533
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 533
      x[6] = tm;
#line 533
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[38]) + x[6];
#line 533
      f += t1;
#line 533
      b = t0 + t1;
#line 533
      break;
    }
#line 534
    while (1) {
#line 534
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 534
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 534
      x[7] = tm;
#line 534
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[39]) + x[7];
#line 534
      e += t1;
#line 534
      a = t0 + t1;
#line 534
      break;
    }
#line 535
    while (1) {
#line 535
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 535
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 535
      x[8] = tm;
#line 535
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[40]) + x[8];
#line 535
      d += t1;
#line 535
      h = t0 + t1;
#line 535
      break;
    }
#line 536
    while (1) {
#line 536
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 536
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 536
      x[9] = tm;
#line 536
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[41]) + x[9];
#line 536
      c += t1;
#line 536
      g = t0 + t1;
#line 536
      break;
    }
#line 537
    while (1) {
#line 537
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 537
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 537
      x[10] = tm;
#line 537
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[42]) + x[10];
#line 537
      b += t1;
#line 537
      f = t0 + t1;
#line 537
      break;
    }
#line 538
    while (1) {
#line 538
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 538
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 538
      x[11] = tm;
#line 538
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[43]) + x[11];
#line 538
      a += t1;
#line 538
      e = t0 + t1;
#line 538
      break;
    }
#line 539
    while (1) {
#line 539
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 539
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 539
      x[12] = tm;
#line 539
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[44]) + x[12];
#line 539
      h += t1;
#line 539
      d = t0 + t1;
#line 539
      break;
    }
#line 540
    while (1) {
#line 540
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 540
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 540
      x[13] = tm;
#line 540
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[45]) + x[13];
#line 540
      g += t1;
#line 540
      c = t0 + t1;
#line 540
      break;
    }
#line 541
    while (1) {
#line 541
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 541
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 541
      x[14] = tm;
#line 541
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[46]) + x[14];
#line 541
      f += t1;
#line 541
      b = t0 + t1;
#line 541
      break;
    }
#line 542
    while (1) {
#line 542
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 542
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 542
      x[15] = tm;
#line 542
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[47]) + x[15];
#line 542
      e += t1;
#line 542
      a = t0 + t1;
#line 542
      break;
    }
#line 543
    while (1) {
#line 543
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 543
      tm = ((((((x[14] << 15) | (x[14] >> 17)) ^ ((x[14] << 13) | (x[14] >> 19))) ^ (x[14] >> 10)) + x[9]) + ((((x[1] << 25) | (x[1] >> 7)) ^ ((x[1] << 14) | (x[1] >> 18))) ^ (x[1] >> 3))) + x[0];
#line 543
      x[0] = tm;
#line 543
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[48]) + x[0];
#line 543
      d += t1;
#line 543
      h = t0 + t1;
#line 543
      break;
    }
#line 544
    while (1) {
#line 544
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 544
      tm = ((((((x[15] << 15) | (x[15] >> 17)) ^ ((x[15] << 13) | (x[15] >> 19))) ^ (x[15] >> 10)) + x[10]) + ((((x[2] << 25) | (x[2] >> 7)) ^ ((x[2] << 14) | (x[2] >> 18))) ^ (x[2] >> 3))) + x[1];
#line 544
      x[1] = tm;
#line 544
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[49]) + x[1];
#line 544
      c += t1;
#line 544
      g = t0 + t1;
#line 544
      break;
    }
#line 545
    while (1) {
#line 545
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 545
      tm = ((((((x[0] << 15) | (x[0] >> 17)) ^ ((x[0] << 13) | (x[0] >> 19))) ^ (x[0] >> 10)) + x[11]) + ((((x[3] << 25) | (x[3] >> 7)) ^ ((x[3] << 14) | (x[3] >> 18))) ^ (x[3] >> 3))) + x[2];
#line 545
      x[2] = tm;
#line 545
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[50]) + x[2];
#line 545
      b += t1;
#line 545
      f = t0 + t1;
#line 545
      break;
    }
#line 546
    while (1) {
#line 546
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 546
      tm = ((((((x[1] << 15) | (x[1] >> 17)) ^ ((x[1] << 13) | (x[1] >> 19))) ^ (x[1] >> 10)) + x[12]) + ((((x[4] << 25) | (x[4] >> 7)) ^ ((x[4] << 14) | (x[4] >> 18))) ^ (x[4] >> 3))) + x[3];
#line 546
      x[3] = tm;
#line 546
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[51]) + x[3];
#line 546
      a += t1;
#line 546
      e = t0 + t1;
#line 546
      break;
    }
#line 547
    while (1) {
#line 547
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 547
      tm = ((((((x[2] << 15) | (x[2] >> 17)) ^ ((x[2] << 13) | (x[2] >> 19))) ^ (x[2] >> 10)) + x[13]) + ((((x[5] << 25) | (x[5] >> 7)) ^ ((x[5] << 14) | (x[5] >> 18))) ^ (x[5] >> 3))) + x[4];
#line 547
      x[4] = tm;
#line 547
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[52]) + x[4];
#line 547
      h += t1;
#line 547
      d = t0 + t1;
#line 547
      break;
    }
#line 548
    while (1) {
#line 548
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 548
      tm = ((((((x[3] << 15) | (x[3] >> 17)) ^ ((x[3] << 13) | (x[3] >> 19))) ^ (x[3] >> 10)) + x[14]) + ((((x[6] << 25) | (x[6] >> 7)) ^ ((x[6] << 14) | (x[6] >> 18))) ^ (x[6] >> 3))) + x[5];
#line 548
      x[5] = tm;
#line 548
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[53]) + x[5];
#line 548
      g += t1;
#line 548
      c = t0 + t1;
#line 548
      break;
    }
#line 549
    while (1) {
#line 549
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 549
      tm = ((((((x[4] << 15) | (x[4] >> 17)) ^ ((x[4] << 13) | (x[4] >> 19))) ^ (x[4] >> 10)) + x[15]) + ((((x[7] << 25) | (x[7] >> 7)) ^ ((x[7] << 14) | (x[7] >> 18))) ^ (x[7] >> 3))) + x[6];
#line 549
      x[6] = tm;
#line 549
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[54]) + x[6];
#line 549
      f += t1;
#line 549
      b = t0 + t1;
#line 549
      break;
    }
#line 550
    while (1) {
#line 550
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 550
      tm = ((((((x[5] << 15) | (x[5] >> 17)) ^ ((x[5] << 13) | (x[5] >> 19))) ^ (x[5] >> 10)) + x[0]) + ((((x[8] << 25) | (x[8] >> 7)) ^ ((x[8] << 14) | (x[8] >> 18))) ^ (x[8] >> 3))) + x[7];
#line 550
      x[7] = tm;
#line 550
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[55]) + x[7];
#line 550
      e += t1;
#line 550
      a = t0 + t1;
#line 550
      break;
    }
#line 551
    while (1) {
#line 551
      t0 = ((((a << 30) | (a >> 2)) ^ ((a << 19) | (a >> 13))) ^ ((a << 10) | (a >> 22))) + ((a & b) | (c & (a | b)));
#line 551
      tm = ((((((x[6] << 15) | (x[6] >> 17)) ^ ((x[6] << 13) | (x[6] >> 19))) ^ (x[6] >> 10)) + x[1]) + ((((x[9] << 25) | (x[9] >> 7)) ^ ((x[9] << 14) | (x[9] >> 18))) ^ (x[9] >> 3))) + x[8];
#line 551
      x[8] = tm;
#line 551
      t1 = (((h + ((((e << 26) | (e >> 6)) ^ ((e << 21) | (e >> 11))) ^ ((e << 7) | (e >> 25)))) + (g ^ (e & (f ^ g)))) + (uint32_t )sha256_round_constants[56]) + x[8];
#line 551
      d += t1;
#line 551
      h = t0 + t1;
#line 551
      break;
    }
#line 552
    while (1) {
#line 552
      t0 = ((((h << 30) | (h >> 2)) ^ ((h << 19) | (h >> 13))) ^ ((h << 10) | (h >> 22))) + ((h & a) | (b & (h | a)));
#line 552
      tm = ((((((x[7] << 15) | (x[7] >> 17)) ^ ((x[7] << 13) | (x[7] >> 19))) ^ (x[7] >> 10)) + x[2]) + ((((x[10] << 25) | (x[10] >> 7)) ^ ((x[10] << 14) | (x[10] >> 18))) ^ (x[10] >> 3))) + x[9];
#line 552
      x[9] = tm;
#line 552
      t1 = (((g + ((((d << 26) | (d >> 6)) ^ ((d << 21) | (d >> 11))) ^ ((d << 7) | (d >> 25)))) + (f ^ (d & (e ^ f)))) + (uint32_t )sha256_round_constants[57]) + x[9];
#line 552
      c += t1;
#line 552
      g = t0 + t1;
#line 552
      break;
    }
#line 553
    while (1) {
#line 553
      t0 = ((((g << 30) | (g >> 2)) ^ ((g << 19) | (g >> 13))) ^ ((g << 10) | (g >> 22))) + ((g & h) | (a & (g | h)));
#line 553
      tm = ((((((x[8] << 15) | (x[8] >> 17)) ^ ((x[8] << 13) | (x[8] >> 19))) ^ (x[8] >> 10)) + x[3]) + ((((x[11] << 25) | (x[11] >> 7)) ^ ((x[11] << 14) | (x[11] >> 18))) ^ (x[11] >> 3))) + x[10];
#line 553
      x[10] = tm;
#line 553
      t1 = (((f + ((((c << 26) | (c >> 6)) ^ ((c << 21) | (c >> 11))) ^ ((c << 7) | (c >> 25)))) + (e ^ (c & (d ^ e)))) + (uint32_t )sha256_round_constants[58]) + x[10];
#line 553
      b += t1;
#line 553
      f = t0 + t1;
#line 553
      break;
    }
#line 554
    while (1) {
#line 554
      t0 = ((((f << 30) | (f >> 2)) ^ ((f << 19) | (f >> 13))) ^ ((f << 10) | (f >> 22))) + ((f & g) | (h & (f | g)));
#line 554
      tm = ((((((x[9] << 15) | (x[9] >> 17)) ^ ((x[9] << 13) | (x[9] >> 19))) ^ (x[9] >> 10)) + x[4]) + ((((x[12] << 25) | (x[12] >> 7)) ^ ((x[12] << 14) | (x[12] >> 18))) ^ (x[12] >> 3))) + x[11];
#line 554
      x[11] = tm;
#line 554
      t1 = (((e + ((((b << 26) | (b >> 6)) ^ ((b << 21) | (b >> 11))) ^ ((b << 7) | (b >> 25)))) + (d ^ (b & (c ^ d)))) + (uint32_t )sha256_round_constants[59]) + x[11];
#line 554
      a += t1;
#line 554
      e = t0 + t1;
#line 554
      break;
    }
#line 555
    while (1) {
#line 555
      t0 = ((((e << 30) | (e >> 2)) ^ ((e << 19) | (e >> 13))) ^ ((e << 10) | (e >> 22))) + ((e & f) | (g & (e | f)));
#line 555
      tm = ((((((x[10] << 15) | (x[10] >> 17)) ^ ((x[10] << 13) | (x[10] >> 19))) ^ (x[10] >> 10)) + x[5]) + ((((x[13] << 25) | (x[13] >> 7)) ^ ((x[13] << 14) | (x[13] >> 18))) ^ (x[13] >> 3))) + x[12];
#line 555
      x[12] = tm;
#line 555
      t1 = (((d + ((((a << 26) | (a >> 6)) ^ ((a << 21) | (a >> 11))) ^ ((a << 7) | (a >> 25)))) + (c ^ (a & (b ^ c)))) + (uint32_t )sha256_round_constants[60]) + x[12];
#line 555
      h += t1;
#line 555
      d = t0 + t1;
#line 555
      break;
    }
#line 556
    while (1) {
#line 556
      t0 = ((((d << 30) | (d >> 2)) ^ ((d << 19) | (d >> 13))) ^ ((d << 10) | (d >> 22))) + ((d & e) | (f & (d | e)));
#line 556
      tm = ((((((x[11] << 15) | (x[11] >> 17)) ^ ((x[11] << 13) | (x[11] >> 19))) ^ (x[11] >> 10)) + x[6]) + ((((x[14] << 25) | (x[14] >> 7)) ^ ((x[14] << 14) | (x[14] >> 18))) ^ (x[14] >> 3))) + x[13];
#line 556
      x[13] = tm;
#line 556
      t1 = (((c + ((((h << 26) | (h >> 6)) ^ ((h << 21) | (h >> 11))) ^ ((h << 7) | (h >> 25)))) + (b ^ (h & (a ^ b)))) + (uint32_t )sha256_round_constants[61]) + x[13];
#line 556
      g += t1;
#line 556
      c = t0 + t1;
#line 556
      break;
    }
#line 557
    while (1) {
#line 557
      t0 = ((((c << 30) | (c >> 2)) ^ ((c << 19) | (c >> 13))) ^ ((c << 10) | (c >> 22))) + ((c & d) | (e & (c | d)));
#line 557
      tm = ((((((x[12] << 15) | (x[12] >> 17)) ^ ((x[12] << 13) | (x[12] >> 19))) ^ (x[12] >> 10)) + x[7]) + ((((x[15] << 25) | (x[15] >> 7)) ^ ((x[15] << 14) | (x[15] >> 18))) ^ (x[15] >> 3))) + x[14];
#line 557
      x[14] = tm;
#line 557
      t1 = (((b + ((((g << 26) | (g >> 6)) ^ ((g << 21) | (g >> 11))) ^ ((g << 7) | (g >> 25)))) + (a ^ (g & (h ^ a)))) + (uint32_t )sha256_round_constants[62]) + x[14];
#line 557
      f += t1;
#line 557
      b = t0 + t1;
#line 557
      break;
    }
#line 558
    while (1) {
#line 558
      t0 = ((((b << 30) | (b >> 2)) ^ ((b << 19) | (b >> 13))) ^ ((b << 10) | (b >> 22))) + ((b & c) | (d & (b | c)));
#line 558
      tm = ((((((x[13] << 15) | (x[13] >> 17)) ^ ((x[13] << 13) | (x[13] >> 19))) ^ (x[13] >> 10)) + x[8]) + ((((x[0] << 25) | (x[0] >> 7)) ^ ((x[0] << 14) | (x[0] >> 18))) ^ (x[0] >> 3))) + x[15];
#line 558
      x[15] = tm;
#line 558
      t1 = (((a + ((((f << 26) | (f >> 6)) ^ ((f << 21) | (f >> 11))) ^ ((f << 7) | (f >> 25)))) + (h ^ (f & (g ^ h)))) + (uint32_t )sha256_round_constants[63]) + x[15];
#line 558
      e += t1;
#line 558
      a = t0 + t1;
#line 558
      break;
    }
#line 560
    tmp = ctx->state[0] + a;
#line 560
    ctx->state[0] = tmp;
#line 560
    a = tmp;
#line 561
    tmp___0 = ctx->state[1] + b;
#line 561
    ctx->state[1] = tmp___0;
#line 561
    b = tmp___0;
#line 562
    tmp___1 = ctx->state[2] + c;
#line 562
    ctx->state[2] = tmp___1;
#line 562
    c = tmp___1;
#line 563
    tmp___2 = ctx->state[3] + d;
#line 563
    ctx->state[3] = tmp___2;
#line 563
    d = tmp___2;
#line 564
    tmp___3 = ctx->state[4] + e;
#line 564
    ctx->state[4] = tmp___3;
#line 564
    e = tmp___3;
#line 565
    tmp___4 = ctx->state[5] + f;
#line 565
    ctx->state[5] = tmp___4;
#line 565
    f = tmp___4;
#line 566
    tmp___5 = ctx->state[6] + g;
#line 566
    ctx->state[6] = tmp___5;
#line 566
    g = tmp___5;
#line 567
    tmp___6 = ctx->state[7] + h;
#line 567
    ctx->state[7] = tmp___6;
#line 567
    h = tmp___6;
  }
#line 569
  return;
}
}
#line 1 "cil-juiY14Ks.o"
#pragma merger("0","../lib/sha512.o.i","")
#line 43 "/home/wslee/project/coreutils-8.1/lib/sha512.h"
void sha512_init_ctx(struct sha512_ctx *ctx ) ;
#line 44
void sha384_init_ctx(struct sha512_ctx *ctx ) ;
#line 50
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 57
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) ;
#line 64
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 65
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) ;
#line 74
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 75
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) ;
#line 81
int sha512_stream(FILE *stream , void *resblock ) ;
#line 82
int sha384_stream(FILE *stream , void *resblock ) ;
#line 88
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 89
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) ;
#line 56 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
static unsigned char const   fillbuf___2[128]  = {      (unsigned char const   )128,      (unsigned char const   )0};
#line 64 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void sha512_init_ctx(struct sha512_ctx *ctx ) 
{ 
  u64 tmp ;

  {
#line 67
  ctx->state[0] = (1779033703UL << 32) + 4089235720UL;
#line 68
  ctx->state[1] = (3144134277UL << 32) + 2227873595UL;
#line 69
  ctx->state[2] = (1013904242UL << 32) + 4271175723UL;
#line 70
  ctx->state[3] = (2773480762UL << 32) + 1595750129UL;
#line 71
  ctx->state[4] = (1359893119UL << 32) + 2917565137UL;
#line 72
  ctx->state[5] = (2600822924UL << 32) + 725511199UL;
#line 73
  ctx->state[6] = (528734635UL << 32) + 4215389547UL;
#line 74
  ctx->state[7] = (1541459225UL << 32) + 327033209UL;
#line 76
  tmp = (u64 )0;
#line 76
  ctx->total[1] = tmp;
#line 76
  ctx->total[0] = tmp;
#line 77
  ctx->buflen = (size_t )0;
#line 78
  return;
}
}
#line 80 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void sha384_init_ctx(struct sha512_ctx *ctx ) 
{ 
  u64 tmp ;

  {
#line 83
  ctx->state[0] = (3418070365UL << 32) + 3238371032UL;
#line 84
  ctx->state[1] = (1654270250UL << 32) + 914150663UL;
#line 85
  ctx->state[2] = (2438529370UL << 32) + 812702999UL;
#line 86
  ctx->state[3] = (355462360UL << 32) + 4144912697UL;
#line 87
  ctx->state[4] = (1731405415UL << 32) + 4290775857UL;
#line 88
  ctx->state[5] = (2394180231UL << 32) + 1750603025UL;
#line 89
  ctx->state[6] = (3675008525UL << 32) + 1694076839UL;
#line 90
  ctx->state[7] = (1203062813UL << 32) + 3204075428UL;
#line 92
  tmp = (u64 )0;
#line 92
  ctx->total[1] = tmp;
#line 92
  ctx->total[0] = tmp;
#line 93
  ctx->buflen = (size_t )0;
#line 94
  return;
}
}
#line 99 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
__inline static void set_uint64(char *cp , u64 v ) 
{ 


  {
#line 102
  memcpy((void * __restrict  )cp, (void const   * __restrict  )(& v), sizeof(v));
#line 103
  return;
}
}
#line 107 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void *sha512_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 111
  r = (char *)resbuf;
#line 113
  i = 0;
#line 113
  while (i < 8) {
#line 114
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
#line 113
    i ++;
  }
#line 116
  return (resbuf);
}
}
#line 119 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void *sha384_read_ctx(struct sha512_ctx  const  *ctx , void *resbuf ) 
{ 
  int i ;
  char *r ;

  {
#line 123
  r = (char *)resbuf;
#line 125
  i = 0;
#line 125
  while (i < 6) {
#line 126
    set_uint64(r + (unsigned long )i * sizeof(ctx->state[0]), (((ctx->state[i] << 56) | ((ctx->state[i] & 65280UL) << 40)) | (((ctx->state[i] & 16711680UL) << 24) | ((ctx->state[i] & 4278190080UL) << 8))) | ((((ctx->state[i] >> 8) & 4278190080UL) | ((ctx->state[i] >> 24) & 16711680UL)) | (((ctx->state[i] >> 40) & 65280UL) | (ctx->state[i] >> 56))));
#line 125
    i ++;
  }
#line 128
  return (resbuf);
}
}
#line 133 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
static void sha512_conclude_ctx(struct sha512_ctx *ctx ) 
{ 
  size_t bytes ;
  size_t size ;
  int tmp ;

  {
#line 137
  bytes = ctx->buflen;
#line 138
  if (bytes < 112UL) {
#line 138
    tmp = 16;
  } else {
#line 138
    tmp = 32;
  }
#line 138
  size = (size_t )tmp;
#line 141
  ctx->total[0] += bytes;
#line 142
  if (ctx->total[0] < bytes) {
#line 143
    (ctx->total[1]) ++;
  }
#line 148
  set_uint64((char *)(& ctx->buffer[size - 2UL]), (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) << 56) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 65280UL) << 40)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 16711680UL) << 24) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) & 4278190080UL) << 8))) | ((((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 8) & 4278190080UL) | ((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 24) & 16711680UL)) | (((((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 40) & 65280UL) | (((ctx->total[1] << 3) | (ctx->total[0] >> 61)) >> 56))));
#line 151
  set_uint64((char *)(& ctx->buffer[size - 1UL]), ((((ctx->total[0] << 3) << 56) | (((ctx->total[0] << 3) & 65280UL) << 40)) | ((((ctx->total[0] << 3) & 16711680UL) << 24) | (((ctx->total[0] << 3) & 4278190080UL) << 8))) | (((((ctx->total[0] << 3) >> 8) & 4278190080UL) | (((ctx->total[0] << 3) >> 24) & 16711680UL)) | ((((ctx->total[0] << 3) >> 40) & 65280UL) | ((ctx->total[0] << 3) >> 56))));
#line 154
  memcpy((void * __restrict  )((char *)(ctx->buffer) + bytes), (void const   * __restrict  )(fillbuf___2),
         (size - 2UL) * 8UL - bytes);
#line 157
  sha512_process_block((void const   *)(ctx->buffer), size * 8UL, ctx);
#line 158
  return;
}
}
#line 160 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void *sha512_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
#line 163
  sha512_conclude_ctx(ctx);
#line 164
  tmp = sha512_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
#line 164
  return (tmp);
}
}
#line 167 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void *sha384_finish_ctx(struct sha512_ctx *ctx , void *resbuf ) 
{ 
  void *tmp ;

  {
#line 170
  sha512_conclude_ctx(ctx);
#line 171
  tmp = sha384_read_ctx((struct sha512_ctx  const  *)ctx, resbuf);
#line 171
  return (tmp);
}
}
#line 177 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
int sha512_stream(FILE *stream , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 183
  tmp = malloc((size_t )32840);
#line 183
  buffer = (char *)tmp;
#line 184
  if (! buffer) {
#line 185
    return (1);
  }
#line 188
  sha512_init_ctx(& ctx);
#line 191
  while (1) {
#line 197
    sum = (size_t )0;
#line 200
    while (1) {
#line 202
      n = fread_unlocked((void * __restrict  )(buffer + sum), (size_t )1, 32768UL - sum,
                         (FILE * __restrict  )stream);
#line 204
      sum += n;
#line 206
      if (sum == 32768UL) {
#line 207
        break;
      }
#line 209
      if (n == 0UL) {
#line 214
        tmp___0 = ferror_unlocked(stream);
#line 214
        if (tmp___0) {
#line 216
          free((void *)buffer);
#line 217
          return (1);
        }
#line 219
        goto process_partial_block;
      }
#line 225
      tmp___1 = feof_unlocked(stream);
#line 225
      if (tmp___1) {
#line 226
        goto process_partial_block;
      }
    }
#line 232
    sha512_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 238
  if (sum > 0UL) {
#line 239
    sha512_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 242
  sha512_finish_ctx(& ctx, resblock);
#line 243
  free((void *)buffer);
#line 244
  return (0);
}
}
#line 248 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
int sha384_stream(FILE *stream , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  size_t sum ;
  char *buffer ;
  void *tmp ;
  size_t n ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 254
  tmp = malloc((size_t )32840);
#line 254
  buffer = (char *)tmp;
#line 255
  if (! buffer) {
#line 256
    return (1);
  }
#line 259
  sha384_init_ctx(& ctx);
#line 262
  while (1) {
#line 268
    sum = (size_t )0;
#line 271
    while (1) {
#line 273
      n = fread_unlocked((void * __restrict  )(buffer + sum), (size_t )1, 32768UL - sum,
                         (FILE * __restrict  )stream);
#line 275
      sum += n;
#line 277
      if (sum == 32768UL) {
#line 278
        break;
      }
#line 280
      if (n == 0UL) {
#line 285
        tmp___0 = ferror_unlocked(stream);
#line 285
        if (tmp___0) {
#line 287
          free((void *)buffer);
#line 288
          return (1);
        }
#line 290
        goto process_partial_block;
      }
#line 296
      tmp___1 = feof_unlocked(stream);
#line 296
      if (tmp___1) {
#line 297
        goto process_partial_block;
      }
    }
#line 303
    sha512_process_block((void const   *)buffer, (size_t )32768, & ctx);
  }
  process_partial_block: ;
#line 309
  if (sum > 0UL) {
#line 310
    sha512_process_bytes((void const   *)buffer, sum, & ctx);
  }
#line 313
  sha384_finish_ctx(& ctx, resblock);
#line 314
  free((void *)buffer);
#line 315
  return (0);
}
}
#line 322 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void *sha512_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  void *tmp ;

  {
#line 328
  sha512_init_ctx(& ctx);
#line 331
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 334
  tmp = sha512_finish_ctx(& ctx, resblock);
#line 334
  return (tmp);
}
}
#line 337 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void *sha384_buffer(char const   *buffer , size_t len , void *resblock ) 
{ 
  struct sha512_ctx ctx ;
  void *tmp ;

  {
#line 343
  sha384_init_ctx(& ctx);
#line 346
  sha512_process_bytes((void const   *)buffer, len, & ctx);
#line 349
  tmp = sha384_finish_ctx(& ctx, resblock);
#line 349
  return (tmp);
}
}
#line 352 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void sha512_process_bytes(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ 
  size_t left_over ;
  size_t add ;
  size_t tmp ;
  void *tmp___0 ;
  size_t left_over___0 ;

  {
#line 357
  if (ctx->buflen != 0UL) {
#line 359
    left_over = ctx->buflen;
#line 360
    if (256UL - left_over > len) {
#line 360
      tmp = len;
    } else {
#line 360
      tmp = 256UL - left_over;
    }
#line 360
    add = tmp;
#line 362
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over), (void const   * __restrict  )buffer,
           add);
#line 363
    ctx->buflen += add;
#line 365
    if (ctx->buflen > 128UL) {
#line 367
      sha512_process_block((void const   *)(ctx->buffer), ctx->buflen & 0xffffffffffffff80UL,
                           ctx);
#line 369
      ctx->buflen &= 127UL;
#line 371
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )((char *)(ctx->buffer) + ((left_over + add) & 0xffffffffffffff80UL)),
             ctx->buflen);
    }
#line 376
    buffer = (void const   *)((char const   *)buffer + add);
#line 377
    len -= add;
  }
#line 381
  if (len >= 128UL) {
#line 386
    if ((size_t )buffer % (unsigned long )(& ((struct __anonstruct_972123420 *)0)->x) != 0UL) {
#line 387
      while (len > 128UL) {
#line 389
        tmp___0 = memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )buffer,
                         (size_t )128);
#line 389
        sha512_process_block((void const   *)tmp___0, (size_t )128, ctx);
#line 390
        buffer = (void const   *)((char const   *)buffer + 128);
#line 391
        len -= 128UL;
      }
    } else {
#line 396
      sha512_process_block(buffer, len & 0xffffffffffffff80UL, ctx);
#line 397
      buffer = (void const   *)((char const   *)buffer + (len & 0xffffffffffffff80UL));
#line 398
      len &= 127UL;
    }
  }
#line 403
  if (len > 0UL) {
#line 405
    left_over___0 = ctx->buflen;
#line 407
    memcpy((void * __restrict  )((char *)(ctx->buffer) + left_over___0), (void const   * __restrict  )buffer,
           len);
#line 408
    left_over___0 += len;
#line 409
    if (left_over___0 >= 128UL) {
#line 411
      sha512_process_block((void const   *)(ctx->buffer), (size_t )128, ctx);
#line 412
      left_over___0 -= 128UL;
#line 413
      memcpy((void * __restrict  )(ctx->buffer), (void const   * __restrict  )(& ctx->buffer[16]),
             left_over___0);
    }
#line 415
    ctx->buflen = left_over___0;
  }
#line 417
  return;
}
}
#line 423 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
static u64 const   sha512_round_constants[80]  = 
#line 423
  {      (u64 const   )((1116352408UL << 32) + 3609767458UL),      (u64 const   )((1899447441UL << 32) + 602891725UL),      (u64 const   )((3049323471UL << 32) + 3964484399UL),      (u64 const   )((3921009573UL << 32) + 2173295548UL), 
        (u64 const   )((961987163UL << 32) + 4081628472UL),      (u64 const   )((1508970993UL << 32) + 3053834265UL),      (u64 const   )((2453635748UL << 32) + 2937671579UL),      (u64 const   )((2870763221UL << 32) + 3664609560UL), 
        (u64 const   )((3624381080UL << 32) + 2734883394UL),      (u64 const   )((310598401UL << 32) + 1164996542UL),      (u64 const   )((607225278UL << 32) + 1323610764UL),      (u64 const   )((1426881987UL << 32) + 3590304994UL), 
        (u64 const   )((1925078388UL << 32) + 4068182383UL),      (u64 const   )((2162078206UL << 32) + 991336113UL),      (u64 const   )((2614888103UL << 32) + 633803317UL),      (u64 const   )((3248222580UL << 32) + 3479774868UL), 
        (u64 const   )((3835390401UL << 32) + 2666613458UL),      (u64 const   )((4022224774UL << 32) + 944711139UL),      (u64 const   )((264347078UL << 32) + 2341262773UL),      (u64 const   )((604807628UL << 32) + 2007800933UL), 
        (u64 const   )((770255983UL << 32) + 1495990901UL),      (u64 const   )((1249150122UL << 32) + 1856431235UL),      (u64 const   )((1555081692UL << 32) + 3175218132UL),      (u64 const   )((1996064986UL << 32) + 2198950837UL), 
        (u64 const   )((2554220882UL << 32) + 3999719339UL),      (u64 const   )((2821834349UL << 32) + 766784016UL),      (u64 const   )((2952996808UL << 32) + 2566594879UL),      (u64 const   )((3210313671UL << 32) + 3203337956UL), 
        (u64 const   )((3336571891UL << 32) + 1034457026UL),      (u64 const   )((3584528711UL << 32) + 2466948901UL),      (u64 const   )((113926993UL << 32) + 3758326383UL),      (u64 const   )((338241895UL << 32) + 168717936UL), 
        (u64 const   )((666307205UL << 32) + 1188179964UL),      (u64 const   )((773529912UL << 32) + 1546045734UL),      (u64 const   )((1294757372UL << 32) + 1522805485UL),      (u64 const   )((1396182291UL << 32) + 2643833823UL), 
        (u64 const   )((1695183700UL << 32) + 2343527390UL),      (u64 const   )((1986661051UL << 32) + 1014477480UL),      (u64 const   )((2177026350UL << 32) + 1206759142UL),      (u64 const   )((2456956037UL << 32) + 344077627UL), 
        (u64 const   )((2730485921UL << 32) + 1290863460UL),      (u64 const   )((2820302411UL << 32) + 3158454273UL),      (u64 const   )((3259730800UL << 32) + 3505952657UL),      (u64 const   )((3345764771UL << 32) + 106217008UL), 
        (u64 const   )((3516065817UL << 32) + 3606008344UL),      (u64 const   )((3600352804UL << 32) + 1432725776UL),      (u64 const   )((4094571909UL << 32) + 1467031594UL),      (u64 const   )((275423344UL << 32) + 851169720UL), 
        (u64 const   )((430227734UL << 32) + 3100823752UL),      (u64 const   )((506948616UL << 32) + 1363258195UL),      (u64 const   )((659060556UL << 32) + 3750685593UL),      (u64 const   )((883997877UL << 32) + 3785050280UL), 
        (u64 const   )((958139571UL << 32) + 3318307427UL),      (u64 const   )((1322822218UL << 32) + 3812723403UL),      (u64 const   )((1537002063UL << 32) + 2003034995UL),      (u64 const   )((1747873779UL << 32) + 3602036899UL), 
        (u64 const   )((1955562222UL << 32) + 1575990012UL),      (u64 const   )((2024104815UL << 32) + 1125592928UL),      (u64 const   )((2227730452UL << 32) + 2716904306UL),      (u64 const   )((2361852424UL << 32) + 442776044UL), 
        (u64 const   )((2428436474UL << 32) + 593698344UL),      (u64 const   )((2756734187UL << 32) + 3733110249UL),      (u64 const   )((3204031479UL << 32) + 2999351573UL),      (u64 const   )((3329325298UL << 32) + 3815920427UL), 
        (u64 const   )((3391569614UL << 32) + 3928383900UL),      (u64 const   )((3515267271UL << 32) + 566280711UL),      (u64 const   )((3940187606UL << 32) + 3454069534UL),      (u64 const   )((4118630271UL << 32) + 4000239992UL), 
        (u64 const   )((116418474UL << 32) + 1914138554UL),      (u64 const   )((174292421UL << 32) + 2731055270UL),      (u64 const   )((289380356UL << 32) + 3203993006UL),      (u64 const   )((460393269UL << 32) + 320620315UL), 
        (u64 const   )((685471733UL << 32) + 587496836UL),      (u64 const   )((852142971UL << 32) + 1086792851UL),      (u64 const   )((1017036298UL << 32) + 365543100UL),      (u64 const   )((1126000580UL << 32) + 2618297676UL), 
        (u64 const   )((1288033470UL << 32) + 3409855158UL),      (u64 const   )((1501505948UL << 32) + 4234509866UL),      (u64 const   )((1607167915UL << 32) + 987167468UL),      (u64 const   )((1816402316UL << 32) + 1246189591UL)};
#line 474 "/home/wslee/project/coreutils-8.1/lib/sha512.c"
void sha512_process_block(void const   *buffer , size_t len , struct sha512_ctx *ctx ) 
{ 
  u64 const   *words ;
  u64 const   *endp ;
  u64 x[16] ;
  u64 a ;
  u64 b ;
  u64 c ;
  u64 d ;
  u64 e ;
  u64 f ;
  u64 g ;
  u64 h ;
  int t ;
  u64 t0 ;
  u64 t1 ;
  u64 t0___0 ;
  u64 t1___0 ;
  u64 t0___1 ;
  u64 t1___1 ;
  u64 t0___2 ;
  u64 t1___2 ;
  u64 t0___3 ;
  u64 t1___3 ;
  u64 t0___4 ;
  u64 t1___4 ;
  u64 t0___5 ;
  u64 t1___5 ;
  u64 t0___6 ;
  u64 t1___6 ;
  u64 t0___7 ;
  u64 t1___7 ;
  u64 t0___8 ;
  u64 t1___8 ;
  u64 t0___9 ;
  u64 t1___9 ;
  u64 t0___10 ;
  u64 t1___10 ;
  u64 t0___11 ;
  u64 t1___11 ;
  u64 t0___12 ;
  u64 t1___12 ;
  u64 t0___13 ;
  u64 t1___13 ;
  u64 t0___14 ;
  u64 t1___14 ;
  u64 t0___15 ;
  u64 t1___15 ;
  u64 t0___16 ;
  u64 t1___16 ;
  u64 t0___17 ;
  u64 t1___17 ;
  u64 t0___18 ;
  u64 t1___18 ;
  u64 t0___19 ;
  u64 t1___19 ;
  u64 t0___20 ;
  u64 t1___20 ;
  u64 t0___21 ;
  u64 t1___21 ;
  u64 t0___22 ;
  u64 t1___22 ;
  u64 t0___23 ;
  u64 t1___23 ;
  u64 t0___24 ;
  u64 t1___24 ;
  u64 t0___25 ;
  u64 t1___25 ;
  u64 t0___26 ;
  u64 t1___26 ;
  u64 t0___27 ;
  u64 t1___27 ;
  u64 t0___28 ;
  u64 t1___28 ;
  u64 t0___29 ;
  u64 t1___29 ;
  u64 t0___30 ;
  u64 t1___30 ;
  u64 t0___31 ;
  u64 t1___31 ;
  u64 t0___32 ;
  u64 t1___32 ;
  u64 t0___33 ;
  u64 t1___33 ;
  u64 t0___34 ;
  u64 t1___34 ;
  u64 t0___35 ;
  u64 t1___35 ;
  u64 t0___36 ;
  u64 t1___36 ;
  u64 t0___37 ;
  u64 t1___37 ;
  u64 t0___38 ;
  u64 t1___38 ;
  u64 t0___39 ;
  u64 t1___39 ;
  u64 t0___40 ;
  u64 t1___40 ;
  u64 t0___41 ;
  u64 t1___41 ;
  u64 t0___42 ;
  u64 t1___42 ;
  u64 t0___43 ;
  u64 t1___43 ;
  u64 t0___44 ;
  u64 t1___44 ;
  u64 t0___45 ;
  u64 t1___45 ;
  u64 t0___46 ;
  u64 t1___46 ;
  u64 t0___47 ;
  u64 t1___47 ;
  u64 t0___48 ;
  u64 t1___48 ;
  u64 t0___49 ;
  u64 t1___49 ;
  u64 t0___50 ;
  u64 t1___50 ;
  u64 t0___51 ;
  u64 t1___51 ;
  u64 t0___52 ;
  u64 t1___52 ;
  u64 t0___53 ;
  u64 t1___53 ;
  u64 t0___54 ;
  u64 t1___54 ;
  u64 t0___55 ;
  u64 t1___55 ;
  u64 t0___56 ;
  u64 t1___56 ;
  u64 t0___57 ;
  u64 t1___57 ;
  u64 t0___58 ;
  u64 t1___58 ;
  u64 t0___59 ;
  u64 t1___59 ;
  u64 t0___60 ;
  u64 t1___60 ;
  u64 t0___61 ;
  u64 t1___61 ;
  u64 t0___62 ;
  u64 t1___62 ;
  u64 t0___63 ;
  u64 t1___63 ;
  u64 t0___64 ;
  u64 t1___64 ;
  u64 t0___65 ;
  u64 t1___65 ;
  u64 t0___66 ;
  u64 t1___66 ;
  u64 t0___67 ;
  u64 t1___67 ;
  u64 t0___68 ;
  u64 t1___68 ;
  u64 t0___69 ;
  u64 t1___69 ;
  u64 t0___70 ;
  u64 t1___70 ;
  u64 t0___71 ;
  u64 t1___71 ;
  u64 t0___72 ;
  u64 t1___72 ;
  u64 t0___73 ;
  u64 t1___73 ;
  u64 t0___74 ;
  u64 t1___74 ;
  u64 t0___75 ;
  u64 t1___75 ;
  u64 t0___76 ;
  u64 t1___76 ;
  u64 t0___77 ;
  u64 t1___77 ;
  u64 t0___78 ;
  u64 t1___78 ;
  u64 tmp ;
  u64 tmp___0 ;
  u64 tmp___1 ;
  u64 tmp___2 ;
  u64 tmp___3 ;
  u64 tmp___4 ;
  u64 tmp___5 ;
  u64 tmp___6 ;

  {
#line 477
  words = (u64 const   *)buffer;
#line 478
  endp = words + len / sizeof(u64 );
#line 480
  a = ctx->state[0];
#line 481
  b = ctx->state[1];
#line 482
  c = ctx->state[2];
#line 483
  d = ctx->state[3];
#line 484
  e = ctx->state[4];
#line 485
  f = ctx->state[5];
#line 486
  g = ctx->state[6];
#line 487
  h = ctx->state[7];
#line 492
  ctx->total[0] += len;
#line 493
  if (ctx->total[0] < len) {
#line 494
    (ctx->total[1]) ++;
  }
#line 519
  while ((unsigned long )words < (unsigned long )endp) {
#line 523
    t = 0;
#line 523
    while (t < 16) {
#line 525
      x[t] = (u64 )((((*words << 56) | ((*words & 65280UL) << 40)) | (((*words & 16711680UL) << 24) | ((*words & 4278190080UL) << 8))) | ((((*words >> 8) & 4278190080UL) | ((*words >> 24) & 16711680UL)) | (((*words >> 40) & 65280UL) | (*words >> 56))));
#line 526
      words ++;
#line 523
      t ++;
    }
#line 529
    while (1) {
#line 529
      t0 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 529
      t1 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[0] + (u64 const   )x[0])));
#line 529
      d += t1;
#line 529
      h = t0 + t1;
#line 529
      break;
    }
#line 530
    while (1) {
#line 530
      t0___0 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 530
      t1___0 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[1] + (u64 const   )x[1])));
#line 530
      c += t1___0;
#line 530
      g = t0___0 + t1___0;
#line 530
      break;
    }
#line 531
    while (1) {
#line 531
      t0___1 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 531
      t1___1 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[2] + (u64 const   )x[2])));
#line 531
      b += t1___1;
#line 531
      f = t0___1 + t1___1;
#line 531
      break;
    }
#line 532
    while (1) {
#line 532
      t0___2 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 532
      t1___2 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[3] + (u64 const   )x[3])));
#line 532
      a += t1___2;
#line 532
      e = t0___2 + t1___2;
#line 532
      break;
    }
#line 533
    while (1) {
#line 533
      t0___3 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 533
      t1___3 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[4] + (u64 const   )x[4])));
#line 533
      h += t1___3;
#line 533
      d = t0___3 + t1___3;
#line 533
      break;
    }
#line 534
    while (1) {
#line 534
      t0___4 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 534
      t1___4 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[5] + (u64 const   )x[5])));
#line 534
      g += t1___4;
#line 534
      c = t0___4 + t1___4;
#line 534
      break;
    }
#line 535
    while (1) {
#line 535
      t0___5 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 535
      t1___5 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[6] + (u64 const   )x[6])));
#line 535
      f += t1___5;
#line 535
      b = t0___5 + t1___5;
#line 535
      break;
    }
#line 536
    while (1) {
#line 536
      t0___6 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 536
      t1___6 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[7] + (u64 const   )x[7])));
#line 536
      e += t1___6;
#line 536
      a = t0___6 + t1___6;
#line 536
      break;
    }
#line 537
    while (1) {
#line 537
      t0___7 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 537
      t1___7 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[8] + (u64 const   )x[8])));
#line 537
      d += t1___7;
#line 537
      h = t0___7 + t1___7;
#line 537
      break;
    }
#line 538
    while (1) {
#line 538
      t0___8 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 538
      t1___8 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[9] + (u64 const   )x[9])));
#line 538
      c += t1___8;
#line 538
      g = t0___8 + t1___8;
#line 538
      break;
    }
#line 539
    while (1) {
#line 539
      t0___9 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 539
      t1___9 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[10] + (u64 const   )x[10])));
#line 539
      b += t1___9;
#line 539
      f = t0___9 + t1___9;
#line 539
      break;
    }
#line 540
    while (1) {
#line 540
      t0___10 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 540
      t1___10 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[11] + (u64 const   )x[11])));
#line 540
      a += t1___10;
#line 540
      e = t0___10 + t1___10;
#line 540
      break;
    }
#line 541
    while (1) {
#line 541
      t0___11 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 541
      t1___11 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[12] + (u64 const   )x[12])));
#line 541
      h += t1___11;
#line 541
      d = t0___11 + t1___11;
#line 541
      break;
    }
#line 542
    while (1) {
#line 542
      t0___12 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 542
      t1___12 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[13] + (u64 const   )x[13])));
#line 542
      g += t1___12;
#line 542
      c = t0___12 + t1___12;
#line 542
      break;
    }
#line 543
    while (1) {
#line 543
      t0___13 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 543
      t1___13 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[14] + (u64 const   )x[14])));
#line 543
      f += t1___13;
#line 543
      b = t0___13 + t1___13;
#line 543
      break;
    }
#line 544
    while (1) {
#line 544
      t0___14 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 544
      t1___14 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[15] + (u64 const   )x[15])));
#line 544
      e += t1___14;
#line 544
      a = t0___14 + t1___14;
#line 544
      break;
    }
#line 545
    while (1) {
#line 545
      t0___15 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 545
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 545
      t1___15 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[16] + (u64 const   )x[0])));
#line 545
      d += t1___15;
#line 545
      h = t0___15 + t1___15;
#line 545
      break;
    }
#line 546
    while (1) {
#line 546
      t0___16 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 546
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 546
      t1___16 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[17] + (u64 const   )x[1])));
#line 546
      c += t1___16;
#line 546
      g = t0___16 + t1___16;
#line 546
      break;
    }
#line 547
    while (1) {
#line 547
      t0___17 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 547
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 547
      t1___17 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[18] + (u64 const   )x[2])));
#line 547
      b += t1___17;
#line 547
      f = t0___17 + t1___17;
#line 547
      break;
    }
#line 548
    while (1) {
#line 548
      t0___18 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 548
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 548
      t1___18 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[19] + (u64 const   )x[3])));
#line 548
      a += t1___18;
#line 548
      e = t0___18 + t1___18;
#line 548
      break;
    }
#line 549
    while (1) {
#line 549
      t0___19 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 549
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 549
      t1___19 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[20] + (u64 const   )x[4])));
#line 549
      h += t1___19;
#line 549
      d = t0___19 + t1___19;
#line 549
      break;
    }
#line 550
    while (1) {
#line 550
      t0___20 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 550
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 550
      t1___20 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[21] + (u64 const   )x[5])));
#line 550
      g += t1___20;
#line 550
      c = t0___20 + t1___20;
#line 550
      break;
    }
#line 551
    while (1) {
#line 551
      t0___21 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 551
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 551
      t1___21 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[22] + (u64 const   )x[6])));
#line 551
      f += t1___21;
#line 551
      b = t0___21 + t1___21;
#line 551
      break;
    }
#line 552
    while (1) {
#line 552
      t0___22 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 552
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 552
      t1___22 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[23] + (u64 const   )x[7])));
#line 552
      e += t1___22;
#line 552
      a = t0___22 + t1___22;
#line 552
      break;
    }
#line 553
    while (1) {
#line 553
      t0___23 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 553
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 553
      t1___23 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[24] + (u64 const   )x[8])));
#line 553
      d += t1___23;
#line 553
      h = t0___23 + t1___23;
#line 553
      break;
    }
#line 554
    while (1) {
#line 554
      t0___24 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 554
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 554
      t1___24 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[25] + (u64 const   )x[9])));
#line 554
      c += t1___24;
#line 554
      g = t0___24 + t1___24;
#line 554
      break;
    }
#line 555
    while (1) {
#line 555
      t0___25 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 555
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 555
      t1___25 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[26] + (u64 const   )x[10])));
#line 555
      b += t1___25;
#line 555
      f = t0___25 + t1___25;
#line 555
      break;
    }
#line 556
    while (1) {
#line 556
      t0___26 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 556
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 556
      t1___26 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[27] + (u64 const   )x[11])));
#line 556
      a += t1___26;
#line 556
      e = t0___26 + t1___26;
#line 556
      break;
    }
#line 557
    while (1) {
#line 557
      t0___27 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 557
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 557
      t1___27 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[28] + (u64 const   )x[12])));
#line 557
      h += t1___27;
#line 557
      d = t0___27 + t1___27;
#line 557
      break;
    }
#line 558
    while (1) {
#line 558
      t0___28 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 558
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 558
      t1___28 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[29] + (u64 const   )x[13])));
#line 558
      g += t1___28;
#line 558
      c = t0___28 + t1___28;
#line 558
      break;
    }
#line 559
    while (1) {
#line 559
      t0___29 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 559
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 559
      t1___29 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[30] + (u64 const   )x[14])));
#line 559
      f += t1___29;
#line 559
      b = t0___29 + t1___29;
#line 559
      break;
    }
#line 560
    while (1) {
#line 560
      t0___30 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 560
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 560
      t1___30 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[31] + (u64 const   )x[15])));
#line 560
      e += t1___30;
#line 560
      a = t0___30 + t1___30;
#line 560
      break;
    }
#line 561
    while (1) {
#line 561
      t0___31 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 561
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 561
      t1___31 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[32] + (u64 const   )x[0])));
#line 561
      d += t1___31;
#line 561
      h = t0___31 + t1___31;
#line 561
      break;
    }
#line 562
    while (1) {
#line 562
      t0___32 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 562
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 562
      t1___32 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[33] + (u64 const   )x[1])));
#line 562
      c += t1___32;
#line 562
      g = t0___32 + t1___32;
#line 562
      break;
    }
#line 563
    while (1) {
#line 563
      t0___33 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 563
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 563
      t1___33 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[34] + (u64 const   )x[2])));
#line 563
      b += t1___33;
#line 563
      f = t0___33 + t1___33;
#line 563
      break;
    }
#line 564
    while (1) {
#line 564
      t0___34 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 564
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 564
      t1___34 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[35] + (u64 const   )x[3])));
#line 564
      a += t1___34;
#line 564
      e = t0___34 + t1___34;
#line 564
      break;
    }
#line 565
    while (1) {
#line 565
      t0___35 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 565
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 565
      t1___35 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[36] + (u64 const   )x[4])));
#line 565
      h += t1___35;
#line 565
      d = t0___35 + t1___35;
#line 565
      break;
    }
#line 566
    while (1) {
#line 566
      t0___36 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 566
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 566
      t1___36 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[37] + (u64 const   )x[5])));
#line 566
      g += t1___36;
#line 566
      c = t0___36 + t1___36;
#line 566
      break;
    }
#line 567
    while (1) {
#line 567
      t0___37 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 567
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 567
      t1___37 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[38] + (u64 const   )x[6])));
#line 567
      f += t1___37;
#line 567
      b = t0___37 + t1___37;
#line 567
      break;
    }
#line 568
    while (1) {
#line 568
      t0___38 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 568
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 568
      t1___38 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[39] + (u64 const   )x[7])));
#line 568
      e += t1___38;
#line 568
      a = t0___38 + t1___38;
#line 568
      break;
    }
#line 569
    while (1) {
#line 569
      t0___39 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 569
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 569
      t1___39 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[40] + (u64 const   )x[8])));
#line 569
      d += t1___39;
#line 569
      h = t0___39 + t1___39;
#line 569
      break;
    }
#line 570
    while (1) {
#line 570
      t0___40 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 570
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 570
      t1___40 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[41] + (u64 const   )x[9])));
#line 570
      c += t1___40;
#line 570
      g = t0___40 + t1___40;
#line 570
      break;
    }
#line 571
    while (1) {
#line 571
      t0___41 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 571
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 571
      t1___41 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[42] + (u64 const   )x[10])));
#line 571
      b += t1___41;
#line 571
      f = t0___41 + t1___41;
#line 571
      break;
    }
#line 572
    while (1) {
#line 572
      t0___42 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 572
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 572
      t1___42 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[43] + (u64 const   )x[11])));
#line 572
      a += t1___42;
#line 572
      e = t0___42 + t1___42;
#line 572
      break;
    }
#line 573
    while (1) {
#line 573
      t0___43 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 573
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 573
      t1___43 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[44] + (u64 const   )x[12])));
#line 573
      h += t1___43;
#line 573
      d = t0___43 + t1___43;
#line 573
      break;
    }
#line 574
    while (1) {
#line 574
      t0___44 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 574
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 574
      t1___44 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[45] + (u64 const   )x[13])));
#line 574
      g += t1___44;
#line 574
      c = t0___44 + t1___44;
#line 574
      break;
    }
#line 575
    while (1) {
#line 575
      t0___45 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 575
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 575
      t1___45 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[46] + (u64 const   )x[14])));
#line 575
      f += t1___45;
#line 575
      b = t0___45 + t1___45;
#line 575
      break;
    }
#line 576
    while (1) {
#line 576
      t0___46 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 576
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 576
      t1___46 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[47] + (u64 const   )x[15])));
#line 576
      e += t1___46;
#line 576
      a = t0___46 + t1___46;
#line 576
      break;
    }
#line 577
    while (1) {
#line 577
      t0___47 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 577
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 577
      t1___47 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[48] + (u64 const   )x[0])));
#line 577
      d += t1___47;
#line 577
      h = t0___47 + t1___47;
#line 577
      break;
    }
#line 578
    while (1) {
#line 578
      t0___48 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 578
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 578
      t1___48 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[49] + (u64 const   )x[1])));
#line 578
      c += t1___48;
#line 578
      g = t0___48 + t1___48;
#line 578
      break;
    }
#line 579
    while (1) {
#line 579
      t0___49 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 579
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 579
      t1___49 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[50] + (u64 const   )x[2])));
#line 579
      b += t1___49;
#line 579
      f = t0___49 + t1___49;
#line 579
      break;
    }
#line 580
    while (1) {
#line 580
      t0___50 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 580
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 580
      t1___50 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[51] + (u64 const   )x[3])));
#line 580
      a += t1___50;
#line 580
      e = t0___50 + t1___50;
#line 580
      break;
    }
#line 581
    while (1) {
#line 581
      t0___51 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 581
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 581
      t1___51 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[52] + (u64 const   )x[4])));
#line 581
      h += t1___51;
#line 581
      d = t0___51 + t1___51;
#line 581
      break;
    }
#line 582
    while (1) {
#line 582
      t0___52 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 582
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 582
      t1___52 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[53] + (u64 const   )x[5])));
#line 582
      g += t1___52;
#line 582
      c = t0___52 + t1___52;
#line 582
      break;
    }
#line 583
    while (1) {
#line 583
      t0___53 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 583
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 583
      t1___53 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[54] + (u64 const   )x[6])));
#line 583
      f += t1___53;
#line 583
      b = t0___53 + t1___53;
#line 583
      break;
    }
#line 584
    while (1) {
#line 584
      t0___54 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 584
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 584
      t1___54 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[55] + (u64 const   )x[7])));
#line 584
      e += t1___54;
#line 584
      a = t0___54 + t1___54;
#line 584
      break;
    }
#line 585
    while (1) {
#line 585
      t0___55 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 585
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 585
      t1___55 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[56] + (u64 const   )x[8])));
#line 585
      d += t1___55;
#line 585
      h = t0___55 + t1___55;
#line 585
      break;
    }
#line 586
    while (1) {
#line 586
      t0___56 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 586
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 586
      t1___56 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[57] + (u64 const   )x[9])));
#line 586
      c += t1___56;
#line 586
      g = t0___56 + t1___56;
#line 586
      break;
    }
#line 587
    while (1) {
#line 587
      t0___57 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 587
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 587
      t1___57 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[58] + (u64 const   )x[10])));
#line 587
      b += t1___57;
#line 587
      f = t0___57 + t1___57;
#line 587
      break;
    }
#line 588
    while (1) {
#line 588
      t0___58 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 588
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 588
      t1___58 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[59] + (u64 const   )x[11])));
#line 588
      a += t1___58;
#line 588
      e = t0___58 + t1___58;
#line 588
      break;
    }
#line 589
    while (1) {
#line 589
      t0___59 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 589
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 589
      t1___59 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[60] + (u64 const   )x[12])));
#line 589
      h += t1___59;
#line 589
      d = t0___59 + t1___59;
#line 589
      break;
    }
#line 590
    while (1) {
#line 590
      t0___60 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 590
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 590
      t1___60 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[61] + (u64 const   )x[13])));
#line 590
      g += t1___60;
#line 590
      c = t0___60 + t1___60;
#line 590
      break;
    }
#line 591
    while (1) {
#line 591
      t0___61 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 591
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 591
      t1___61 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[62] + (u64 const   )x[14])));
#line 591
      f += t1___61;
#line 591
      b = t0___61 + t1___61;
#line 591
      break;
    }
#line 592
    while (1) {
#line 592
      t0___62 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 592
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 592
      t1___62 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[63] + (u64 const   )x[15])));
#line 592
      e += t1___62;
#line 592
      a = t0___62 + t1___62;
#line 592
      break;
    }
#line 593
    while (1) {
#line 593
      t0___63 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 593
      x[0] += (((x[14] << 45) | (x[14] >> 19)) ^ (((x[14] << 3) | (x[14] >> 61)) ^ (x[14] >> 6))) + (x[9] + (((x[1] << 63) | (x[1] >> 1)) ^ (((x[1] << 56) | (x[1] >> 8)) ^ (x[1] >> 7))));
#line 593
      t1___63 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[64] + (u64 const   )x[0])));
#line 593
      d += t1___63;
#line 593
      h = t0___63 + t1___63;
#line 593
      break;
    }
#line 594
    while (1) {
#line 594
      t0___64 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 594
      x[1] += (((x[15] << 45) | (x[15] >> 19)) ^ (((x[15] << 3) | (x[15] >> 61)) ^ (x[15] >> 6))) + (x[10] + (((x[2] << 63) | (x[2] >> 1)) ^ (((x[2] << 56) | (x[2] >> 8)) ^ (x[2] >> 7))));
#line 594
      t1___64 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[65] + (u64 const   )x[1])));
#line 594
      c += t1___64;
#line 594
      g = t0___64 + t1___64;
#line 594
      break;
    }
#line 595
    while (1) {
#line 595
      t0___65 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 595
      x[2] += (((x[0] << 45) | (x[0] >> 19)) ^ (((x[0] << 3) | (x[0] >> 61)) ^ (x[0] >> 6))) + (x[11] + (((x[3] << 63) | (x[3] >> 1)) ^ (((x[3] << 56) | (x[3] >> 8)) ^ (x[3] >> 7))));
#line 595
      t1___65 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[66] + (u64 const   )x[2])));
#line 595
      b += t1___65;
#line 595
      f = t0___65 + t1___65;
#line 595
      break;
    }
#line 596
    while (1) {
#line 596
      t0___66 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 596
      x[3] += (((x[1] << 45) | (x[1] >> 19)) ^ (((x[1] << 3) | (x[1] >> 61)) ^ (x[1] >> 6))) + (x[12] + (((x[4] << 63) | (x[4] >> 1)) ^ (((x[4] << 56) | (x[4] >> 8)) ^ (x[4] >> 7))));
#line 596
      t1___66 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[67] + (u64 const   )x[3])));
#line 596
      a += t1___66;
#line 596
      e = t0___66 + t1___66;
#line 596
      break;
    }
#line 597
    while (1) {
#line 597
      t0___67 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 597
      x[4] += (((x[2] << 45) | (x[2] >> 19)) ^ (((x[2] << 3) | (x[2] >> 61)) ^ (x[2] >> 6))) + (x[13] + (((x[5] << 63) | (x[5] >> 1)) ^ (((x[5] << 56) | (x[5] >> 8)) ^ (x[5] >> 7))));
#line 597
      t1___67 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[68] + (u64 const   )x[4])));
#line 597
      h += t1___67;
#line 597
      d = t0___67 + t1___67;
#line 597
      break;
    }
#line 598
    while (1) {
#line 598
      t0___68 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 598
      x[5] += (((x[3] << 45) | (x[3] >> 19)) ^ (((x[3] << 3) | (x[3] >> 61)) ^ (x[3] >> 6))) + (x[14] + (((x[6] << 63) | (x[6] >> 1)) ^ (((x[6] << 56) | (x[6] >> 8)) ^ (x[6] >> 7))));
#line 598
      t1___68 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[69] + (u64 const   )x[5])));
#line 598
      g += t1___68;
#line 598
      c = t0___68 + t1___68;
#line 598
      break;
    }
#line 599
    while (1) {
#line 599
      t0___69 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 599
      x[6] += (((x[4] << 45) | (x[4] >> 19)) ^ (((x[4] << 3) | (x[4] >> 61)) ^ (x[4] >> 6))) + (x[15] + (((x[7] << 63) | (x[7] >> 1)) ^ (((x[7] << 56) | (x[7] >> 8)) ^ (x[7] >> 7))));
#line 599
      t1___69 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[70] + (u64 const   )x[6])));
#line 599
      f += t1___69;
#line 599
      b = t0___69 + t1___69;
#line 599
      break;
    }
#line 600
    while (1) {
#line 600
      t0___70 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 600
      x[7] += (((x[5] << 45) | (x[5] >> 19)) ^ (((x[5] << 3) | (x[5] >> 61)) ^ (x[5] >> 6))) + (x[0] + (((x[8] << 63) | (x[8] >> 1)) ^ (((x[8] << 56) | (x[8] >> 8)) ^ (x[8] >> 7))));
#line 600
      t1___70 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[71] + (u64 const   )x[7])));
#line 600
      e += t1___70;
#line 600
      a = t0___70 + t1___70;
#line 600
      break;
    }
#line 601
    while (1) {
#line 601
      t0___71 = (((a << 36) | (a >> 28)) ^ (((a << 30) | (a >> 34)) ^ ((a << 25) | (a >> 39)))) + ((a & b) | (c & (a | b)));
#line 601
      x[8] += (((x[6] << 45) | (x[6] >> 19)) ^ (((x[6] << 3) | (x[6] >> 61)) ^ (x[6] >> 6))) + (x[1] + (((x[9] << 63) | (x[9] >> 1)) ^ (((x[9] << 56) | (x[9] >> 8)) ^ (x[9] >> 7))));
#line 601
      t1___71 = h + ((((e << 50) | (e >> 14)) ^ (((e << 46) | (e >> 18)) ^ ((e << 23) | (e >> 41)))) + ((g ^ (e & (f ^ g))) + (unsigned long )(sha512_round_constants[72] + (u64 const   )x[8])));
#line 601
      d += t1___71;
#line 601
      h = t0___71 + t1___71;
#line 601
      break;
    }
#line 602
    while (1) {
#line 602
      t0___72 = (((h << 36) | (h >> 28)) ^ (((h << 30) | (h >> 34)) ^ ((h << 25) | (h >> 39)))) + ((h & a) | (b & (h | a)));
#line 602
      x[9] += (((x[7] << 45) | (x[7] >> 19)) ^ (((x[7] << 3) | (x[7] >> 61)) ^ (x[7] >> 6))) + (x[2] + (((x[10] << 63) | (x[10] >> 1)) ^ (((x[10] << 56) | (x[10] >> 8)) ^ (x[10] >> 7))));
#line 602
      t1___72 = g + ((((d << 50) | (d >> 14)) ^ (((d << 46) | (d >> 18)) ^ ((d << 23) | (d >> 41)))) + ((f ^ (d & (e ^ f))) + (unsigned long )(sha512_round_constants[73] + (u64 const   )x[9])));
#line 602
      c += t1___72;
#line 602
      g = t0___72 + t1___72;
#line 602
      break;
    }
#line 603
    while (1) {
#line 603
      t0___73 = (((g << 36) | (g >> 28)) ^ (((g << 30) | (g >> 34)) ^ ((g << 25) | (g >> 39)))) + ((g & h) | (a & (g | h)));
#line 603
      x[10] += (((x[8] << 45) | (x[8] >> 19)) ^ (((x[8] << 3) | (x[8] >> 61)) ^ (x[8] >> 6))) + (x[3] + (((x[11] << 63) | (x[11] >> 1)) ^ (((x[11] << 56) | (x[11] >> 8)) ^ (x[11] >> 7))));
#line 603
      t1___73 = f + ((((c << 50) | (c >> 14)) ^ (((c << 46) | (c >> 18)) ^ ((c << 23) | (c >> 41)))) + ((e ^ (c & (d ^ e))) + (unsigned long )(sha512_round_constants[74] + (u64 const   )x[10])));
#line 603
      b += t1___73;
#line 603
      f = t0___73 + t1___73;
#line 603
      break;
    }
#line 604
    while (1) {
#line 604
      t0___74 = (((f << 36) | (f >> 28)) ^ (((f << 30) | (f >> 34)) ^ ((f << 25) | (f >> 39)))) + ((f & g) | (h & (f | g)));
#line 604
      x[11] += (((x[9] << 45) | (x[9] >> 19)) ^ (((x[9] << 3) | (x[9] >> 61)) ^ (x[9] >> 6))) + (x[4] + (((x[12] << 63) | (x[12] >> 1)) ^ (((x[12] << 56) | (x[12] >> 8)) ^ (x[12] >> 7))));
#line 604
      t1___74 = e + ((((b << 50) | (b >> 14)) ^ (((b << 46) | (b >> 18)) ^ ((b << 23) | (b >> 41)))) + ((d ^ (b & (c ^ d))) + (unsigned long )(sha512_round_constants[75] + (u64 const   )x[11])));
#line 604
      a += t1___74;
#line 604
      e = t0___74 + t1___74;
#line 604
      break;
    }
#line 605
    while (1) {
#line 605
      t0___75 = (((e << 36) | (e >> 28)) ^ (((e << 30) | (e >> 34)) ^ ((e << 25) | (e >> 39)))) + ((e & f) | (g & (e | f)));
#line 605
      x[12] += (((x[10] << 45) | (x[10] >> 19)) ^ (((x[10] << 3) | (x[10] >> 61)) ^ (x[10] >> 6))) + (x[5] + (((x[13] << 63) | (x[13] >> 1)) ^ (((x[13] << 56) | (x[13] >> 8)) ^ (x[13] >> 7))));
#line 605
      t1___75 = d + ((((a << 50) | (a >> 14)) ^ (((a << 46) | (a >> 18)) ^ ((a << 23) | (a >> 41)))) + ((c ^ (a & (b ^ c))) + (unsigned long )(sha512_round_constants[76] + (u64 const   )x[12])));
#line 605
      h += t1___75;
#line 605
      d = t0___75 + t1___75;
#line 605
      break;
    }
#line 606
    while (1) {
#line 606
      t0___76 = (((d << 36) | (d >> 28)) ^ (((d << 30) | (d >> 34)) ^ ((d << 25) | (d >> 39)))) + ((d & e) | (f & (d | e)));
#line 606
      x[13] += (((x[11] << 45) | (x[11] >> 19)) ^ (((x[11] << 3) | (x[11] >> 61)) ^ (x[11] >> 6))) + (x[6] + (((x[14] << 63) | (x[14] >> 1)) ^ (((x[14] << 56) | (x[14] >> 8)) ^ (x[14] >> 7))));
#line 606
      t1___76 = c + ((((h << 50) | (h >> 14)) ^ (((h << 46) | (h >> 18)) ^ ((h << 23) | (h >> 41)))) + ((b ^ (h & (a ^ b))) + (unsigned long )(sha512_round_constants[77] + (u64 const   )x[13])));
#line 606
      g += t1___76;
#line 606
      c = t0___76 + t1___76;
#line 606
      break;
    }
#line 607
    while (1) {
#line 607
      t0___77 = (((c << 36) | (c >> 28)) ^ (((c << 30) | (c >> 34)) ^ ((c << 25) | (c >> 39)))) + ((c & d) | (e & (c | d)));
#line 607
      x[14] += (((x[12] << 45) | (x[12] >> 19)) ^ (((x[12] << 3) | (x[12] >> 61)) ^ (x[12] >> 6))) + (x[7] + (((x[15] << 63) | (x[15] >> 1)) ^ (((x[15] << 56) | (x[15] >> 8)) ^ (x[15] >> 7))));
#line 607
      t1___77 = b + ((((g << 50) | (g >> 14)) ^ (((g << 46) | (g >> 18)) ^ ((g << 23) | (g >> 41)))) + ((a ^ (g & (h ^ a))) + (unsigned long )(sha512_round_constants[78] + (u64 const   )x[14])));
#line 607
      f += t1___77;
#line 607
      b = t0___77 + t1___77;
#line 607
      break;
    }
#line 608
    while (1) {
#line 608
      t0___78 = (((b << 36) | (b >> 28)) ^ (((b << 30) | (b >> 34)) ^ ((b << 25) | (b >> 39)))) + ((b & c) | (d & (b | c)));
#line 608
      x[15] += (((x[13] << 45) | (x[13] >> 19)) ^ (((x[13] << 3) | (x[13] >> 61)) ^ (x[13] >> 6))) + (x[8] + (((x[0] << 63) | (x[0] >> 1)) ^ (((x[0] << 56) | (x[0] >> 8)) ^ (x[0] >> 7))));
#line 608
      t1___78 = a + ((((f << 50) | (f >> 14)) ^ (((f << 46) | (f >> 18)) ^ ((f << 23) | (f >> 41)))) + ((h ^ (f & (g ^ h))) + (unsigned long )(sha512_round_constants[79] + (u64 const   )x[15])));
#line 608
      e += t1___78;
#line 608
      a = t0___78 + t1___78;
#line 608
      break;
    }
#line 610
    tmp = ctx->state[0] + a;
#line 610
    ctx->state[0] = tmp;
#line 610
    a = tmp;
#line 611
    tmp___0 = ctx->state[1] + b;
#line 611
    ctx->state[1] = tmp___0;
#line 611
    b = tmp___0;
#line 612
    tmp___1 = ctx->state[2] + c;
#line 612
    ctx->state[2] = tmp___1;
#line 612
    c = tmp___1;
#line 613
    tmp___2 = ctx->state[3] + d;
#line 613
    ctx->state[3] = tmp___2;
#line 613
    d = tmp___2;
#line 614
    tmp___3 = ctx->state[4] + e;
#line 614
    ctx->state[4] = tmp___3;
#line 614
    e = tmp___3;
#line 615
    tmp___4 = ctx->state[5] + f;
#line 615
    ctx->state[5] = tmp___4;
#line 615
    f = tmp___4;
#line 616
    tmp___5 = ctx->state[6] + g;
#line 616
    ctx->state[6] = tmp___5;
#line 616
    g = tmp___5;
#line 617
    tmp___6 = ctx->state[7] + h;
#line 617
    ctx->state[7] = tmp___6;
#line 617
    h = tmp___6;
  }
#line 619
  return;
}
}
#line 1 "cil-MwnoaQdu.o"
#pragma merger("0","../lib/sig2str.o.i","")
#line 369 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __libc_current_sigrtmin)(void) ;
#line 371
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) __libc_current_sigrtmax)(void) ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/sig2str.h"
int sig2str(int signum , char *signame ) ;
#line 31
int str2sig(char const   *signame , int *signum ) ;
#line 41 "/home/wslee/project/coreutils-8.1/lib/sig2str.c"
static struct numname numname_table[35]  = 
#line 41 "/home/wslee/project/coreutils-8.1/lib/sig2str.c"
  {      {1, {(char const   )'H', (char const   )'U', (char const   )'P', (char const   )'\000'}}, 
        {2,
      {(char const   )'I', (char const   )'N', (char const   )'T', (char const   )'\000'}}, 
        {3,
      {(char const   )'Q', (char const   )'U', (char const   )'I', (char const   )'T',
       (char const   )'\000'}}, 
        {4, {(char const   )'I', (char const   )'L', (char const   )'L', (char const   )'\000'}}, 
        {5,
      {(char const   )'T', (char const   )'R', (char const   )'A', (char const   )'P',
       (char const   )'\000'}}, 
        {6, {(char const   )'A', (char const   )'B', (char const   )'R', (char const   )'T',
          (char const   )'\000'}}, 
        {8, {(char const   )'F', (char const   )'P', (char const   )'E', (char const   )'\000'}}, 
        {9,
      {(char const   )'K', (char const   )'I', (char const   )'L', (char const   )'L',
       (char const   )'\000'}}, 
        {7, {(char const   )'B', (char const   )'U', (char const   )'S', (char const   )'\000'}}, 
        {11,
      {(char const   )'S', (char const   )'E', (char const   )'G', (char const   )'V',
       (char const   )'\000'}}, 
        {13, {(char const   )'P', (char const   )'I', (char const   )'P', (char const   )'E',
           (char const   )'\000'}}, 
        {14, {(char const   )'A', (char const   )'L', (char const   )'R', (char const   )'M',
           (char const   )'\000'}}, 
        {15, {(char const   )'T', (char const   )'E', (char const   )'R', (char const   )'M',
           (char const   )'\000'}}, 
        {10, {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'1',
           (char const   )'\000'}}, 
        {12, {(char const   )'U', (char const   )'S', (char const   )'R', (char const   )'2',
           (char const   )'\000'}}, 
        {17, {(char const   )'C', (char const   )'H', (char const   )'L', (char const   )'D',
           (char const   )'\000'}}, 
        {23, {(char const   )'U', (char const   )'R', (char const   )'G', (char const   )'\000'}}, 
        {19,
      {(char const   )'S', (char const   )'T', (char const   )'O', (char const   )'P',
       (char const   )'\000'}}, 
        {20, {(char const   )'T', (char const   )'S', (char const   )'T', (char const   )'P',
           (char const   )'\000'}}, 
        {18, {(char const   )'C', (char const   )'O', (char const   )'N', (char const   )'T',
           (char const   )'\000'}}, 
        {21, {(char const   )'T', (char const   )'T', (char const   )'I', (char const   )'N',
           (char const   )'\000'}}, 
        {22, {(char const   )'T', (char const   )'T', (char const   )'O', (char const   )'U',
           (char const   )'\000'}}, 
        {31, {(char const   )'S', (char const   )'Y', (char const   )'S', (char const   )'\000'}}, 
        {29,
      {(char const   )'P', (char const   )'O', (char const   )'L', (char const   )'L',
       (char const   )'\000'}}, 
        {26, {(char const   )'V', (char const   )'T', (char const   )'A', (char const   )'L',
           (char const   )'R', (char const   )'M', (char const   )'\000'}}, 
        {27, {(char const   )'P', (char const   )'R', (char const   )'O', (char const   )'F',
           (char const   )'\000'}}, 
        {24, {(char const   )'X', (char const   )'C', (char const   )'P', (char const   )'U',
           (char const   )'\000'}}, 
        {25, {(char const   )'X', (char const   )'F', (char const   )'S', (char const   )'Z',
           (char const   )'\000'}}, 
        {6, {(char const   )'I', (char const   )'O', (char const   )'T', (char const   )'\000'}}, 
        {17,
      {(char const   )'C', (char const   )'L', (char const   )'D', (char const   )'\000'}}, 
        {30,
      {(char const   )'P', (char const   )'W', (char const   )'R', (char const   )'\000'}}, 
        {28,
      {(char const   )'W', (char const   )'I', (char const   )'N', (char const   )'C',
       (char const   )'H', (char const   )'\000'}}, 
        {29, {(char const   )'I', (char const   )'O', (char const   )'\000'}}, 
        {16, {(char const   )'S', (char const   )'T', (char const   )'K', (char const   )'F',
           (char const   )'L', (char const   )'T', (char const   )'\000'}}, 
        {0, {(char const   )'E', (char const   )'X', (char const   )'I', (char const   )'T',
          (char const   )'\000'}}};
#line 258 "/home/wslee/project/coreutils-8.1/lib/sig2str.c"
static int str2signum(char const   *signame ) 
{ 
  char *endp ;
  long n ;
  long tmp ;
  unsigned int i ;
  int tmp___0 ;
  char *endp___0 ;
  int rtmin ;
  int tmp___1 ;
  int rtmax ;
  int tmp___2 ;
  long n___0 ;
  long tmp___3 ;
  long n___1 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 261
  if ((unsigned int )*signame - 48U <= 9U) {
#line 264
    tmp = strtol((char const   * __restrict  )signame, (char ** __restrict  )(& endp),
                 10);
#line 264
    n = tmp;
#line 265
    if (! *endp) {
#line 265
      if (n <= 64L) {
#line 266
        return ((int )n);
      }
    }
  } else {
#line 271
    i = 0U;
#line 271
    while ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0])) {
#line 272
      tmp___0 = strcmp(numname_table[i].name, signame);
#line 272
      if (tmp___0 == 0) {
#line 273
        return (numname_table[i].num);
      }
#line 271
      i ++;
    }
#line 277
    tmp___1 = __libc_current_sigrtmin();
#line 277
    rtmin = tmp___1;
#line 278
    tmp___2 = __libc_current_sigrtmax();
#line 278
    rtmax = tmp___2;
#line 280
    if (0 < rtmin) {
#line 280
      tmp___6 = strncmp(signame, "RTMIN", (size_t )5);
#line 280
      if (tmp___6 == 0) {
#line 282
        tmp___3 = strtol((char const   * __restrict  )(signame + 5), (char ** __restrict  )(& endp___0),
                         10);
#line 282
        n___0 = tmp___3;
#line 283
        if (! *endp___0) {
#line 283
          if (0L <= n___0) {
#line 283
            if (n___0 <= (long )(rtmax - rtmin)) {
#line 284
              return ((int )((long )rtmin + n___0));
            }
          }
        }
      } else {
#line 280
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 286
    if (0 < rtmax) {
#line 286
      tmp___5 = strncmp(signame, "RTMAX", (size_t )5);
#line 286
      if (tmp___5 == 0) {
#line 288
        tmp___4 = strtol((char const   * __restrict  )(signame + 5), (char ** __restrict  )(& endp___0),
                         10);
#line 288
        n___1 = tmp___4;
#line 289
        if (! *endp___0) {
#line 289
          if ((long )(rtmin - rtmax) <= n___1) {
#line 289
            if (n___1 <= 0L) {
#line 290
              return ((int )((long )rtmax + n___1));
            }
          }
        }
      }
    }
  }
#line 295
  return (-1);
}
}
#line 301 "/home/wslee/project/coreutils-8.1/lib/sig2str.c"
int str2sig(char const   *signame , int *signum ) 
{ 
  int tmp ;

  {
#line 304
  *signum = str2signum(signame);
#line 305
  if (*signum < 0) {
#line 305
    tmp = -1;
  } else {
#line 305
    tmp = 0;
  }
#line 305
  return (tmp);
}
}
#line 312 "/home/wslee/project/coreutils-8.1/lib/sig2str.c"
int sig2str(int signum , char *signame ) 
{ 
  unsigned int i ;
  int rtmin ;
  int tmp ;
  int rtmax ;
  int tmp___0 ;
  int delta ;
  char const   *tmp___1 ;
  int delta___0 ;
  char const   *tmp___2 ;

  {
#line 316
  i = 0U;
#line 316
  while ((unsigned long )i < sizeof(numname_table) / sizeof(numname_table[0])) {
#line 317
    if (numname_table[i].num == signum) {
#line 319
      strcpy((char * __restrict  )signame, (char const   * __restrict  )(numname_table[i].name));
#line 320
      return (0);
    }
#line 316
    i ++;
  }
#line 324
  tmp = __libc_current_sigrtmin();
#line 324
  rtmin = tmp;
#line 325
  tmp___0 = __libc_current_sigrtmax();
#line 325
  rtmax = tmp___0;
#line 327
  if (rtmin <= signum) {
#line 327
    if (! (signum <= rtmax)) {
#line 328
      return (-1);
    }
  } else {
#line 328
    return (-1);
  }
#line 330
  if (signum <= rtmin + (rtmax - rtmin) / 2) {
#line 332
    delta = signum - rtmin;
#line 333
    if (delta) {
#line 333
      tmp___1 = "RTMIN+%d";
    } else {
#line 333
      tmp___1 = "RTMIN";
    }
#line 333
    sprintf((char * __restrict  )signame, (char const   * __restrict  )tmp___1, delta);
  } else {
#line 337
    delta___0 = rtmax - signum;
#line 338
    if (delta___0) {
#line 338
      tmp___2 = "RTMAX-%d";
    } else {
#line 338
      tmp___2 = "RTMAX";
    }
#line 338
    sprintf((char * __restrict  )signame, (char const   * __restrict  )tmp___2, delta___0);
  }
#line 341
  return (0);
}
}
#line 1 "cil-rtC6sAVf.o"
#pragma merger("0","../lib/sockets.o.i","")
#line 29 "/home/wslee/project/coreutils-8.1/lib/sockets.h"
int gl_sockets_startup(int version  __attribute__((__unused__)) ) ;
#line 30
int gl_sockets_cleanup(void) ;
#line 76 "/home/wslee/project/coreutils-8.1/lib/sockets.c"
int gl_sockets_startup(int version  __attribute__((__unused__)) ) 
{ 


  {
#line 99
  return (0);
}
}
#line 102 "/home/wslee/project/coreutils-8.1/lib/sockets.c"
int gl_sockets_cleanup(void) 
{ 


  {
#line 117
  return (0);
}
}
#line 1 "cil-PnnFQS0N.o"
#pragma merger("0","../lib/strftime.o.i","")
#line 29 "/home/wslee/project/coreutils-8.1/lib/strftime.h"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) ;
#line 316 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
static char *memcpy_lowcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 320
  while (1) {
#line 320
    tmp___0 = len;
#line 320
    len --;
#line 320
    if (! (tmp___0 > 0UL)) {
#line 320
      break;
    }
#line 321
    tmp = tolower((int )((unsigned char )*(src + len)));
#line 321
    *(dest + len) = (char )tmp;
  }
#line 322
  return (dest);
}
}
#line 325 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
static char *memcpy_uppcase(char *dest , char const   *src , size_t len ) 
{ 
  int tmp ;
  size_t tmp___0 ;

  {
#line 329
  while (1) {
#line 329
    tmp___0 = len;
#line 329
    len --;
#line 329
    if (! (tmp___0 > 0UL)) {
#line 329
      break;
    }
#line 330
    tmp = toupper((int )((unsigned char )*(src + len)));
#line 330
    *(dest + len) = (char )tmp;
  }
#line 331
  return (dest);
}
}
#line 420 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
static size_t strftime_case____0(_Bool upcase , char *s , size_t maxsize , char const   *format ,
                                 struct tm  const  *tp , int ut , int ns ) 
{ 
  int hour12 ;
  char const   *zone ;
  size_t i ;
  char *p ;
  char const   *f ;
  int pad ;
  int modifier ;
  int digits ;
  int number_value ;
  unsigned int u_number_value ;
  _Bool negative_number ;
  _Bool always_output_a_sign ;
  int tz_colon_mask ;
  char const   *subfmt ;
  char sign_char ;
  char *bufp ;
  char buf___0[3UL + (((sizeof(time_t ) * 8UL - 1UL) * 146UL) / 485UL + 2UL)] ;
  int width ;
  _Bool to_lowcase ;
  _Bool to_uppcase ;
  size_t colons ;
  _Bool change_case ;
  int format_char ;
  int _n ;
  int _delta ;
  int _incr ;
  int tmp ;
  char const   *tmp___0 ;
  int _n___0 ;
  int _delta___0 ;
  int _incr___0 ;
  int tmp___1 ;
  size_t len ;
  size_t tmp___2 ;
  int _n___1 ;
  int _delta___1 ;
  int _incr___1 ;
  int tmp___3 ;
  char ufmt[5] ;
  char *u ;
  char ubuf[1024] ;
  size_t len___0 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int _n___2 ;
  int _delta___2 ;
  int _incr___2 ;
  int tmp___8 ;
  int century ;
  int tmp___9 ;
  int tmp___10 ;
  int _n___3 ;
  int _delta___3 ;
  int _incr___3 ;
  int tmp___11 ;
  int padding ;
  int _n___4 ;
  int _delta___4 ;
  int _incr___4 ;
  int tmp___12 ;
  int _n___5 ;
  int _delta___5 ;
  int _incr___5 ;
  int tmp___13 ;
  int _n___6 ;
  int _delta___6 ;
  int _incr___6 ;
  int tmp___14 ;
  int _n___7 ;
  int _delta___7 ;
  int _incr___7 ;
  int tmp___15 ;
  int j ;
  int _n___8 ;
  int _delta___8 ;
  int _incr___8 ;
  int tmp___16 ;
  struct tm ltm ;
  time_t t ;
  int d ;
  int tmp___17 ;
  int _n___9 ;
  int _delta___9 ;
  int _incr___9 ;
  int tmp___18 ;
  int year___0 ;
  int tmp___19 ;
  int year_adjust ;
  int days ;
  int tmp___20 ;
  int tmp___21 ;
  int d___0 ;
  int tmp___22 ;
  int tmp___23 ;
  int yy ;
  int tmp___24 ;
  int yy___0 ;
  int _n___10 ;
  size_t tmp___25 ;
  int _delta___10 ;
  int _incr___10 ;
  int tmp___26 ;
  int diff ;
  int hour_diff ;
  int min_diff ;
  int sec_diff ;
  int flen ;
  int _n___11 ;
  int _delta___11 ;
  int _incr___11 ;
  int tmp___27 ;

  {
#line 433
  hour12 = (int )tp->tm_hour;
#line 458
  i = (size_t )0;
#line 459
  p = s;
#line 474
  zone = (char const   *)((void *)0);
#line 482
  zone = (char const   *)tp->tm_zone;
#line 500
  if (hour12 > 12) {
#line 501
    hour12 -= 12;
  } else
#line 503
  if (hour12 == 0) {
#line 504
    hour12 = 12;
  }
#line 506
  f = format;
#line 506
  while ((int const   )*f != 0) {
#line 508
    pad = 0;
#line 510
    digits = 0;
#line 524
    width = -1;
#line 525
    to_lowcase = (_Bool)0;
#line 526
    to_uppcase = upcase;
#line 528
    change_case = (_Bool)0;
#line 611
    if ((int const   )*f != 37) {
#line 613
      while (1) {
#line 613
        _n = 1;
#line 613
        _delta = width - _n;
#line 613
        if (_delta > 0) {
#line 613
          tmp = _delta;
        } else {
#line 613
          tmp = 0;
        }
#line 613
        _incr = _n + tmp;
#line 613
        if ((size_t )_incr >= maxsize - i) {
#line 613
          return ((size_t )0);
        }
#line 613
        if (p) {
#line 613
          if (digits == 0) {
#line 613
            if (_delta > 0) {
#line 613
              if (pad == 48) {
#line 613
                memset((void *)p, '0', (size_t )_delta);
#line 613
                p += _delta;
              } else {
#line 613
                memset((void *)p, ' ', (size_t )_delta);
#line 613
                p += _delta;
              }
            }
          }
#line 613
          *p = (char )*f;
#line 613
          p += _n;
        }
#line 613
        i += (size_t )_incr;
#line 613
        break;
      }
#line 614
      goto __Cont;
    }
#line 620
    while (1) {
#line 622
      f ++;
#line 622
      switch ((int const   )*f) {
      case 48: 
      case 45: 
      case 95: 
#line 628
      pad = (int )*f;
#line 629
      continue;
      case 94: 
#line 633
      to_uppcase = (_Bool)1;
#line 634
      continue;
      case 35: 
#line 636
      change_case = (_Bool)1;
#line 637
      continue;
      default: 
#line 640
      break;
      }
#line 642
      break;
    }
#line 646
    if ((unsigned int )*f - 48U <= 9U) {
#line 648
      width = 0;
#line 649
      while (1) {
#line 651
        if (width > 214748364) {
#line 654
          width = 2147483647;
        } else
#line 651
        if (width == 214748364) {
#line 651
          if ((int const   )*f - 48 > 7) {
#line 654
            width = 2147483647;
          } else {
#line 657
            width *= 10;
#line 658
            width += (int )((int const   )*f - 48);
          }
        } else {
#line 657
          width *= 10;
#line 658
          width += (int )((int const   )*f - 48);
        }
#line 660
        f ++;
#line 649
        if (! ((unsigned int )*f - 48U <= 9U)) {
#line 649
          break;
        }
      }
    }
#line 666
    switch ((int const   )*f) {
    case 79: 
    case 69: 
#line 670
    tmp___0 = f;
#line 670
    f ++;
#line 670
    modifier = (int )*tmp___0;
#line 671
    break;
    default: 
#line 674
    modifier = 0;
#line 675
    break;
    }
#line 679
    format_char = (int )*f;
#line 680
    switch (format_char) {
    case 37: 
#line 703
    if (modifier != 0) {
#line 704
      goto bad_format;
    }
#line 705
    while (1) {
#line 705
      _n___0 = 1;
#line 705
      _delta___0 = width - _n___0;
#line 705
      if (_delta___0 > 0) {
#line 705
        tmp___1 = _delta___0;
      } else {
#line 705
        tmp___1 = 0;
      }
#line 705
      _incr___0 = _n___0 + tmp___1;
#line 705
      if ((size_t )_incr___0 >= maxsize - i) {
#line 705
        return ((size_t )0);
      }
#line 705
      if (p) {
#line 705
        if (digits == 0) {
#line 705
          if (_delta___0 > 0) {
#line 705
            if (pad == 48) {
#line 705
              memset((void *)p, '0', (size_t )_delta___0);
#line 705
              p += _delta___0;
            } else {
#line 705
              memset((void *)p, ' ', (size_t )_delta___0);
#line 705
              p += _delta___0;
            }
          }
        }
#line 705
        *p = (char )*f;
#line 705
        p += _n___0;
      }
#line 705
      i += (size_t )_incr___0;
#line 705
      break;
    }
#line 706
    break;
    case 97: 
#line 709
    if (modifier != 0) {
#line 710
      goto bad_format;
    }
#line 711
    if (change_case) {
#line 713
      to_uppcase = (_Bool)1;
#line 714
      to_lowcase = (_Bool)0;
    }
#line 720
    goto underlying_strftime;
    case 65: 
#line 724
    if (modifier != 0) {
#line 725
      goto bad_format;
    }
#line 726
    if (change_case) {
#line 728
      to_uppcase = (_Bool)1;
#line 729
      to_lowcase = (_Bool)0;
    }
#line 735
    goto underlying_strftime;
    case 104: 
    case 98: 
#line 740
    if (change_case) {
#line 742
      to_uppcase = (_Bool)1;
#line 743
      to_lowcase = (_Bool)0;
    }
#line 745
    if (modifier != 0) {
#line 746
      goto bad_format;
    }
#line 751
    goto underlying_strftime;
    case 66: 
#line 755
    if (modifier != 0) {
#line 756
      goto bad_format;
    }
#line 757
    if (change_case) {
#line 759
      to_uppcase = (_Bool)1;
#line 760
      to_lowcase = (_Bool)0;
    }
#line 766
    goto underlying_strftime;
    case 99: 
#line 770
    if (modifier == 79) {
#line 771
      goto bad_format;
    }
#line 780
    goto underlying_strftime;
    subformat: 
#line 785
    tmp___2 = strftime_case____0(to_uppcase, (char *)((void *)0), (size_t )-1, subfmt,
                                 tp, ut, ns);
#line 785
    len = tmp___2;
#line 789
    while (1) {
#line 789
      _n___1 = (int )len;
#line 789
      _delta___1 = width - _n___1;
#line 789
      if (_delta___1 > 0) {
#line 789
        tmp___3 = _delta___1;
      } else {
#line 789
        tmp___3 = 0;
      }
#line 789
      _incr___1 = _n___1 + tmp___3;
#line 789
      if ((size_t )_incr___1 >= maxsize - i) {
#line 789
        return ((size_t )0);
      }
#line 789
      if (p) {
#line 789
        if (digits == 0) {
#line 789
          if (_delta___1 > 0) {
#line 789
            if (pad == 48) {
#line 789
              memset((void *)p, '0', (size_t )_delta___1);
#line 789
              p += _delta___1;
            } else {
#line 789
              memset((void *)p, ' ', (size_t )_delta___1);
#line 789
              p += _delta___1;
            }
          }
        }
#line 789
        strftime_case____0(to_uppcase, p, maxsize - i, subfmt, tp, ut, ns);
#line 789
        p += _n___1;
      }
#line 789
      i += (size_t )_incr___1;
#line 789
      break;
    }
#line 794
    break;
    underlying_strftime: 
#line 802
    u = ufmt;
#line 815
    tmp___4 = u;
#line 815
    u ++;
#line 815
    *tmp___4 = (char )' ';
#line 816
    tmp___5 = u;
#line 816
    u ++;
#line 816
    *tmp___5 = (char )'%';
#line 817
    if (modifier != 0) {
#line 818
      tmp___6 = u;
#line 818
      u ++;
#line 818
      *tmp___6 = (char )modifier;
    }
#line 819
    tmp___7 = u;
#line 819
    u ++;
#line 819
    *tmp___7 = (char )format_char;
#line 820
    *u = (char )'\000';
#line 821
    len___0 = strftime((char * __restrict  )(ubuf), sizeof(ubuf), (char const   * __restrict  )(ufmt),
                       (struct tm  const  * __restrict  )tp);
#line 822
    if (len___0 != 0UL) {
#line 823
      while (1) {
#line 823
        _n___2 = (int )(len___0 - 1UL);
#line 823
        _delta___2 = width - _n___2;
#line 823
        if (_delta___2 > 0) {
#line 823
          tmp___8 = _delta___2;
        } else {
#line 823
          tmp___8 = 0;
        }
#line 823
        _incr___2 = _n___2 + tmp___8;
#line 823
        if ((size_t )_incr___2 >= maxsize - i) {
#line 823
          return ((size_t )0);
        }
#line 823
        if (p) {
#line 823
          if (digits == 0) {
#line 823
            if (_delta___2 > 0) {
#line 823
              if (pad == 48) {
#line 823
                memset((void *)p, '0', (size_t )_delta___2);
#line 823
                p += _delta___2;
              } else {
#line 823
                memset((void *)p, ' ', (size_t )_delta___2);
#line 823
                p += _delta___2;
              }
            }
          }
#line 823
          if (to_lowcase) {
#line 823
            memcpy_lowcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
          } else
#line 823
          if (to_uppcase) {
#line 823
            memcpy_uppcase(p, (char const   *)(ubuf + 1), (size_t )_n___2);
          } else {
#line 823
            memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)(ubuf + 1)),
                   (size_t )_n___2);
          }
#line 823
          p += _n___2;
        }
#line 823
        i += (size_t )_incr___2;
#line 823
        break;
      }
    }
#line 825
    break;
    case 67: 
#line 829
    if (modifier == 79) {
#line 830
      goto bad_format;
    }
#line 831
    if (modifier == 69) {
#line 847
      goto underlying_strftime;
    }
#line 852
    century = (int )(tp->tm_year / 100 + 19);
#line 853
    if (tp->tm_year % 100 < 0) {
#line 853
      if (0 < century) {
#line 853
        tmp___9 = 1;
      } else {
#line 853
        tmp___9 = 0;
      }
    } else {
#line 853
      tmp___9 = 0;
    }
#line 853
    century -= tmp___9;
#line 854
    digits = 2;
#line 854
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 854
    u_number_value = (unsigned int )century;
#line 854
    goto do_signed_number;
    case 120: 
#line 858
    if (modifier == 79) {
#line 859
      goto bad_format;
    }
#line 868
    goto underlying_strftime;
    case 68: 
#line 871
    if (modifier != 0) {
#line 872
      goto bad_format;
    }
#line 873
    subfmt = "%m/%d/%y";
#line 874
    goto subformat;
    case 100: 
#line 877
    if (modifier == 69) {
#line 878
      goto bad_format;
    }
#line 880
    digits = 2;
#line 880
    number_value = (int )tp->tm_mday;
#line 880
    goto do_number;
    case 101: 
#line 883
    if (modifier == 69) {
#line 884
      goto bad_format;
    }
#line 886
    digits = 2;
#line 886
    number_value = (int )tp->tm_mday;
#line 886
    goto do_number_spacepad;
    do_tz_offset: 
#line 892
    always_output_a_sign = (_Bool)1;
#line 893
    goto do_number_body;
    do_number_spacepad: 
#line 897
    if (pad != 48) {
#line 897
      if (pad != 45) {
#line 898
        pad = '_';
      }
    }
    do_number: 
#line 902
    negative_number = (_Bool )(number_value < 0);
#line 903
    u_number_value = (unsigned int )number_value;
    do_signed_number: 
#line 906
    always_output_a_sign = (_Bool)0;
#line 907
    tz_colon_mask = 0;
    do_number_body: 
#line 915
    if (modifier == 79) {
#line 915
      if (! negative_number) {
#line 933
        goto underlying_strftime;
      }
    }
#line 937
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 939
    if (negative_number) {
#line 940
      u_number_value = - u_number_value;
    }
#line 942
    while (1) {
#line 944
      if (tz_colon_mask & 1) {
#line 945
        bufp --;
#line 945
        *bufp = (char )':';
      }
#line 946
      tz_colon_mask >>= 1;
#line 947
      bufp --;
#line 947
      *bufp = (char )(u_number_value % 10U + 48U);
#line 948
      u_number_value /= 10U;
#line 942
      if (! (u_number_value != 0U)) {
#line 942
        if (! (tz_colon_mask != 0)) {
#line 942
          break;
        }
      }
    }
    do_number_sign_and_padding: 
#line 953
    if (digits < width) {
#line 954
      digits = width;
    }
#line 956
    if (negative_number) {
#line 956
      sign_char = (char )'-';
    } else {
#line 956
      if (always_output_a_sign) {
#line 956
        tmp___10 = '+';
      } else {
#line 956
        tmp___10 = 0;
      }
#line 956
      sign_char = (char )tmp___10;
    }
#line 960
    if (pad == 45) {
#line 962
      if (sign_char) {
#line 963
        while (1) {
#line 963
          _n___3 = 1;
#line 963
          _delta___3 = width - _n___3;
#line 963
          if (_delta___3 > 0) {
#line 963
            tmp___11 = _delta___3;
          } else {
#line 963
            tmp___11 = 0;
          }
#line 963
          _incr___3 = _n___3 + tmp___11;
#line 963
          if ((size_t )_incr___3 >= maxsize - i) {
#line 963
            return ((size_t )0);
          }
#line 963
          if (p) {
#line 963
            if (digits == 0) {
#line 963
              if (_delta___3 > 0) {
#line 963
                if (pad == 48) {
#line 963
                  memset((void *)p, '0', (size_t )_delta___3);
#line 963
                  p += _delta___3;
                } else {
#line 963
                  memset((void *)p, ' ', (size_t )_delta___3);
#line 963
                  p += _delta___3;
                }
              }
            }
#line 963
            *p = sign_char;
#line 963
            p += _n___3;
          }
#line 963
          i += (size_t )_incr___3;
#line 963
          break;
        }
      }
    } else {
#line 967
      padding = (int )(((long )digits - ((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp)) - (long )(! (! sign_char)));
#line 970
      if (padding > 0) {
#line 972
        if (pad == 95) {
#line 974
          if ((size_t )padding >= maxsize - i) {
#line 975
            return ((size_t )0);
          }
#line 977
          if (p) {
#line 978
            memset((void *)p, ' ', (size_t )padding);
#line 978
            p += padding;
          }
#line 979
          i += (size_t )padding;
#line 980
          if (width > padding) {
#line 980
            width -= padding;
          } else {
#line 980
            width = 0;
          }
#line 981
          if (sign_char) {
#line 982
            while (1) {
#line 982
              _n___4 = 1;
#line 982
              _delta___4 = width - _n___4;
#line 982
              if (_delta___4 > 0) {
#line 982
                tmp___12 = _delta___4;
              } else {
#line 982
                tmp___12 = 0;
              }
#line 982
              _incr___4 = _n___4 + tmp___12;
#line 982
              if ((size_t )_incr___4 >= maxsize - i) {
#line 982
                return ((size_t )0);
              }
#line 982
              if (p) {
#line 982
                if (digits == 0) {
#line 982
                  if (_delta___4 > 0) {
#line 982
                    if (pad == 48) {
#line 982
                      memset((void *)p, '0', (size_t )_delta___4);
#line 982
                      p += _delta___4;
                    } else {
#line 982
                      memset((void *)p, ' ', (size_t )_delta___4);
#line 982
                      p += _delta___4;
                    }
                  }
                }
#line 982
                *p = sign_char;
#line 982
                p += _n___4;
              }
#line 982
              i += (size_t )_incr___4;
#line 982
              break;
            }
          }
        } else {
#line 986
          if ((size_t )digits >= maxsize - i) {
#line 987
            return ((size_t )0);
          }
#line 989
          if (sign_char) {
#line 990
            while (1) {
#line 990
              _n___5 = 1;
#line 990
              _delta___5 = width - _n___5;
#line 990
              if (_delta___5 > 0) {
#line 990
                tmp___13 = _delta___5;
              } else {
#line 990
                tmp___13 = 0;
              }
#line 990
              _incr___5 = _n___5 + tmp___13;
#line 990
              if ((size_t )_incr___5 >= maxsize - i) {
#line 990
                return ((size_t )0);
              }
#line 990
              if (p) {
#line 990
                if (digits == 0) {
#line 990
                  if (_delta___5 > 0) {
#line 990
                    if (pad == 48) {
#line 990
                      memset((void *)p, '0', (size_t )_delta___5);
#line 990
                      p += _delta___5;
                    } else {
#line 990
                      memset((void *)p, ' ', (size_t )_delta___5);
#line 990
                      p += _delta___5;
                    }
                  }
                }
#line 990
                *p = sign_char;
#line 990
                p += _n___5;
              }
#line 990
              i += (size_t )_incr___5;
#line 990
              break;
            }
          }
#line 992
          if (p) {
#line 993
            memset((void *)p, '0', (size_t )padding);
#line 993
            p += padding;
          }
#line 994
          i += (size_t )padding;
#line 995
          width = 0;
        }
      } else
#line 1000
      if (sign_char) {
#line 1001
        while (1) {
#line 1001
          _n___6 = 1;
#line 1001
          _delta___6 = width - _n___6;
#line 1001
          if (_delta___6 > 0) {
#line 1001
            tmp___14 = _delta___6;
          } else {
#line 1001
            tmp___14 = 0;
          }
#line 1001
          _incr___6 = _n___6 + tmp___14;
#line 1001
          if ((size_t )_incr___6 >= maxsize - i) {
#line 1001
            return ((size_t )0);
          }
#line 1001
          if (p) {
#line 1001
            if (digits == 0) {
#line 1001
              if (_delta___6 > 0) {
#line 1001
                if (pad == 48) {
#line 1001
                  memset((void *)p, '0', (size_t )_delta___6);
#line 1001
                  p += _delta___6;
                } else {
#line 1001
                  memset((void *)p, ' ', (size_t )_delta___6);
#line 1001
                  p += _delta___6;
                }
              }
            }
#line 1001
            *p = sign_char;
#line 1001
            p += _n___6;
          }
#line 1001
          i += (size_t )_incr___6;
#line 1001
          break;
        }
      }
    }
#line 1005
    while (1) {
#line 1005
      _n___7 = (int )((buf___0 + sizeof(buf___0) / sizeof(buf___0[0])) - bufp);
#line 1005
      _delta___7 = width - _n___7;
#line 1005
      if (_delta___7 > 0) {
#line 1005
        tmp___15 = _delta___7;
      } else {
#line 1005
        tmp___15 = 0;
      }
#line 1005
      _incr___7 = _n___7 + tmp___15;
#line 1005
      if ((size_t )_incr___7 >= maxsize - i) {
#line 1005
        return ((size_t )0);
      }
#line 1005
      if (p) {
#line 1005
        if (digits == 0) {
#line 1005
          if (_delta___7 > 0) {
#line 1005
            if (pad == 48) {
#line 1005
              memset((void *)p, '0', (size_t )_delta___7);
#line 1005
              p += _delta___7;
            } else {
#line 1005
              memset((void *)p, ' ', (size_t )_delta___7);
#line 1005
              p += _delta___7;
            }
          }
        }
#line 1005
        if (to_lowcase) {
#line 1005
          memcpy_lowcase(p, (char const   *)bufp, (size_t )_n___7);
        } else
#line 1005
        if (to_uppcase) {
#line 1005
          memcpy_uppcase(p, (char const   *)bufp, (size_t )_n___7);
        } else {
#line 1005
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)bufp),
                 (size_t )_n___7);
        }
#line 1005
        p += _n___7;
      }
#line 1005
      i += (size_t )_incr___7;
#line 1005
      break;
    }
#line 1006
    break;
    case 70: 
#line 1009
    if (modifier != 0) {
#line 1010
      goto bad_format;
    }
#line 1011
    subfmt = "%Y-%m-%d";
#line 1012
    goto subformat;
    case 72: 
#line 1015
    if (modifier == 69) {
#line 1016
      goto bad_format;
    }
#line 1018
    digits = 2;
#line 1018
    number_value = (int )tp->tm_hour;
#line 1018
    goto do_number;
    case 73: 
#line 1021
    if (modifier == 69) {
#line 1022
      goto bad_format;
    }
#line 1024
    digits = 2;
#line 1024
    number_value = hour12;
#line 1024
    goto do_number;
    case 107: 
#line 1027
    if (modifier == 69) {
#line 1028
      goto bad_format;
    }
#line 1030
    digits = 2;
#line 1030
    number_value = (int )tp->tm_hour;
#line 1030
    goto do_number_spacepad;
    case 108: 
#line 1033
    if (modifier == 69) {
#line 1034
      goto bad_format;
    }
#line 1036
    digits = 2;
#line 1036
    number_value = hour12;
#line 1036
    goto do_number_spacepad;
    case 106: 
#line 1039
    if (modifier == 69) {
#line 1040
      goto bad_format;
    }
#line 1042
    digits = 3;
#line 1042
    negative_number = (_Bool )(tp->tm_yday < -1);
#line 1042
    u_number_value = (unsigned int )tp->tm_yday + 1U;
#line 1042
    goto do_signed_number;
    case 77: 
#line 1045
    if (modifier == 69) {
#line 1046
      goto bad_format;
    }
#line 1048
    digits = 2;
#line 1048
    number_value = (int )tp->tm_min;
#line 1048
    goto do_number;
    case 109: 
#line 1051
    if (modifier == 69) {
#line 1052
      goto bad_format;
    }
#line 1054
    digits = 2;
#line 1054
    negative_number = (_Bool )(tp->tm_mon < -1);
#line 1054
    u_number_value = (unsigned int )tp->tm_mon + 1U;
#line 1054
    goto do_signed_number;
    case 78: 
#line 1058
    if (modifier == 69) {
#line 1059
      goto bad_format;
    }
#line 1061
    number_value = ns;
#line 1062
    if (width == -1) {
#line 1063
      width = 9;
    } else {
#line 1068
      j = width;
#line 1068
      while (j < 9) {
#line 1069
        number_value /= 10;
#line 1068
        j ++;
      }
    }
#line 1072
    digits = width;
#line 1072
    number_value = number_value;
#line 1072
    goto do_number;
    case 110: 
#line 1076
    while (1) {
#line 1076
      _n___8 = 1;
#line 1076
      _delta___8 = width - _n___8;
#line 1076
      if (_delta___8 > 0) {
#line 1076
        tmp___16 = _delta___8;
      } else {
#line 1076
        tmp___16 = 0;
      }
#line 1076
      _incr___8 = _n___8 + tmp___16;
#line 1076
      if ((size_t )_incr___8 >= maxsize - i) {
#line 1076
        return ((size_t )0);
      }
#line 1076
      if (p) {
#line 1076
        if (digits == 0) {
#line 1076
          if (_delta___8 > 0) {
#line 1076
            if (pad == 48) {
#line 1076
              memset((void *)p, '0', (size_t )_delta___8);
#line 1076
              p += _delta___8;
            } else {
#line 1076
              memset((void *)p, ' ', (size_t )_delta___8);
#line 1076
              p += _delta___8;
            }
          }
        }
#line 1076
        *p = (char )'\n';
#line 1076
        p += _n___8;
      }
#line 1076
      i += (size_t )_incr___8;
#line 1076
      break;
    }
#line 1077
    break;
    case 80: 
#line 1080
    to_lowcase = (_Bool)1;
#line 1082
    format_char = 'p';
    case 112: 
#line 1087
    if (change_case) {
#line 1089
      to_uppcase = (_Bool)0;
#line 1090
      to_lowcase = (_Bool)1;
    }
#line 1096
    goto underlying_strftime;
    case 82: 
#line 1100
    subfmt = "%H:%M";
#line 1101
    goto subformat;
    case 114: 
#line 1111
    goto underlying_strftime;
    case 83: 
#line 1115
    if (modifier == 69) {
#line 1116
      goto bad_format;
    }
#line 1118
    digits = 2;
#line 1118
    number_value = (int )tp->tm_sec;
#line 1118
    goto do_number;
    case 115: 
#line 1125
    ltm = (struct tm )*tp;
#line 1126
    t = mktime(& ltm);
#line 1131
    bufp = buf___0 + sizeof(buf___0) / sizeof(buf___0[0]);
#line 1132
    negative_number = (_Bool )(t < 0L);
#line 1134
    while (1) {
#line 1136
      d = (int )(t % 10L);
#line 1137
      t /= 10L;
#line 1138
      bufp --;
#line 1138
      if (negative_number) {
#line 1138
        tmp___17 = - d;
      } else {
#line 1138
        tmp___17 = d;
      }
#line 1138
      *bufp = (char )(tmp___17 + 48);
#line 1134
      if (! (t != 0L)) {
#line 1134
        break;
      }
    }
#line 1142
    digits = 1;
#line 1143
    always_output_a_sign = (_Bool)0;
#line 1144
    goto do_number_sign_and_padding;
    case 88: 
#line 1148
    if (modifier == 79) {
#line 1149
      goto bad_format;
    }
#line 1158
    goto underlying_strftime;
    case 84: 
#line 1161
    subfmt = "%H:%M:%S";
#line 1162
    goto subformat;
    case 116: 
#line 1165
    while (1) {
#line 1165
      _n___9 = 1;
#line 1165
      _delta___9 = width - _n___9;
#line 1165
      if (_delta___9 > 0) {
#line 1165
        tmp___18 = _delta___9;
      } else {
#line 1165
        tmp___18 = 0;
      }
#line 1165
      _incr___9 = _n___9 + tmp___18;
#line 1165
      if ((size_t )_incr___9 >= maxsize - i) {
#line 1165
        return ((size_t )0);
      }
#line 1165
      if (p) {
#line 1165
        if (digits == 0) {
#line 1165
          if (_delta___9 > 0) {
#line 1165
            if (pad == 48) {
#line 1165
              memset((void *)p, '0', (size_t )_delta___9);
#line 1165
              p += _delta___9;
            } else {
#line 1165
              memset((void *)p, ' ', (size_t )_delta___9);
#line 1165
              p += _delta___9;
            }
          }
        }
#line 1165
        *p = (char )'\t';
#line 1165
        p += _n___9;
      }
#line 1165
      i += (size_t )_incr___9;
#line 1165
      break;
    }
#line 1166
    break;
    case 117: 
#line 1169
    digits = 1;
#line 1169
    number_value = (int )(((tp->tm_wday - 1) + 7) % 7 + 1);
#line 1169
    goto do_number;
    case 85: 
#line 1172
    if (modifier == 69) {
#line 1173
      goto bad_format;
    }
#line 1175
    digits = 2;
#line 1175
    number_value = (int )(((tp->tm_yday - tp->tm_wday) + 7) / 7);
#line 1175
    goto do_number;
    case 71: 
    case 103: 
    case 86: 
#line 1180
    if (modifier == 69) {
#line 1181
      goto bad_format;
    }
#line 1187
    if (tp->tm_year < 0) {
#line 1187
      tmp___19 = 300;
    } else {
#line 1187
      tmp___19 = -100;
    }
#line 1187
    year___0 = (int )(tp->tm_year + (int const   )tmp___19);
#line 1191
    year_adjust = 0;
#line 1192
    tmp___20 = iso_week_days((int )tp->tm_yday, (int )tp->tm_wday);
#line 1192
    days = tmp___20;
#line 1194
    if (days < 0) {
#line 1197
      year_adjust = -1;
#line 1198
      if ((year___0 - 1) % 4 == 0) {
#line 1198
        if ((year___0 - 1) % 100 != 0) {
#line 1198
          tmp___21 = 1;
        } else
#line 1198
        if ((year___0 - 1) % 400 == 0) {
#line 1198
          tmp___21 = 1;
        } else {
#line 1198
          tmp___21 = 0;
        }
      } else {
#line 1198
        tmp___21 = 0;
      }
#line 1198
      days = iso_week_days((int )(tp->tm_yday + (int const   )(365 + tmp___21)), (int )tp->tm_wday);
    } else {
#line 1203
      if (year___0 % 4 == 0) {
#line 1203
        if (year___0 % 100 != 0) {
#line 1203
          tmp___22 = 1;
        } else
#line 1203
        if (year___0 % 400 == 0) {
#line 1203
          tmp___22 = 1;
        } else {
#line 1203
          tmp___22 = 0;
        }
      } else {
#line 1203
        tmp___22 = 0;
      }
#line 1203
      tmp___23 = iso_week_days((int )(tp->tm_yday - (int const   )(365 + tmp___22)),
                               (int )tp->tm_wday);
#line 1203
      d___0 = tmp___23;
#line 1205
      if (0 <= d___0) {
#line 1208
        year_adjust = 1;
#line 1209
        days = d___0;
      }
    }
#line 1213
    switch ((int const   )*f) {
    case 103: 
#line 1217
    yy = (int )((tp->tm_year % 100 + (int const   )year_adjust) % 100);
#line 1218
    digits = 2;
#line 1218
    if (0 <= yy) {
#line 1218
      number_value = yy;
    } else {
#line 1218
      if (tp->tm_year < (int const   )(-1900 - year_adjust)) {
#line 1218
        tmp___24 = - yy;
      } else {
#line 1218
        tmp___24 = yy + 100;
      }
#line 1218
      number_value = tmp___24;
    }
#line 1218
    goto do_number;
    case 71: 
#line 1226
    digits = 4;
#line 1226
    negative_number = (_Bool )(tp->tm_year < (int const   )(-1900 - year_adjust));
#line 1226
    u_number_value = ((unsigned int )tp->tm_year + 1900U) + (unsigned int )year_adjust;
#line 1226
    goto do_signed_number;
    default: 
#line 1231
    digits = 2;
#line 1231
    number_value = days / 7 + 1;
#line 1231
    goto do_number;
    }
    case 87: 
#line 1236
    if (modifier == 69) {
#line 1237
      goto bad_format;
    }
#line 1239
    digits = 2;
#line 1239
    number_value = (int )(((tp->tm_yday - ((tp->tm_wday - 1) + 7) % 7) + 7) / 7);
#line 1239
    goto do_number;
    case 119: 
#line 1242
    if (modifier == 69) {
#line 1243
      goto bad_format;
    }
#line 1245
    digits = 1;
#line 1245
    number_value = (int )tp->tm_wday;
#line 1245
    goto do_number;
    case 89: 
#line 1248
    if (modifier == 69) {
#line 1262
      goto underlying_strftime;
    }
#line 1265
    if (modifier == 79) {
#line 1266
      goto bad_format;
    } else {
#line 1268
      digits = 4;
    }
#line 1268
    negative_number = (_Bool )(tp->tm_year < -1900);
#line 1268
    u_number_value = (unsigned int )tp->tm_year + 1900U;
#line 1268
    goto do_signed_number;
    case 121: 
#line 1272
    if (modifier == 69) {
#line 1283
      goto underlying_strftime;
    }
#line 1288
    yy___0 = (int )(tp->tm_year % 100);
#line 1289
    if (yy___0 < 0) {
#line 1290
      if (tp->tm_year < -1900) {
#line 1290
        yy___0 = - yy___0;
      } else {
#line 1290
        yy___0 += 100;
      }
    }
#line 1291
    digits = 2;
#line 1291
    number_value = yy___0;
#line 1291
    goto do_number;
    case 90: 
#line 1295
    if (change_case) {
#line 1297
      to_uppcase = (_Bool)0;
#line 1298
      to_lowcase = (_Bool)1;
    }
#line 1306
    if (! zone) {
#line 1307
      zone = "";
    }
#line 1319
    while (1) {
#line 1319
      tmp___25 = strlen(zone);
#line 1319
      _n___10 = (int )tmp___25;
#line 1319
      _delta___10 = width - _n___10;
#line 1319
      if (_delta___10 > 0) {
#line 1319
        tmp___26 = _delta___10;
      } else {
#line 1319
        tmp___26 = 0;
      }
#line 1319
      _incr___10 = _n___10 + tmp___26;
#line 1319
      if ((size_t )_incr___10 >= maxsize - i) {
#line 1319
        return ((size_t )0);
      }
#line 1319
      if (p) {
#line 1319
        if (digits == 0) {
#line 1319
          if (_delta___10 > 0) {
#line 1319
            if (pad == 48) {
#line 1319
              memset((void *)p, '0', (size_t )_delta___10);
#line 1319
              p += _delta___10;
            } else {
#line 1319
              memset((void *)p, ' ', (size_t )_delta___10);
#line 1319
              p += _delta___10;
            }
          }
        }
#line 1319
        if (to_lowcase) {
#line 1319
          memcpy_lowcase(p, zone, (size_t )_n___10);
        } else
#line 1319
        if (to_uppcase) {
#line 1319
          memcpy_uppcase(p, zone, (size_t )_n___10);
        } else {
#line 1319
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)zone),
                 (size_t )_n___10);
        }
#line 1319
        p += _n___10;
      }
#line 1319
      i += (size_t )_incr___10;
#line 1319
      break;
    }
#line 1321
    break;
    case 58: 
#line 1326
    colons = (size_t )1;
#line 1326
    while ((int const   )*(f + colons) == 58) {
#line 1327
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1326
      colons ++;
    }
#line 1328
    if ((int const   )*(f + colons) != 122) {
#line 1329
      goto bad_format;
    }
#line 1330
    f += colons;
#line 1331
    goto do_z_conversion;
    case 122: 
#line 1334
    colons = (size_t )0;
    do_z_conversion: 
#line 1337
    if (tp->tm_isdst < 0) {
#line 1338
      break;
    }
#line 1346
    diff = (int )tp->tm_gmtoff;
#line 1383
    hour_diff = (diff / 60) / 60;
#line 1384
    min_diff = (diff / 60) % 60;
#line 1385
    sec_diff = diff % 60;
#line 1387
    switch (colons) {
    case 0UL: 
#line 1390
    digits = 5;
#line 1390
    negative_number = (_Bool )(diff < 0);
#line 1390
    tz_colon_mask = 0;
#line 1390
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1390
    goto do_tz_offset;
    tz_hh_mm: 
    case 1UL: 
#line 1393
    digits = 6;
#line 1393
    negative_number = (_Bool )(diff < 0);
#line 1393
    tz_colon_mask = 4;
#line 1393
    u_number_value = (unsigned int )(hour_diff * 100 + min_diff);
#line 1393
    goto do_tz_offset;
    tz_hh_mm_ss: 
    case 2UL: 
#line 1396
    digits = 9;
#line 1396
    negative_number = (_Bool )(diff < 0);
#line 1396
    tz_colon_mask = 20;
#line 1396
    u_number_value = (unsigned int )((hour_diff * 10000 + min_diff * 100) + sec_diff);
#line 1396
    goto do_tz_offset;
    case 3UL: 
#line 1400
    if (sec_diff != 0) {
#line 1401
      goto tz_hh_mm_ss;
    }
#line 1402
    if (min_diff != 0) {
#line 1403
      goto tz_hh_mm;
    }
#line 1404
    digits = 3;
#line 1404
    negative_number = (_Bool )(diff < 0);
#line 1404
    tz_colon_mask = 0;
#line 1404
    u_number_value = (unsigned int )hour_diff;
#line 1404
    goto do_tz_offset;
    default: 
#line 1407
    goto bad_format;
    }
    case 0: 
#line 1412
    f --;
    bad_format: 
    default: 
#line 1421
    flen = 1;
#line 1421
    while ((int const   )*(f + (1 - flen)) != 37) {
#line 1422
      goto __Cont___1;
      __Cont___1: /* CIL Label */ 
#line 1421
      flen ++;
    }
#line 1423
    while (1) {
#line 1423
      _n___11 = flen;
#line 1423
      _delta___11 = width - _n___11;
#line 1423
      if (_delta___11 > 0) {
#line 1423
        tmp___27 = _delta___11;
      } else {
#line 1423
        tmp___27 = 0;
      }
#line 1423
      _incr___11 = _n___11 + tmp___27;
#line 1423
      if ((size_t )_incr___11 >= maxsize - i) {
#line 1423
        return ((size_t )0);
      }
#line 1423
      if (p) {
#line 1423
        if (digits == 0) {
#line 1423
          if (_delta___11 > 0) {
#line 1423
            if (pad == 48) {
#line 1423
              memset((void *)p, '0', (size_t )_delta___11);
#line 1423
              p += _delta___11;
            } else {
#line 1423
              memset((void *)p, ' ', (size_t )_delta___11);
#line 1423
              p += _delta___11;
            }
          }
        }
#line 1423
        if (to_lowcase) {
#line 1423
          memcpy_lowcase(p, f + (1 - flen), (size_t )_n___11);
        } else
#line 1423
        if (to_uppcase) {
#line 1423
          memcpy_uppcase(p, f + (1 - flen), (size_t )_n___11);
        } else {
#line 1423
          memcpy((void * __restrict  )((void *)p), (void const   * __restrict  )((void const   *)(f + (1 - flen))),
                 (size_t )_n___11);
        }
#line 1423
        p += _n___11;
      }
#line 1423
      i += (size_t )_incr___11;
#line 1423
      break;
    }
#line 1425
    break;
    }
    __Cont: /* CIL Label */ 
#line 506
    f ++;
  }
#line 1430
  if (p) {
#line 1430
    if (maxsize != 0UL) {
#line 1431
      *p = (char )'\000';
    }
  }
#line 1434
  return (i);
}
}
#line 1443 "/home/wslee/project/coreutils-8.1/lib/strftime.c"
size_t nstrftime(char *s , size_t maxsize , char const   *format , struct tm  const  *tp ,
                 int ut , int ns ) 
{ 
  size_t tmp ;

  {
#line 1448
  tmp = strftime_case____0((_Bool)0, s, maxsize, format, tp, ut, ns);
#line 1448
  return (tmp);
}
}
#line 1 "cil-V6lnOBlA.o"
#pragma merger("0","../lib/striconv.o.i","")
#line 37 "/usr/include/iconv.h"
extern iconv_t iconv_open(char const   *__tocode , char const   *__fromcode ) ;
#line 42
extern size_t iconv(iconv_t __cd , char ** __restrict  __inbuf , size_t * __restrict  __inbytesleft ,
                    char ** __restrict  __outbuf , size_t * __restrict  __outbytesleft ) ;
#line 51
extern int iconv_close(iconv_t __cd ) ;
#line 45 "/home/wslee/project/coreutils-8.1/lib/striconv.h"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) ;
#line 56
char *str_cd_iconv(char const   *src , iconv_t cd ) ;
#line 67
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) ;
#line 43 "/home/wslee/project/coreutils-8.1/lib/striconv.c"
int mem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                 size_t *lengthp ) 
{ 
  size_t length ;
  char *result ;
  size_t count ;
  union __anonunion_tmp_771759453 tmp ;
  char const   *inptr ;
  size_t insize ;
  char *outptr ;
  size_t outsize ;
  size_t res ;
  size_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *outptr___0 ;
  size_t outsize___0 ;
  size_t res___0 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  char const   *inptr___0 ;
  size_t insize___0 ;
  char *outptr___1 ;
  size_t outsize___1 ;
  size_t res___1 ;
  size_t tmp___6 ;
  int *tmp___7 ;
  size_t res___2 ;
  size_t tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
#line 55
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
#line 60
  count = (size_t )0;
#line 65
  inptr = src;
#line 66
  insize = srclen;
#line 68
  while (insize > 0UL) {
#line 70
    outptr = tmp.buf;
#line 71
    outsize = (size_t )4096;
#line 72
    tmp___0 = iconv(cd, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& insize),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outsize));
#line 72
    res = tmp___0;
#line 76
    if (res == 0xffffffffffffffffUL) {
#line 78
      tmp___2 = __errno_location();
#line 78
      if (! (*tmp___2 == 7)) {
#line 80
        tmp___1 = __errno_location();
#line 80
        if (*tmp___1 == 22) {
#line 81
          break;
        } else {
#line 83
          return (-1);
        }
      }
    }
#line 96
    count += (size_t )(outptr - tmp.buf);
  }
#line 102
  outptr___0 = tmp.buf;
#line 103
  outsize___0 = (size_t )4096;
#line 104
  tmp___3 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                  (char ** __restrict  )(& outptr___0), (size_t * __restrict  )(& outsize___0));
#line 104
  res___0 = tmp___3;
#line 106
  if (res___0 == 0xffffffffffffffffUL) {
#line 107
    return (-1);
  }
#line 108
  count += (size_t )(outptr___0 - tmp.buf);
#line 111
  length = count;
#line 115
  if (length == 0UL) {
#line 117
    *lengthp = (size_t )0;
#line 118
    return (0);
  }
#line 120
  if ((unsigned long )*resultp != (unsigned long )((void *)0)) {
#line 120
    if (*lengthp >= length) {
#line 121
      result = *resultp;
    } else {
#line 120
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 124
    tmp___4 = malloc(length);
#line 124
    result = (char *)tmp___4;
#line 125
    if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 127
      tmp___5 = __errno_location();
#line 127
      *tmp___5 = 12;
#line 128
      return (-1);
    }
  }
#line 136
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
#line 141
  inptr___0 = src;
#line 142
  insize___0 = srclen;
#line 143
  outptr___1 = result;
#line 144
  outsize___1 = length;
#line 146
  while (insize___0 > 0UL) {
#line 148
    tmp___6 = iconv(cd, (char ** __restrict  )((char **)(& inptr___0)), (size_t * __restrict  )(& insize___0),
                    (char ** __restrict  )(& outptr___1), (size_t * __restrict  )(& outsize___1));
#line 148
    res___1 = tmp___6;
#line 152
    if (res___1 == 0xffffffffffffffffUL) {
#line 154
      tmp___7 = __errno_location();
#line 154
      if (*tmp___7 == 22) {
#line 155
        break;
      } else {
#line 157
        goto fail;
      }
    }
  }
#line 175
  tmp___8 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                  (char ** __restrict  )(& outptr___1), (size_t * __restrict  )(& outsize___1));
#line 175
  res___2 = tmp___8;
#line 177
  if (res___2 == 0xffffffffffffffffUL) {
#line 178
    goto fail;
  }
#line 181
  if (outsize___1 != 0UL) {
#line 182
    abort();
  }
#line 185
  *resultp = result;
#line 186
  *lengthp = length;
#line 188
  return (0);
  fail: 
#line 192
  if ((unsigned long )result != (unsigned long )*resultp) {
#line 194
    tmp___9 = __errno_location();
#line 194
    saved_errno = *tmp___9;
#line 195
    free((void *)result);
#line 196
    tmp___10 = __errno_location();
#line 196
    *tmp___10 = saved_errno;
  }
#line 198
  return (-1);
}
}
#line 203 "/home/wslee/project/coreutils-8.1/lib/striconv.c"
char *str_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  size_t result_size ;
  size_t length ;
  char const   *inptr ;
  size_t inbytes_remaining ;
  size_t tmp ;
  size_t approx_sqrt_SIZE_MAX ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *outptr ;
  size_t outbytes_remaining ;
  size_t res ;
  size_t tmp___2 ;
  size_t used ;
  size_t newsize ;
  char *newresult ;
  int *tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t res___0 ;
  size_t tmp___8 ;
  size_t used___0 ;
  size_t newsize___0 ;
  char *newresult___0 ;
  int *tmp___9 ;
  void *tmp___10 ;
  int *tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  char *smaller_result ;
  void *tmp___14 ;
  int saved_errno ;
  int *tmp___15 ;
  int *tmp___16 ;

  {
#line 253
  inptr = src;
#line 254
  tmp = strlen(src);
#line 254
  inbytes_remaining = tmp;
#line 259
  result_size = inbytes_remaining;
#line 261
  approx_sqrt_SIZE_MAX = 0xffffffffffffffffUL >> (sizeof(size_t ) * 8UL) / 2UL;
#line 262
  if (result_size <= approx_sqrt_SIZE_MAX / 16UL) {
#line 263
    result_size *= 16UL;
  }
#line 265
  result_size ++;
#line 267
  tmp___0 = malloc(result_size);
#line 267
  result = (char *)tmp___0;
#line 268
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 270
    tmp___1 = __errno_location();
#line 270
    *tmp___1 = 12;
#line 271
    return ((char *)((void *)0));
  }
#line 278
  iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
        (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0));
#line 283
  outptr = result;
#line 284
  outbytes_remaining = result_size - 1UL;
#line 286
  while (1) {
#line 290
    tmp___2 = iconv(cd, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& inbytes_remaining),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytes_remaining));
#line 290
    res = tmp___2;
#line 294
    if (res == 0xffffffffffffffffUL) {
#line 296
      tmp___7 = __errno_location();
#line 296
      if (*tmp___7 == 22) {
#line 297
        break;
      } else {
#line 298
        tmp___6 = __errno_location();
#line 298
        if (*tmp___6 == 7) {
#line 300
          used = (size_t )(outptr - result);
#line 301
          newsize = result_size * 2UL;
#line 304
          if (! (newsize > result_size)) {
#line 306
            tmp___3 = __errno_location();
#line 306
            *tmp___3 = 12;
#line 307
            goto failed;
          }
#line 309
          tmp___4 = realloc((void *)result, newsize);
#line 309
          newresult = (char *)tmp___4;
#line 310
          if ((unsigned long )newresult == (unsigned long )((void *)0)) {
#line 312
            tmp___5 = __errno_location();
#line 312
            *tmp___5 = 12;
#line 313
            goto failed;
          }
#line 315
          result = newresult;
#line 316
          result_size = newsize;
#line 317
          outptr = result + used;
#line 318
          outbytes_remaining = (result_size - 1UL) - used;
        } else {
#line 321
          goto failed;
        }
      }
    } else {
#line 324
      break;
    }
  }
#line 329
  while (1) {
#line 332
    tmp___8 = iconv(cd, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                    (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytes_remaining));
#line 332
    res___0 = tmp___8;
#line 334
    if (res___0 == 0xffffffffffffffffUL) {
#line 336
      tmp___12 = __errno_location();
#line 336
      if (*tmp___12 == 7) {
#line 338
        used___0 = (size_t )(outptr - result);
#line 339
        newsize___0 = result_size * 2UL;
#line 342
        if (! (newsize___0 > result_size)) {
#line 344
          tmp___9 = __errno_location();
#line 344
          *tmp___9 = 12;
#line 345
          goto failed;
        }
#line 347
        tmp___10 = realloc((void *)result, newsize___0);
#line 347
        newresult___0 = (char *)tmp___10;
#line 348
        if ((unsigned long )newresult___0 == (unsigned long )((void *)0)) {
#line 350
          tmp___11 = __errno_location();
#line 350
          *tmp___11 = 12;
#line 351
          goto failed;
        }
#line 353
        result = newresult___0;
#line 354
        result_size = newsize___0;
#line 355
        outptr = result + used___0;
#line 356
        outbytes_remaining = (result_size - 1UL) - used___0;
      } else {
#line 359
        goto failed;
      }
    } else {
#line 362
      break;
    }
  }
#line 367
  tmp___13 = outptr;
#line 367
  outptr ++;
#line 367
  *tmp___13 = (char )'\000';
#line 369
  length = (size_t )(outptr - result);
#line 373
  if (length < result_size) {
#line 375
    tmp___14 = realloc((void *)result, length);
#line 375
    smaller_result = (char *)tmp___14;
#line 377
    if ((unsigned long )smaller_result != (unsigned long )((void *)0)) {
#line 378
      result = smaller_result;
    }
  }
#line 381
  return (result);
  failed: 
#line 385
  tmp___15 = __errno_location();
#line 385
  saved_errno = *tmp___15;
#line 386
  free((void *)result);
#line 387
  tmp___16 = __errno_location();
#line 387
  *tmp___16 = saved_errno;
#line 388
  return ((char *)((void *)0));
}
}
#line 396 "/home/wslee/project/coreutils-8.1/lib/striconv.c"
char *str_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;
  iconv_t cd ;
  char *result___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int saved_errno___0 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 399
  if ((int const   )*src == 0) {
#line 399
    goto _L;
  } else {
#line 399
    tmp___6 = c_strcasecmp(from_codeset, to_codeset);
#line 399
    if (tmp___6 == 0) {
      _L: /* CIL Label */ 
#line 401
      tmp = strdup(src);
#line 401
      result = tmp;
#line 403
      if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 404
        tmp___0 = __errno_location();
#line 404
        *tmp___0 = 12;
      }
#line 405
      return (result);
    } else {
#line 422
      cd = iconv_open(to_codeset, from_codeset);
#line 423
      if ((unsigned long )cd == (unsigned long )((iconv_t )-1)) {
#line 424
        return ((char *)((void *)0));
      }
#line 426
      result___0 = str_cd_iconv(src, cd);
#line 428
      if ((unsigned long )result___0 == (unsigned long )((void *)0)) {
#line 431
        tmp___1 = __errno_location();
#line 431
        saved_errno = *tmp___1;
#line 432
        iconv_close(cd);
#line 433
        tmp___2 = __errno_location();
#line 433
        *tmp___2 = saved_errno;
      } else {
#line 437
        tmp___5 = iconv_close(cd);
#line 437
        if (tmp___5 < 0) {
#line 441
          tmp___3 = __errno_location();
#line 441
          saved_errno___0 = *tmp___3;
#line 442
          free((void *)result___0);
#line 443
          tmp___4 = __errno_location();
#line 443
          *tmp___4 = saved_errno___0;
#line 444
          return ((char *)((void *)0));
        }
      }
#line 447
      return (result___0);
    }
  }
}
}
#line 1 "cil-XeZEk8Jo.o"
#pragma merger("0","../lib/strintcmp.o.i","")
#line 1 "/home/wslee/project/coreutils-8.1/lib/strnumcmp.h"
int strintcmp(char const   *a , char const   *b ) ;
#line 74 "/home/wslee/project/coreutils-8.1/lib/strnumcmp-in.h"
__inline static int fraccompare(char const   *a , char const   *b , char decimal_point ) 
{ 
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 77
  if ((int const   )*a == (int const   )decimal_point) {
#line 77
    if ((int const   )*b == (int const   )decimal_point) {
#line 79
      while (1) {
#line 79
        a ++;
#line 79
        b ++;
#line 79
        if (! ((int const   )*a == (int const   )*b)) {
#line 79
          break;
        }
#line 80
        if (! ((unsigned int )*a - 48U <= 9U)) {
#line 81
          return (0);
        }
      }
#line 82
      if ((unsigned int )*a - 48U <= 9U) {
#line 82
        if ((unsigned int )*b - 48U <= 9U) {
#line 83
          return ((int )((int const   )*a - (int const   )*b));
        }
      }
#line 84
      if ((unsigned int )*a - 48U <= 9U) {
#line 85
        goto a_trailing_nonzero;
      }
#line 86
      if ((unsigned int )*b - 48U <= 9U) {
#line 87
        goto b_trailing_nonzero;
      }
#line 88
      return (0);
    } else {
#line 77
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 90
    tmp___0 = a;
#line 90
    a ++;
#line 90
    if ((int const   )*tmp___0 == (int const   )decimal_point) {
      a_trailing_nonzero: 
#line 93
      while ((int const   )*a == 48) {
#line 94
        a ++;
      }
#line 95
      return ((unsigned int )*a - 48U <= 9U);
    } else {
#line 97
      tmp = b;
#line 97
      b ++;
#line 97
      if ((int const   )*tmp == (int const   )decimal_point) {
        b_trailing_nonzero: 
#line 100
        while ((int const   )*b == 48) {
#line 101
          b ++;
        }
#line 102
        return (- ((unsigned int )*b - 48U <= 9U));
      }
    }
  }
#line 104
  return (0);
}
}
#line 114 "/home/wslee/project/coreutils-8.1/lib/strnumcmp-in.h"
__inline static int numcompare(char const   *a , char const   *b , int decimal_point ,
                               int thousands_sep ) 
{ 
  unsigned char tmpa ;
  unsigned char tmpb ;
  int tmp ;
  size_t log_a ;
  size_t log_b ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 118
  tmpa = (unsigned char )*a;
#line 119
  tmpb = (unsigned char )*b;
#line 124
  if ((int )tmpa == 45) {
#line 126
    while (1) {
#line 127
      a ++;
#line 127
      tmpa = (unsigned char )*a;
#line 126
      if (! ((int )tmpa == 48)) {
#line 126
        if (! ((int )tmpa == thousands_sep)) {
#line 126
          break;
        }
      }
    }
#line 129
    if ((int )tmpb != 45) {
#line 131
      if ((int )tmpa == decimal_point) {
#line 132
        while (1) {
#line 133
          a ++;
#line 133
          tmpa = (unsigned char )*a;
#line 132
          if (! ((int )tmpa == 48)) {
#line 132
            break;
          }
        }
      }
#line 135
      if ((unsigned int )tmpa - 48U <= 9U) {
#line 136
        return (-1);
      }
#line 137
      while (1) {
#line 137
        if (! ((int )tmpb == 48)) {
#line 137
          if (! ((int )tmpb == thousands_sep)) {
#line 137
            break;
          }
        }
#line 138
        b ++;
#line 138
        tmpb = (unsigned char )*b;
      }
#line 139
      if ((int )tmpb == decimal_point) {
#line 140
        while (1) {
#line 141
          b ++;
#line 141
          tmpb = (unsigned char )*b;
#line 140
          if (! ((int )tmpb == 48)) {
#line 140
            break;
          }
        }
      }
#line 143
      return (- ((unsigned int )tmpb - 48U <= 9U));
    }
#line 145
    while (1) {
#line 146
      b ++;
#line 146
      tmpb = (unsigned char )*b;
#line 145
      if (! ((int )tmpb == 48)) {
#line 145
        if (! ((int )tmpb == thousands_sep)) {
#line 145
          break;
        }
      }
    }
#line 149
    while (1) {
#line 149
      if ((int )tmpa == (int )tmpb) {
#line 149
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 149
          break;
        }
      } else {
#line 149
        break;
      }
#line 151
      while (1) {
#line 152
        a ++;
#line 152
        tmpa = (unsigned char )*a;
#line 151
        if (! ((int )tmpa == thousands_sep)) {
#line 151
          break;
        }
      }
#line 154
      while (1) {
#line 155
        b ++;
#line 155
        tmpb = (unsigned char )*b;
#line 154
        if (! ((int )tmpb == thousands_sep)) {
#line 154
          break;
        }
      }
    }
#line 159
    if ((int )tmpa == decimal_point) {
#line 159
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
#line 161
        tmp___0 = fraccompare(b, a, (char )decimal_point);
#line 161
        return (tmp___0);
      } else {
#line 159
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 159
    if ((int )tmpb == decimal_point) {
#line 159
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 161
        tmp___0 = fraccompare(b, a, (char )decimal_point);
#line 161
        return (tmp___0);
      }
    }
#line 163
    tmp = (int )tmpb - (int )tmpa;
#line 165
    log_a = (size_t )0;
#line 165
    while ((unsigned int )tmpa - 48U <= 9U) {
#line 166
      while (1) {
#line 167
        a ++;
#line 167
        tmpa = (unsigned char )*a;
#line 166
        if (! ((int )tmpa == thousands_sep)) {
#line 166
          break;
        }
      }
#line 165
      log_a ++;
    }
#line 170
    log_b = (size_t )0;
#line 170
    while ((unsigned int )tmpb - 48U <= 9U) {
#line 171
      while (1) {
#line 172
        b ++;
#line 172
        tmpb = (unsigned char )*b;
#line 171
        if (! ((int )tmpb == thousands_sep)) {
#line 171
          break;
        }
      }
#line 170
      log_b ++;
    }
#line 175
    if (log_a != log_b) {
#line 176
      if (log_a < log_b) {
#line 176
        tmp___1 = 1;
      } else {
#line 176
        tmp___1 = -1;
      }
#line 176
      return (tmp___1);
    }
#line 178
    if (! log_a) {
#line 179
      return (0);
    }
#line 181
    return (tmp);
  } else
#line 183
  if ((int )tmpb == 45) {
#line 185
    while (1) {
#line 186
      b ++;
#line 186
      tmpb = (unsigned char )*b;
#line 185
      if (! ((int )tmpb == 48)) {
#line 185
        if (! ((int )tmpb == thousands_sep)) {
#line 185
          break;
        }
      }
    }
#line 188
    if ((int )tmpb == decimal_point) {
#line 189
      while (1) {
#line 190
        b ++;
#line 190
        tmpb = (unsigned char )*b;
#line 189
        if (! ((int )tmpb == 48)) {
#line 189
          break;
        }
      }
    }
#line 192
    if ((unsigned int )tmpb - 48U <= 9U) {
#line 193
      return (1);
    }
#line 194
    while (1) {
#line 194
      if (! ((int )tmpa == 48)) {
#line 194
        if (! ((int )tmpa == thousands_sep)) {
#line 194
          break;
        }
      }
#line 195
      a ++;
#line 195
      tmpa = (unsigned char )*a;
    }
#line 196
    if ((int )tmpa == decimal_point) {
#line 197
      while (1) {
#line 198
        a ++;
#line 198
        tmpa = (unsigned char )*a;
#line 197
        if (! ((int )tmpa == 48)) {
#line 197
          break;
        }
      }
    }
#line 200
    return ((unsigned int )tmpa - 48U <= 9U);
  } else {
#line 204
    while (1) {
#line 204
      if (! ((int )tmpa == 48)) {
#line 204
        if (! ((int )tmpa == thousands_sep)) {
#line 204
          break;
        }
      }
#line 205
      a ++;
#line 205
      tmpa = (unsigned char )*a;
    }
#line 206
    while (1) {
#line 206
      if (! ((int )tmpb == 48)) {
#line 206
        if (! ((int )tmpb == thousands_sep)) {
#line 206
          break;
        }
      }
#line 207
      b ++;
#line 207
      tmpb = (unsigned char )*b;
    }
#line 209
    while (1) {
#line 209
      if ((int )tmpa == (int )tmpb) {
#line 209
        if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 209
          break;
        }
      } else {
#line 209
        break;
      }
#line 211
      while (1) {
#line 212
        a ++;
#line 212
        tmpa = (unsigned char )*a;
#line 211
        if (! ((int )tmpa == thousands_sep)) {
#line 211
          break;
        }
      }
#line 214
      while (1) {
#line 215
        b ++;
#line 215
        tmpb = (unsigned char )*b;
#line 214
        if (! ((int )tmpb == thousands_sep)) {
#line 214
          break;
        }
      }
    }
#line 219
    if ((int )tmpa == decimal_point) {
#line 219
      if (! ((unsigned int )tmpb - 48U <= 9U)) {
#line 221
        tmp___2 = fraccompare(a, b, (char )decimal_point);
#line 221
        return (tmp___2);
      } else {
#line 219
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 219
    if ((int )tmpb == decimal_point) {
#line 219
      if (! ((unsigned int )tmpa - 48U <= 9U)) {
#line 221
        tmp___2 = fraccompare(a, b, (char )decimal_point);
#line 221
        return (tmp___2);
      }
    }
#line 223
    tmp = (int )tmpa - (int )tmpb;
#line 225
    log_a = (size_t )0;
#line 225
    while ((unsigned int )tmpa - 48U <= 9U) {
#line 226
      while (1) {
#line 227
        a ++;
#line 227
        tmpa = (unsigned char )*a;
#line 226
        if (! ((int )tmpa == thousands_sep)) {
#line 226
          break;
        }
      }
#line 225
      log_a ++;
    }
#line 230
    log_b = (size_t )0;
#line 230
    while ((unsigned int )tmpb - 48U <= 9U) {
#line 231
      while (1) {
#line 232
        b ++;
#line 232
        tmpb = (unsigned char )*b;
#line 231
        if (! ((int )tmpb == thousands_sep)) {
#line 231
          break;
        }
      }
#line 230
      log_b ++;
    }
#line 235
    if (log_a != log_b) {
#line 236
      if (log_a < log_b) {
#line 236
        tmp___3 = -1;
      } else {
#line 236
        tmp___3 = 1;
      }
#line 236
      return (tmp___3);
    }
#line 238
    if (! log_a) {
#line 239
      return (0);
    }
#line 241
    return (tmp);
  }
}
}
#line 28 "/home/wslee/project/coreutils-8.1/lib/strintcmp.c"
int strintcmp(char const   *a , char const   *b ) 
{ 
  int tmp ;

  {
#line 31
  tmp = numcompare(a, b, -1, -1);
#line 31
  return (tmp);
}
}
#line 1 "cil-fhBfBPWP.o"
#pragma merger("0","../lib/stripslash.o.i","")
#line 71 "/home/wslee/project/coreutils-8.1/lib/dirname.h"
_Bool strip_trailing_slashes(char *file ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/stripslash.c"
_Bool strip_trailing_slashes(char *file ) 
{ 
  char *base ;
  char *tmp ;
  char *base_lim ;
  _Bool had_slash ;
  size_t tmp___0 ;

  {
#line 32
  tmp = last_component((char const   *)file);
#line 32
  base = tmp;
#line 38
  if (! *base) {
#line 39
    base = file;
  }
#line 40
  tmp___0 = base_len((char const   *)base);
#line 40
  base_lim = base + tmp___0;
#line 41
  had_slash = (_Bool )((int )*base_lim != 0);
#line 42
  *base_lim = (char )'\000';
#line 43
  return (had_slash);
}
}
#line 1 "cil-176WVxiJ.o"
#pragma merger("0","../lib/strnlen1.o.i","")
#line 27 "/home/wslee/project/coreutils-8.1/lib/strnlen1.c"
size_t strnlen1(char const   *string , size_t maxlen ) 
{ 
  char const   *end ;
  void *tmp ;

  {
#line 30
  tmp = memchr((void const   *)string, '\000', maxlen);
#line 30
  end = (char const   *)tmp;
#line 31
  if ((unsigned long )end != (unsigned long )((void *)0)) {
#line 32
    return ((size_t )((end - string) + 1L));
  } else {
#line 34
    return (maxlen);
  }
}
}
#line 1 "cil-Rm_XzJmb.o"
#pragma merger("0","../lib/strnumcmp.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/strnumcmp.h"
int strnumcmp(char const   *a , char const   *b , int decimal_point , int thousands_sep ) ;
#line 26 "/home/wslee/project/coreutils-8.1/lib/strnumcmp.c"
int strnumcmp(char const   *a , char const   *b , int decimal_point , int thousands_sep ) 
{ 
  int tmp ;

  {
#line 30
  tmp = numcompare(a, b, decimal_point, thousands_sep);
#line 30
  return (tmp);
}
}
#line 1 "cil-w4fHEZFK.o"
#pragma merger("0","../lib/tempname.o.i","")
#line 48 "/home/wslee/project/coreutils-8.1/lib/tempname.h"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) ;
#line 49
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) ;
#line 184 "/home/wslee/project/coreutils-8.1/lib/tempname.c"
__inline static _Bool check_x_suffix(char const   *s , size_t len ) 
{ 
  size_t tmp ;

  {
#line 187
  tmp = strspn(s, "X");
#line 187
  return ((_Bool )(len <= tmp));
}
}
#line 191 "/home/wslee/project/coreutils-8.1/lib/tempname.c"
static char const   letters[63]  = 
#line 191
  {      (char const   )'a',      (char const   )'b',      (char const   )'c',      (char const   )'d', 
        (char const   )'e',      (char const   )'f',      (char const   )'g',      (char const   )'h', 
        (char const   )'i',      (char const   )'j',      (char const   )'k',      (char const   )'l', 
        (char const   )'m',      (char const   )'n',      (char const   )'o',      (char const   )'p', 
        (char const   )'q',      (char const   )'r',      (char const   )'s',      (char const   )'t', 
        (char const   )'u',      (char const   )'v',      (char const   )'w',      (char const   )'x', 
        (char const   )'y',      (char const   )'z',      (char const   )'A',      (char const   )'B', 
        (char const   )'C',      (char const   )'D',      (char const   )'E',      (char const   )'F', 
        (char const   )'G',      (char const   )'H',      (char const   )'I',      (char const   )'J', 
        (char const   )'K',      (char const   )'L',      (char const   )'M',      (char const   )'N', 
        (char const   )'O',      (char const   )'P',      (char const   )'Q',      (char const   )'R', 
        (char const   )'S',      (char const   )'T',      (char const   )'U',      (char const   )'V', 
        (char const   )'W',      (char const   )'X',      (char const   )'Y',      (char const   )'Z', 
        (char const   )'0',      (char const   )'1',      (char const   )'2',      (char const   )'3', 
        (char const   )'4',      (char const   )'5',      (char const   )'6',      (char const   )'7', 
        (char const   )'8',      (char const   )'9',      (char const   )'\000'};
#line 208 "/home/wslee/project/coreutils-8.1/lib/tempname.c"
int gen_tempname_len(char *tmpl , int suffixlen , int flags , int kind , size_t x_suffix_len ) 
{ 
  size_t len ;
  char *XXXXXX ;
  unsigned int count ;
  int fd ;
  int save_errno ;
  int *tmp ;
  struct stat st ;
  struct randint_source *rand_src ;
  unsigned int attempts ;
  int *tmp___0 ;
  _Bool tmp___1 ;
  size_t i ;
  randint tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int saved_errno ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
#line 215
  fd = -1;
#line 216
  tmp = __errno_location();
#line 216
  save_errno = *tmp;
#line 234
  attempts = 238328U;
#line 237
  len = strlen((char const   *)tmpl);
#line 238
  if (len < x_suffix_len + (size_t )suffixlen) {
#line 242
    tmp___0 = __errno_location();
#line 242
    *tmp___0 = 22;
#line 243
    return (-1);
  } else {
#line 238
    tmp___1 = check_x_suffix((char const   *)(tmpl + ((len - x_suffix_len) - (size_t )suffixlen)),
                             x_suffix_len);
#line 238
    if (! tmp___1) {
#line 242
      tmp___0 = __errno_location();
#line 242
      *tmp___0 = 22;
#line 243
      return (-1);
    }
  }
#line 247
  XXXXXX = tmpl + ((len - x_suffix_len) - (size_t )suffixlen);
#line 250
  rand_src = randint_all_new((char const   *)((void *)0), (size_t )8);
#line 251
  if (! rand_src) {
#line 252
    return (-1);
  }
#line 254
  count = 0U;
#line 254
  while (count < attempts) {
#line 258
    i = (size_t )0;
#line 258
    while (i < x_suffix_len) {
#line 259
      tmp___2 = randint_genmax(rand_src, sizeof(letters) - 2UL);
#line 259
      *(XXXXXX + i) = (char )letters[tmp___2];
#line 258
      i ++;
    }
#line 261
    switch (kind) {
    case 0: 
#line 264
    fd = open((char const   *)tmpl, (((flags & -4) | 2) | 64) | 128, 384);
#line 267
    break;
    case 1: 
#line 270
    fd = mkdir((char const   *)tmpl, (__mode_t )448);
#line 271
    break;
    case 2: 
#line 278
    tmp___5 = lstat((char const   * __restrict  )tmpl, (struct stat * __restrict  )(& st));
#line 278
    if (tmp___5 < 0) {
#line 280
      tmp___4 = __errno_location();
#line 280
      if (*tmp___4 == 2) {
#line 282
        tmp___3 = __errno_location();
#line 282
        *tmp___3 = save_errno;
#line 283
        fd = 0;
#line 284
        goto done;
      } else {
#line 289
        fd = -1;
#line 290
        goto done;
      }
    }
#line 293
    goto __Cont;
    default: 
#line 296
    __assert_fail("! \"invalid KIND in __gen_tempname\"", "/home/wslee/project/coreutils-8.1/lib/tempname.c",
                  296U, "gen_tempname_len");
#line 297
    abort();
    }
#line 300
    if (fd >= 0) {
#line 302
      tmp___6 = __errno_location();
#line 302
      *tmp___6 = save_errno;
#line 303
      goto done;
    } else {
#line 305
      tmp___7 = __errno_location();
#line 305
      if (*tmp___7 != 17) {
#line 307
        fd = -1;
#line 308
        goto done;
      }
    }
    __Cont: /* CIL Label */ 
#line 254
    count ++;
  }
#line 312
  randint_all_free(rand_src);
#line 315
  tmp___8 = __errno_location();
#line 315
  *tmp___8 = 17;
#line 316
  return (-1);
  done: 
#line 320
  tmp___9 = __errno_location();
#line 320
  saved_errno = *tmp___9;
#line 321
  randint_all_free(rand_src);
#line 322
  tmp___10 = __errno_location();
#line 322
  *tmp___10 = saved_errno;
#line 324
  return (fd);
}
}
#line 327 "/home/wslee/project/coreutils-8.1/lib/tempname.c"
int gen_tempname(char *tmpl , int suffixlen , int flags , int kind ) 
{ 
  int tmp ;

  {
#line 330
  tmp = gen_tempname_len(tmpl, suffixlen, flags, kind, (size_t )6);
#line 330
  return (tmp);
}
}
#line 1 "cil-0IceSyuh.o"
#pragma merger("0","../lib/trim.o.i","")
#line 146 "/usr/include/wctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) iswspace)(wint_t __wc ) ;
#line 115 "/home/wslee/project/coreutils-8.1/lib/mbiter.h"
__inline static void mbiter_multi_next(struct mbiter_multi *iter ) 
{ 
  int tmp ;
  int tmp___0 ;
  _Bool tmp___1 ;

  {
#line 118
  if (iter->next_done) {
#line 119
    return;
  }
#line 120
  if (iter->in_shift) {
#line 121
    goto with_shift;
  }
#line 123
  tmp___1 = is_basic((char )*(iter->cur.ptr));
#line 123
  if (tmp___1) {
#line 128
    iter->cur.bytes = (size_t )1;
#line 129
    iter->cur.wc = (wchar_t )*(iter->cur.ptr);
#line 130
    iter->cur.wc_valid = (_Bool)1;
  } else {
#line 134
    tmp = mbsinit((mbstate_t const   *)(& iter->state));
#line 134
    if (! tmp) {
#line 134
      __assert_fail("mbsinit (&iter->state)", "/home/wslee/project/coreutils-8.1/lib/mbiter.h",
                    134U, "mbiter_multi_next");
    }
#line 135
    iter->in_shift = (_Bool)1;
    with_shift: 
#line 137
    iter->cur.bytes = mbrtowc((wchar_t * __restrict  )(& iter->cur.wc), (char const   * __restrict  )iter->cur.ptr,
                              (size_t )(iter->limit - iter->cur.ptr), (mbstate_t * __restrict  )(& iter->state));
#line 139
    if (iter->cur.bytes == 0xffffffffffffffffUL) {
#line 142
      iter->cur.bytes = (size_t )1;
#line 143
      iter->cur.wc_valid = (_Bool)0;
    } else
#line 147
    if (iter->cur.bytes == 0xfffffffffffffffeUL) {
#line 150
      iter->cur.bytes = (size_t )(iter->limit - iter->cur.ptr);
#line 151
      iter->cur.wc_valid = (_Bool)0;
    } else {
#line 157
      if (iter->cur.bytes == 0UL) {
#line 160
        iter->cur.bytes = (size_t )1;
#line 161
        if (! ((int const   )*(iter->cur.ptr) == 0)) {
#line 161
          __assert_fail("*iter->cur.ptr == \'\\0\'", "/home/wslee/project/coreutils-8.1/lib/mbiter.h",
                        161U, "mbiter_multi_next");
        }
#line 162
        if (! (iter->cur.wc == 0)) {
#line 162
          __assert_fail("iter->cur.wc == 0", "/home/wslee/project/coreutils-8.1/lib/mbiter.h",
                        162U, "mbiter_multi_next");
        }
      }
#line 164
      iter->cur.wc_valid = (_Bool)1;
#line 168
      tmp___0 = mbsinit((mbstate_t const   *)(& iter->state));
#line 168
      if (tmp___0) {
#line 169
        iter->in_shift = (_Bool)0;
      }
    }
  }
#line 172
  iter->next_done = (_Bool)1;
#line 173
  return;
}
}
#line 40 "/home/wslee/project/coreutils-8.1/lib/trim.c"
char *trim2(char const   *s , int how ) 
{ 
  char *d ;
  mbi_iterator_t i ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int state ;
  char *r ;
  size_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *p ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;
  unsigned short const   **tmp___11 ;
  size_t tmp___12 ;

  {
#line 45
  d = strdup(s);
#line 47
  if (! d) {
#line 48
    xalloc_die();
  }
#line 50
  tmp___12 = __ctype_get_mb_cur_max();
#line 50
  if (tmp___12 > 1UL) {
#line 55
    if (how != 0) {
#line 57
      i.cur.ptr = (char const   *)d;
#line 57
      tmp = strlen((char const   *)d);
#line 57
      i.limit = i.cur.ptr + tmp;
#line 57
      i.in_shift = (_Bool)0;
#line 57
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 57
      i.next_done = (_Bool)0;
#line 59
      while (1) {
#line 59
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
#line 59
          mbiter_multi_next(& i);
#line 59
          if (i.cur.wc_valid) {
#line 59
            tmp___0 = iswspace((wint_t )i.cur.wc);
#line 59
            if (! tmp___0) {
#line 59
              break;
            }
          } else {
#line 59
            break;
          }
        } else {
#line 59
          break;
        }
#line 59
        i.cur.ptr += i.cur.bytes;
#line 59
        i.next_done = (_Bool)0;
      }
#line 62
      tmp___1 = strlen(i.cur.ptr);
#line 62
      memmove((void *)d, (void const   *)i.cur.ptr, tmp___1 + 1UL);
    }
#line 66
    if (how != 1) {
#line 68
      state = 0;
#line 71
      i.cur.ptr = (char const   *)d;
#line 71
      tmp___2 = strlen((char const   *)d);
#line 71
      i.limit = i.cur.ptr + tmp___2;
#line 71
      i.in_shift = (_Bool)0;
#line 71
      memset((void *)(& i.state), '\000', sizeof(mbstate_t ));
#line 71
      i.next_done = (_Bool)0;
#line 73
      while (1) {
#line 73
        if ((unsigned long )i.cur.ptr < (unsigned long )i.limit) {
#line 73
          mbiter_multi_next(& i);
        } else {
#line 73
          break;
        }
#line 75
        if (state == 0) {
#line 75
          if (i.cur.wc_valid) {
#line 75
            tmp___3 = iswspace((wint_t )i.cur.wc);
#line 75
            if (tmp___3) {
#line 77
              state = 0;
#line 78
              goto __Cont;
            }
          }
        }
#line 81
        if (state == 0) {
#line 81
          if (i.cur.wc_valid) {
#line 81
            tmp___4 = iswspace((wint_t )i.cur.wc);
#line 81
            if (! tmp___4) {
#line 83
              state = 1;
#line 84
              goto __Cont;
            }
          } else {
#line 83
            state = 1;
#line 84
            goto __Cont;
          }
        }
#line 87
        if (state == 1) {
#line 87
          if (i.cur.wc_valid) {
#line 87
            tmp___5 = iswspace((wint_t )i.cur.wc);
#line 87
            if (! tmp___5) {
#line 89
              state = 1;
#line 90
              goto __Cont;
            }
          } else {
#line 89
            state = 1;
#line 90
            goto __Cont;
          }
        }
#line 93
        if (state == 1) {
#line 93
          if (i.cur.wc_valid) {
#line 93
            tmp___7 = iswspace((wint_t )i.cur.wc);
#line 93
            if (tmp___7) {
#line 95
              state = 2;
#line 96
              r = (char *)i.cur.ptr;
            } else {
#line 93
              goto _L;
            }
          } else {
#line 93
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 98
        if (state == 2) {
#line 98
          if (i.cur.wc_valid) {
#line 98
            tmp___6 = iswspace((wint_t )i.cur.wc);
#line 98
            if (tmp___6) {
#line 100
              state = 2;
            } else {
#line 104
              state = 1;
            }
          } else {
#line 104
            state = 1;
          }
        } else {
#line 104
          state = 1;
        }
        __Cont: /* CIL Label */ 
#line 73
        i.cur.ptr += i.cur.bytes;
#line 73
        i.next_done = (_Bool)0;
      }
#line 108
      if (state == 2) {
#line 109
        *r = (char )'\000';
      }
    }
  } else {
#line 117
    if (how != 0) {
#line 118
      p = d;
#line 118
      while (1) {
#line 118
        if (*p) {
#line 118
          tmp___8 = __ctype_b_loc();
#line 118
          if (! ((int const   )*(*tmp___8 + (int )((unsigned char )*p)) & 8192)) {
#line 118
            break;
          }
        } else {
#line 118
          break;
        }
#line 118
        p ++;
      }
#line 121
      tmp___9 = strlen((char const   *)p);
#line 121
      memmove((void *)d, (void const   *)p, tmp___9 + 1UL);
    }
#line 125
    if (how != 1) {
#line 126
      tmp___10 = strlen((char const   *)d);
#line 126
      p = (d + tmp___10) - 1;
#line 126
      while (1) {
#line 126
        if ((unsigned long )p >= (unsigned long )d) {
#line 126
          tmp___11 = __ctype_b_loc();
#line 126
          if (! ((int const   )*(*tmp___11 + (int )((unsigned char )*p)) & 8192)) {
#line 126
            break;
          }
        } else {
#line 126
          break;
        }
#line 127
        *p = (char )'\000';
#line 126
        p --;
      }
    }
  }
#line 131
  return (d);
}
}
#line 1 "cil-YvhTmgbm.o"
#pragma merger("0","../lib/uinttostr.o.i","")
#line 46 "/home/wslee/project/coreutils-8.1/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___0 ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) uinttostr)(unsigned int i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 32
  p = buf___0 + (((sizeof(unsigned int ) * 8UL) * 146UL) / 485UL + 1UL);
#line 33
  *p = (char)0;
#line 48
  while (1) {
#line 49
    p --;
#line 49
    *p = (char )(48U + i % 10U);
#line 48
    i /= 10U;
#line 48
    if (! (i != 0U)) {
#line 48
      break;
    }
  }
#line 53
  return (p);
}
}
#line 1 "cil-dBqlqqi9.o"
#pragma merger("0","../lib/umaxtostr.o.i","")
#line 45 "/home/wslee/project/coreutils-8.1/lib/inttostr.h"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___0 ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/inttostr.c"
char *( __attribute__((__warn_unused_result__)) umaxtostr)(uintmax_t i , char *buf___0 ) 
{ 
  char *p ;

  {
#line 32
  p = buf___0 + (((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL);
#line 33
  *p = (char)0;
#line 48
  while (1) {
#line 49
    p --;
#line 49
    *p = (char )(48UL + i % 10UL);
#line 48
    i /= 10UL;
#line 48
    if (! (i != 0UL)) {
#line 48
      break;
    }
  }
#line 53
  return (p);
}
}
#line 1 "cil-NCMvvJcs.o"
#pragma merger("0","../lib/unicodeio.o.i","")
#line 30 "/home/wslee/project/coreutils-8.1/lib/unicodeio.h"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) ;
#line 40
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) ;
#line 45
long fwrite_success_callback(char const   *buf___0 , size_t buflen , void *callback_arg ) ;
#line 301 "/home/wslee/project/coreutils-8.1/lib/unistr.h"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) ;
#line 307 "/home/wslee/project/coreutils-8.1/lib/unistr.h"
__inline static int u8_uctomb(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int tmp ;

  {
#line 310
  if (uc < 128U) {
#line 310
    if (n > 0) {
#line 312
      *(s + 0) = (uint8_t )uc;
#line 313
      return (1);
    } else {
#line 316
      tmp = u8_uctomb_aux(s, uc, n);
#line 316
      return (tmp);
    }
  } else {
#line 316
    tmp = u8_uctomb_aux(s, uc, n);
#line 316
    return (tmp);
  }
}
}
#line 72 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
static int initialized  ;
#line 73 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
static int is_utf8  ;
#line 75 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
static iconv_t utf8_to_local  ;
#line 64 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
long unicode_to_mb(unsigned int code , long (*success)(char const   *buf , size_t buflen ,
                                                       void *callback_arg ) , long (*failure)(unsigned int code ,
                                                                                              char const   *msg ,
                                                                                              void *callback_arg ) ,
                   void *callback_arg ) 
{ 
  char inbuf[6] ;
  int count ;
  char const   *charset ;
  char const   *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char outbuf[25] ;
  char const   *inptr ;
  size_t inbytesleft ;
  char *outptr ;
  size_t outbytesleft ;
  size_t res ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  long tmp___7 ;

  {
#line 81
  if (! initialized) {
#line 83
    tmp = locale_charset();
#line 83
    charset = tmp;
#line 85
    tmp___0 = strcmp(charset, "UTF-8");
#line 85
    if (tmp___0) {
#line 85
      tmp___1 = 0;
    } else {
#line 85
      tmp___1 = 1;
    }
#line 85
    is_utf8 = tmp___1;
#line 87
    if (! is_utf8) {
#line 89
      utf8_to_local = iconv_open(charset, "UTF-8");
#line 90
      if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
#line 92
        utf8_to_local = iconv_open("ASCII", "UTF-8");
      }
    }
#line 95
    initialized = 1;
  }
#line 99
  if (! is_utf8) {
#line 102
    if ((unsigned long )utf8_to_local == (unsigned long )((iconv_t )-1)) {
#line 103
      tmp___2 = (*failure)(code, "iconv function not usable", callback_arg);
#line 103
      return (tmp___2);
    }
  }
#line 110
  count = u8_uctomb((unsigned char *)(inbuf), code, (int )sizeof(inbuf));
#line 111
  if (count < 0) {
#line 112
    tmp___3 = (*failure)(code, "character out of range", callback_arg);
#line 112
    return (tmp___3);
  }
#line 115
  if (! is_utf8) {
#line 124
    inptr = (char const   *)(inbuf);
#line 125
    inbytesleft = (size_t )count;
#line 126
    outptr = outbuf;
#line 127
    outbytesleft = sizeof(outbuf);
#line 130
    res = iconv(utf8_to_local, (char ** __restrict  )((char **)(& inptr)), (size_t * __restrict  )(& inbytesleft),
                (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytesleft));
#line 133
    if (inbytesleft > 0UL) {
#line 139
      tmp___4 = (*failure)(code, (char const   *)((void *)0), callback_arg);
#line 139
      return (tmp___4);
    } else
#line 133
    if (res == 0xffffffffffffffffUL) {
#line 139
      tmp___4 = (*failure)(code, (char const   *)((void *)0), callback_arg);
#line 139
      return (tmp___4);
    }
#line 146
    res = iconv(utf8_to_local, (char ** __restrict  )((void *)0), (size_t * __restrict  )((void *)0),
                (char ** __restrict  )(& outptr), (size_t * __restrict  )(& outbytesleft));
#line 147
    if (res == 0xffffffffffffffffUL) {
#line 148
      tmp___5 = (*failure)(code, (char const   *)((void *)0), callback_arg);
#line 148
      return (tmp___5);
    }
#line 151
    tmp___6 = (*success)((char const   *)(outbuf), (size_t )(outptr - outbuf), callback_arg);
#line 151
    return (tmp___6);
  }
#line 156
  tmp___7 = (*success)((char const   *)(inbuf), (size_t )count, callback_arg);
#line 156
  return (tmp___7);
}
}
#line 161 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
long fwrite_success_callback(char const   *buf___0 , size_t buflen , void *callback_arg ) 
{ 
  FILE *stream ;
  size_t tmp ;

  {
#line 164
  stream = (FILE *)callback_arg;
#line 170
  tmp = fwrite((void const   * __restrict  )buf___0, (size_t )1, buflen, (FILE * __restrict  )stream);
#line 170
  ignore_value((int )tmp);
#line 171
  return (0L);
}
}
#line 175 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
static long exit_failure_callback(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 179
  if ((unsigned long )msg == (unsigned long )((void *)0)) {
#line 180
    tmp = gettext("cannot convert U+%04X to local character set");
#line 180
    error(1, 0, (char const   *)tmp, code);
  } else {
#line 182
    tmp___0 = gettext(msg);
#line 182
    tmp___1 = gettext("cannot convert U+%04X to local character set: %s");
#line 182
    error(1, 0, (char const   *)tmp___1, code, tmp___0);
  }
#line 184
  return (-1L);
}
}
#line 189 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
static long fallback_failure_callback(unsigned int code , char const   *msg  __attribute__((__unused__)) ,
                                      void *callback_arg ) 
{ 
  FILE *stream ;

  {
#line 194
  stream = (FILE *)callback_arg;
#line 196
  if (code < 65536U) {
#line 197
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\\u%04X", code);
  } else {
#line 199
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"\\U%08X", code);
  }
#line 200
  return (-1L);
}
}
#line 206 "/home/wslee/project/coreutils-8.1/lib/unicodeio.c"
void print_unicode_char(FILE *stream , unsigned int code , int exit_on_error ) 
{ 
  long (*tmp)(unsigned int code , char const   *msg , void *callback_arg  __attribute__((__unused__)) ) ;

  {
#line 209
  if (exit_on_error) {
#line 209
    tmp = & exit_failure_callback;
  } else {
#line 209
    tmp = & fallback_failure_callback;
  }
#line 209
  unicode_to_mb(code, & fwrite_success_callback, tmp, (void *)stream);
#line 214
  return;
}
}
#line 1 "cil-KQBbageD.o"
#pragma merger("0","../lib/userspec.o.i","")
#line 6 "/home/wslee/project/coreutils-8.1/lib/userspec.h"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 106 "/home/wslee/project/coreutils-8.1/lib/userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) ;
#line 106 "/home/wslee/project/coreutils-8.1/lib/userspec.c"
static char const   *E_invalid_user  =    "invalid user";
#line 107 "/home/wslee/project/coreutils-8.1/lib/userspec.c"
static char const   *E_invalid_group  =    "invalid group";
#line 108 "/home/wslee/project/coreutils-8.1/lib/userspec.c"
static char const   *E_bad_spec  =    "invalid spec";
#line 101 "/home/wslee/project/coreutils-8.1/lib/userspec.c"
static char const   *parse_with_separator(char const   *spec , char const   *separator ,
                                          uid_t *uid , gid_t *gid , char **username ,
                                          char **groupname ) 
{ 
  char const   *error_msg ;
  struct passwd *pwd ;
  struct group *grp ;
  char *u ;
  char const   *g ;
  char *gname ;
  uid_t unum ;
  gid_t gnum ;
  char *tmp ;
  size_t ulen ;
  void *tmp___0 ;
  struct passwd *tmp___1 ;
  _Bool use_login_group ;
  int tmp___2 ;
  unsigned long tmp___3 ;
  strtol_error tmp___4 ;
  char buf___0[(((sizeof(uintmax_t ) * 8UL) * 146UL) / 485UL + 1UL) + 1UL] ;
  char *tmp___5 ;
  char *tmp___6 ;
  struct group *tmp___7 ;
  unsigned long tmp___8 ;
  strtol_error tmp___9 ;
  char *tmp___10 ;

  {
#line 115
  gname = (char *)((void *)0);
#line 116
  unum = *uid;
#line 117
  gnum = *gid;
#line 119
  error_msg = (char const   *)((void *)0);
#line 120
  tmp = (char *)((void *)0);
#line 120
  *groupname = tmp;
#line 120
  *username = tmp;
#line 126
  u = (char *)((void *)0);
#line 127
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 129
    if (*spec) {
#line 130
      u = xstrdup(spec);
    }
  } else {
#line 134
    ulen = (size_t )(separator - spec);
#line 135
    if (ulen != 0UL) {
#line 137
      tmp___0 = xmemdup((void const   *)spec, ulen + 1UL);
#line 137
      u = (char *)tmp___0;
#line 138
      *(u + ulen) = (char )'\000';
    }
  }
#line 142
  if ((unsigned long )separator == (unsigned long )((void *)0)) {
#line 142
    g = (char const   *)((void *)0);
  } else
#line 142
  if ((int const   )*(separator + 1) == 0) {
#line 142
    g = (char const   *)((void *)0);
  } else {
#line 142
    g = separator + 1;
  }
#line 155
  if ((unsigned long )u != (unsigned long )((void *)0)) {
#line 158
    if ((int )*u == 43) {
#line 158
      pwd = (struct passwd *)((void *)0);
    } else {
#line 158
      tmp___1 = getpwnam((char const   *)u);
#line 158
      pwd = tmp___1;
    }
#line 159
    if ((unsigned long )pwd == (unsigned long )((void *)0)) {
#line 161
      if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 161
        if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 161
          tmp___2 = 1;
        } else {
#line 161
          tmp___2 = 0;
        }
      } else {
#line 161
        tmp___2 = 0;
      }
#line 161
      use_login_group = (_Bool )tmp___2;
#line 162
      if (use_login_group) {
#line 166
        error_msg = E_bad_spec;
      } else {
#line 171
        tmp___4 = xstrtoul((char const   *)u, (char **)((void *)0), 10, & tmp___3,
                           "");
#line 171
        if ((unsigned int )tmp___4 == 0U) {
#line 171
          if (tmp___3 <= 4294967295UL) {
#line 173
            unum = (uid_t )tmp___3;
          } else {
#line 175
            error_msg = E_invalid_user;
          }
        } else {
#line 175
          error_msg = E_invalid_user;
        }
      }
    } else {
#line 180
      unum = pwd->pw_uid;
#line 181
      if ((unsigned long )g == (unsigned long )((void *)0)) {
#line 181
        if ((unsigned long )separator != (unsigned long )((void *)0)) {
#line 186
          gnum = pwd->pw_gid;
#line 187
          grp = getgrgid(gnum);
#line 188
          if (grp) {
#line 188
            tmp___6 = grp->gr_name;
          } else {
#line 188
            tmp___5 = umaxtostr((uintmax_t )gnum, buf___0);
#line 188
            tmp___6 = tmp___5;
          }
#line 188
          gname = xstrdup((char const   *)tmp___6);
#line 189
          endgrent();
        }
      }
    }
#line 192
    endpwent();
  }
#line 195
  if ((unsigned long )g != (unsigned long )((void *)0)) {
#line 195
    if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 199
      if ((int const   )*g == 43) {
#line 199
        grp = (struct group *)((void *)0);
      } else {
#line 199
        tmp___7 = getgrnam(g);
#line 199
        grp = tmp___7;
      }
#line 200
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
#line 203
        tmp___9 = xstrtoul(g, (char **)((void *)0), 10, & tmp___8, "");
#line 203
        if ((unsigned int )tmp___9 == 0U) {
#line 203
          if (tmp___8 <= 4294967295UL) {
#line 204
            gnum = (gid_t )tmp___8;
          } else {
#line 206
            error_msg = E_invalid_group;
          }
        } else {
#line 206
          error_msg = E_invalid_group;
        }
      } else {
#line 209
        gnum = grp->gr_gid;
      }
#line 210
      endgrent();
#line 211
      gname = xstrdup(g);
    }
  }
#line 214
  if ((unsigned long )error_msg == (unsigned long )((void *)0)) {
#line 216
    *uid = unum;
#line 217
    *gid = gnum;
#line 218
    *username = u;
#line 219
    *groupname = gname;
#line 220
    u = (char *)((void *)0);
  } else {
#line 223
    free((void *)gname);
  }
#line 225
  free((void *)u);
#line 226
  tmp___10 = gettext(error_msg);
#line 226
  return ((char const   *)tmp___10);
}
}
#line 245 "/home/wslee/project/coreutils-8.1/lib/userspec.c"
char const   *parse_user_spec(char const   *spec , uid_t *uid , gid_t *gid , char **username ,
                              char **groupname ) 
{ 
  char const   *colon ;
  char *tmp ;
  char const   *error_msg ;
  char const   *tmp___0 ;
  char const   *dot ;
  char *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 249
  tmp = strchr(spec, ':');
#line 249
  colon = (char const   *)tmp;
#line 250
  tmp___0 = parse_with_separator(spec, colon, uid, gid, username, groupname);
#line 250
  error_msg = tmp___0;
#line 253
  if (! colon) {
#line 253
    if (error_msg) {
#line 261
      tmp___1 = strchr(spec, '.');
#line 261
      dot = (char const   *)tmp___1;
#line 262
      if (dot) {
#line 262
        tmp___2 = parse_with_separator(spec, dot, uid, gid, username, groupname);
#line 262
        if (! tmp___2) {
#line 264
          error_msg = (char const   *)((void *)0);
        }
      }
    }
  }
#line 267
  return (error_msg);
}
}
#line 1 "cil-urPqs6TT.o"
#pragma merger("0","../lib/utimecmp.o.i","")
#line 35 "/home/wslee/project/coreutils-8.1/lib/utimecmp.h"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) ;
#line 49 "/home/wslee/project/coreutils-8.1/lib/stat-time.h"
__inline static long get_stat_atime_ns(struct stat  const  *st ) 
{ 


  {
#line 53
  return ((long )st->st_atim.tv_nsec);
}
}
#line 62 "/home/wslee/project/coreutils-8.1/lib/stat-time.h"
__inline static long get_stat_ctime_ns(struct stat  const  *st ) 
{ 


  {
#line 66
  return ((long )st->st_ctim.tv_nsec);
}
}
#line 75 "/home/wslee/project/coreutils-8.1/lib/stat-time.h"
__inline static long get_stat_mtime_ns(struct stat  const  *st ) 
{ 


  {
#line 79
  return ((long )st->st_mtim.tv_nsec);
}
}
#line 4 "/home/wslee/project/coreutils-8.1/lib/utimens.h"
int utimens(char const   *file , struct timespec  const  *timespec ) ;
#line 5
int lutimens(char const   *file , struct timespec  const  *timespec ) ;
#line 80 "/home/wslee/project/coreutils-8.1/lib/utimecmp.c"
static size_t dev_info_hash(void const   *x , size_t table_size ) 
{ 
  struct fs_res  const  *p ;

  {
#line 83
  p = (struct fs_res  const  *)x;
#line 92
  return ((size_t )(p->dev % (unsigned long const   )table_size));
}
}
#line 96 "/home/wslee/project/coreutils-8.1/lib/utimecmp.c"
static _Bool dev_info_compare(void const   *x , void const   *y ) 
{ 
  struct fs_res  const  *a ;
  struct fs_res  const  *b ;

  {
#line 99
  a = (struct fs_res  const  *)x;
#line 100
  b = (struct fs_res  const  *)y;
#line 101
  return ((_Bool )(a->dev == b->dev));
}
}
#line 148 "/home/wslee/project/coreutils-8.1/lib/utimecmp.c"
static Hash_table *ht  ;
#line 151 "/home/wslee/project/coreutils-8.1/lib/utimecmp.c"
static struct fs_res *new_dst_res  ;
#line 117 "/home/wslee/project/coreutils-8.1/lib/utimecmp.c"
int utimecmp(char const   *dst_name , struct stat  const  *dst_stat , struct stat  const  *src_stat ,
             int options ) 
{ 
  time_t dst_s ;
  time_t src_s ;
  int dst_ns ;
  long tmp ;
  int src_ns ;
  long tmp___0 ;
  struct fs_res *dst_res ;
  int res ;
  void *tmp___1 ;
  void *tmp___2 ;
  time_t dst_a_s ;
  time_t dst_c_s ;
  time_t dst_m_s ;
  int dst_a_ns ;
  long tmp___3 ;
  int dst_c_ns ;
  long tmp___4 ;
  int dst_m_ns ;
  _Bool odd_second ;
  int a ;
  int c ;
  int m ;
  int SR10 ;
  struct timespec timespec[2] ;
  struct stat dst_status ;
  time_t s ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int stat_result ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  long tmp___11 ;
  int old_res ;
  int a___0 ;
  long tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 138
  dst_s = (time_t )dst_stat->st_mtim.tv_sec;
#line 139
  src_s = (time_t )src_stat->st_mtim.tv_sec;
#line 140
  tmp = get_stat_mtime_ns(dst_stat);
#line 140
  dst_ns = (int )tmp;
#line 141
  tmp___0 = get_stat_mtime_ns(src_stat);
#line 141
  src_ns = (int )tmp___0;
#line 143
  if (options & 1) {
#line 160
    if (dst_s == src_s) {
#line 160
      if (dst_ns == src_ns) {
#line 161
        return (0);
      }
    }
#line 162
    if (dst_s <= src_s - 2L) {
#line 163
      return (-1);
    }
#line 164
    if (src_s <= dst_s - 2L) {
#line 165
      return (1);
    }
#line 167
    if (! ht) {
#line 168
      ht = hash_initialize((size_t )16, (Hash_tuning const   *)((void *)0), & dev_info_hash,
                           & dev_info_compare, (void (*)(void * ))(& free));
    }
#line 169
    if (! new_dst_res) {
#line 171
      tmp___1 = xmalloc(sizeof(*new_dst_res));
#line 171
      new_dst_res = (struct fs_res *)tmp___1;
#line 172
      new_dst_res->resolution = 2000000000;
#line 173
      new_dst_res->exact = (_Bool)0;
    }
#line 175
    new_dst_res->dev = (dev_t )dst_stat->st_dev;
#line 176
    tmp___2 = hash_insert(ht, (void const   *)new_dst_res);
#line 176
    dst_res = (struct fs_res *)tmp___2;
#line 177
    if (! dst_res) {
#line 178
      xalloc_die();
    }
#line 180
    if ((unsigned long )dst_res == (unsigned long )new_dst_res) {
#line 184
      new_dst_res = (struct fs_res *)((void *)0);
    }
#line 187
    res = dst_res->resolution;
#line 202
    if (! dst_res->exact) {
#line 207
      dst_a_s = (time_t )dst_stat->st_atim.tv_sec;
#line 208
      dst_c_s = (time_t )dst_stat->st_ctim.tv_sec;
#line 209
      dst_m_s = dst_s;
#line 210
      tmp___3 = get_stat_atime_ns(dst_stat);
#line 210
      dst_a_ns = (int )tmp___3;
#line 211
      tmp___4 = get_stat_ctime_ns(dst_stat);
#line 211
      dst_c_ns = (int )tmp___4;
#line 212
      dst_m_ns = dst_ns;
#line 221
      odd_second = (_Bool )(((dst_a_s | dst_c_s) | dst_m_s) & 1L);
#line 230
      a = dst_a_ns;
#line 231
      c = dst_c_ns;
#line 232
      m = dst_m_ns;
#line 236
      SR10 = 1;
#line 236
      SR10 *= 10;
#line 238
      if (((a % SR10 | c % SR10) | m % SR10) != 0) {
#line 239
        res = 1;
      } else {
#line 241
        res = SR10;
#line 241
        a /= SR10;
#line 241
        c /= SR10;
#line 241
        m /= SR10;
#line 241
        while (1) {
#line 241
          if (res < dst_res->resolution) {
#line 241
            if (! (((a % 10 | c % 10) | m % 10) == 0)) {
#line 241
              break;
            }
          } else {
#line 241
            break;
          }
#line 245
          if (res == 1000000000) {
#line 247
            if (! odd_second) {
#line 248
              res *= 2;
            }
#line 249
            break;
          }
#line 241
          res *= 10;
#line 241
          a /= 10;
#line 241
          c /= 10;
#line 241
          m /= 10;
        }
      }
#line 253
      dst_res->resolution = res;
#line 256
      if (1 < res) {
#line 263
        src_ns = src_ns;
#line 269
        s = src_s & (long )(~ (res == 2000000000));
#line 270
        if (src_s < dst_s) {
#line 271
          return (1);
        } else
#line 270
        if (src_s == dst_s) {
#line 270
          if (src_ns <= dst_ns) {
#line 271
            return (1);
          }
        }
#line 272
        if (dst_s < s) {
#line 274
          return (-1);
        } else
#line 272
        if (dst_s == s) {
#line 272
          if (dst_ns < src_ns - src_ns % res) {
#line 274
            return (-1);
          }
        }
#line 283
        timespec[0].tv_sec = dst_a_s;
#line 284
        timespec[0].tv_nsec = (__syscall_slong_t )dst_a_ns;
#line 285
        timespec[1].tv_sec = dst_m_s | (long )(res == 2000000000);
#line 286
        timespec[1].tv_nsec = (__syscall_slong_t )(dst_m_ns + res / 9);
#line 291
        if ((dst_stat->st_mode & 61440U) == 40960U) {
#line 291
          tmp___5 = lutimens(dst_name, (struct timespec  const  *)(timespec));
#line 291
          tmp___7 = tmp___5;
        } else {
#line 291
          tmp___6 = utimens(dst_name, (struct timespec  const  *)(timespec));
#line 291
          tmp___7 = tmp___6;
        }
#line 291
        if (tmp___7 != 0) {
#line 294
          return (-2);
        }
#line 298
        if ((dst_stat->st_mode & 61440U) == 40960U) {
#line 298
          tmp___8 = lstat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_status));
#line 298
          tmp___10 = tmp___8;
        } else {
#line 298
          tmp___9 = stat((char const   * __restrict  )dst_name, (struct stat * __restrict  )(& dst_status));
#line 298
          tmp___10 = tmp___9;
        }
#line 298
        stat_result = tmp___10;
#line 302
        tmp___11 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
#line 302
        if (((long )stat_result | (dst_status.st_mtim.tv_sec ^ dst_m_s)) | (tmp___11 ^ (long )dst_m_ns)) {
#line 308
          timespec[1].tv_sec = dst_m_s;
#line 309
          timespec[1].tv_nsec = (__syscall_slong_t )dst_m_ns;
#line 310
          if ((dst_stat->st_mode & 61440U) == 40960U) {
#line 311
            lutimens(dst_name, (struct timespec  const  *)(timespec));
          } else {
#line 313
            utimens(dst_name, (struct timespec  const  *)(timespec));
          }
        }
#line 316
        if (stat_result != 0) {
#line 317
          return (-2);
        }
#line 323
        old_res = res;
#line 324
        tmp___12 = get_stat_mtime_ns((struct stat  const  *)(& dst_status));
#line 324
        a___0 = (int )(1000000000L * (dst_status.st_mtim.tv_sec & 1L) + tmp___12);
#line 327
        res = 1;
#line 329
        a___0 /= res;
#line 329
        while (a___0 % 10 != 0) {
#line 331
          if (res == 1000000000) {
#line 333
            res *= 2;
#line 334
            break;
          }
#line 336
          res *= 10;
#line 337
          if (res == old_res) {
#line 338
            break;
          }
#line 329
          a___0 /= 10;
        }
      }
#line 343
      dst_res->resolution = res;
#line 344
      dst_res->exact = (_Bool)1;
    }
#line 348
    src_s &= (long )(~ (res == 2000000000));
#line 349
    src_ns -= src_ns % res;
  }
#line 353
  if (dst_s < src_s) {
#line 353
    tmp___15 = -1;
  } else {
#line 353
    if (dst_s > src_s) {
#line 353
      tmp___14 = 1;
    } else {
#line 353
      if (dst_ns < src_ns) {
#line 353
        tmp___13 = -1;
      } else {
#line 353
        tmp___13 = dst_ns > src_ns;
      }
#line 353
      tmp___14 = tmp___13;
    }
#line 353
    tmp___15 = tmp___14;
  }
#line 353
  return (tmp___15);
}
}
#line 1 "cil-aGYVlGxQ.o"
#pragma merger("0","../lib/utimens.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/utimens.h"
int fdutimens(char const   *file , int fd , struct timespec  const  *timespec ) ;
#line 3
int gl_futimens(int fd , char const   *file , struct timespec  const  *timespec ) ;
#line 363 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) utimensat)(int __fd ,
                                                                                                char const   *__path ,
                                                                                                struct timespec  const  *__times ,
                                                                                                int __flags ) ;
#line 371
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimens)(int __fd ,
                                                                               struct timespec  const  *__times ) ;
#line 138 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 143
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) lutimes)(char const   *__file ,
                                                                                              struct timeval  const  *__tvp ) ;
#line 154
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) futimesat)(int __fd ,
                                                                                char const   *__file ,
                                                                                struct timeval  const  *__tvp ) ;
#line 60 "/home/wslee/project/coreutils-8.1/lib/utimens.c"
static int utimensat_works_really  ;
#line 75 "/home/wslee/project/coreutils-8.1/lib/utimens.c"
static int validate_timespec(struct timespec *timespec ) 
{ 
  int result ;
  int *tmp ;

  {
#line 78
  result = 0;
#line 79
  if (! timespec) {
#line 79
    __assert_fail("timespec", "/home/wslee/project/coreutils-8.1/lib/utimens.c", 79U,
                  "validate_timespec");
  }
#line 80
  if ((timespec + 0)->tv_nsec != (1L << 30) - 1L) {
#line 80
    if ((timespec + 0)->tv_nsec != (1L << 30) - 2L) {
#line 80
      if ((timespec + 0)->tv_nsec < 0L) {
#line 87
        tmp = __errno_location();
#line 87
        *tmp = 22;
#line 88
        return (-1);
      } else
#line 80
      if (1000000000L <= (timespec + 0)->tv_nsec) {
#line 87
        tmp = __errno_location();
#line 87
        *tmp = 22;
#line 88
        return (-1);
      } else {
#line 80
        goto _L___0;
      }
    } else {
#line 80
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 80
  if ((timespec + 1)->tv_nsec != (1L << 30) - 1L) {
#line 80
    if ((timespec + 1)->tv_nsec != (1L << 30) - 2L) {
#line 80
      if ((timespec + 1)->tv_nsec < 0L) {
#line 87
        tmp = __errno_location();
#line 87
        *tmp = 22;
#line 88
        return (-1);
      } else
#line 80
      if (1000000000L <= (timespec + 1)->tv_nsec) {
#line 87
        tmp = __errno_location();
#line 87
        *tmp = 22;
#line 88
        return (-1);
      }
    }
  }
#line 93
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 96
    (timespec + 0)->tv_sec = (__time_t )0;
#line 97
    result = 1;
  } else
#line 93
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 96
    (timespec + 0)->tv_sec = (__time_t )0;
#line 97
    result = 1;
  }
#line 99
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 102
    (timespec + 1)->tv_sec = (__time_t )0;
#line 103
    result = 1;
  } else
#line 99
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 102
    (timespec + 1)->tv_sec = (__time_t )0;
#line 103
    result = 1;
  }
#line 105
  return (result);
}
}
#line 114 "/home/wslee/project/coreutils-8.1/lib/utimens.c"
static _Bool update_timespec(struct stat  const  *statbuf , struct timespec **ts ) 
{ 
  struct timespec *timespec ;

  {
#line 117
  timespec = *ts;
#line 118
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 118
    if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 120
      return ((_Bool)1);
    }
  }
#line 121
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 121
    if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 124
      *ts = (struct timespec *)((void *)0);
#line 125
      return ((_Bool)0);
    }
  }
#line 128
  if ((timespec + 0)->tv_nsec == (1L << 30) - 2L) {
#line 129
    *(timespec + 0) = get_stat_atime(statbuf);
  } else
#line 130
  if ((timespec + 0)->tv_nsec == (1L << 30) - 1L) {
#line 131
    gettime(timespec + 0);
  }
#line 133
  if ((timespec + 1)->tv_nsec == (1L << 30) - 2L) {
#line 134
    *(timespec + 1) = get_stat_mtime(statbuf);
  } else
#line 135
  if ((timespec + 1)->tv_nsec == (1L << 30) - 1L) {
#line 136
    gettime(timespec + 1);
  }
#line 138
  return ((_Bool)0);
}
}
#line 151 "/home/wslee/project/coreutils-8.1/lib/utimens.c"
int fdutimens(char const   *file , int fd , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  int *tmp___0 ;
  int tmp___1 ;
  int result ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int result___0 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  struct stat st ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  _Bool tmp___11 ;
  struct timeval timeval[2] ;
  struct timeval  const  *t ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 155
  if (timespec) {
#line 155
    tmp = adjusted_timespec;
  } else {
#line 155
    tmp = (struct timespec *)((void *)0);
  }
#line 155
  ts = tmp;
#line 156
  adjustment_needed = 0;
#line 158
  if (ts) {
#line 160
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 161
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 162
    adjustment_needed = validate_timespec((struct timespec *)ts);
  }
#line 164
  if (adjustment_needed < 0) {
#line 165
    return (-1);
  }
#line 170
  if (! file) {
#line 172
    if (fd < 0) {
#line 174
      tmp___0 = __errno_location();
#line 174
      *tmp___0 = 9;
#line 175
      return (-1);
    }
#line 177
    tmp___1 = dup2(fd, fd);
#line 177
    if (tmp___1 != fd) {
#line 178
      return (-1);
    }
  }
#line 204
  if (0 <= utimensat_works_really) {
#line 207
    if (fd < 0) {
#line 209
      tmp___2 = utimensat(-100, file, (struct timespec  const  *)ts, 0);
#line 209
      result = tmp___2;
#line 218
      if (0 < result) {
#line 219
        tmp___3 = __errno_location();
#line 219
        *tmp___3 = 38;
      }
#line 221
      if (result == 0) {
#line 223
        utimensat_works_really = 1;
#line 224
        return (result);
      } else {
#line 221
        tmp___4 = __errno_location();
#line 221
        if (*tmp___4 != 38) {
#line 223
          utimensat_works_really = 1;
#line 224
          return (result);
        }
      }
    }
#line 230
    tmp___5 = futimens(fd, (struct timespec  const  *)ts);
#line 230
    result___0 = tmp___5;
#line 233
    if (0 < result___0) {
#line 234
      tmp___6 = __errno_location();
#line 234
      *tmp___6 = 38;
    }
#line 236
    if (result___0 == 0) {
#line 238
      utimensat_works_really = 1;
#line 239
      return (result___0);
    } else {
#line 236
      tmp___7 = __errno_location();
#line 236
      if (*tmp___7 != 38) {
#line 238
        utimensat_works_really = 1;
#line 239
        return (result___0);
      }
    }
  }
#line 244
  utimensat_works_really = -1;
#line 251
  if (adjustment_needed) {
#line 251
    goto _L;
  } else
#line 251
  if (0) {
    _L: /* CIL Label */ 
#line 254
    if (fd < 0) {
#line 254
      tmp___8 = stat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 254
      tmp___10 = tmp___8;
    } else {
#line 254
      tmp___9 = fstat(fd, & st);
#line 254
      tmp___10 = tmp___9;
    }
#line 254
    if (tmp___10) {
#line 255
      return (-1);
    }
#line 256
    if (ts) {
#line 256
      tmp___11 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
#line 256
      if (tmp___11) {
#line 257
        return (0);
      }
    }
  }
#line 264
  if (ts) {
#line 266
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 267
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 268
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 269
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 270
    t = (struct timeval  const  *)(timeval);
  } else {
#line 273
    t = (struct timeval  const  *)((void *)0);
  }
#line 275
  if (fd < 0) {
#line 278
    tmp___12 = futimesat(-100, file, (struct timeval  const  *)t);
#line 278
    return (tmp___12);
  } else {
#line 294
    tmp___13 = futimesat(fd, (char const   *)((void *)0), (struct timeval  const  *)t);
#line 294
    if (tmp___13 == 0) {
#line 295
      return (0);
    }
  }
#line 303
  if (! file) {
#line 309
    return (-1);
  }
#line 313
  tmp___14 = utimes(file, (struct timeval  const  *)t);
#line 313
  return (tmp___14);
}
}
#line 343 "/home/wslee/project/coreutils-8.1/lib/utimens.c"
int gl_futimens(int fd , char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
#line 346
  tmp = fdutimens(file, fd, timespec);
#line 346
  return (tmp);
}
}
#line 351 "/home/wslee/project/coreutils-8.1/lib/utimens.c"
int utimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  int tmp ;

  {
#line 354
  tmp = fdutimens(file, -1, timespec);
#line 354
  return (tmp);
}
}
#line 361 "/home/wslee/project/coreutils-8.1/lib/utimens.c"
int lutimens(char const   *file , struct timespec  const  *timespec ) 
{ 
  struct timespec adjusted_timespec[2] ;
  struct timespec *ts ;
  struct timespec *tmp ;
  int adjustment_needed ;
  struct stat st ;
  int result ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  _Bool tmp___4 ;
  struct timeval timeval[2] ;
  struct timeval  const  *t ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;

  {
#line 365
  if (timespec) {
#line 365
    tmp = adjusted_timespec;
  } else {
#line 365
    tmp = (struct timespec *)((void *)0);
  }
#line 365
  ts = tmp;
#line 366
  adjustment_needed = 0;
#line 369
  if (ts) {
#line 371
    adjusted_timespec[0] = (struct timespec )*(timespec + 0);
#line 372
    adjusted_timespec[1] = (struct timespec )*(timespec + 1);
#line 373
    adjustment_needed = validate_timespec((struct timespec *)ts);
  }
#line 375
  if (adjustment_needed < 0) {
#line 376
    return (-1);
  }
#line 384
  if (0 <= utimensat_works_really) {
#line 386
    tmp___0 = utimensat(-100, file, (struct timespec  const  *)ts, 256);
#line 386
    result = tmp___0;
#line 395
    if (0 < result) {
#line 396
      tmp___1 = __errno_location();
#line 396
      *tmp___1 = 38;
    }
#line 398
    if (result == 0) {
#line 400
      utimensat_works_really = 1;
#line 401
      return (result);
    } else {
#line 398
      tmp___2 = __errno_location();
#line 398
      if (*tmp___2 != 38) {
#line 400
        utimensat_works_really = 1;
#line 401
        return (result);
      }
    }
  }
#line 404
  utimensat_works_really = -1;
#line 411
  if (adjustment_needed) {
#line 411
    goto _L;
  } else
#line 411
  if (0) {
    _L: /* CIL Label */ 
#line 413
    tmp___3 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 413
    if (tmp___3) {
#line 414
      return (-1);
    }
#line 415
    if (ts) {
#line 415
      tmp___4 = update_timespec((struct stat  const  *)(& st), (struct timespec **)(& ts));
#line 415
      if (tmp___4) {
#line 416
        return (0);
      }
    }
  }
#line 423
  if (ts) {
#line 425
    timeval[0].tv_sec = (ts + 0)->tv_sec;
#line 426
    timeval[0].tv_usec = (ts + 0)->tv_nsec / 1000L;
#line 427
    timeval[1].tv_sec = (ts + 1)->tv_sec;
#line 428
    timeval[1].tv_usec = (ts + 1)->tv_nsec / 1000L;
#line 429
    t = (struct timeval  const  *)(timeval);
  } else {
#line 432
    t = (struct timeval  const  *)((void *)0);
  }
#line 434
  tmp___5 = lutimes(file, (struct timeval  const  *)t);
#line 434
  return (tmp___5);
#line 439
  if (! adjustment_needed) {
#line 439
    tmp___6 = lstat((char const   * __restrict  )file, (struct stat * __restrict  )(& st));
#line 439
    if (tmp___6) {
#line 440
      return (-1);
    }
  }
#line 441
  if (! ((st.st_mode & 61440U) == 40960U)) {
#line 442
    tmp___7 = fdutimens(file, -1, (struct timespec  const  *)ts);
#line 442
    return (tmp___7);
  }
#line 443
  tmp___8 = __errno_location();
#line 443
  *tmp___8 = 38;
#line 444
  return (-1);
}
}
#line 1 "cil-cM5xcCc_.o"
#pragma merger("0","../lib/vasnprintf.o.i","")
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 73 "/home/wslee/project/coreutils-8.1/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xsum4(size_t size1 , size_t size2 ,
                                                        size_t size3 , size_t size4 ) 
{ 
  size_t __attribute__((__pure__))  tmp ;
  size_t __attribute__((__pure__))  tmp___0 ;
  size_t __attribute__((__pure__))  tmp___1 ;

  {
#line 79
  tmp = xsum(size1, size2);
#line 79
  tmp___0 = xsum((size_t )tmp, size3);
#line 79
  tmp___1 = xsum((size_t )tmp___0, size4);
#line 79
  return (tmp___1);
}
}
#line 83 "/home/wslee/project/coreutils-8.1/lib/xsize.h"
__inline static size_t __attribute__((__pure__))  xmax(size_t size1 , size_t size2 ) 
{ 
  size_t tmp ;

  {
#line 91
  if (size1 >= size2) {
#line 91
    tmp = size1;
  } else {
#line 91
    tmp = size2;
  }
#line 91
  return ((size_t __attribute__((__pure__))  )tmp);
}
}
#line 259 "/home/wslee/project/coreutils-8.1/lib/vasnprintf.c"
static char decimal_point_char(void) 
{ 
  char const   *point ;
  char *tmp ;
  int tmp___0 ;

  {
#line 268
  tmp = nl_langinfo(65536);
#line 268
  point = (char const   *)tmp;
#line 277
  if ((int const   )*(point + 0) != 0) {
#line 277
    tmp___0 = (int const   )*(point + 0);
  } else {
#line 277
    tmp___0 = (int const   )'.';
  }
#line 277
  return ((char )tmp___0);
}
}
#line 296 "/home/wslee/project/coreutils-8.1/lib/vasnprintf.c"
static int is_infinite_or_zerol(long double x ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 299
  tmp = rpl_isnanl(x);
#line 299
  if (tmp) {
#line 299
    tmp___0 = 1;
  } else
#line 299
  if (x + x == x) {
#line 299
    tmp___0 = 1;
  } else {
#line 299
    tmp___0 = 0;
  }
#line 299
  return (tmp___0);
}
}
#line 3322
extern int ( /* missing proto */  __builtin_signbitl)() ;
#line 3322
extern int ( /* missing proto */  __builtin_signbit)() ;
#line 3322
#line 1477 "/home/wslee/project/coreutils-8.1/lib/vasnprintf.c"
char *( /* format attribute */  vasnprintf)(char *resultbuf , size_t *lengthp , char const   *format ,
                                            va_list args ) 
{ 
  char_directives d ;
  arguments a ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  size_t buf_neededlength ;
  char *buf___0 ;
  char *buf_malloced ;
  char const   *cp ;
  size_t i ;
  char_directive *dp ;
  char *result ;
  size_t allocated ;
  size_t length ;
  size_t __attribute__((__pure__))  tmp___2 ;
  void *tmp___3 ;
  size_t buf_memsize ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t n ;
  size_t augmented_length ;
  size_t __attribute__((__pure__))  tmp___6 ;
  size_t memory_size ;
  char *memory ;
  size_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  size_t tmp___10 ;
  char const   *tmp___11 ;
  size_t augmented_length___0 ;
  size_t __attribute__((__pure__))  tmp___12 ;
  size_t memory_size___0 ;
  char *memory___0 ;
  size_t tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int flags ;
  int has_width ;
  size_t width ;
  int has_precision ;
  size_t precision ;
  size_t tmp_length ;
  char tmpbuf[700] ;
  char *tmp___16 ;
  char *pad_ptr ;
  char *p ;
  int arg ;
  char const   *digitp ;
  char const   *tmp___17 ;
  size_t tmp___18 ;
  size_t __attribute__((__pure__))  tmp___19 ;
  int arg___0 ;
  char const   *digitp___0 ;
  char const   *tmp___20 ;
  size_t tmp___21 ;
  size_t __attribute__((__pure__))  tmp___22 ;
  size_t __attribute__((__pure__))  tmp___23 ;
  size_t __attribute__((__pure__))  tmp___24 ;
  size_t tmp_memsize ;
  size_t tmp___25 ;
  void *tmp___26 ;
  long double arg___1 ;
  char *tmp___27 ;
  char *tmp___28 ;
  char *tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  int sign ;
  fpucw_t oldcw ;
  fpucw_t _cw ;
  fpucw_t _ncw ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  char *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  char *tmp___46 ;
  char *tmp___47 ;
  char *tmp___48 ;
  char *tmp___49 ;
  char *tmp___50 ;
  char *tmp___51 ;
  char *tmp___52 ;
  char *tmp___53 ;
  char *tmp___54 ;
  char *tmp___55 ;
  char *tmp___56 ;
  char *tmp___57 ;
  size_t ndigits ;
  size_t tmp___58 ;
  char *tmp___59 ;
  char *tmp___60 ;
  char *tmp___61 ;
  char *tmp___62 ;
  char *tmp___63 ;
  char *tmp___64 ;
  char *tmp___65 ;
  char *tmp___66 ;
  char *tmp___67 ;
  char *tmp___68 ;
  fpucw_t _ncw___0 ;
  int tmp___69 ;
  size_t pad ;
  char *end ;
  char *tmp___70 ;
  char *q ;
  char *tmp___71 ;
  char *q___0 ;
  char *tmp___72 ;
  size_t count ;
  size_t n___0 ;
  size_t __attribute__((__pure__))  tmp___73 ;
  size_t memory_size___1 ;
  char *memory___1 ;
  size_t tmp___74 ;
  void *tmp___75 ;
  void *tmp___76 ;
  arg_type type ;
  int flags___0 ;
  char *fbp ;
  unsigned int prefix_count ;
  int prefixes[2] ;
  char *tmp___77 ;
  char *tmp___78 ;
  char *tmp___79 ;
  char *tmp___80 ;
  char *tmp___81 ;
  char *tmp___82 ;
  char *tmp___83 ;
  size_t n___1 ;
  char const   *mp ;
  char *tmp___84 ;
  char const   *tmp___85 ;
  size_t n___2 ;
  char const   *mp___0 ;
  char *tmp___86 ;
  char const   *tmp___87 ;
  char *tmp___88 ;
  char *tmp___89 ;
  char *tmp___90 ;
  unsigned int tmp___91 ;
  unsigned int tmp___92 ;
  size_t memory_size___2 ;
  char *memory___2 ;
  size_t tmp___93 ;
  size_t __attribute__((__pure__))  tmp___94 ;
  size_t __attribute__((__pure__))  tmp___95 ;
  void *tmp___96 ;
  void *tmp___97 ;
  size_t __attribute__((__pure__))  tmp___98 ;
  int count___0 ;
  int retcount ;
  size_t maxlen ;
  int arg___2 ;
  unsigned int arg___3 ;
  int arg___4 ;
  unsigned int arg___5 ;
  int arg___6 ;
  unsigned int arg___7 ;
  long arg___8 ;
  unsigned long arg___9 ;
  long long arg___10 ;
  unsigned long long arg___11 ;
  double arg___12 ;
  long double arg___13 ;
  int arg___14 ;
  wint_t arg___15 ;
  char const   *arg___16 ;
  wchar_t const   *arg___17 ;
  void *arg___18 ;
  size_t bigger_need ;
  size_t tmp___99 ;
  size_t __attribute__((__pure__))  tmp___100 ;
  size_t memory_size___3 ;
  char *memory___3 ;
  size_t tmp___101 ;
  void *tmp___102 ;
  void *tmp___103 ;
  int *tmp___104 ;
  size_t n___3 ;
  size_t tmp___105 ;
  size_t __attribute__((__pure__))  tmp___106 ;
  size_t __attribute__((__pure__))  tmp___107 ;
  size_t memory_size___4 ;
  char *memory___4 ;
  size_t tmp___108 ;
  void *tmp___109 ;
  void *tmp___110 ;
  int tmp___111 ;
  size_t memory_size___5 ;
  char *memory___5 ;
  size_t tmp___112 ;
  size_t __attribute__((__pure__))  tmp___113 ;
  size_t __attribute__((__pure__))  tmp___114 ;
  void *tmp___115 ;
  void *tmp___116 ;
  size_t __attribute__((__pure__))  tmp___117 ;
  char *memory___6 ;
  void *tmp___118 ;
  int *tmp___119 ;
  int *tmp___120 ;

  {
#line 1484
  tmp = printf_parse(format, & d, & a);
#line 1484
  if (tmp < 0) {
#line 1486
    return ((char *)((void *)0));
  }
#line 1493
  tmp___1 = printf_fetchargs(args, & a);
#line 1493
  if (tmp___1 < 0) {
#line 1495
    free((void *)d.dir);
#line 1495
    if (a.arg) {
#line 1495
      free((void *)a.arg);
    }
#line 1496
    tmp___0 = __errno_location();
#line 1496
    *tmp___0 = 22;
#line 1497
    return ((char *)((void *)0));
  }
#line 1514
  tmp___2 = xsum4((size_t )7, d.max_width_length, d.max_precision_length, (size_t )6);
#line 1514
  buf_neededlength = (size_t )tmp___2;
#line 1517
  if (buf_neededlength < 4000UL / sizeof(char )) {
#line 1519
    tmp___3 = __builtin_alloca(buf_neededlength * sizeof(char ));
#line 1519
    buf___0 = (char *)tmp___3;
#line 1520
    buf_malloced = (char *)((void *)0);
  } else {
#line 1525
    if (buf_neededlength <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1525
      tmp___4 = buf_neededlength * sizeof(char );
    } else {
#line 1525
      tmp___4 = 0xffffffffffffffffUL;
    }
#line 1525
    buf_memsize = tmp___4;
#line 1526
    if (buf_memsize == 0xffffffffffffffffUL) {
#line 1527
      goto out_of_memory_1;
    }
#line 1528
    tmp___5 = malloc(buf_memsize);
#line 1528
    buf___0 = (char *)tmp___5;
#line 1529
    if ((unsigned long )buf___0 == (unsigned long )((void *)0)) {
#line 1530
      goto out_of_memory_1;
    }
#line 1531
    buf_malloced = buf___0;
  }
#line 1534
  if ((unsigned long )resultbuf != (unsigned long )((void *)0)) {
#line 1536
    result = resultbuf;
#line 1537
    allocated = *lengthp;
  } else {
#line 1541
    result = (char *)((void *)0);
#line 1542
    allocated = (size_t )0;
  }
#line 1544
  length = (size_t )0;
#line 1574
  cp = format;
#line 1574
  i = (size_t )0;
#line 1574
  dp = d.dir + 0;
#line 1574
  while (1) {
#line 1576
    if ((unsigned long )cp != (unsigned long )dp->dir_start) {
#line 1578
      n = (size_t )(dp->dir_start - cp);
#line 1579
      tmp___6 = xsum(length, n);
#line 1579
      augmented_length = (size_t )tmp___6;
#line 1581
      if (augmented_length > allocated) {
#line 1581
        if (allocated > 0UL) {
#line 1581
          if (allocated <= 9223372036854775807UL) {
#line 1581
            tmp___7 = allocated * 2UL;
          } else {
#line 1581
            tmp___7 = 0xffffffffffffffffUL;
          }
#line 1581
          allocated = tmp___7;
        } else {
#line 1581
          allocated = (size_t )12;
        }
#line 1581
        if (augmented_length > allocated) {
#line 1581
          allocated = augmented_length;
        }
#line 1581
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1581
          memory_size = allocated * sizeof(char );
        } else {
#line 1581
          memory_size = 0xffffffffffffffffUL;
        }
#line 1581
        if (memory_size == 0xffffffffffffffffUL) {
#line 1581
          goto out_of_memory;
        }
#line 1581
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1581
          tmp___8 = malloc(memory_size);
#line 1581
          memory = (char *)tmp___8;
        } else
#line 1581
        if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 1581
          tmp___8 = malloc(memory_size);
#line 1581
          memory = (char *)tmp___8;
        } else {
#line 1581
          tmp___9 = realloc((void *)result, memory_size);
#line 1581
          memory = (char *)tmp___9;
        }
#line 1581
        if ((unsigned long )memory == (unsigned long )((void *)0)) {
#line 1581
          goto out_of_memory;
        }
#line 1581
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1581
          if (length > 0UL) {
#line 1581
            memcpy((void * __restrict  )memory, (void const   * __restrict  )result,
                   length);
          }
        }
#line 1581
        result = memory;
      }
#line 1585
      if (sizeof(char ) == sizeof(char )) {
#line 1587
        memcpy((void * __restrict  )(result + length), (void const   * __restrict  )cp,
               n);
#line 1588
        length = augmented_length;
      } else {
#line 1592
        while (1) {
#line 1593
          tmp___10 = length;
#line 1593
          length ++;
#line 1593
          tmp___11 = cp;
#line 1593
          cp ++;
#line 1593
          *(result + tmp___10) = (char )((unsigned char )*tmp___11);
#line 1592
          n --;
#line 1592
          if (! (n > 0UL)) {
#line 1592
            break;
          }
        }
      }
    }
#line 1597
    if (i == d.count) {
#line 1598
      break;
    }
#line 1601
    if ((int )dp->conversion == 37) {
#line 1605
      if (! (dp->arg_index == 0xffffffffffffffffUL)) {
#line 1606
        abort();
      }
#line 1607
      tmp___12 = xsum(length, (size_t )1);
#line 1607
      augmented_length___0 = (size_t )tmp___12;
#line 1608
      if (augmented_length___0 > allocated) {
#line 1608
        if (allocated > 0UL) {
#line 1608
          if (allocated <= 9223372036854775807UL) {
#line 1608
            tmp___13 = allocated * 2UL;
          } else {
#line 1608
            tmp___13 = 0xffffffffffffffffUL;
          }
#line 1608
          allocated = tmp___13;
        } else {
#line 1608
          allocated = (size_t )12;
        }
#line 1608
        if (augmented_length___0 > allocated) {
#line 1608
          allocated = augmented_length___0;
        }
#line 1608
        if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 1608
          memory_size___0 = allocated * sizeof(char );
        } else {
#line 1608
          memory_size___0 = 0xffffffffffffffffUL;
        }
#line 1608
        if (memory_size___0 == 0xffffffffffffffffUL) {
#line 1608
          goto out_of_memory;
        }
#line 1608
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1608
          tmp___14 = malloc(memory_size___0);
#line 1608
          memory___0 = (char *)tmp___14;
        } else
#line 1608
        if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 1608
          tmp___14 = malloc(memory_size___0);
#line 1608
          memory___0 = (char *)tmp___14;
        } else {
#line 1608
          tmp___15 = realloc((void *)result, memory_size___0);
#line 1608
          memory___0 = (char *)tmp___15;
        }
#line 1608
        if ((unsigned long )memory___0 == (unsigned long )((void *)0)) {
#line 1608
          goto out_of_memory;
        }
#line 1608
        if ((unsigned long )result == (unsigned long )resultbuf) {
#line 1608
          if (length > 0UL) {
#line 1608
            memcpy((void * __restrict  )memory___0, (void const   * __restrict  )result,
                   length);
          }
        }
#line 1608
        result = memory___0;
      }
#line 1609
      *(result + length) = (char )'%';
#line 1610
      length = augmented_length___0;
    } else {
#line 1614
      if (! (dp->arg_index != 0xffffffffffffffffUL)) {
#line 1615
        abort();
      }
#line 1617
      if ((int )dp->conversion == 110) {
#line 1619
        switch ((unsigned int )(a.arg + dp->arg_index)->type) {
        case 18U: 
#line 1622
        *((a.arg + dp->arg_index)->a.a_count_schar_pointer) = (signed char )length;
#line 1623
        break;
        case 19U: 
#line 1625
        *((a.arg + dp->arg_index)->a.a_count_short_pointer) = (short )length;
#line 1626
        break;
        case 20U: 
#line 1628
        *((a.arg + dp->arg_index)->a.a_count_int_pointer) = (int )length;
#line 1629
        break;
        case 21U: 
#line 1631
        *((a.arg + dp->arg_index)->a.a_count_longint_pointer) = (long )length;
#line 1632
        break;
        case 22U: 
#line 1635
        *((a.arg + dp->arg_index)->a.a_count_longlongint_pointer) = (long long )length;
#line 1636
        break;
        default: 
#line 1639
        abort();
        }
      } else
#line 3115
      if ((int )dp->conversion == 102) {
#line 3115
        goto _L___11;
      } else
#line 3115
      if ((int )dp->conversion == 70) {
#line 3115
        goto _L___11;
      } else
#line 3115
      if ((int )dp->conversion == 101) {
#line 3115
        goto _L___11;
      } else
#line 3115
      if ((int )dp->conversion == 69) {
#line 3115
        goto _L___11;
      } else
#line 3115
      if ((int )dp->conversion == 103) {
#line 3115
        goto _L___11;
      } else
#line 3115
      if ((int )dp->conversion == 71) {
#line 3115
        goto _L___11;
      } else
#line 3115
      if ((int )dp->conversion == 97) {
#line 3115
        goto _L___11;
      } else
#line 3115
      if ((int )dp->conversion == 65) {
        _L___11: /* CIL Label */ 
#line 3115
        if ((unsigned int )(a.arg + dp->arg_index)->type == 12U) {
#line 3115
          tmp___111 = is_infinite_or_zerol((a.arg + dp->arg_index)->a.a_longdouble);
#line 3115
          if (tmp___111) {
#line 3144
            flags = dp->flags;
#line 3155
            has_width = 0;
#line 3156
            width = (size_t )0;
#line 3157
            if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 3159
              if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 3163
                if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 3164
                  abort();
                }
#line 3165
                arg = (a.arg + dp->width_arg_index)->a.a_int;
#line 3166
                if (arg < 0) {
#line 3170
                  flags |= 2;
#line 3171
                  width = (size_t )((unsigned int )(- arg));
                } else {
#line 3174
                  width = (size_t )arg;
                }
              } else {
#line 3178
                digitp = dp->width_start;
#line 3180
                while (1) {
#line 3181
                  tmp___17 = digitp;
#line 3181
                  digitp ++;
#line 3181
                  if (width <= 1844674407370955161UL) {
#line 3181
                    tmp___18 = width * 10UL;
                  } else {
#line 3181
                    tmp___18 = 0xffffffffffffffffUL;
                  }
#line 3181
                  tmp___19 = xsum(tmp___18, (size_t )((int const   )*tmp___17 - 48));
#line 3181
                  width = (size_t )tmp___19;
#line 3180
                  if (! ((unsigned long )digitp != (unsigned long )dp->width_end)) {
#line 3180
                    break;
                  }
                }
              }
#line 3184
              has_width = 1;
            }
#line 3187
            has_precision = 0;
#line 3188
            precision = (size_t )0;
#line 3189
            if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 3191
              if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 3195
                if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 3196
                  abort();
                }
#line 3197
                arg___0 = (a.arg + dp->precision_arg_index)->a.a_int;
#line 3200
                if (arg___0 >= 0) {
#line 3202
                  precision = (size_t )arg___0;
#line 3203
                  has_precision = 1;
                }
              } else {
#line 3208
                digitp___0 = dp->precision_start + 1;
#line 3210
                precision = (size_t )0;
#line 3211
                while ((unsigned long )digitp___0 != (unsigned long )dp->precision_end) {
#line 3212
                  tmp___20 = digitp___0;
#line 3212
                  digitp___0 ++;
#line 3212
                  if (precision <= 1844674407370955161UL) {
#line 3212
                    tmp___21 = precision * 10UL;
                  } else {
#line 3212
                    tmp___21 = 0xffffffffffffffffUL;
                  }
#line 3212
                  tmp___22 = xsum(tmp___21, (size_t )((int const   )*tmp___20 - 48));
#line 3212
                  precision = (size_t )tmp___22;
                }
#line 3213
                has_precision = 1;
              }
            }
#line 3221
            if (! has_precision) {
#line 3222
              if (! ((int )dp->conversion == 97)) {
#line 3222
                if (! ((int )dp->conversion == 65)) {
#line 3223
                  precision = (size_t )6;
                }
              }
            }
#line 3235
            tmp_length = (size_t )0;
#line 3237
            if (tmp_length < precision) {
#line 3238
              tmp_length = precision;
            }
#line 3272
            tmp___23 = xsum(tmp_length, (size_t )12);
#line 3272
            tmp_length = (size_t )tmp___23;
#line 3274
            if (tmp_length < width) {
#line 3275
              tmp_length = width;
            }
#line 3277
            tmp___24 = xsum(tmp_length, (size_t )1);
#line 3277
            tmp_length = (size_t )tmp___24;
#line 3279
            if (tmp_length <= sizeof(tmpbuf) / sizeof(char )) {
#line 3280
              tmp___16 = tmpbuf;
            } else {
#line 3283
              if (tmp_length <= 0xffffffffffffffffUL / sizeof(char )) {
#line 3283
                tmp___25 = tmp_length * sizeof(char );
              } else {
#line 3283
                tmp___25 = 0xffffffffffffffffUL;
              }
#line 3283
              tmp_memsize = tmp___25;
#line 3285
              if (tmp_memsize == 0xffffffffffffffffUL) {
#line 3287
                goto out_of_memory;
              }
#line 3288
              tmp___26 = malloc(tmp_memsize);
#line 3288
              tmp___16 = (char *)tmp___26;
#line 3289
              if ((unsigned long )tmp___16 == (unsigned long )((void *)0)) {
#line 3291
                goto out_of_memory;
              }
            }
#line 3294
            pad_ptr = (char *)((void *)0);
#line 3295
            p = tmp___16;
#line 3302
            arg___1 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 3304
            tmp___69 = rpl_isnanl(arg___1);
#line 3304
            if (tmp___69) {
#line 3306
              if ((int )dp->conversion >= 65) {
#line 3306
                if ((int )dp->conversion <= 90) {
#line 3308
                  tmp___27 = p;
#line 3308
                  p ++;
#line 3308
                  *tmp___27 = (char )'N';
#line 3308
                  tmp___28 = p;
#line 3308
                  p ++;
#line 3308
                  *tmp___28 = (char )'A';
#line 3308
                  tmp___29 = p;
#line 3308
                  p ++;
#line 3308
                  *tmp___29 = (char )'N';
                } else {
#line 3306
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 3312
                tmp___30 = p;
#line 3312
                p ++;
#line 3312
                *tmp___30 = (char )'n';
#line 3312
                tmp___31 = p;
#line 3312
                p ++;
#line 3312
                *tmp___31 = (char )'a';
#line 3312
                tmp___32 = p;
#line 3312
                p ++;
#line 3312
                *tmp___32 = (char )'n';
              }
            } else {
#line 3317
              sign = 0;
#line 3320
              __asm__  volatile   ("fnstcw %0": "=m" (_cw));
#line 3320
              oldcw = _cw;
#line 3320
              _ncw = (fpucw_t )(((int )oldcw & -769) | 768);
#line 3320
              __asm__  volatile   ("fldcw %0": : "m" (_ncw));
#line 3322
              if (sizeof(arg___1) == sizeof(long double )) {
#line 3322
                tmp___33 = __builtin_signbitl(arg___1);
#line 3322
                tmp___37 = tmp___33;
              } else {
#line 3322
                if (sizeof(arg___1) == sizeof(double )) {
#line 3322
                  tmp___34 = __builtin_signbit(arg___1);
#line 3322
                  tmp___36 = tmp___34;
                } else {
#line 3322
                  tmp___35 = 1; //__builtin_signbitf(arg___1);
#line 3322
                  tmp___36 = tmp___35;
                }
#line 3322
                tmp___37 = tmp___36;
              }
#line 3322
              if (tmp___37) {
#line 3324
                sign = -1;
#line 3325
                arg___1 = - arg___1;
              }
#line 3328
              if (sign < 0) {
#line 3329
                tmp___38 = p;
#line 3329
                p ++;
#line 3329
                *tmp___38 = (char )'-';
              } else
#line 3330
              if (flags & 4) {
#line 3331
                tmp___39 = p;
#line 3331
                p ++;
#line 3331
                *tmp___39 = (char )'+';
              } else
#line 3332
              if (flags & 8) {
#line 3333
                tmp___40 = p;
#line 3333
                p ++;
#line 3333
                *tmp___40 = (char )' ';
              }
#line 3335
              if (arg___1 > 0.0L) {
#line 3335
                if (arg___1 + arg___1 == arg___1) {
#line 3337
                  if ((int )dp->conversion >= 65) {
#line 3337
                    if ((int )dp->conversion <= 90) {
#line 3339
                      tmp___41 = p;
#line 3339
                      p ++;
#line 3339
                      *tmp___41 = (char )'I';
#line 3339
                      tmp___42 = p;
#line 3339
                      p ++;
#line 3339
                      *tmp___42 = (char )'N';
#line 3339
                      tmp___43 = p;
#line 3339
                      p ++;
#line 3339
                      *tmp___43 = (char )'F';
                    } else {
#line 3337
                      goto _L___0;
                    }
                  } else {
                    _L___0: /* CIL Label */ 
#line 3343
                    tmp___44 = p;
#line 3343
                    p ++;
#line 3343
                    *tmp___44 = (char )'i';
#line 3343
                    tmp___45 = p;
#line 3343
                    p ++;
#line 3343
                    *tmp___45 = (char )'n';
#line 3343
                    tmp___46 = p;
#line 3343
                    p ++;
#line 3343
                    *tmp___46 = (char )'f';
                  }
                } else {
#line 3335
                  goto _L___8;
                }
              } else {
                _L___8: /* CIL Label */ 
#line 3699
                if (! (arg___1 == 0.0L)) {
#line 3700
                  abort();
                }
#line 3702
                pad_ptr = p;
#line 3704
                if ((int )dp->conversion == 102) {
#line 3704
                  goto _L___7;
                } else
#line 3704
                if ((int )dp->conversion == 70) {
                  _L___7: /* CIL Label */ 
#line 3706
                  tmp___47 = p;
#line 3706
                  p ++;
#line 3706
                  *tmp___47 = (char )'0';
#line 3707
                  if (flags & 16) {
#line 3707
                    goto _L___1;
                  } else
#line 3707
                  if (precision > 0UL) {
                    _L___1: /* CIL Label */ 
#line 3709
                    tmp___48 = p;
#line 3709
                    p ++;
#line 3709
                    *tmp___48 = decimal_point_char();
#line 3710
                    while (precision > 0UL) {
#line 3711
                      tmp___49 = p;
#line 3711
                      p ++;
#line 3711
                      *tmp___49 = (char )'0';
#line 3710
                      precision --;
                    }
                  }
                } else
#line 3714
                if ((int )dp->conversion == 101) {
#line 3714
                  goto _L___6;
                } else
#line 3714
                if ((int )dp->conversion == 69) {
                  _L___6: /* CIL Label */ 
#line 3716
                  tmp___50 = p;
#line 3716
                  p ++;
#line 3716
                  *tmp___50 = (char )'0';
#line 3717
                  if (flags & 16) {
#line 3717
                    goto _L___2;
                  } else
#line 3717
                  if (precision > 0UL) {
                    _L___2: /* CIL Label */ 
#line 3719
                    tmp___51 = p;
#line 3719
                    p ++;
#line 3719
                    *tmp___51 = decimal_point_char();
#line 3720
                    while (precision > 0UL) {
#line 3721
                      tmp___52 = p;
#line 3721
                      p ++;
#line 3721
                      *tmp___52 = (char )'0';
#line 3720
                      precision --;
                    }
                  }
#line 3723
                  tmp___53 = p;
#line 3723
                  p ++;
#line 3723
                  *tmp___53 = dp->conversion;
#line 3724
                  tmp___54 = p;
#line 3724
                  p ++;
#line 3724
                  *tmp___54 = (char )'+';
#line 3725
                  tmp___55 = p;
#line 3725
                  p ++;
#line 3725
                  *tmp___55 = (char )'0';
#line 3726
                  tmp___56 = p;
#line 3726
                  p ++;
#line 3726
                  *tmp___56 = (char )'0';
                } else
#line 3728
                if ((int )dp->conversion == 103) {
#line 3728
                  goto _L___5;
                } else
#line 3728
                if ((int )dp->conversion == 71) {
                  _L___5: /* CIL Label */ 
#line 3730
                  tmp___57 = p;
#line 3730
                  p ++;
#line 3730
                  *tmp___57 = (char )'0';
#line 3731
                  if (flags & 16) {
#line 3733
                    if (precision > 0UL) {
#line 3733
                      tmp___58 = precision - 1UL;
                    } else {
#line 3733
                      tmp___58 = (size_t )0;
                    }
#line 3733
                    ndigits = tmp___58;
#line 3735
                    tmp___59 = p;
#line 3735
                    p ++;
#line 3735
                    *tmp___59 = decimal_point_char();
#line 3736
                    while (ndigits > 0UL) {
#line 3737
                      tmp___60 = p;
#line 3737
                      p ++;
#line 3737
                      *tmp___60 = (char )'0';
#line 3736
                      ndigits --;
                    }
                  }
                } else
#line 3740
                if ((int )dp->conversion == 97) {
#line 3740
                  goto _L___4;
                } else
#line 3740
                if ((int )dp->conversion == 65) {
                  _L___4: /* CIL Label */ 
#line 3742
                  tmp___61 = p;
#line 3742
                  p ++;
#line 3742
                  *tmp___61 = (char )'0';
#line 3743
                  tmp___62 = p;
#line 3743
                  p ++;
#line 3743
                  *tmp___62 = (char )(((int )dp->conversion - 65) + 88);
#line 3744
                  pad_ptr = p;
#line 3745
                  tmp___63 = p;
#line 3745
                  p ++;
#line 3745
                  *tmp___63 = (char )'0';
#line 3746
                  if (flags & 16) {
#line 3746
                    goto _L___3;
                  } else
#line 3746
                  if (precision > 0UL) {
                    _L___3: /* CIL Label */ 
#line 3748
                    tmp___64 = p;
#line 3748
                    p ++;
#line 3748
                    *tmp___64 = decimal_point_char();
#line 3749
                    while (precision > 0UL) {
#line 3750
                      tmp___65 = p;
#line 3750
                      p ++;
#line 3750
                      *tmp___65 = (char )'0';
#line 3749
                      precision --;
                    }
                  }
#line 3752
                  tmp___66 = p;
#line 3752
                  p ++;
#line 3752
                  *tmp___66 = (char )(((int )dp->conversion - 65) + 80);
#line 3753
                  tmp___67 = p;
#line 3753
                  p ++;
#line 3753
                  *tmp___67 = (char )'+';
#line 3754
                  tmp___68 = p;
#line 3754
                  p ++;
#line 3754
                  *tmp___68 = (char )'0';
                } else {
#line 3757
                  abort();
                }
              }
#line 3761
              _ncw___0 = oldcw;
#line 3761
              __asm__  volatile   ("fldcw %0": : "m" (_ncw___0));
            }
#line 4241
            if (has_width) {
#line 4241
              if ((size_t )(p - tmp___16) < width) {
#line 4243
                pad = width - (size_t )(p - tmp___16);
#line 4244
                end = p + pad;
#line 4246
                if (flags & 2) {
#line 4249
                  while (pad > 0UL) {
#line 4250
                    tmp___70 = p;
#line 4250
                    p ++;
#line 4250
                    *tmp___70 = (char )' ';
#line 4249
                    pad --;
                  }
                } else
#line 4252
                if (flags & 32) {
#line 4252
                  if ((unsigned long )pad_ptr != (unsigned long )((void *)0)) {
#line 4255
                    q = end;
#line 4257
                    while ((unsigned long )p > (unsigned long )pad_ptr) {
#line 4258
                      q --;
#line 4258
                      p --;
#line 4258
                      *q = *p;
                    }
#line 4259
                    while (pad > 0UL) {
#line 4260
                      tmp___71 = p;
#line 4260
                      p ++;
#line 4260
                      *tmp___71 = (char )'0';
#line 4259
                      pad --;
                    }
                  } else {
#line 4252
                    goto _L___9;
                  }
                } else {
                  _L___9: /* CIL Label */ 
#line 4265
                  q___0 = end;
#line 4267
                  while ((unsigned long )p > (unsigned long )tmp___16) {
#line 4268
                    q___0 --;
#line 4268
                    p --;
#line 4268
                    *q___0 = *p;
                  }
#line 4269
                  while (pad > 0UL) {
#line 4270
                    tmp___72 = p;
#line 4270
                    p ++;
#line 4270
                    *tmp___72 = (char )' ';
#line 4269
                    pad --;
                  }
                }
#line 4273
                p = end;
              }
            }
#line 4277
            count = (size_t )(p - tmp___16);
#line 4279
            if (count >= tmp_length) {
#line 4282
              abort();
            }
#line 4285
            if (count >= allocated - length) {
#line 4287
              tmp___73 = xsum(length, count);
#line 4287
              n___0 = (size_t )tmp___73;
#line 4289
              if (n___0 > allocated) {
#line 4289
                if (allocated > 0UL) {
#line 4289
                  if (allocated <= 9223372036854775807UL) {
#line 4289
                    tmp___74 = allocated * 2UL;
                  } else {
#line 4289
                    tmp___74 = 0xffffffffffffffffUL;
                  }
#line 4289
                  allocated = tmp___74;
                } else {
#line 4289
                  allocated = (size_t )12;
                }
#line 4289
                if (n___0 > allocated) {
#line 4289
                  allocated = n___0;
                }
#line 4289
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4289
                  memory_size___1 = allocated * sizeof(char );
                } else {
#line 4289
                  memory_size___1 = 0xffffffffffffffffUL;
                }
#line 4289
                if (memory_size___1 == 0xffffffffffffffffUL) {
#line 4289
                  goto out_of_memory;
                }
#line 4289
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4289
                  tmp___75 = malloc(memory_size___1);
#line 4289
                  memory___1 = (char *)tmp___75;
                } else
#line 4289
                if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 4289
                  tmp___75 = malloc(memory_size___1);
#line 4289
                  memory___1 = (char *)tmp___75;
                } else {
#line 4289
                  tmp___76 = realloc((void *)result, memory_size___1);
#line 4289
                  memory___1 = (char *)tmp___76;
                }
#line 4289
                if ((unsigned long )memory___1 == (unsigned long )((void *)0)) {
#line 4289
                  goto out_of_memory;
                }
#line 4289
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4289
                  if (length > 0UL) {
#line 4289
                    memcpy((void * __restrict  )memory___1, (void const   * __restrict  )result,
                           length);
                  }
                }
#line 4289
                result = memory___1;
              }
            }
#line 4293
            memcpy((void * __restrict  )(result + length), (void const   * __restrict  )tmp___16,
                   count * sizeof(char ));
#line 4294
            if ((unsigned long )tmp___16 != (unsigned long )(tmpbuf)) {
#line 4295
              free((void *)tmp___16);
            }
#line 4296
            length += count;
          } else {
#line 3115
            goto _L___10;
          }
        } else {
#line 3115
          goto _L___10;
        }
      } else {
        _L___10: /* CIL Label */ 
#line 4302
        type = (a.arg + dp->arg_index)->type;
#line 4303
        flags___0 = dp->flags;
#line 4699
        fbp = buf___0;
#line 4700
        tmp___77 = fbp;
#line 4700
        fbp ++;
#line 4700
        *tmp___77 = (char )'%';
#line 4706
        if (flags___0 & 1) {
#line 4707
          tmp___78 = fbp;
#line 4707
          fbp ++;
#line 4707
          *tmp___78 = (char )'\'';
        }
#line 4709
        if (flags___0 & 2) {
#line 4710
          tmp___79 = fbp;
#line 4710
          fbp ++;
#line 4710
          *tmp___79 = (char )'-';
        }
#line 4711
        if (flags___0 & 4) {
#line 4712
          tmp___80 = fbp;
#line 4712
          fbp ++;
#line 4712
          *tmp___80 = (char )'+';
        }
#line 4713
        if (flags___0 & 8) {
#line 4714
          tmp___81 = fbp;
#line 4714
          fbp ++;
#line 4714
          *tmp___81 = (char )' ';
        }
#line 4715
        if (flags___0 & 16) {
#line 4716
          tmp___82 = fbp;
#line 4716
          fbp ++;
#line 4716
          *tmp___82 = (char )'#';
        }
#line 4719
        if (flags___0 & 32) {
#line 4720
          tmp___83 = fbp;
#line 4720
          fbp ++;
#line 4720
          *tmp___83 = (char )'0';
        }
#line 4721
        if ((unsigned long )dp->width_start != (unsigned long )dp->width_end) {
#line 4723
          n___1 = (size_t )(dp->width_end - dp->width_start);
#line 4726
          if (sizeof(char ) == sizeof(char )) {
#line 4728
            memcpy((void * __restrict  )fbp, (void const   * __restrict  )dp->width_start,
                   n___1 * sizeof(char ));
#line 4729
            fbp += n___1;
          } else {
#line 4733
            mp = dp->width_start;
#line 4734
            while (1) {
#line 4735
              tmp___84 = fbp;
#line 4735
              fbp ++;
#line 4735
              tmp___85 = mp;
#line 4735
              mp ++;
#line 4735
              *tmp___84 = (char )((unsigned char )*tmp___85);
#line 4734
              n___1 --;
#line 4734
              if (! (n___1 > 0UL)) {
#line 4734
                break;
              }
            }
          }
        }
#line 4742
        if ((unsigned long )dp->precision_start != (unsigned long )dp->precision_end) {
#line 4744
          n___2 = (size_t )(dp->precision_end - dp->precision_start);
#line 4747
          if (sizeof(char ) == sizeof(char )) {
#line 4749
            memcpy((void * __restrict  )fbp, (void const   * __restrict  )dp->precision_start,
                   n___2 * sizeof(char ));
#line 4750
            fbp += n___2;
          } else {
#line 4754
            mp___0 = dp->precision_start;
#line 4755
            while (1) {
#line 4756
              tmp___86 = fbp;
#line 4756
              fbp ++;
#line 4756
              tmp___87 = mp___0;
#line 4756
              mp___0 ++;
#line 4756
              *tmp___86 = (char )((unsigned char )*tmp___87);
#line 4755
              n___2 --;
#line 4755
              if (! (n___2 > 0UL)) {
#line 4755
                break;
              }
            }
          }
        }
#line 4762
        switch ((unsigned int )type) {
        case 10U: 
        case 9U: 
#line 4773
        tmp___88 = fbp;
#line 4773
        fbp ++;
#line 4773
        *tmp___88 = (char )'l';
        case 16U: 
        case 14U: 
        case 8U: 
        case 7U: 
#line 4785
        tmp___89 = fbp;
#line 4785
        fbp ++;
#line 4785
        *tmp___89 = (char )'l';
#line 4786
        break;
        case 12U: 
#line 4788
        tmp___90 = fbp;
#line 4788
        fbp ++;
#line 4788
        *tmp___90 = (char )'L';
#line 4789
        break;
        default: 
#line 4791
        break;
        }
#line 4798
        *fbp = dp->conversion;
#line 4828
        *(fbp + 1) = (char )'\000';
#line 4835
        prefix_count = 0U;
#line 4836
        if (dp->width_arg_index != 0xffffffffffffffffUL) {
#line 4838
          if (! ((unsigned int )(a.arg + dp->width_arg_index)->type == 5U)) {
#line 4839
            abort();
          }
#line 4840
          tmp___91 = prefix_count;
#line 4840
          prefix_count ++;
#line 4840
          prefixes[tmp___91] = (a.arg + dp->width_arg_index)->a.a_int;
        }
#line 4842
        if (dp->precision_arg_index != 0xffffffffffffffffUL) {
#line 4844
          if (! ((unsigned int )(a.arg + dp->precision_arg_index)->type == 5U)) {
#line 4845
            abort();
          }
#line 4846
          tmp___92 = prefix_count;
#line 4846
          prefix_count ++;
#line 4846
          prefixes[tmp___92] = (a.arg + dp->precision_arg_index)->a.a_int;
        }
#line 4858
        tmp___98 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4858
        if (tmp___98 > (size_t __attribute__((__pure__))  )allocated) {
#line 4858
          if (allocated > 0UL) {
#line 4858
            if (allocated <= 9223372036854775807UL) {
#line 4858
              tmp___93 = allocated * 2UL;
            } else {
#line 4858
              tmp___93 = 0xffffffffffffffffUL;
            }
#line 4858
            allocated = tmp___93;
          } else {
#line 4858
            allocated = (size_t )12;
          }
#line 4858
          tmp___95 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4858
          if (tmp___95 > (size_t __attribute__((__pure__))  )allocated) {
#line 4858
            tmp___94 = xsum(length, ((2UL + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 4858
            allocated = (size_t )tmp___94;
          }
#line 4858
          if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 4858
            memory_size___2 = allocated * sizeof(char );
          } else {
#line 4858
            memory_size___2 = 0xffffffffffffffffUL;
          }
#line 4858
          if (memory_size___2 == 0xffffffffffffffffUL) {
#line 4858
            goto out_of_memory;
          }
#line 4858
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4858
            tmp___96 = malloc(memory_size___2);
#line 4858
            memory___2 = (char *)tmp___96;
          } else
#line 4858
          if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 4858
            tmp___96 = malloc(memory_size___2);
#line 4858
            memory___2 = (char *)tmp___96;
          } else {
#line 4858
            tmp___97 = realloc((void *)result, memory_size___2);
#line 4858
            memory___2 = (char *)tmp___97;
          }
#line 4858
          if ((unsigned long )memory___2 == (unsigned long )((void *)0)) {
#line 4858
            goto out_of_memory;
          }
#line 4858
          if ((unsigned long )result == (unsigned long )resultbuf) {
#line 4858
            if (length > 0UL) {
#line 4858
              memcpy((void * __restrict  )memory___2, (void const   * __restrict  )result,
                     length);
            }
          }
#line 4858
          result = memory___2;
        }
#line 4863
        *(result + length) = (char )'\000';
#line 4866
        while (1) {
#line 4868
          count___0 = -1;
#line 4871
          retcount = 0;
#line 4872
          maxlen = allocated - length;
#line 4875
          if (maxlen > 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 4876
            maxlen = 2147483647UL / (sizeof(char ) / sizeof(char ));
          }
#line 4877
          maxlen *= sizeof(char ) / sizeof(char );
#line 4919
          switch ((unsigned int )type) {
          case 1U: 
#line 4923
          arg___2 = (int )(a.arg + dp->arg_index)->a.a_schar;
#line 4924
          switch (prefix_count) {
          case 0U: 
#line 4924
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___2, & count___0);
#line 4924
          break;
          case 1U: 
#line 4924
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___2, & count___0);
#line 4924
          break;
          case 2U: 
#line 4924
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___2, & count___0);
#line 4924
          break;
          default: 
#line 4924
          abort();
          }
#line 4926
          break;
          case 2U: 
#line 4929
          arg___3 = (unsigned int )(a.arg + dp->arg_index)->a.a_uchar;
#line 4930
          switch (prefix_count) {
          case 0U: 
#line 4930
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___3, & count___0);
#line 4930
          break;
          case 1U: 
#line 4930
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___3, & count___0);
#line 4930
          break;
          case 2U: 
#line 4930
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___3, & count___0);
#line 4930
          break;
          default: 
#line 4930
          abort();
          }
#line 4932
          break;
          case 3U: 
#line 4935
          arg___4 = (int )(a.arg + dp->arg_index)->a.a_short;
#line 4936
          switch (prefix_count) {
          case 0U: 
#line 4936
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___4, & count___0);
#line 4936
          break;
          case 1U: 
#line 4936
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___4, & count___0);
#line 4936
          break;
          case 2U: 
#line 4936
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___4, & count___0);
#line 4936
          break;
          default: 
#line 4936
          abort();
          }
#line 4938
          break;
          case 4U: 
#line 4941
          arg___5 = (unsigned int )(a.arg + dp->arg_index)->a.a_ushort;
#line 4942
          switch (prefix_count) {
          case 0U: 
#line 4942
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___5, & count___0);
#line 4942
          break;
          case 1U: 
#line 4942
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___5, & count___0);
#line 4942
          break;
          case 2U: 
#line 4942
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___5, & count___0);
#line 4942
          break;
          default: 
#line 4942
          abort();
          }
#line 4944
          break;
          case 5U: 
#line 4947
          arg___6 = (a.arg + dp->arg_index)->a.a_int;
#line 4948
          switch (prefix_count) {
          case 0U: 
#line 4948
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___6, & count___0);
#line 4948
          break;
          case 1U: 
#line 4948
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___6, & count___0);
#line 4948
          break;
          case 2U: 
#line 4948
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___6, & count___0);
#line 4948
          break;
          default: 
#line 4948
          abort();
          }
#line 4950
          break;
          case 6U: 
#line 4953
          arg___7 = (a.arg + dp->arg_index)->a.a_uint;
#line 4954
          switch (prefix_count) {
          case 0U: 
#line 4954
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___7, & count___0);
#line 4954
          break;
          case 1U: 
#line 4954
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___7, & count___0);
#line 4954
          break;
          case 2U: 
#line 4954
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___7, & count___0);
#line 4954
          break;
          default: 
#line 4954
          abort();
          }
#line 4956
          break;
          case 7U: 
#line 4959
          arg___8 = (a.arg + dp->arg_index)->a.a_longint;
#line 4960
          switch (prefix_count) {
          case 0U: 
#line 4960
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___8, & count___0);
#line 4960
          break;
          case 1U: 
#line 4960
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___8, & count___0);
#line 4960
          break;
          case 2U: 
#line 4960
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___8, & count___0);
#line 4960
          break;
          default: 
#line 4960
          abort();
          }
#line 4962
          break;
          case 8U: 
#line 4965
          arg___9 = (a.arg + dp->arg_index)->a.a_ulongint;
#line 4966
          switch (prefix_count) {
          case 0U: 
#line 4966
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___9, & count___0);
#line 4966
          break;
          case 1U: 
#line 4966
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___9, & count___0);
#line 4966
          break;
          case 2U: 
#line 4966
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___9, & count___0);
#line 4966
          break;
          default: 
#line 4966
          abort();
          }
#line 4968
          break;
          case 9U: 
#line 4972
          arg___10 = (a.arg + dp->arg_index)->a.a_longlongint;
#line 4973
          switch (prefix_count) {
          case 0U: 
#line 4973
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___10, & count___0);
#line 4973
          break;
          case 1U: 
#line 4973
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___10, & count___0);
#line 4973
          break;
          case 2U: 
#line 4973
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___10, & count___0);
#line 4973
          break;
          default: 
#line 4973
          abort();
          }
#line 4975
          break;
          case 10U: 
#line 4978
          arg___11 = (a.arg + dp->arg_index)->a.a_ulonglongint;
#line 4979
          switch (prefix_count) {
          case 0U: 
#line 4979
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___11, & count___0);
#line 4979
          break;
          case 1U: 
#line 4979
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___11, & count___0);
#line 4979
          break;
          case 2U: 
#line 4979
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___11, & count___0);
#line 4979
          break;
          default: 
#line 4979
          abort();
          }
#line 4981
          break;
          case 11U: 
#line 4985
          arg___12 = (a.arg + dp->arg_index)->a.a_double;
#line 4986
          switch (prefix_count) {
          case 0U: 
#line 4986
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___12, & count___0);
#line 4986
          break;
          case 1U: 
#line 4986
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___12, & count___0);
#line 4986
          break;
          case 2U: 
#line 4986
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___12, & count___0);
#line 4986
          break;
          default: 
#line 4986
          abort();
          }
#line 4988
          break;
          case 12U: 
#line 4991
          arg___13 = (a.arg + dp->arg_index)->a.a_longdouble;
#line 4992
          switch (prefix_count) {
          case 0U: 
#line 4992
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___13, & count___0);
#line 4992
          break;
          case 1U: 
#line 4992
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___13, & count___0);
#line 4992
          break;
          case 2U: 
#line 4992
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___13, & count___0);
#line 4992
          break;
          default: 
#line 4992
          abort();
          }
#line 4994
          break;
          case 13U: 
#line 4997
          arg___14 = (a.arg + dp->arg_index)->a.a_char;
#line 4998
          switch (prefix_count) {
          case 0U: 
#line 4998
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___14, & count___0);
#line 4998
          break;
          case 1U: 
#line 4998
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___14, & count___0);
#line 4998
          break;
          case 2U: 
#line 4998
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___14, & count___0);
#line 4998
          break;
          default: 
#line 4998
          abort();
          }
#line 5000
          break;
          case 14U: 
#line 5004
          arg___15 = (a.arg + dp->arg_index)->a.a_wide_char;
#line 5005
          switch (prefix_count) {
          case 0U: 
#line 5005
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___15, & count___0);
#line 5005
          break;
          case 1U: 
#line 5005
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___15, & count___0);
#line 5005
          break;
          case 2U: 
#line 5005
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___15, & count___0);
#line 5005
          break;
          default: 
#line 5005
          abort();
          }
#line 5007
          break;
          case 15U: 
#line 5011
          arg___16 = (a.arg + dp->arg_index)->a.a_string;
#line 5012
          switch (prefix_count) {
          case 0U: 
#line 5012
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___16, & count___0);
#line 5012
          break;
          case 1U: 
#line 5012
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___16, & count___0);
#line 5012
          break;
          case 2U: 
#line 5012
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___16, & count___0);
#line 5012
          break;
          default: 
#line 5012
          abort();
          }
#line 5014
          break;
          case 16U: 
#line 5018
          arg___17 = (a.arg + dp->arg_index)->a.a_wide_string;
#line 5019
          switch (prefix_count) {
          case 0U: 
#line 5019
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___17, & count___0);
#line 5019
          break;
          case 1U: 
#line 5019
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___17, & count___0);
#line 5019
          break;
          case 2U: 
#line 5019
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___17, & count___0);
#line 5019
          break;
          default: 
#line 5019
          abort();
          }
#line 5021
          break;
          case 17U: 
#line 5025
          arg___18 = (a.arg + dp->arg_index)->a.a_pointer;
#line 5026
          switch (prefix_count) {
          case 0U: 
#line 5026
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              arg___18, & count___0);
#line 5026
          break;
          case 1U: 
#line 5026
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], arg___18, & count___0);
#line 5026
          break;
          case 2U: 
#line 5026
          retcount = snprintf((char * __restrict  )(result + length), maxlen, (char const   * __restrict  )buf___0,
                              prefixes[0], prefixes[1], arg___18, & count___0);
#line 5026
          break;
          default: 
#line 5026
          abort();
          }
#line 5028
          break;
          default: 
#line 5030
          abort();
          }
#line 5038
          if (count___0 >= 0) {
#line 5042
            if ((size_t )count___0 < maxlen) {
#line 5042
              if ((int )*((result + length) + count___0) != 0) {
#line 5044
                abort();
              }
            }
#line 5046
            if (retcount > count___0) {
#line 5047
              count___0 = retcount;
            }
          } else
#line 5053
          if ((int )*(fbp + 1) != 0) {
#line 5057
            *(fbp + 1) = (char )'\000';
#line 5058
            goto __Cont;
          } else
#line 5063
          if (retcount < 0) {
#line 5070
            if (allocated <= 9223372036854775807UL) {
#line 5070
              tmp___99 = allocated * 2UL;
            } else {
#line 5070
              tmp___99 = 0xffffffffffffffffUL;
            }
#line 5070
            tmp___100 = xsum(tmp___99, (size_t )12);
#line 5070
            bigger_need = (size_t )tmp___100;
#line 5072
            if (bigger_need > allocated) {
#line 5072
              if (allocated > 0UL) {
#line 5072
                if (allocated <= 9223372036854775807UL) {
#line 5072
                  tmp___101 = allocated * 2UL;
                } else {
#line 5072
                  tmp___101 = 0xffffffffffffffffUL;
                }
#line 5072
                allocated = tmp___101;
              } else {
#line 5072
                allocated = (size_t )12;
              }
#line 5072
              if (bigger_need > allocated) {
#line 5072
                allocated = bigger_need;
              }
#line 5072
              if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5072
                memory_size___3 = allocated * sizeof(char );
              } else {
#line 5072
                memory_size___3 = 0xffffffffffffffffUL;
              }
#line 5072
              if (memory_size___3 == 0xffffffffffffffffUL) {
#line 5072
                goto out_of_memory;
              }
#line 5072
              if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5072
                tmp___102 = malloc(memory_size___3);
#line 5072
                memory___3 = (char *)tmp___102;
              } else
#line 5072
              if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 5072
                tmp___102 = malloc(memory_size___3);
#line 5072
                memory___3 = (char *)tmp___102;
              } else {
#line 5072
                tmp___103 = realloc((void *)result, memory_size___3);
#line 5072
                memory___3 = (char *)tmp___103;
              }
#line 5072
              if ((unsigned long )memory___3 == (unsigned long )((void *)0)) {
#line 5072
                goto out_of_memory;
              }
#line 5072
              if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5072
                if (length > 0UL) {
#line 5072
                  memcpy((void * __restrict  )memory___3, (void const   * __restrict  )result,
                         length);
                }
              }
#line 5072
              result = memory___3;
            }
#line 5073
            goto __Cont;
          } else {
#line 5076
            count___0 = retcount;
          }
#line 5082
          if (count___0 < 0) {
#line 5084
            if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5084
              if (! ((unsigned long )result == (unsigned long )((void *)0))) {
#line 5085
                free((void *)result);
              }
            }
#line 5086
            if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5087
              free((void *)buf_malloced);
            }
#line 5088
            free((void *)d.dir);
#line 5088
            if (a.arg) {
#line 5088
              free((void *)a.arg);
            }
#line 5089
            tmp___104 = __errno_location();
#line 5089
            *tmp___104 = 22;
#line 5090
            return ((char *)((void *)0));
          }
#line 5099
          if ((size_t )((unsigned int )count___0 + 1U) >= maxlen) {
#line 5104
            if (maxlen == 2147483647UL / (sizeof(char ) / sizeof(char ))) {
#line 5105
              goto overflow;
            } else {
#line 5117
              if (allocated <= 9223372036854775807UL) {
#line 5117
                tmp___105 = allocated * 2UL;
              } else {
#line 5117
                tmp___105 = 0xffffffffffffffffUL;
              }
#line 5117
              tmp___106 = xsum(length, (((unsigned long )((unsigned int )count___0 + 2U) + sizeof(char ) / sizeof(char )) - 1UL) / (sizeof(char ) / sizeof(char )));
#line 5117
              tmp___107 = xmax((size_t )tmp___106, tmp___105);
#line 5117
              n___3 = (size_t )tmp___107;
#line 5124
              if (n___3 > allocated) {
#line 5124
                if (allocated > 0UL) {
#line 5124
                  if (allocated <= 9223372036854775807UL) {
#line 5124
                    tmp___108 = allocated * 2UL;
                  } else {
#line 5124
                    tmp___108 = 0xffffffffffffffffUL;
                  }
#line 5124
                  allocated = tmp___108;
                } else {
#line 5124
                  allocated = (size_t )12;
                }
#line 5124
                if (n___3 > allocated) {
#line 5124
                  allocated = n___3;
                }
#line 5124
                if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5124
                  memory_size___4 = allocated * sizeof(char );
                } else {
#line 5124
                  memory_size___4 = 0xffffffffffffffffUL;
                }
#line 5124
                if (memory_size___4 == 0xffffffffffffffffUL) {
#line 5124
                  goto out_of_memory;
                }
#line 5124
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5124
                  tmp___109 = malloc(memory_size___4);
#line 5124
                  memory___4 = (char *)tmp___109;
                } else
#line 5124
                if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 5124
                  tmp___109 = malloc(memory_size___4);
#line 5124
                  memory___4 = (char *)tmp___109;
                } else {
#line 5124
                  tmp___110 = realloc((void *)result, memory_size___4);
#line 5124
                  memory___4 = (char *)tmp___110;
                }
#line 5124
                if ((unsigned long )memory___4 == (unsigned long )((void *)0)) {
#line 5124
                  goto out_of_memory;
                }
#line 5124
                if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5124
                  if (length > 0UL) {
#line 5124
                    memcpy((void * __restrict  )memory___4, (void const   * __restrict  )result,
                           length);
                  }
                }
#line 5124
                result = memory___4;
              }
#line 5125
              goto __Cont;
            }
          }
#line 5422
          length += (size_t )count___0;
#line 5423
          break;
          __Cont: /* CIL Label */ ;
        }
      }
    }
#line 1574
    cp = dp->dir_end;
#line 1574
    i ++;
#line 1574
    dp ++;
  }
#line 5430
  tmp___117 = xsum(length, (size_t )1);
#line 5430
  if (tmp___117 > (size_t __attribute__((__pure__))  )allocated) {
#line 5430
    if (allocated > 0UL) {
#line 5430
      if (allocated <= 9223372036854775807UL) {
#line 5430
        tmp___112 = allocated * 2UL;
      } else {
#line 5430
        tmp___112 = 0xffffffffffffffffUL;
      }
#line 5430
      allocated = tmp___112;
    } else {
#line 5430
      allocated = (size_t )12;
    }
#line 5430
    tmp___114 = xsum(length, (size_t )1);
#line 5430
    if (tmp___114 > (size_t __attribute__((__pure__))  )allocated) {
#line 5430
      tmp___113 = xsum(length, (size_t )1);
#line 5430
      allocated = (size_t )tmp___113;
    }
#line 5430
    if (allocated <= 0xffffffffffffffffUL / sizeof(char )) {
#line 5430
      memory_size___5 = allocated * sizeof(char );
    } else {
#line 5430
      memory_size___5 = 0xffffffffffffffffUL;
    }
#line 5430
    if (memory_size___5 == 0xffffffffffffffffUL) {
#line 5430
      goto out_of_memory;
    }
#line 5430
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5430
      tmp___115 = malloc(memory_size___5);
#line 5430
      memory___5 = (char *)tmp___115;
    } else
#line 5430
    if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 5430
      tmp___115 = malloc(memory_size___5);
#line 5430
      memory___5 = (char *)tmp___115;
    } else {
#line 5430
      tmp___116 = realloc((void *)result, memory_size___5);
#line 5430
      memory___5 = (char *)tmp___116;
    }
#line 5430
    if ((unsigned long )memory___5 == (unsigned long )((void *)0)) {
#line 5430
      goto out_of_memory;
    }
#line 5430
    if ((unsigned long )result == (unsigned long )resultbuf) {
#line 5430
      if (length > 0UL) {
#line 5430
        memcpy((void * __restrict  )memory___5, (void const   * __restrict  )result,
               length);
      }
    }
#line 5430
    result = memory___5;
  }
#line 5431
  *(result + length) = (char )'\000';
#line 5433
  if ((unsigned long )result != (unsigned long )resultbuf) {
#line 5433
    if (length + 1UL < allocated) {
#line 5438
      tmp___118 = realloc((void *)result, (length + 1UL) * sizeof(char ));
#line 5438
      memory___6 = (char *)tmp___118;
#line 5439
      if ((unsigned long )memory___6 != (unsigned long )((void *)0)) {
#line 5440
        result = memory___6;
      }
    }
  }
#line 5443
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5444
    free((void *)buf_malloced);
  }
#line 5445
  free((void *)d.dir);
#line 5445
  if (a.arg) {
#line 5445
    free((void *)a.arg);
  }
#line 5446
  *lengthp = length;
#line 5451
  return (result);
  overflow: 
#line 5455
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5455
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
#line 5456
      free((void *)result);
    }
  }
#line 5457
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5458
    free((void *)buf_malloced);
  }
#line 5459
  free((void *)d.dir);
#line 5459
  if (a.arg) {
#line 5459
    free((void *)a.arg);
  }
#line 5460
  tmp___119 = __errno_location();
#line 5460
  *tmp___119 = 75;
#line 5461
  return ((char *)((void *)0));
  out_of_memory: 
#line 5465
  if (! ((unsigned long )result == (unsigned long )resultbuf)) {
#line 5465
    if (! ((unsigned long )result == (unsigned long )((void *)0))) {
#line 5466
      free((void *)result);
    }
  }
#line 5467
  if ((unsigned long )buf_malloced != (unsigned long )((void *)0)) {
#line 5468
    free((void *)buf_malloced);
  }
  out_of_memory_1: 
#line 5470
  free((void *)d.dir);
#line 5470
  if (a.arg) {
#line 5470
    free((void *)a.arg);
  }
#line 5471
  tmp___120 = __errno_location();
#line 5471
  *tmp___120 = 12;
#line 5472
  return ((char *)((void *)0));
}
}
#line 1 "cil-mKnY_24o.o"
#pragma merger("0","../lib/vasprintf.o.i","")
#line 33 "/home/wslee/project/coreutils-8.1/lib/vasprintf.c"
int ( /* format attribute */  rpl_vasprintf)(char **resultp , char const   *format ,
                                             va_list args ) 
{ 
  size_t length ;
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 37
  tmp = vasnprintf((char *)((void *)0), & length, format, args);
#line 37
  result = tmp;
#line 38
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 39
    return (-1);
  }
#line 41
  if (length > 2147483647UL) {
#line 43
    free((void *)result);
#line 44
    tmp___0 = __errno_location();
#line 44
    *tmp___0 = 75;
#line 45
    return (-1);
  }
#line 48
  *resultp = result;
#line 50
  return ((int )length);
}
}
#line 1 "cil-uihQtZLG.o"
#pragma merger("0","../lib/verror.o.i","")
#line 45 "/home/wslee/project/coreutils-8.1/lib/error.h"
extern void ( /* format attribute */  error_at_line)(int __status , int __errnum ,
                                                     char const   *__fname , unsigned int __lineno ,
                                                     char const   *__format  , ...) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/verror.h"
void ( /* format attribute */  verror)(int status , int errnum , char const   *format ,
                                       va_list args ) ;
#line 44
void ( /* format attribute */  verror_at_line)(int status , int errnum , char const   *file ,
                                               unsigned int line_number , char const   *format ,
                                               va_list args ) ;
#line 49 "/home/wslee/project/coreutils-8.1/lib/xvasprintf.h"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) ;
#line 42 "/home/wslee/project/coreutils-8.1/lib/verror.c"
void ( /* format attribute */  verror)(int status , int errnum , char const   *format ,
                                       va_list args ) 
{ 


  {
#line 45
  verror_at_line(status, errnum, (char const   *)((void *)0), 0U, format, args);
#line 46
  return;
}
}
#line 54 "/home/wslee/project/coreutils-8.1/lib/verror.c"
void ( /* format attribute */  verror_at_line)(int status , int errnum , char const   *file ,
                                               unsigned int line_number , char const   *format ,
                                               va_list args ) 
{ 
  char *message ;
  char *tmp ;
  char *tmp___0 ;
  int *tmp___1 ;

  {
#line 58
  tmp = xvasprintf(format, args);
#line 58
  message = tmp;
#line 59
  if (message) {
#line 64
    if (file) {
#line 65
      error_at_line(status, errnum, file, line_number, "%s", message);
    } else {
#line 67
      error(status, errnum, "%s", message);
    }
  } else {
#line 73
    tmp___0 = gettext("unable to display error message");
#line 73
    tmp___1 = __errno_location();
#line 73
    error(0, *tmp___1, (char const   *)tmp___0);
#line 74
    abort();
  }
#line 76
  free((void *)message);
#line 77
  return;
}
}
#line 1 "cil-6GnWy9Ht.o"
#pragma merger("0","../lib/version-etc-fsf.o.i","")
#line 34 "/home/wslee/project/coreutils-8.1/lib/version-etc.h"
char const   version_etc_copyright[47] ;
#line 26 "/home/wslee/project/coreutils-8.1/lib/version-etc-fsf.c"
char const   version_etc_copyright[47]  = 
#line 26 "/home/wslee/project/coreutils-8.1/lib/version-etc-fsf.c"
  {      (char const   )'C',      (char const   )'o',      (char const   )'p',      (char const   )'y', 
        (char const   )'r',      (char const   )'i',      (char const   )'g',      (char const   )'h', 
        (char const   )'t',      (char const   )' ',      (char const   )'%',      (char const   )'s', 
        (char const   )' ',      (char const   )'%',      (char const   )'d',      (char const   )' ', 
        (char const   )'F',      (char const   )'r',      (char const   )'e',      (char const   )'e', 
        (char const   )' ',      (char const   )'S',      (char const   )'o',      (char const   )'f', 
        (char const   )'t',      (char const   )'w',      (char const   )'a',      (char const   )'r', 
        (char const   )'e',      (char const   )' ',      (char const   )'F',      (char const   )'o', 
        (char const   )'u',      (char const   )'n',      (char const   )'d',      (char const   )'a', 
        (char const   )'t',      (char const   )'i',      (char const   )'o',      (char const   )'n', 
        (char const   )',',      (char const   )' ',      (char const   )'I',      (char const   )'n', 
        (char const   )'c',      (char const   )'.',      (char const   )'\000'};
#line 1 "cil-mokGHeAc.o"
#pragma merger("0","../lib/version-etc.o.i","")
#line 52 "/home/wslee/project/coreutils-8.1/lib/version-etc.h"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) ;
#line 58
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) ;
#line 76
void emit_bug_reporting_address(void) ;
#line 55 "/home/wslee/project/coreutils-8.1/lib/version-etc.c"
void version_etc_arn(FILE *stream , char const   *command_name , char const   *package ,
                     char const   *version , char const   * const  *authors , size_t n_authors ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
#line 61
  if (command_name) {
#line 62
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s (%s) %s\n",
            command_name, package, version);
  } else {
#line 64
    fprintf((FILE * __restrict  )stream, (char const   * __restrict  )"%s %s\n", package,
            version);
  }
#line 78
  tmp = gettext("(C)");
#line 78
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )(version_etc_copyright),
          tmp, 2009);
#line 80
  tmp___0 = gettext("\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\n");
#line 80
  fputs_unlocked((char const   * __restrict  )tmp___0, (FILE * __restrict  )stream);
#line 89
  switch (n_authors) {
  case 0UL: 
#line 93
  abort();
  case 1UL: 
#line 96
  tmp___1 = gettext("Written by %s.\n");
#line 96
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___1, *(authors + 0));
#line 97
  break;
  case 2UL: 
#line 100
  tmp___2 = gettext("Written by %s and %s.\n");
#line 100
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___2, *(authors + 0),
          *(authors + 1));
#line 101
  break;
  case 3UL: 
#line 104
  tmp___3 = gettext("Written by %s, %s, and %s.\n");
#line 104
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___3, *(authors + 0),
          *(authors + 1), *(authors + 2));
#line 106
  break;
  case 4UL: 
#line 111
  tmp___4 = gettext("Written by %s, %s, %s,\nand %s.\n");
#line 111
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___4, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3));
#line 113
  break;
  case 5UL: 
#line 118
  tmp___5 = gettext("Written by %s, %s, %s,\n%s, and %s.\n");
#line 118
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___5, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4));
#line 120
  break;
  case 6UL: 
#line 125
  tmp___6 = gettext("Written by %s, %s, %s,\n%s, %s, and %s.\n");
#line 125
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___6, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5));
#line 128
  break;
  case 7UL: 
#line 133
  tmp___7 = gettext("Written by %s, %s, %s,\n%s, %s, %s, and %s.\n");
#line 133
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___7, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6));
#line 136
  break;
  case 8UL: 
#line 141
  tmp___8 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\nand %s.\n");
#line 141
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___8, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7));
#line 145
  break;
  case 9UL: 
#line 150
  tmp___9 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, and %s.\n");
#line 150
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___9, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7), *(authors + 8));
#line 154
  break;
  default: 
#line 161
  tmp___10 = gettext("Written by %s, %s, %s,\n%s, %s, %s, %s,\n%s, %s, and others.\n");
#line 161
  fprintf((FILE * __restrict  )stream, (char const   * __restrict  )tmp___10, *(authors + 0),
          *(authors + 1), *(authors + 2), *(authors + 3), *(authors + 4), *(authors + 5),
          *(authors + 6), *(authors + 7), *(authors + 8));
#line 165
  break;
  }
#line 167
  return;
}
}
#line 173 "/home/wslee/project/coreutils-8.1/lib/version-etc.c"
void version_etc_ar(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , char const   * const  *authors ) 
{ 
  size_t n_authors ;

  {
#line 180
  n_authors = (size_t )0;
#line 180
  while (*(authors + n_authors)) {
#line 180
    n_authors ++;
  }
#line 182
  version_etc_arn(stream, command_name, package, version, authors, n_authors);
#line 183
  return;
}
}
#line 189 "/home/wslee/project/coreutils-8.1/lib/version-etc.c"
void version_etc_va(FILE *stream , char const   *command_name , char const   *package ,
                    char const   *version , va_list authors ) 
{ 
  size_t n_authors ;
  char const   *authtab[10] ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 197
  n_authors = (size_t )0;
#line 197
  while (1) {
#line 197
    if (n_authors < 10UL) {
#line 197
      tmp___0 = __builtin_va_arg(authors, char const   *);
#line 197
      tmp = tmp___0;
#line 197
      authtab[n_authors] = tmp;
#line 197
      if (! ((unsigned long )tmp != (unsigned long )((void *)0))) {
#line 197
        break;
      }
    } else {
#line 197
      break;
    }
#line 197
    n_authors ++;
  }
#line 202
  version_etc_arn(stream, command_name, package, version, (char const   * const  *)(authtab),
                  n_authors);
#line 204
  return;
}
}
#line 220
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...)  __attribute__((__sentinel__)) ;
#line 220 "/home/wslee/project/coreutils-8.1/lib/version-etc.c"
void version_etc(FILE *stream , char const   *command_name , char const   *package ,
                 char const   *version  , ...) 
{ 
  va_list authors ;

  {
#line 227
  __builtin_va_start(authors, version);
#line 228
  version_etc_va(stream, command_name, package, version, authors);
#line 229
  __builtin_va_end(authors);
#line 230
  return;
}
}
#line 232 "/home/wslee/project/coreutils-8.1/lib/version-etc.c"
void emit_bug_reporting_address(void) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 239
  tmp = gettext("\nReport bugs to: %s\n");
#line 239
  printf((char const   * __restrict  )tmp, "bug-coreutils@gnu.org");
#line 245
  tmp___0 = gettext("%s home page: <%s>\n");
#line 245
  printf((char const   * __restrict  )tmp___0, "GNU coreutils", "http://www.gnu.org/software/coreutils/");
#line 250
  tmp___1 = gettext("General help using GNU software: <http://www.gnu.org/gethelp/>\n");
#line 250
  fputs_unlocked((char const   * __restrict  )tmp___1, (FILE * __restrict  )stdout);
#line 252
  return;
}
}
#line 1 "cil-m23OfNty.o"
#pragma merger("0","../lib/vfprintf.o.i","")
#line 572 "./stdio.h"
int ( /* format attribute */  rpl_vfprintf)(FILE *fp , char const   *format , va_list args ) ;
#line 35 "/home/wslee/project/coreutils-8.1/lib/vfprintf.c"
int ( /* format attribute */  rpl_vfprintf)(FILE *fp , char const   *format , va_list args ) 
{ 
  char buf___0[2000] ;
  char *output ;
  size_t len ;
  size_t lenbuf ;
  int saved_errno ;
  int *tmp ;
  int *tmp___0 ;
  size_t tmp___1 ;
  int *tmp___2 ;

  {
#line 41
  lenbuf = sizeof(buf___0);
#line 43
  output = vasnprintf(buf___0, & lenbuf, format, args);
#line 44
  len = lenbuf;
#line 46
  if (! output) {
#line 48
    fseterr(fp);
#line 49
    return (-1);
  }
#line 52
  tmp___1 = fwrite((void const   * __restrict  )output, (size_t )1, len, (FILE * __restrict  )fp);
#line 52
  if (tmp___1 < len) {
#line 54
    if ((unsigned long )output != (unsigned long )(buf___0)) {
#line 56
      tmp = __errno_location();
#line 56
      saved_errno = *tmp;
#line 57
      free((void *)output);
#line 58
      tmp___0 = __errno_location();
#line 58
      *tmp___0 = saved_errno;
    }
#line 60
    return (-1);
  }
#line 63
  if (len > 2147483647UL) {
#line 65
    tmp___2 = __errno_location();
#line 65
    *tmp___2 = 75;
#line 66
    fseterr(fp);
#line 67
    return (-1);
  }
#line 70
  return ((int )len);
}
}
#line 1 "cil-Yc_zgP5s.o"
#pragma merger("0","../lib/vprintf.o.i","")
#line 591 "./stdio.h"
int ( /* format attribute */  rpl_vprintf)(char const   *format , va_list args ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/vprintf.c"
int ( /* format attribute */  rpl_vprintf)(char const   *format , va_list args ) 
{ 
  int tmp ;

  {
#line 32
  tmp = rpl_vfprintf(stdout, format, args);
#line 32
  return (tmp);
}
}
#line 1 "cil-Q2hLRq8f.o"
#pragma merger("0","../lib/write-any-file.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/write-any-file.h"
_Bool can_write_any_file(void) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/write-any-file.c"
static _Bool initialized___0  ;
#line 34 "/home/wslee/project/coreutils-8.1/lib/write-any-file.c"
static _Bool can_write  ;
#line 30 "/home/wslee/project/coreutils-8.1/lib/write-any-file.c"
_Bool can_write_any_file(void) 
{ 
  _Bool can ;
  __uid_t tmp ;

  {
#line 36
  if (! initialized___0) {
#line 38
    can = (_Bool)0;
#line 43
    tmp = geteuid();
#line 43
    can = (_Bool )(tmp == 0U);
#line 45
    can_write = can;
#line 46
    initialized___0 = (_Bool)1;
  }
#line 49
  return (can_write);
}
}
#line 1 "cil-wV8S4kBS.o"
#pragma merger("0","../lib/xalloc-die.o.i","")
#line 31 "/home/wslee/project/coreutils-8.1/lib/xalloc-die.c"
 __attribute__((__noreturn__)) void xalloc_die(void) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/xalloc-die.c"
void xalloc_die(void) 
{ 
  char *tmp ;

  {
#line 34
  tmp = gettext("memory exhausted");
#line 34
  error((int )exit_failure, 0, "%s", tmp);
#line 40
  abort();
}
}
#line 1 "cil-HiRWNPUC.o"
#pragma merger("0","../lib/xasprintf.o.i","")
#line 47 "/home/wslee/project/coreutils-8.1/lib/xvasprintf.h"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) ;
#line 22 "/home/wslee/project/coreutils-8.1/lib/xasprintf.c"
char *( /* format attribute */  xasprintf)(char const   *format  , ...) 
{ 
  va_list args ;
  char *result ;

  {
#line 28
  __builtin_va_start(args, format);
#line 29
  result = xvasprintf(format, args);
#line 30
  __builtin_va_end(args);
#line 32
  return (result);
}
}
#line 1 "cil-GK4cPEqb.o"
#pragma merger("0","../lib/xfreopen.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/xfreopen.h"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/xfreopen.c"
void xfreopen(char const   *filename , char const   *mode , FILE *fp ) 
{ 
  char const   *f ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;
  int *tmp___10 ;
  FILE *tmp___11 ;

  {
#line 32
  tmp___11 = freopen_safer(filename, mode, fp);
#line 32
  if (! tmp___11) {
#line 34
    if (filename) {
#line 34
      tmp___6 = filename;
    } else {
#line 34
      if ((unsigned long )fp == (unsigned long )stdin) {
#line 34
        tmp = gettext("stdin");
#line 34
        tmp___5 = tmp;
      } else {
#line 34
        if ((unsigned long )fp == (unsigned long )stdout) {
#line 34
          tmp___0 = gettext("stdout");
#line 34
          tmp___4 = tmp___0;
        } else {
#line 34
          if ((unsigned long )fp == (unsigned long )stderr) {
#line 34
            tmp___1 = gettext("stderr");
#line 34
            tmp___3 = tmp___1;
          } else {
#line 34
            tmp___2 = gettext("unknown stream");
#line 34
            tmp___3 = tmp___2;
          }
#line 34
          tmp___4 = tmp___3;
        }
#line 34
        tmp___5 = tmp___4;
      }
#line 34
      tmp___6 = (char const   *)tmp___5;
    }
#line 34
    f = tmp___6;
#line 39
    tmp___7 = quote_n(1, mode);
#line 39
    tmp___8 = quote_n(0, f);
#line 39
    tmp___9 = gettext("failed to reopen %s with mode %s");
#line 39
    tmp___10 = __errno_location();
#line 39
    error((int )exit_failure, *tmp___10, (char const   *)tmp___9, tmp___8, tmp___7);
  }
#line 42
  return;
}
}
#line 1 "cil-4Sso6aWd.o"
#pragma merger("0","../lib/xfts.o.i","")
#line 36 "/home/wslee/project/coreutils-8.1/lib/xfts.c"
FTS *xfts_open(char * const  *argv , int options , int (*compar)(FTSENT const   ** ,
                                                                 FTSENT const   ** ) ) 
{ 
  FTS *fts ;
  FTS *tmp ;
  _Bool invalid_arg ;
  char const   *tmp___0 ;
  char *tmp___1 ;

  {
#line 40
  tmp = fts_open(argv, options | 512, compar);
#line 40
  fts = tmp;
#line 41
  if ((unsigned long )fts == (unsigned long )((void *)0)) {
#line 50
    invalid_arg = (_Bool)0;
#line 51
    while (*argv) {
#line 53
      if ((int )*(*argv) == 0) {
#line 54
        invalid_arg = (_Bool)1;
      }
#line 51
      argv ++;
    }
#line 56
    if (invalid_arg) {
#line 57
      tmp___0 = quote("");
#line 57
      tmp___1 = gettext("invalid argument: %s");
#line 57
      error(1, 0, (char const   *)tmp___1, tmp___0);
    } else {
#line 59
      xalloc_die();
    }
  }
#line 62
  return (fts);
}
}
#line 72 "/home/wslee/project/coreutils-8.1/lib/xfts.c"
_Bool cycle_warning_required(FTS const   *fts , FTSENT const   *ent ) 
{ 
  int tmp ;

  {
#line 79
  if (fts->fts_options & 16) {
#line 79
    if (! (fts->fts_options & 1)) {
#line 79
      tmp = 1;
    } else {
#line 79
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 79
  if (fts->fts_options & 16) {
#line 79
    if (fts->fts_options & 1) {
#line 79
      if (ent->fts_level != 0L) {
#line 79
        tmp = 1;
      } else {
#line 79
        tmp = 0;
      }
    } else {
#line 79
      tmp = 0;
    }
  } else {
#line 79
    tmp = 0;
  }
#line 79
  return ((_Bool )tmp);
}
}
#line 1 "cil-hC975xl8.o"
#pragma merger("0","../lib/xgetcwd.o.i","")
#line 514 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 33 "/home/wslee/project/coreutils-8.1/lib/xgetcwd.c"
char *xgetcwd(void) 
{ 
  char *cwd ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 36
  tmp = getcwd((char *)((void *)0), (size_t )0);
#line 36
  cwd = tmp;
#line 37
  if (! cwd) {
#line 37
    tmp___0 = __errno_location();
#line 37
    if (*tmp___0 == 12) {
#line 38
      xalloc_die();
    }
  }
#line 39
  return (cwd);
}
}
#line 1 "cil-dXBXYyw1.o"
#pragma merger("0","../lib/xgethostname.o.i","")
#line 1 "/home/wslee/project/coreutils-8.1/lib/xgethostname.h"
char *xgethostname(void) ;
#line 882 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 39 "/home/wslee/project/coreutils-8.1/lib/xgethostname.c"
char *xgethostname(void) 
{ 
  char *hostname ;
  size_t size ;
  size_t size_1 ;
  void *tmp ;
  int *tmp___0 ;
  int saved_errno ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;

  {
#line 42
  hostname = (char *)((void *)0);
#line 43
  size = (size_t )34;
#line 45
  while (1) {
#line 52
    tmp = x2realloc((void *)hostname, & size);
#line 52
    hostname = (char *)tmp;
#line 53
    size_1 = size - 1UL;
#line 54
    *(hostname + (size_1 - 1UL)) = (char )'\000';
#line 55
    tmp___0 = __errno_location();
#line 55
    *tmp___0 = 0;
#line 57
    tmp___7 = gethostname(hostname, size_1);
#line 57
    if (tmp___7 == 0) {
#line 59
      if (! *(hostname + (size_1 - 1UL))) {
#line 60
        break;
      }
    } else {
#line 62
      tmp___3 = __errno_location();
#line 62
      if (*tmp___3 != 0) {
#line 62
        tmp___4 = __errno_location();
#line 62
        if (*tmp___4 != 36) {
#line 62
          tmp___5 = __errno_location();
#line 62
          if (*tmp___5 != 22) {
#line 62
            tmp___6 = __errno_location();
#line 62
            if (*tmp___6 != 12) {
#line 66
              tmp___1 = __errno_location();
#line 66
              saved_errno = *tmp___1;
#line 67
              free((void *)hostname);
#line 68
              tmp___2 = __errno_location();
#line 68
              *tmp___2 = saved_errno;
#line 69
              return ((char *)((void *)0));
            }
          }
        }
      }
    }
  }
#line 73
  return (hostname);
}
}
#line 1 "cil-cBVB7ywg.o"
#pragma merger("0","../lib/xmalloc.o.i","")
#line 42 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
void *xmalloc(size_t n )  __attribute__((__malloc__)) ;
#line 42 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
void *xmalloc(size_t n ) 
{ 
  void *p ;
  void *tmp ;

  {
#line 45
  tmp = malloc(n);
#line 45
  p = tmp;
#line 46
  if (! p) {
#line 46
    if (n != 0UL) {
#line 47
      xalloc_die();
    }
  }
#line 48
  return (p);
}
}
#line 54 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
void *xrealloc(void *p , size_t n ) 
{ 


  {
#line 57
  p = realloc(p, n);
#line 58
  if (! p) {
#line 58
    if (n != 0UL) {
#line 59
      xalloc_die();
    }
  }
#line 60
  return (p);
}
}
#line 69 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
void *x2realloc(void *p , size_t *pn ) 
{ 
  void *tmp ;

  {
#line 72
  tmp = x2nrealloc(p, pn, (size_t )1);
#line 72
  return (tmp);
}
}
#line 79
void *xzalloc(size_t s )  __attribute__((__malloc__)) ;
#line 79 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
void *xzalloc(size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 82
  tmp = xmalloc(s);
#line 82
  tmp___0 = memset(tmp, 0, s);
#line 82
  return (tmp___0);
}
}
#line 88
void *xcalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 88 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
void *xcalloc(size_t n , size_t s ) 
{ 
  void *p ;

  {
#line 96
  p = calloc(n, s);
#line 96
  if (! p) {
#line 98
    xalloc_die();
  }
#line 99
  return (p);
}
}
#line 106
void *xmemdup(void const   *p , size_t s )  __attribute__((__malloc__)) ;
#line 106 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
void *xmemdup(void const   *p , size_t s ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 109
  tmp = xmalloc(s);
#line 109
  tmp___0 = memcpy((void * __restrict  )tmp, (void const   * __restrict  )p, s);
#line 109
  return (tmp___0);
}
}
#line 114
char *xstrdup(char const   *string )  __attribute__((__malloc__)) ;
#line 114 "/home/wslee/project/coreutils-8.1/lib/xmalloc.c"
char *xstrdup(char const   *string ) 
{ 
  size_t tmp ;
  void *tmp___0 ;

  {
#line 117
  tmp = strlen(string);
#line 117
  tmp___0 = xmemdup((void const   *)string, tmp + 1UL);
#line 117
  return ((char *)tmp___0);
}
}
#line 1 "cil-Wq9sUOqK.o"
#pragma merger("0","../lib/xmemcoll.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/xmemcoll.h"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) ;
#line 40 "/home/wslee/project/coreutils-8.1/lib/xmemcoll.c"
int xmemcoll(char *s1 , size_t s1len , char *s2 , size_t s2len ) 
{ 
  int diff ;
  int tmp ;
  int collation_errno ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
#line 43
  tmp = memcoll(s1, s1len, s2, s2len);
#line 43
  diff = tmp;
#line 44
  tmp___0 = __errno_location();
#line 44
  collation_errno = *tmp___0;
#line 46
  if (collation_errno) {
#line 48
    tmp___1 = gettext("string comparison failed");
#line 48
    error(0, collation_errno, (char const   *)tmp___1);
#line 49
    tmp___2 = gettext("Set LC_ALL=\'C\' to work around the problem.");
#line 49
    error(0, 0, (char const   *)tmp___2);
#line 50
    tmp___3 = quotearg_n_style_mem(1, (enum quoting_style )6, (char const   *)s2,
                                   s2len);
#line 50
    tmp___4 = quotearg_n_style_mem(0, (enum quoting_style )6, (char const   *)s1,
                                   s1len);
#line 50
    tmp___5 = gettext("The strings compared were %s and %s.");
#line 50
    error((int )exit_failure, 0, (char const   *)tmp___5, tmp___4, tmp___3);
  }
#line 56
  return (diff);
}
}
#line 1 "cil-fENUDWIl.o"
#pragma merger("0","../lib/xmemxfrm.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/lib/xmemxfrm.h"
size_t xmemxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
                size_t srcsize ) ;
#line 46 "/home/wslee/project/coreutils-8.1/lib/xmemxfrm.c"
size_t xmemxfrm(char * __restrict  dest , size_t destsize , char * __restrict  src ,
                size_t srcsize ) 
{ 
  size_t translated_size ;
  size_t tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;

  {
#line 50
  tmp = memxfrm(dest, destsize, src, srcsize);
#line 50
  translated_size = tmp;
#line 52
  tmp___5 = __errno_location();
#line 52
  if (*tmp___5) {
#line 54
    tmp___0 = gettext("string transformation failed");
#line 54
    tmp___1 = __errno_location();
#line 54
    error(0, *tmp___1, (char const   *)tmp___0);
#line 55
    tmp___2 = gettext("set LC_ALL=\'C\' to work around the problem");
#line 55
    error(0, 0, (char const   *)tmp___2);
#line 56
    tmp___3 = quotearg_n_style_mem(0, (enum quoting_style )6, (char const   *)src,
                                   srcsize);
#line 56
    tmp___4 = gettext("the untransformed string was %s");
#line 56
    error((int )exit_failure, 0, (char const   *)tmp___4, tmp___3);
  }
#line 61
  return (translated_size);
}
}
#line 1 "cil-6TkDG1Dh.o"
#pragma merger("0","../lib/xnanosleep.o.i","")
#line 1 "/home/wslee/project/coreutils-8.1/lib/xnanosleep.h"
int xnanosleep(double seconds ) ;
#line 47 "/home/wslee/project/coreutils-8.1/lib/xnanosleep.c"
int xnanosleep(double seconds ) 
{ 
  _Bool overflow ;
  int tmp ;
  int tmp___0 ;
  struct timespec ts_sleep ;
  time_t floor_seconds ;
  double ns ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;

  {
#line 59
  if ((time_t )((double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) / (double )2) == ~ (-1L << (sizeof(time_t ) * 8UL - 1UL)) / 2L) {
#line 59
    tmp___0 = (double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) < seconds;
  } else {
#line 59
    if ((time_t )((long double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) / (long double )2) == ~ (-1L << (sizeof(time_t ) * 8UL - 1UL)) / 2L) {
#line 59
      tmp = (long double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) < (long double )seconds;
    } else {
#line 59
      tmp = (long double )(~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) <= (long double )seconds;
    }
#line 59
    tmp___0 = tmp;
  }
#line 59
  overflow = (_Bool )tmp___0;
#line 67
  if (! ((double )0 <= seconds)) {
#line 67
    __assert_fail("0 <= seconds", "/home/wslee/project/coreutils-8.1/lib/xnanosleep.c",
                  67U, "xnanosleep");
  }
#line 70
  if (! overflow) {
#line 72
    floor_seconds = (time_t )seconds;
#line 73
    ns = (double )1000000000 * (seconds - (double )floor_seconds);
#line 74
    ts_sleep.tv_sec = floor_seconds;
#line 81
    ts_sleep.tv_nsec = (__syscall_slong_t )ns;
#line 82
    ts_sleep.tv_nsec += (__syscall_slong_t )((double )ts_sleep.tv_nsec < ns);
#line 85
    if (1000000000L <= ts_sleep.tv_nsec) {
#line 87
      if (ts_sleep.tv_sec == ~ (-1L << (sizeof(time_t ) * 8UL - 1UL))) {
#line 88
        overflow = (_Bool)1;
      } else {
#line 91
        (ts_sleep.tv_sec) ++;
#line 92
        ts_sleep.tv_nsec -= 1000000000L;
      }
    }
  }
#line 97
  while (1) {
#line 99
    if (overflow) {
#line 101
      ts_sleep.tv_sec = ~ (-1L << (sizeof(time_t ) * 8UL - 1UL));
#line 102
      ts_sleep.tv_nsec = (__syscall_slong_t )999999999;
    }
#line 111
    tmp___1 = __errno_location();
#line 111
    *tmp___1 = 0;
#line 112
    tmp___2 = rpl_nanosleep((struct timespec  const  *)(& ts_sleep), (struct timespec *)((void *)0));
#line 112
    if (tmp___2 == 0) {
#line 113
      break;
    }
#line 114
    tmp___3 = __errno_location();
#line 114
    if (*tmp___3 != 4) {
#line 114
      tmp___4 = __errno_location();
#line 114
      if (*tmp___4 != 0) {
#line 115
        return (-1);
      }
    }
  }
#line 118
  return (0);
}
}
#line 1 "cil-45UKN3Yj.o"
#pragma merger("0","../lib/xprintf.o.i","")
#line 36 "/home/wslee/project/coreutils-8.1/lib/xprintf.h"
int ( /* format attribute */  xprintf)(char const   * __restrict  format  , ...) ;
#line 38
int ( /* format attribute */  xvprintf)(char const   * __restrict  format , va_list args ) ;
#line 40
int ( /* format attribute */  xfprintf)(FILE * __restrict  stream , char const   * __restrict  format 
                                        , ...) ;
#line 42
int ( /* format attribute */  xvfprintf)(FILE * __restrict  stream , char const   * __restrict  format ,
                                         va_list args ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/xprintf.c"
int ( /* format attribute */  xprintf)(char const   * __restrict  format  , ...) 
{ 
  va_list args ;
  int retval ;

  {
#line 36
  __builtin_va_start(args, format);
#line 37
  retval = xvprintf(format, args);
#line 38
  __builtin_va_end(args);
#line 40
  return (retval);
}
}
#line 45 "/home/wslee/project/coreutils-8.1/lib/xprintf.c"
int ( /* format attribute */  xvprintf)(char const   * __restrict  format , va_list args ) 
{ 
  int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 48
  tmp = rpl_vprintf((char const   *)format, args);
#line 48
  retval = tmp;
#line 49
  if (retval < 0) {
#line 49
    tmp___2 = ferror(stdout);
#line 49
    if (! tmp___2) {
#line 50
      tmp___0 = gettext("cannot perform formatted output");
#line 50
      tmp___1 = __errno_location();
#line 50
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
    }
  }
#line 52
  return (retval);
}
}
#line 57 "/home/wslee/project/coreutils-8.1/lib/xprintf.c"
int ( /* format attribute */  xfprintf)(FILE * __restrict  stream , char const   * __restrict  format 
                                        , ...) 
{ 
  va_list args ;
  int retval ;

  {
#line 62
  __builtin_va_start(args, format);
#line 63
  retval = xvfprintf(stream, format, args);
#line 64
  __builtin_va_end(args);
#line 66
  return (retval);
}
}
#line 71 "/home/wslee/project/coreutils-8.1/lib/xprintf.c"
int ( /* format attribute */  xvfprintf)(FILE * __restrict  stream , char const   * __restrict  format ,
                                         va_list args ) 
{ 
  int retval ;
  int tmp ;
  char *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 74
  tmp = rpl_vfprintf((FILE *)stream, (char const   *)format, args);
#line 74
  retval = tmp;
#line 75
  if (retval < 0) {
#line 75
    tmp___2 = ferror((FILE *)stream);
#line 75
    if (! tmp___2) {
#line 76
      tmp___0 = gettext("cannot perform formatted output");
#line 76
      tmp___1 = __errno_location();
#line 76
      error((int )exit_failure, *tmp___1, (char const   *)tmp___0);
    }
  }
#line 78
  return (retval);
}
}
#line 1 "cil-yOD1SB9w.o"
#pragma merger("0","../lib/xreadlink.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/xreadlink.h"
char *xreadlink(char const   *filename ) ;
#line 37 "/home/wslee/project/coreutils-8.1/lib/xreadlink.c"
char *xreadlink(char const   *filename ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 40
  tmp = areadlink(filename);
#line 40
  result = tmp;
#line 41
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 41
    tmp___0 = __errno_location();
#line 41
    if (*tmp___0 == 12) {
#line 42
      xalloc_die();
    }
  }
#line 43
  return (result);
}
}
#line 1 "cil-_wXwUZVi.o"
#pragma merger("0","../lib/xstriconv.o.i","")
#line 45 "/home/wslee/project/coreutils-8.1/lib/xstriconv.h"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) ;
#line 57
char *xstr_cd_iconv(char const   *src , iconv_t cd ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/xstriconv.c"
int xmem_cd_iconv(char const   *src , size_t srclen , iconv_t cd , char **resultp ,
                  size_t *lengthp ) 
{ 
  int retval ;
  int tmp ;
  int *tmp___0 ;

  {
#line 35
  tmp = mem_cd_iconv(src, srclen, cd, resultp, lengthp);
#line 35
  retval = tmp;
#line 37
  if (retval < 0) {
#line 37
    tmp___0 = __errno_location();
#line 37
    if (*tmp___0 == 12) {
#line 38
      xalloc_die();
    }
  }
#line 39
  return (retval);
}
}
#line 42 "/home/wslee/project/coreutils-8.1/lib/xstriconv.c"
char *xstr_cd_iconv(char const   *src , iconv_t cd ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 45
  tmp = str_cd_iconv(src, cd);
#line 45
  result = tmp;
#line 47
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 47
    tmp___0 = __errno_location();
#line 47
    if (*tmp___0 == 12) {
#line 48
      xalloc_die();
    }
  }
#line 49
  return (result);
}
}
#line 54 "/home/wslee/project/coreutils-8.1/lib/xstriconv.c"
char *xstr_iconv(char const   *src , char const   *from_codeset , char const   *to_codeset ) 
{ 
  char *result ;
  char *tmp ;
  int *tmp___0 ;

  {
#line 57
  tmp = str_iconv(src, from_codeset, to_codeset);
#line 57
  result = tmp;
#line 59
  if ((unsigned long )result == (unsigned long )((void *)0)) {
#line 59
    tmp___0 = __errno_location();
#line 59
    if (*tmp___0 == 12) {
#line 60
      xalloc_die();
    }
  }
#line 61
  return (result);
}
}
#line 1 "cil-3k5XOGFj.o"
#pragma merger("0","../lib/xstrndup.o.i","")
#line 179 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strndup)(char const   *__string ,
                                                                                                size_t __n )  __attribute__((__malloc__)) ;
#line 29 "/home/wslee/project/coreutils-8.1/lib/xstrndup.c"
char *xstrndup(char const   *string , size_t n ) 
{ 
  char *s ;
  char *tmp ;

  {
#line 32
  tmp = strndup(string, n);
#line 32
  s = tmp;
#line 33
  if (! s) {
#line 34
    xalloc_die();
  }
#line 35
  return (s);
}
}
#line 1 "cil-IEdP5Gpn.o"
#pragma merger("0","../lib/xstrtod.o.i","")
#line 25 "/home/wslee/project/coreutils-8.1/lib/xstrtod.h"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) ;
#line 44 "/home/wslee/project/coreutils-8.1/lib/xstrtod.c"
_Bool xstrtod(char const   *str , char const   **ptr , double *result , double (*convert)(char const   * ,
                                                                                          char ** ) ) 
{ 
  double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 50
  ok = (_Bool)1;
#line 52
  tmp = __errno_location();
#line 52
  *tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
#line 56
  if ((unsigned long )terminator == (unsigned long )str) {
#line 57
    ok = (_Bool)0;
  } else
#line 56
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 56
    if ((int )*terminator != 0) {
#line 57
      ok = (_Bool)0;
    } else {
#line 56
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 62
  if (val != (double )0) {
#line 62
    tmp___0 = __errno_location();
#line 62
    if (*tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 1 "cil-tYLrDsT2.o"
#pragma merger("0","../lib/xstrtoimax.o.i","")
#line 297 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) intmax_t ( __attribute__((__leaf__)) strtoimax)(char const   * __restrict  __nptr ,
                                                                                     char ** __restrict  __endptr ,
                                                                                     int __base ) ;
#line 46 "/home/wslee/project/coreutils-8.1/lib/xstrtol.h"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) ;
#line 46 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale(intmax_t *x , int scale_factor ) 
{ 


  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (intmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power(intmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
strtol_error xstrtoimax(char const   *s , char **ptr , int strtol_base , intmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  intmax_t tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                    83U, "xstrtoimax");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                  83U, "xstrtoimax");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoimax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___2 = strchr(valid_suffixes, (int )*(*p));
#line 104
        if (tmp___2) {
#line 105
          tmp = (intmax_t )1;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___4 = __errno_location();
#line 109
    if (*tmp___4 != 0) {
#line 111
      tmp___3 = __errno_location();
#line 111
      if (*tmp___3 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___5) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___6 = strchr(valid_suffixes, '0');
#line 137
    if (tmp___6) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 68: 
      case 66: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power(& tmp, base, 6);
#line 177
    break;
    case 103: 
    case 71: 
#line 181
    overflow = bkm_scale_by_power(& tmp, base, 3);
#line 182
    break;
    case 75: 
    case 107: 
#line 186
    overflow = bkm_scale_by_power(& tmp, base, 1);
#line 187
    break;
    case 109: 
    case 77: 
#line 191
    overflow = bkm_scale_by_power(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power(& tmp, base, 5);
#line 196
    break;
    case 116: 
    case 84: 
#line 200
    overflow = bkm_scale_by_power(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "cil-fnwaZw6C.o"
#pragma merger("0","../lib/xstrtol-error.o.i","")
#line 46 "/home/wslee/project/coreutils-8.1/lib/xstrtol-error.c"
static void xstrtol_error(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___1 ,
                          char const   *arg , int exit_status ) 
{ 
  char const   *hyphens ;
  char const   *msgid ;
  char const   *option ;
  char option_buffer[2] ;
  char *tmp ;

  {
#line 52
  hyphens = "--";
#line 57
  switch ((unsigned int )err) {
  default: 
#line 60
  abort();
  case 4U: 
#line 63
  msgid = "invalid %s%s argument `%s\'";
#line 64
  break;
  case 3U: 
  case 2U: 
#line 68
  msgid = "invalid suffix in %s%s argument `%s\'";
#line 69
  break;
  case 1U: 
#line 72
  msgid = "%s%s argument `%s\' too large";
#line 73
  break;
  }
#line 76
  if (opt_idx < 0) {
#line 78
    hyphens -= opt_idx;
#line 79
    option_buffer[0] = c;
#line 80
    option_buffer[1] = (char )'\000';
#line 81
    option = (char const   *)(option_buffer);
  } else {
#line 84
    option = (char const   *)(long_options___1 + opt_idx)->name;
  }
#line 86
  tmp = gettext(msgid);
#line 86
  error(exit_status, 0, (char const   *)tmp, hyphens, option, arg);
#line 87
  return;
}
}
#line 91
 __attribute__((__noreturn__)) void xstrtol_fatal(enum strtol_error err , int opt_idx ,
                                                  char c , struct option  const  *long_options___1 ,
                                                  char const   *arg ) ;
#line 91 "/home/wslee/project/coreutils-8.1/lib/xstrtol-error.c"
void xstrtol_fatal(enum strtol_error err , int opt_idx , char c , struct option  const  *long_options___1 ,
                   char const   *arg ) 
{ 


  {
#line 96
  xstrtol_error(err, opt_idx, c, long_options___1, arg, (int )exit_failure);
#line 97
  abort();
}
}
#line 1 "cil-l3NvUk76.o"
#pragma merger("0","../lib/xstrtol.o.i","")
#line 44 "/home/wslee/project/coreutils-8.1/lib/xstrtol.h"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) ;
#line 46 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale___0(long *x , int scale_factor ) 
{ 


  {
#line 49
  if (*x < (-0x7FFFFFFFFFFFFFFF-1) / (long )scale_factor) {
#line 51
    *x = (-0x7FFFFFFFFFFFFFFF-1);
#line 52
    return ((strtol_error )1);
  }
#line 54
  if (9223372036854775807L / (long )scale_factor < *x) {
#line 56
    *x = 9223372036854775807L;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___0(long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale___0(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
strtol_error xstrtol(char const   *s , char **ptr , int strtol_base , long *val ,
                     char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  long tmp ;
  strtol_error err ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                    83U, "xstrtol");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                  83U, "xstrtol");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtol((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___2 = strchr(valid_suffixes, (int )*(*p));
#line 104
        if (tmp___2) {
#line 105
          tmp = 1L;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___4 = __errno_location();
#line 109
    if (*tmp___4 != 0) {
#line 111
      tmp___3 = __errno_location();
#line 111
      if (*tmp___3 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___5) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___6 = strchr(valid_suffixes, '0');
#line 137
    if (tmp___6) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 68: 
      case 66: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___0(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___0(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___0(& tmp, base, 6);
#line 177
    break;
    case 103: 
    case 71: 
#line 181
    overflow = bkm_scale_by_power___0(& tmp, base, 3);
#line 182
    break;
    case 75: 
    case 107: 
#line 186
    overflow = bkm_scale_by_power___0(& tmp, base, 1);
#line 187
    break;
    case 109: 
    case 77: 
#line 191
    overflow = bkm_scale_by_power___0(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___0(& tmp, base, 5);
#line 196
    break;
    case 116: 
    case 84: 
#line 200
    overflow = bkm_scale_by_power___0(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___0(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___0(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___0(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "cil-Tyz5DufS.o"
#pragma merger("0","../lib/xstrtold.o.i","")
#line 27 "/home/wslee/project/coreutils-8.1/lib/xstrtod.h"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) ;
#line 44 "/home/wslee/project/coreutils-8.1/lib/xstrtod.c"
_Bool xstrtold(char const   *str , char const   **ptr , long double *result , long double (*convert)(char const   * ,
                                                                                                     char ** ) ) 
{ 
  long double val ;
  char *terminator ;
  _Bool ok ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 50
  ok = (_Bool)1;
#line 52
  tmp = __errno_location();
#line 52
  *tmp = 0;
#line 53
  val = (*convert)(str, & terminator);
#line 56
  if ((unsigned long )terminator == (unsigned long )str) {
#line 57
    ok = (_Bool)0;
  } else
#line 56
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 56
    if ((int )*terminator != 0) {
#line 57
      ok = (_Bool)0;
    } else {
#line 56
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 62
  if (val != (long double )0) {
#line 62
    tmp___0 = __errno_location();
#line 62
    if (*tmp___0 == 34) {
#line 63
      ok = (_Bool)0;
    }
  }
#line 66
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 67
    *ptr = (char const   *)terminator;
  }
#line 69
  *result = val;
#line 70
  return (ok);
}
}
#line 1 "cil-KTiMMfef.o"
#pragma merger("0","../lib/xstrtoul.o.i","")
#line 46 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale___1(unsigned long *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (unsigned long )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___1(unsigned long *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale___1(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
strtol_error xstrtoul(char const   *s , char **ptr , int strtol_base , unsigned long *val ,
                      char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  unsigned long tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                    83U, "xstrtoul");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                  83U, "xstrtoul");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
#line 91
  while (1) {
#line 91
    tmp___0 = __ctype_b_loc();
#line 91
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
#line 91
      break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoul((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___2 = strchr(valid_suffixes, (int )*(*p));
#line 104
        if (tmp___2) {
#line 105
          tmp = 1UL;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___4 = __errno_location();
#line 109
    if (*tmp___4 != 0) {
#line 111
      tmp___3 = __errno_location();
#line 111
      if (*tmp___3 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___5) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___6 = strchr(valid_suffixes, '0');
#line 137
    if (tmp___6) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 68: 
      case 66: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___1(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___1(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___1(& tmp, base, 6);
#line 177
    break;
    case 103: 
    case 71: 
#line 181
    overflow = bkm_scale_by_power___1(& tmp, base, 3);
#line 182
    break;
    case 75: 
    case 107: 
#line 186
    overflow = bkm_scale_by_power___1(& tmp, base, 1);
#line 187
    break;
    case 109: 
    case 77: 
#line 191
    overflow = bkm_scale_by_power___1(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___1(& tmp, base, 5);
#line 196
    break;
    case 116: 
    case 84: 
#line 200
    overflow = bkm_scale_by_power___1(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___1(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___1(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___1(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
#line 1 "cil-eyDtnaXA.o"
#pragma merger("0","../lib/xstrtoumax.o.i","")
#line 301 "/usr/include/inttypes.h"
extern  __attribute__((__nothrow__)) uintmax_t ( __attribute__((__leaf__)) strtoumax)(char const   * __restrict  __nptr ,
                                                                                      char ** __restrict  __endptr ,
                                                                                      int __base ) ;
#line 46 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale___2(uintmax_t *x , int scale_factor ) 
{ 


  {
#line 54
  if (0xffffffffffffffffUL / (unsigned long )scale_factor < *x) {
#line 56
    *x = 0xffffffffffffffffUL;
#line 57
    return ((strtol_error )1);
  }
#line 59
  *x *= (uintmax_t )scale_factor;
#line 60
  return ((strtol_error )0);
}
}
#line 63 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
static strtol_error bkm_scale_by_power___2(uintmax_t *x , int base , int power ) 
{ 
  strtol_error err ;
  strtol_error tmp ;
  int tmp___0 ;

  {
#line 66
  err = (strtol_error )0;
#line 67
  while (1) {
#line 67
    tmp___0 = power;
#line 67
    power --;
#line 67
    if (! tmp___0) {
#line 67
      break;
    }
#line 68
    tmp = bkm_scale___2(x, base);
#line 68
    err = (strtol_error )((unsigned int )err | (unsigned int )tmp);
  }
#line 69
  return (err);
}
}
#line 74 "/home/wslee/project/coreutils-8.1/lib/xstrtol.c"
strtol_error xstrtoumax(char const   *s , char **ptr , int strtol_base , uintmax_t *val ,
                        char const   *valid_suffixes ) 
{ 
  char *t_ptr ;
  char **p ;
  uintmax_t tmp ;
  strtol_error err ;
  char const   *q ;
  unsigned char ch ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int base ;
  int suffixes ;
  strtol_error overflow ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 81
  err = (strtol_error )0;
#line 83
  if (0 <= strtol_base) {
#line 83
    if (! (strtol_base <= 36)) {
#line 83
      __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                    83U, "xstrtoumax");
    }
  } else {
#line 83
    __assert_fail("0 <= strtol_base && strtol_base <= 36", "/home/wslee/project/coreutils-8.1/lib/xstrtol.c",
                  83U, "xstrtoumax");
  }
#line 85
  if (ptr) {
#line 85
    p = ptr;
  } else {
#line 85
    p = & t_ptr;
  }
#line 89
  q = s;
#line 90
  ch = (unsigned char )*q;
#line 91
  while (1) {
#line 91
    tmp___0 = __ctype_b_loc();
#line 91
    if (! ((int const   )*(*tmp___0 + (int )ch) & 8192)) {
#line 91
      break;
    }
#line 92
    q ++;
#line 92
    ch = (unsigned char )*q;
  }
#line 93
  if ((int )ch == 45) {
#line 94
    return ((strtol_error )4);
  }
#line 97
  tmp___1 = __errno_location();
#line 97
  *tmp___1 = 0;
#line 98
  tmp = strtoumax((char const   * __restrict  )s, (char ** __restrict  )p, strtol_base);
#line 100
  if ((unsigned long )*p == (unsigned long )s) {
#line 104
    if (valid_suffixes) {
#line 104
      if (*(*p)) {
#line 104
        tmp___2 = strchr(valid_suffixes, (int )*(*p));
#line 104
        if (tmp___2) {
#line 105
          tmp = (uintmax_t )1;
        } else {
#line 107
          return ((strtol_error )4);
        }
      } else {
#line 107
        return ((strtol_error )4);
      }
    } else {
#line 107
      return ((strtol_error )4);
    }
  } else {
#line 109
    tmp___4 = __errno_location();
#line 109
    if (*tmp___4 != 0) {
#line 111
      tmp___3 = __errno_location();
#line 111
      if (*tmp___3 != 34) {
#line 112
        return ((strtol_error )4);
      }
#line 113
      err = (strtol_error )1;
    }
  }
#line 119
  if (! valid_suffixes) {
#line 121
    *val = tmp;
#line 122
    return (err);
  }
#line 125
  if ((int )*(*p) != 0) {
#line 127
    base = 1024;
#line 128
    suffixes = 1;
#line 131
    tmp___5 = strchr(valid_suffixes, (int )*(*p));
#line 131
    if (! tmp___5) {
#line 133
      *val = tmp;
#line 134
      return ((strtol_error )((unsigned int )err | 2U));
    }
#line 137
    tmp___6 = strchr(valid_suffixes, '0');
#line 137
    if (tmp___6) {
#line 146
      switch ((int )*(*(p + 0) + 1)) {
      case 105: 
#line 149
      if ((int )*(*(p + 0) + 2) == 66) {
#line 150
        suffixes += 2;
      }
#line 151
      break;
      case 68: 
      case 66: 
#line 155
      base = 1000;
#line 156
      suffixes ++;
#line 157
      break;
      }
    }
#line 161
    switch ((int )*(*p)) {
    case 98: 
#line 164
    overflow = bkm_scale___2(& tmp, 512);
#line 165
    break;
    case 66: 
#line 168
    overflow = bkm_scale___2(& tmp, 1024);
#line 169
    break;
    case 99: 
#line 172
    overflow = (strtol_error )0;
#line 173
    break;
    case 69: 
#line 176
    overflow = bkm_scale_by_power___2(& tmp, base, 6);
#line 177
    break;
    case 103: 
    case 71: 
#line 181
    overflow = bkm_scale_by_power___2(& tmp, base, 3);
#line 182
    break;
    case 75: 
    case 107: 
#line 186
    overflow = bkm_scale_by_power___2(& tmp, base, 1);
#line 187
    break;
    case 109: 
    case 77: 
#line 191
    overflow = bkm_scale_by_power___2(& tmp, base, 2);
#line 192
    break;
    case 80: 
#line 195
    overflow = bkm_scale_by_power___2(& tmp, base, 5);
#line 196
    break;
    case 116: 
    case 84: 
#line 200
    overflow = bkm_scale_by_power___2(& tmp, base, 4);
#line 201
    break;
    case 119: 
#line 204
    overflow = bkm_scale___2(& tmp, 2);
#line 205
    break;
    case 89: 
#line 208
    overflow = bkm_scale_by_power___2(& tmp, base, 8);
#line 209
    break;
    case 90: 
#line 212
    overflow = bkm_scale_by_power___2(& tmp, base, 7);
#line 213
    break;
    default: 
#line 216
    *val = tmp;
#line 217
    return ((strtol_error )((unsigned int )err | 2U));
    }
#line 220
    err = (strtol_error )((unsigned int )err | (unsigned int )overflow);
#line 221
    *p += suffixes;
#line 222
    if (*(*p)) {
#line 223
      err = (strtol_error )((unsigned int )err | 2U);
    }
  }
#line 226
  *val = tmp;
#line 227
  return (err);
}
}
/* compiler builtin: 
   void __builtin_va_copy(__builtin_va_list  , __builtin_va_list  ) ;  */
#line 1 "cil-tWrcev02.o"
#pragma merger("0","../lib/xvasprintf.o.i","")
#line 119 "/home/wslee/project/coreutils-8.1/lib/xalloc.h"
__inline static void *xnmalloc(size_t n , size_t s )  __attribute__((__malloc__)) ;
#line 32 "/home/wslee/project/coreutils-8.1/lib/xvasprintf.c"
__inline static char *xstrcat(size_t argcount , va_list args ) 
{ 
  char *result ;
  va_list ap ;
  size_t totalsize ;
  size_t i ;
  char *p ;
  char const   *next ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  size_t __attribute__((__pure__))  tmp___2 ;
  int *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  char const   *next___0 ;
  char const   *tmp___8 ;
  size_t len ;
  size_t tmp___9 ;

  {
#line 42
  totalsize = (size_t )0;
#line 43
  __builtin_va_copy(ap, args);
#line 44
  i = argcount;
#line 44
  while (i > 0UL) {
#line 46
    tmp___0 = __builtin_va_arg(ap, char const   *);
#line 46
    next = tmp___0;
#line 47
    tmp___1 = strlen(next);
#line 47
    tmp___2 = xsum(totalsize, tmp___1);
#line 47
    totalsize = (size_t )tmp___2;
#line 44
    i --;
  }
#line 49
  __builtin_va_end(ap);
#line 54
  if (totalsize == 0xffffffffffffffffUL) {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
#line 57
    return ((char *)((void *)0));
  } else
#line 54
  if (totalsize > 2147483647UL) {
#line 56
    tmp___3 = __errno_location();
#line 56
    *tmp___3 = 75;
#line 57
    return ((char *)((void *)0));
  }
#line 61
  if (sizeof(char ) == 1UL) {
#line 61
    tmp___4 = xmalloc(totalsize + 1UL);
#line 61
    tmp___6 = tmp___4;
  } else {
#line 61
    tmp___5 = xnmalloc(totalsize + 1UL, sizeof(char ));
#line 61
    tmp___6 = tmp___5;
  }
#line 61
  result = (char *)tmp___6;
#line 62
  p = result;
#line 63
  i = argcount;
#line 63
  while (i > 0UL) {
#line 65
    tmp___8 = __builtin_va_arg(args, char const   *);
#line 65
    next___0 = tmp___8;
#line 66
    tmp___9 = strlen(next___0);
#line 66
    len = tmp___9;
#line 67
    memcpy((void * __restrict  )p, (void const   * __restrict  )next___0, len);
#line 68
    p += len;
#line 63
    i --;
  }
#line 70
  *p = (char )'\000';
#line 72
  return (result);
}
}
#line 75 "/home/wslee/project/coreutils-8.1/lib/xvasprintf.c"
char *( /* format attribute */  xvasprintf)(char const   *format , va_list args ) 
{ 
  char *result ;
  size_t argcount ;
  char const   *f ;
  char *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 84
  argcount = (size_t )0;
#line 87
  f = format;
#line 87
  while (1) {
#line 89
    if ((int const   )*f == 0) {
#line 91
      tmp = xstrcat(argcount, args);
#line 91
      return (tmp);
    }
#line 92
    if ((int const   )*f != 37) {
#line 93
      break;
    }
#line 94
    f ++;
#line 95
    if ((int const   )*f != 115) {
#line 96
      break;
    }
#line 97
    f ++;
#line 98
    argcount ++;
  }
#line 102
  tmp___1 = rpl_vasprintf(& result, format, args);
#line 102
  if (tmp___1 < 0) {
#line 104
    tmp___0 = __errno_location();
#line 104
    if (*tmp___0 == 12) {
#line 105
      xalloc_die();
    }
#line 106
    return ((char *)((void *)0));
  }
#line 109
  return (result);
}
}
#line 1 "cil-68BqmVDd.o"
#pragma merger("0","../lib/yesno.o.i","")
#line 22 "/home/wslee/project/coreutils-8.1/lib/yesno.h"
_Bool yesno(void) ;
#line 887 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rpmatch)(char const   *__response ) ;
#line 31 "/home/wslee/project/coreutils-8.1/lib/yesno.c"
_Bool yesno(void) 
{ 
  _Bool yes ;
  char *response ;
  size_t response_size ;
  ssize_t response_len ;
  __ssize_t tmp ;
  int tmp___0 ;

  {
#line 37
  response = (char *)((void *)0);
#line 38
  response_size = (size_t )0;
#line 39
  tmp = getline((char ** __restrict  )(& response), (size_t * __restrict  )(& response_size),
                (FILE * __restrict  )stdin);
#line 39
  response_len = tmp;
#line 41
  if (response_len <= 0L) {
#line 42
    yes = (_Bool)0;
  } else {
#line 45
    *(response + (response_len - 1L)) = (char )'\000';
#line 46
    tmp___0 = rpmatch((char const   *)response);
#line 46
    yes = (_Bool )(0 < tmp___0);
  }
#line 49
  free((void *)response);
#line 59
  return (yes);
}
}
#line 1 "cil-VQ6KRC0z.o"
#pragma merger("0","../lib/unistr/u8-uctomb-aux.o.i","")
#line 23 "/home/wslee/project/coreutils-8.1/lib/unistr/u8-uctomb-aux.c"
int u8_uctomb_aux(uint8_t *s , ucs4_t uc , int n ) 
{ 
  int count ;

  {
#line 28
  if (uc < 128U) {
#line 30
    return (-2);
  } else
#line 31
  if (uc < 2048U) {
#line 32
    count = 2;
  } else
#line 33
  if (uc < 65536U) {
#line 35
    if (uc < 55296U) {
#line 36
      count = 3;
    } else
#line 35
    if (uc >= 57344U) {
#line 36
      count = 3;
    } else {
#line 38
      return (-1);
    }
  } else
#line 48
  if (uc < 1114112U) {
#line 49
    count = 4;
  } else {
#line 52
    return (-1);
  }
#line 54
  if (n < count) {
#line 55
    return (-2);
  }
#line 57
  switch (count) {
  case 4: 
#line 63
  *(s + 3) = (uint8_t )(128U | (uc & 63U));
#line 63
  uc >>= 6;
#line 63
  uc |= 65536U;
  case 3: 
#line 64
  *(s + 2) = (uint8_t )(128U | (uc & 63U));
#line 64
  uc >>= 6;
#line 64
  uc |= 2048U;
  case 2: 
#line 65
  *(s + 1) = (uint8_t )(128U | (uc & 63U));
#line 65
  uc >>= 6;
#line 65
  uc |= 192U;
#line 66
  *(s + 0) = (uint8_t )uc;
  }
#line 68
  return (count);
}
}
#line 1 "cil-1onKKuZw.o"
#pragma merger("0","../lib/unistr/u8-uctomb.o.i","")
#line 1 "cil-ZZhJD2Qq.o"
#pragma merger("0","version.o.i","")
#line 2 "/home/wslee/project/coreutils-8.1/src/version.c"
char const   *Version  =    "8.1";
