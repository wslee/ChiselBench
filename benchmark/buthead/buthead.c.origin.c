/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

typedef unsigned long size_t;
typedef long __off_t;
typedef long __off64_t;
struct _IO_FILE;
struct _IO_FILE;
typedef struct _IO_FILE FILE;
struct _IO_FILE;
typedef void _IO_lock_t;
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
typedef struct _IO_FILE _IO_FILE;
extern int _IO_getc(_IO_FILE *__fp ) ;
extern struct _IO_FILE *stdin ;
extern struct _IO_FILE *stderr ;
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
extern int getchar(void) ;
extern int putchar(int __c ) ;
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
int main(int argc , char **argv ) 
{ 
  long lines_to_skip ;
  long i ;
  int c ;
  char *p ;
  int *tmp ;

  {
  if (argc != 2) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Usage: %s count\n",
            *(argv + 0));
    exit(2);
    }
  }
  {
  lines_to_skip = strtol((char const   * __restrict  )*(argv + 1), (char ** __restrict  )(& p),
                         10);
  tmp = __errno_location();
  }
  if (*tmp) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buthead error: invalid line count \'%s\'\n",
            *(argv + 1));
    exit(2);
    }
  } else
  if (lines_to_skip < 0L) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buthead error: invalid line count \'%s\'\n",
            *(argv + 1));
    exit(2);
    }
  } else
  if ((int )*(*(argv + 1) + 0) == 0) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buthead error: invalid line count \'%s\'\n",
            *(argv + 1));
    exit(2);
    }
  } else
  if ((int )*p != 0) {
    {
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buthead error: invalid line count \'%s\'\n",
            *(argv + 1));
    exit(2);
    }
  }
  i = 0L;
  {
  while (1) {
    while_continue: /* CIL Label */ ;
    if (! (i < lines_to_skip)) {
      goto while_break;
    }
    {
    c = _IO_getc(stdin);
    }
    if (c == -1) {
      {
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"buthead error: EOF on line %ld while skipping %ld\n",
              i + 1L, lines_to_skip);
      exit(1);
      }
    }
    if (c == 10) {
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
    c = getchar();
    }
    if (! (c != -1)) {
      goto while_break___0;
    }
    {
    putchar(c);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  return (0);
}
}
